/*
	Copyright (c) 2004-2011, The Dojo Foundation All Rights Reserved.
	Available via Academic Free License >= 2.1 OR the modified BSD license.
	see: http://dojotoolkit.org/license for details
*/

/*
	This is an optimized version of Dojo, built for deployment and not for
	development. To get sources and documentation, please visit:

		http://dojotoolkit.org
*/

if(!dojo._hasResource["dijit._base.manager"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._base.manager"] = true;
dojo.provide("dijit._base.manager");


dojo.declare("dijit.WidgetSet", null, {
	// summary:
	//		A set of widgets indexed by id. A default instance of this class is
	//		available as `dijit.registry`
	//
	// example:
	//		Create a small list of widgets:
	//		|	var ws = new dijit.WidgetSet();
	//		|	ws.add(dijit.byId("one"));
	//		| 	ws.add(dijit.byId("two"));
	//		|	// destroy both:
	//		|	ws.forEach(function(w){ w.destroy(); });
	//
	// example:
	//		Using dijit.registry:
	//		|	dijit.registry.forEach(function(w){ /* do something */ });

	constructor: function(){
		this._hash = {};
		this.length = 0;
	},

	add: function(/*dijit._Widget*/ widget){
		// summary:
		//		Add a widget to this list. If a duplicate ID is detected, a error is thrown.
		//
		// widget: dijit._Widget
		//		Any dijit._Widget subclass.
		if(this._hash[widget.id]){
			throw new Error("Tried to register widget with id==" + widget.id + " but that id is already registered");
		}
		this._hash[widget.id] = widget;
		this.length++;
	},

	remove: function(/*String*/ id){
		// summary:
		//		Remove a widget from this WidgetSet. Does not destroy the widget; simply
		//		removes the reference.
		if(this._hash[id]){
			delete this._hash[id];
			this.length--;
		}
	},

	forEach: function(/*Function*/ func, /* Object? */thisObj){
		// summary:
		//		Call specified function for each widget in this set.
		//
		// func:
		//		A callback function to run for each item. Is passed the widget, the index
		//		in the iteration, and the full hash, similar to `dojo.forEach`.
		//
		// thisObj:
		//		An optional scope parameter
		//
		// example:
		//		Using the default `dijit.registry` instance:
		//		|	dijit.registry.forEach(function(widget){
		//		|		console.log(widget.declaredClass);
		//		|	});
		//
		// returns:
		//		Returns self, in order to allow for further chaining.

		thisObj = thisObj || dojo.global;
		var i = 0, id;
		for(id in this._hash){
			func.call(thisObj, this._hash[id], i++, this._hash);
		}
		return this;	// dijit.WidgetSet
	},

	filter: function(/*Function*/ filter, /* Object? */thisObj){
		// summary:
		//		Filter down this WidgetSet to a smaller new WidgetSet
		//		Works the same as `dojo.filter` and `dojo.NodeList.filter`
		//
		// filter:
		//		Callback function to test truthiness. Is passed the widget
		//		reference and the pseudo-index in the object.
		//
		// thisObj: Object?
		//		Option scope to use for the filter function.
		//
		// example:
		//		Arbitrary: select the odd widgets in this list
		//		|	dijit.registry.filter(function(w, i){
		//		|		return i % 2 == 0;
		//		|	}).forEach(function(w){ /* odd ones */ });

		thisObj = thisObj || dojo.global;
		var res = new dijit.WidgetSet(), i = 0, id;
		for(id in this._hash){
			var w = this._hash[id];
			if(filter.call(thisObj, w, i++, this._hash)){
				res.add(w);
			}
		}
		return res; // dijit.WidgetSet
	},

	byId: function(/*String*/ id){
		// summary:
		//		Find a widget in this list by it's id.
		// example:
		//		Test if an id is in a particular WidgetSet
		//		| var ws = new dijit.WidgetSet();
		//		| ws.add(dijit.byId("bar"));
		//		| var t = ws.byId("bar") // returns a widget
		//		| var x = ws.byId("foo"); // returns undefined

		return this._hash[id];	// dijit._Widget
	},

	byClass: function(/*String*/ cls){
		// summary:
		//		Reduce this widgetset to a new WidgetSet of a particular `declaredClass`
		//
		// cls: String
		//		The Class to scan for. Full dot-notated string.
		//
		// example:
		//		Find all `dijit.TitlePane`s in a page:
		//		|	dijit.registry.byClass("dijit.TitlePane").forEach(function(tp){ tp.close(); });

		var res = new dijit.WidgetSet(), id, widget;
		for(id in this._hash){
			widget = this._hash[id];
			if(widget.declaredClass == cls){
				res.add(widget);
			}
		 }
		 return res; // dijit.WidgetSet
},

	toArray: function(){
		// summary:
		//		Convert this WidgetSet into a true Array
		//
		// example:
		//		Work with the widget .domNodes in a real Array
		//		|	dojo.map(dijit.registry.toArray(), function(w){ return w.domNode; });

		var ar = [];
		for(var id in this._hash){
			ar.push(this._hash[id]);
		}
		return ar;	// dijit._Widget[]
},

	map: function(/* Function */func, /* Object? */thisObj){
		// summary:
		//		Create a new Array from this WidgetSet, following the same rules as `dojo.map`
		// example:
		//		|	var nodes = dijit.registry.map(function(w){ return w.domNode; });
		//
		// returns:
		//		A new array of the returned values.
		return dojo.map(this.toArray(), func, thisObj); // Array
	},

	every: function(func, thisObj){
		// summary:
		// 		A synthetic clone of `dojo.every` acting explicitly on this WidgetSet
		//
		// func: Function
		//		A callback function run for every widget in this list. Exits loop
		//		when the first false return is encountered.
		//
		// thisObj: Object?
		//		Optional scope parameter to use for the callback

		thisObj = thisObj || dojo.global;
		var x = 0, i;
		for(i in this._hash){
			if(!func.call(thisObj, this._hash[i], x++, this._hash)){
				return false; // Boolean
			}
		}
		return true; // Boolean
	},

	some: function(func, thisObj){
		// summary:
		// 		A synthetic clone of `dojo.some` acting explictly on this WidgetSet
		//
		// func: Function
		//		A callback function run for every widget in this list. Exits loop
		//		when the first true return is encountered.
		//
		// thisObj: Object?
		//		Optional scope parameter to use for the callback

		thisObj = thisObj || dojo.global;
		var x = 0, i;
		for(i in this._hash){
			if(func.call(thisObj, this._hash[i], x++, this._hash)){
				return true; // Boolean
			}
		}
		return false; // Boolean
	}

});

(function(){

	/*=====
	dijit.registry = {
		// summary:
		//		A list of widgets on a page.
		// description:
		//		Is an instance of `dijit.WidgetSet`
	};
	=====*/
	dijit.registry = new dijit.WidgetSet();

	var hash = dijit.registry._hash,
		attr = dojo.attr,
		hasAttr = dojo.hasAttr,
		style = dojo.style;

	dijit.byId = function(/*String|dijit._Widget*/ id){
		// summary:
		//		Returns a widget by it's id, or if passed a widget, no-op (like dojo.byId())
		return typeof id == "string" ? hash[id] : id; // dijit._Widget
	};

	var _widgetTypeCtr = {};
	dijit.getUniqueId = function(/*String*/widgetType){
		// summary:
		//		Generates a unique id for a given widgetType
	
		var id;
		do{
			id = widgetType + "_" +
				(widgetType in _widgetTypeCtr ?
					++_widgetTypeCtr[widgetType] : _widgetTypeCtr[widgetType] = 0);
		}while(hash[id]);
		return dijit._scopeName == "dijit" ? id : dijit._scopeName + "_" + id; // String
	};
	
	dijit.findWidgets = function(/*DomNode*/ root){
		// summary:
		//		Search subtree under root returning widgets found.
		//		Doesn't search for nested widgets (ie, widgets inside other widgets).
	
		var outAry = [];
	
		function getChildrenHelper(root){
			for(var node = root.firstChild; node; node = node.nextSibling){
				if(node.nodeType == 1){
					var widgetId = node.getAttribute("widgetId");
					if(widgetId){
						var widget = hash[widgetId];
						if(widget){	// may be null on page w/multiple dojo's loaded
							outAry.push(widget);
						}
					}else{
						getChildrenHelper(node);
					}
				}
			}
		}
	
		getChildrenHelper(root);
		return outAry;
	};
	
	dijit._destroyAll = function(){
		// summary:
		//		Code to destroy all widgets and do other cleanup on page unload
	
		// Clean up focus manager lingering references to widgets and nodes
		dijit._curFocus = null;
		dijit._prevFocus = null;
		dijit._activeStack = [];
	
		// Destroy all the widgets, top down
		dojo.forEach(dijit.findWidgets(dojo.body()), function(widget){
			// Avoid double destroy of widgets like Menu that are attached to <body>
			// even though they are logically children of other widgets.
			if(!widget._destroyed){
				if(widget.destroyRecursive){
					widget.destroyRecursive();
				}else if(widget.destroy){
					widget.destroy();
				}
			}
		});
	};
	
	if(dojo.isIE){
		// Only run _destroyAll() for IE because we think it's only necessary in that case,
		// and because it causes problems on FF.  See bug #3531 for details.
		dojo.addOnWindowUnload(function(){
			dijit._destroyAll();
		});
	}
	
	dijit.byNode = function(/*DOMNode*/ node){
		// summary:
		//		Returns the widget corresponding to the given DOMNode
		return hash[node.getAttribute("widgetId")]; // dijit._Widget
	};
	
	dijit.getEnclosingWidget = function(/*DOMNode*/ node){
		// summary:
		//		Returns the widget whose DOM tree contains the specified DOMNode, or null if
		//		the node is not contained within the DOM tree of any widget
		while(node){
			var id = node.getAttribute && node.getAttribute("widgetId");
			if(id){
				return hash[id];
			}
			node = node.parentNode;
		}
		return null;
	};

	var shown = (dijit._isElementShown = function(/*Element*/ elem){
		var s = style(elem);
		return (s.visibility != "hidden")
			&& (s.visibility != "collapsed")
			&& (s.display != "none")
			&& (attr(elem, "type") != "hidden");
	});
	
	dijit.hasDefaultTabStop = function(/*Element*/ elem){
		// summary:
		//		Tests if element is tab-navigable even without an explicit tabIndex setting
	
		// No explicit tabIndex setting, need to investigate node type
		switch(elem.nodeName.toLowerCase()){
			case "a":
				// An <a> w/out a tabindex is only navigable if it has an href
				return hasAttr(elem, "href");
			case "area":
			case "button":
			case "input":
			case "object":
			case "select":
			case "textarea":
				// These are navigable by default
				return true;
			case "iframe":
				// If it's an editor <iframe> then it's tab navigable.
				var body;
				try{
					// non-IE
					var contentDocument = elem.contentDocument;
					if("designMode" in contentDocument && contentDocument.designMode == "on"){
						return true;
					}
					body = contentDocument.body;
				}catch(e1){
					// contentWindow.document isn't accessible within IE7/8
					// if the iframe.src points to a foreign url and this
					// page contains an element, that could get focus
					try{
						body = elem.contentWindow.document.body;
					}catch(e2){
						return false;
					}
				}
				return body.contentEditable == 'true' || (body.firstChild && body.firstChild.contentEditable == 'true');
			default:
				return elem.contentEditable == 'true';
		}
	};
	
	var isTabNavigable = (dijit.isTabNavigable = function(/*Element*/ elem){
		// summary:
		//		Tests if an element is tab-navigable
	
		// TODO: convert (and rename method) to return effective tabIndex; will save time in _getTabNavigable()
		if(attr(elem, "disabled")){
			return false;
		}else if(hasAttr(elem, "tabIndex")){
			// Explicit tab index setting
			return attr(elem, "tabIndex") >= 0; // boolean
		}else{
			// No explicit tabIndex setting, so depends on node type
			return dijit.hasDefaultTabStop(elem);
		}
	});

	dijit._getTabNavigable = function(/*DOMNode*/ root){
		// summary:
		//		Finds descendants of the specified root node.
		//
		// description:
		//		Finds the following descendants of the specified root node:
		//		* the first tab-navigable element in document order
		//		  without a tabIndex or with tabIndex="0"
		//		* the last tab-navigable element in document order
		//		  without a tabIndex or with tabIndex="0"
		//		* the first element in document order with the lowest
		//		  positive tabIndex value
		//		* the last element in document order with the highest
		//		  positive tabIndex value
		var first, last, lowest, lowestTabindex, highest, highestTabindex, radioSelected = {};
		function radioName(node) {
			// If this element is part of a radio button group, return the name for that group.
			return node && node.tagName.toLowerCase() == "input" &&
				node.type && node.type.toLowerCase() == "radio" &&
				node.name && node.name.toLowerCase();
		}
		var walkTree = function(/*DOMNode*/parent){
			dojo.query("> *", parent).forEach(function(child){
				// Skip hidden elements, and also non-HTML elements (those in custom namespaces) in IE,
				// since show() invokes getAttribute("type"), which crash on VML nodes in IE.
				if((dojo.isIE && child.scopeName!=="HTML") || !shown(child)){
					return;
				}

				if(isTabNavigable(child)){
					var tabindex = attr(child, "tabIndex");
					if(!hasAttr(child, "tabIndex") || tabindex == 0){
						if(!first){ first = child; }
						last = child;
					}else if(tabindex > 0){
						if(!lowest || tabindex < lowestTabindex){
							lowestTabindex = tabindex;
							lowest = child;
						}
						if(!highest || tabindex >= highestTabindex){
							highestTabindex = tabindex;
							highest = child;
						}
					}
					var rn = radioName(child);
					if(dojo.attr(child, "checked") && rn) {
						radioSelected[rn] = child;
					}
				}
				if(child.nodeName.toUpperCase() != 'SELECT'){
					walkTree(child);
				}
			});
		};
		if(shown(root)){ walkTree(root) }
		function rs(node) {
			// substitute checked radio button for unchecked one, if there is a checked one with the same name.
			return radioSelected[radioName(node)] || node;
		}
		return { first: rs(first), last: rs(last), lowest: rs(lowest), highest: rs(highest) };
	}
	dijit.getFirstInTabbingOrder = function(/*String|DOMNode*/ root){
		// summary:
		//		Finds the descendant of the specified root node
		//		that is first in the tabbing order
		var elems = dijit._getTabNavigable(dojo.byId(root));
		return elems.lowest ? elems.lowest : elems.first; // DomNode
	};
	
	dijit.getLastInTabbingOrder = function(/*String|DOMNode*/ root){
		// summary:
		//		Finds the descendant of the specified root node
		//		that is last in the tabbing order
		var elems = dijit._getTabNavigable(dojo.byId(root));
		return elems.last ? elems.last : elems.highest; // DomNode
	};
	
	/*=====
	dojo.mixin(dijit, {
		// defaultDuration: Integer
		//		The default animation speed (in ms) to use for all Dijit
		//		transitional animations, unless otherwise specified
		//		on a per-instance basis. Defaults to 200, overrided by
		//		`djConfig.defaultDuration`
		defaultDuration: 200
	});
	=====*/
	
	dijit.defaultDuration = dojo.config["defaultDuration"] || 200;

})();

}

if(!dojo._hasResource["dojo.Stateful"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.Stateful"] = true;
dojo.provide("dojo.Stateful");


dojo.declare("dojo.Stateful", null, {
	// summary:
	//		Base class for objects that provide named properties with optional getter/setter
	//		control and the ability to watch for property changes
	// example:
	//	|	var obj = new dojo.Stateful();
	//	|	obj.watch("foo", function(){
	//	|		console.log("foo changed to " + this.get("foo"));
	//	|	});
	//	|	obj.set("foo","bar");
	postscript: function(mixin){
		if(mixin){
			dojo.mixin(this, mixin);
		}
	},
	
	get: function(/*String*/name){
		// summary:
		//		Get a property on a Stateful instance.
		//	name:
		//		The property to get.
		// description:
		//		Get a named property on a Stateful object. The property may
		//		potentially be retrieved via a getter method in subclasses. In the base class
		// 		this just retrieves the object's property.
		// 		For example:
		//	|	stateful = new dojo.Stateful({foo: 3});
		//	|	stateful.get("foo") // returns 3
		//	|	stateful.foo // returns 3
		
		return this[name];
	},
	set: function(/*String*/name, /*Object*/value){
		// summary:
		//		Set a property on a Stateful instance
		//	name:
		//		The property to set.
		//	value:
		//		The value to set in the property.
		// description:
		//		Sets named properties on a stateful object and notifies any watchers of
		// 		the property. A programmatic setter may be defined in subclasses.
		// 		For example:
		//	|	stateful = new dojo.Stateful();
		//	|	stateful.watch(function(name, oldValue, value){
		//	|		// this will be called on the set below
		//	|	}
		//	|	stateful.set(foo, 5);
		//
		//	set() may also be called with a hash of name/value pairs, ex:
		//	|	myObj.set({
		//	|		foo: "Howdy",
		//	|		bar: 3
		//	|	})
		//	This is equivalent to calling set(foo, "Howdy") and set(bar, 3)
		if(typeof name === "object"){
			for(var x in name){
				this.set(x, name[x]);
			}
			return this;
		}
		var oldValue = this[name];
		this[name] = value;
		if(this._watchCallbacks){
			this._watchCallbacks(name, oldValue, value);
		}
		return this;
	},
	watch: function(/*String?*/name, /*Function*/callback){
		// summary:
		//		Watches a property for changes
		//	name:
		//		Indicates the property to watch. This is optional (the callback may be the
		// 		only parameter), and if omitted, all the properties will be watched
		// returns:
		//		An object handle for the watch. The unwatch method of this object
		// 		can be used to discontinue watching this property:
		//		|	var watchHandle = obj.watch("foo", callback);
		//		|	watchHandle.unwatch(); // callback won't be called now
		//	callback:
		//		The function to execute when the property changes. This will be called after
		//		the property has been changed. The callback will be called with the |this|
		//		set to the instance, the first argument as the name of the property, the
		// 		second argument as the old value and the third argument as the new value.
		
		var callbacks = this._watchCallbacks;
		if(!callbacks){
			var self = this;
			callbacks = this._watchCallbacks = function(name, oldValue, value, ignoreCatchall){
				var notify = function(propertyCallbacks){
					if(propertyCallbacks){
                        propertyCallbacks = propertyCallbacks.slice();
						for(var i = 0, l = propertyCallbacks.length; i < l; i++){
							try{
								propertyCallbacks[i].call(self, name, oldValue, value);
							}catch(e){
								console.error(e);
							}
						}
					}
				};
				notify(callbacks['_' + name]);
				if(!ignoreCatchall){
					notify(callbacks["*"]); // the catch-all
				}
			}; // we use a function instead of an object so it will be ignored by JSON conversion
		}
		if(!callback && typeof name === "function"){
			callback = name;
			name = "*";
		}else{
			// prepend with dash to prevent name conflicts with function (like "name" property)
			name = '_' + name;
		}
		var propertyCallbacks = callbacks[name];
		if(typeof propertyCallbacks !== "object"){
			propertyCallbacks = callbacks[name] = [];
		}
		propertyCallbacks.push(callback);
		return {
			unwatch: function(){
				propertyCallbacks.splice(dojo.indexOf(propertyCallbacks, callback), 1);
			}
		};
	}
	
});

}

if(!dojo._hasResource["dijit._WidgetBase"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._WidgetBase"] = true;
dojo.provide("dijit._WidgetBase");




(function(){

dojo.declare("dijit._WidgetBase", dojo.Stateful, {
	// summary:
	//		Future base class for all Dijit widgets.
	//		_Widget extends this class adding support for various features needed by desktop.

	// id: [const] String
	//		A unique, opaque ID string that can be assigned by users or by the
	//		system. If the developer passes an ID which is known not to be
	//		unique, the specified ID is ignored and the system-generated ID is
	//		used instead.
	id: "",

	// lang: [const] String
	//		Rarely used.  Overrides the default Dojo locale used to render this widget,
	//		as defined by the [HTML LANG](http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang) attribute.
	//		Value must be among the list of locales specified during by the Dojo bootstrap,
	//		formatted according to [RFC 3066](http://www.ietf.org/rfc/rfc3066.txt) (like en-us).
	lang: "",

	// dir: [const] String
	//		Bi-directional support, as defined by the [HTML DIR](http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir)
	//		attribute. Either left-to-right "ltr" or right-to-left "rtl".  If undefined, widgets renders in page's
	//		default direction.
	dir: "",

	// class: String
	//		HTML class attribute
	"class": "",

	// style: String||Object
	//		HTML style attributes as cssText string or name/value hash
	style: "",

	// title: String
	//		HTML title attribute.
	//
	//		For form widgets this specifies a tooltip to display when hovering over
	//		the widget (just like the native HTML title attribute).
	//
	//		For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,
	//		etc., it's used to specify the tab label, accordion pane title, etc.
	title: "",

	// tooltip: String
	//		When this widget's title attribute is used to for a tab label, accordion pane title, etc.,
	//		this specifies the tooltip to appear when the mouse is hovered over that text.
	tooltip: "",

	// baseClass: [protected] String
	//		Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate
	//		widget state.
	baseClass: "",

	// srcNodeRef: [readonly] DomNode
	//		pointer to original DOM node
	srcNodeRef: null,

	// domNode: [readonly] DomNode
	//		This is our visible representation of the widget! Other DOM
	//		Nodes may by assigned to other properties, usually through the
	//		template system's dojoAttachPoint syntax, but the domNode
	//		property is the canonical "top level" node in widget UI.
	domNode: null,

	// containerNode: [readonly] DomNode
	//		Designates where children of the source DOM node will be placed.
	//		"Children" in this case refers to both DOM nodes and widgets.
	//		For example, for myWidget:
	//
	//		|	<div dojoType=myWidget>
	//		|		<b> here's a plain DOM node
	//		|		<span dojoType=subWidget>and a widget</span>
	//		|		<i> and another plain DOM node </i>
	//		|	</div>
	//
	//		containerNode would point to:
	//
	//		|		<b> here's a plain DOM node
	//		|		<span dojoType=subWidget>and a widget</span>
	//		|		<i> and another plain DOM node </i>
	//
	//		In templated widgets, "containerNode" is set via a
	//		dojoAttachPoint assignment.
	//
	//		containerNode must be defined for any widget that accepts innerHTML
	//		(like ContentPane or BorderContainer or even Button), and conversely
	//		is null for widgets that don't, like TextBox.
	containerNode: null,

/*=====
	// _started: Boolean
	//		startup() has completed.
	_started: false,
=====*/

	// attributeMap: [protected] Object
	//		attributeMap sets up a "binding" between attributes (aka properties)
	//		of the widget and the widget's DOM.
	//		Changes to widget attributes listed in attributeMap will be
	//		reflected into the DOM.
	//
	//		For example, calling set('title', 'hello')
	//		on a TitlePane will automatically cause the TitlePane's DOM to update
	//		with the new title.
	//
	//		attributeMap is a hash where the key is an attribute of the widget,
	//		and the value reflects a binding to a:
	//
	//		- DOM node attribute
	// |		focus: {node: "focusNode", type: "attribute"}
	// 		Maps this.focus to this.focusNode.focus
	//
	//		- DOM node innerHTML
	//	|		title: { node: "titleNode", type: "innerHTML" }
	//		Maps this.title to this.titleNode.innerHTML
	//
	//		- DOM node innerText
	//	|		title: { node: "titleNode", type: "innerText" }
	//		Maps this.title to this.titleNode.innerText
	//
	//		- DOM node CSS class
	// |		myClass: { node: "domNode", type: "class" }
	//		Maps this.myClass to this.domNode.className
	//
	//		If the value is an array, then each element in the array matches one of the
	//		formats of the above list.
	//
	//		There are also some shorthands for backwards compatibility:
	//		- string --> { node: string, type: "attribute" }, for example:
	//	|	"focusNode" ---> { node: "focusNode", type: "attribute" }
	//		- "" --> { node: "domNode", type: "attribute" }
	attributeMap: {id:"", dir:"", lang:"", "class":"", style:"", title:""},

	// _blankGif: [protected] String
	//		Path to a blank 1x1 image.
	//		Used by <img> nodes in templates that really get their image via CSS background-image.
	_blankGif: (dojo.config.blankGif || dojo.moduleUrl("dojo", "resources/blank.gif")).toString(),

	//////////// INITIALIZATION METHODS ///////////////////////////////////////

	postscript: function(/*Object?*/params, /*DomNode|String*/srcNodeRef){
		// summary:
		//		Kicks off widget instantiation.  See create() for details.
		// tags:
		//		private
		this.create(params, srcNodeRef);
	},

	create: function(/*Object?*/params, /*DomNode|String?*/srcNodeRef){
		// summary:
		//		Kick off the life-cycle of a widget
		// params:
		//		Hash of initialization parameters for widget, including
		//		scalar values (like title, duration etc.) and functions,
		//		typically callbacks like onClick.
		// srcNodeRef:
		//		If a srcNodeRef (DOM node) is specified:
		//			- use srcNodeRef.innerHTML as my contents
		//			- if this is a behavioral widget then apply behavior
		//			  to that srcNodeRef
		//			- otherwise, replace srcNodeRef with my generated DOM
		//			  tree
		// description:
		//		Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,
		//		etc.), some of which of you'll want to override. See http://docs.dojocampus.org/dijit/_Widget
		//		for a discussion of the widget creation lifecycle.
		//
		//		Of course, adventurous developers could override create entirely, but this should
		//		only be done as a last resort.
		// tags:
		//		private

		// store pointer to original DOM tree
		this.srcNodeRef = dojo.byId(srcNodeRef);

		// For garbage collection.  An array of handles returned by Widget.connect()
		// Each handle returned from Widget.connect() is an array of handles from dojo.connect()
		this._connects = [];

		// For garbage collection.  An array of handles returned by Widget.subscribe()
		// The handle returned from Widget.subscribe() is the handle returned from dojo.subscribe()
		this._subscribes = [];

		// mix in our passed parameters
		if(this.srcNodeRef && (typeof this.srcNodeRef.id == "string")){ this.id = this.srcNodeRef.id; }
		if(params){
			this.params = params;
			dojo._mixin(this, params);
		}
		this.postMixInProperties();

		// generate an id for the widget if one wasn't specified
		// (be sure to do this before buildRendering() because that function might
		// expect the id to be there.)
		if(!this.id){
			this.id = dijit.getUniqueId(this.declaredClass.replace(/\./g,"_"));
		}
		dijit.registry.add(this);

		this.buildRendering();

		if(this.domNode){
			// Copy attributes listed in attributeMap into the [newly created] DOM for the widget.
			// Also calls custom setters for all attributes with custom setters.
			this._applyAttributes();

			// If srcNodeRef was specified, then swap out original srcNode for this widget's DOM tree.
			// For 2.0, move this after postCreate().  postCreate() shouldn't depend on the
			// widget being attached to the DOM since it isn't when a widget is created programmatically like
			// new MyWidget({}).   See #11635.
			var source = this.srcNodeRef;
			if(source && source.parentNode && this.domNode !== source){
				source.parentNode.replaceChild(this.domNode, source);
			}
		}

		if(this.domNode){
			// Note: for 2.0 may want to rename widgetId to dojo._scopeName + "_widgetId",
			// assuming that dojo._scopeName even exists in 2.0
			this.domNode.setAttribute("widgetId", this.id);
		}
		this.postCreate();

		// If srcNodeRef has been processed and removed from the DOM (e.g. TemplatedWidget) then delete it to allow GC.
		if(this.srcNodeRef && !this.srcNodeRef.parentNode){
			delete this.srcNodeRef;
		}

		this._created = true;
	},

	_applyAttributes: function(){
		// summary:
		//		Step during widget creation to copy all widget attributes to the
		//		DOM as per attributeMap and _setXXXAttr functions.
		// description:
		//		Skips over blank/false attribute values, unless they were explicitly specified
		//		as parameters to the widget, since those are the default anyway,
		//		and setting tabIndex="" is different than not setting tabIndex at all.
		//
		//		It processes the attributes in the attribute map first, and then
		//		it goes through and processes the attributes for the _setXXXAttr
		//		functions that have been specified
		// tags:
		//		private
		var condAttrApply = function(attr, scope){
			if((scope.params && attr in scope.params) || scope[attr]){
				scope.set(attr, scope[attr]);
			}
		};

		// Do the attributes in attributeMap
		for(var attr in this.attributeMap){
			condAttrApply(attr, this);
		}

		// And also any attributes with custom setters
		dojo.forEach(this._getSetterAttributes(), function(a){
			if(!(a in this.attributeMap)){
				condAttrApply(a, this);
			}
		}, this);
	},

	_getSetterAttributes: function(){
		// summary:
		//		Returns list of attributes with custom setters for this widget
		var ctor = this.constructor;
		if(!ctor._setterAttrs){
			var r = (ctor._setterAttrs = []),
				attrs,
				proto = ctor.prototype;
			for(var fxName in proto){
				if(dojo.isFunction(proto[fxName]) && (attrs = fxName.match(/^_set([a-zA-Z]*)Attr$/)) && attrs[1]){
					r.push(attrs[1].charAt(0).toLowerCase() + attrs[1].substr(1));
				}
			}
		}
		return ctor._setterAttrs;	// String[]
	},

	postMixInProperties: function(){
		// summary:
		//		Called after the parameters to the widget have been read-in,
		//		but before the widget template is instantiated. Especially
		//		useful to set properties that are referenced in the widget
		//		template.
		// tags:
		//		protected
	},

	buildRendering: function(){
		// summary:
		//		Construct the UI for this widget, setting this.domNode
		// description:
		//		Most widgets will mixin `dijit._Templated`, which implements this
		//		method.
		// tags:
		//		protected

		if(!this.domNode){
			// Create root node if it wasn't created by _Templated
			this.domNode = this.srcNodeRef || dojo.create('div');
		}

		// baseClass is a single class name or occasionally a space-separated list of names.
		// Add those classes to the DOMNode.  If RTL mode then also add with Rtl suffix.
		// TODO: make baseClass custom setter
		if(this.baseClass){
			var classes = this.baseClass.split(" ");
			if(!this.isLeftToRight()){
				classes = classes.concat( dojo.map(classes, function(name){ return name+"Rtl"; }));
			}
			dojo.addClass(this.domNode, classes);
		}
	},

	postCreate: function(){
		// summary:
		//		Processing after the DOM fragment is created
		// description:
		//		Called after the DOM fragment has been created, but not necessarily
		//		added to the document.  Do not include any operations which rely on
		//		node dimensions or placement.
		// tags:
		//		protected
	},

	startup: function(){
		// summary:
		//		Processing after the DOM fragment is added to the document
		// description:
		//		Called after a widget and its children have been created and added to the page,
		//		and all related widgets have finished their create() cycle, up through postCreate().
		//		This is useful for composite widgets that need to control or layout sub-widgets.
		//		Many layout widgets can use this as a wiring phase.
		this._started = true;
	},

	//////////// DESTROY FUNCTIONS ////////////////////////////////

	destroyRecursive: function(/*Boolean?*/ preserveDom){
		// summary:
		// 		Destroy this widget and its descendants
		// description:
		//		This is the generic "destructor" function that all widget users
		// 		should call to cleanly discard with a widget. Once a widget is
		// 		destroyed, it is removed from the manager object.
		// preserveDom:
		//		If true, this method will leave the original DOM structure
		//		alone of descendant Widgets. Note: This will NOT work with
		//		dijit._Templated widgets.

		this._beingDestroyed = true;
		this.destroyDescendants(preserveDom);
		this.destroy(preserveDom);
	},

	destroy: function(/*Boolean*/ preserveDom){
		// summary:
		// 		Destroy this widget, but not its descendants.
		//		This method will, however, destroy internal widgets such as those used within a template.
		// preserveDom: Boolean
		//		If true, this method will leave the original DOM structure alone.
		//		Note: This will not yet work with _Templated widgets

		this._beingDestroyed = true;
		this.uninitialize();
		var d = dojo,
			dfe = d.forEach,
			dun = d.unsubscribe;
		dfe(this._connects, function(array){
			dfe(array, d.disconnect);
		});
		dfe(this._subscribes, function(handle){
			dun(handle);
		});

		// destroy widgets created as part of template, etc.
		dfe(this._supportingWidgets || [], function(w){
			if(w.destroyRecursive){
				w.destroyRecursive();
			}else if(w.destroy){
				w.destroy();
			}
		});

		this.destroyRendering(preserveDom);
		dijit.registry.remove(this.id);
		this._destroyed = true;
	},

	destroyRendering: function(/*Boolean?*/ preserveDom){
		// summary:
		//		Destroys the DOM nodes associated with this widget
		// preserveDom:
		//		If true, this method will leave the original DOM structure alone
		//		during tear-down. Note: this will not work with _Templated
		//		widgets yet.
		// tags:
		//		protected

		if(this.bgIframe){
			this.bgIframe.destroy(preserveDom);
			delete this.bgIframe;
		}

		if(this.domNode){
			if(preserveDom){
				dojo.removeAttr(this.domNode, "widgetId");
			}else{
				dojo.destroy(this.domNode);
			}
			delete this.domNode;
		}

		if(this.srcNodeRef){
			if(!preserveDom){
				dojo.destroy(this.srcNodeRef);
			}
			delete this.srcNodeRef;
		}
	},

	destroyDescendants: function(/*Boolean?*/ preserveDom){
		// summary:
		//		Recursively destroy the children of this widget and their
		//		descendants.
		// preserveDom:
		//		If true, the preserveDom attribute is passed to all descendant
		//		widget's .destroy() method. Not for use with _Templated
		//		widgets.

		// get all direct descendants and destroy them recursively
		dojo.forEach(this.getChildren(), function(widget){
			if(widget.destroyRecursive){
				widget.destroyRecursive(preserveDom);
			}
		});
	},

	uninitialize: function(){
		// summary:
		//		Stub function. Override to implement custom widget tear-down
		//		behavior.
		// tags:
		//		protected
		return false;
	},

	////////////////// GET/SET, CUSTOM SETTERS, ETC. ///////////////////

	_setClassAttr: function(/*String*/ value){
		// summary:
		//		Custom setter for the CSS "class" attribute
		// tags:
		//		protected
		var mapNode = this[this.attributeMap["class"] || 'domNode'];
		dojo.replaceClass(mapNode, value, this["class"]);
		this._set("class", value);
	},

	_setStyleAttr: function(/*String||Object*/ value){
		// summary:
		//		Sets the style attribute of the widget according to value,
		//		which is either a hash like {height: "5px", width: "3px"}
		//		or a plain string
		// description:
		//		Determines which node to set the style on based on style setting
		//		in attributeMap.
		// tags:
		//		protected

		var mapNode = this[this.attributeMap.style || 'domNode'];

		// Note: technically we should revert any style setting made in a previous call
		// to his method, but that's difficult to keep track of.

		if(dojo.isObject(value)){
			dojo.style(mapNode, value);
		}else{
			if(mapNode.style.cssText){
				mapNode.style.cssText += "; " + value;
			}else{
				mapNode.style.cssText = value;
			}
		}

		this._set("style", value);
	},

	_attrToDom: function(/*String*/ attr, /*String*/ value){
		// summary:
		//		Reflect a widget attribute (title, tabIndex, duration etc.) to
		//		the widget DOM, as specified in attributeMap.
		//		Note some attributes like "type"
		//		cannot be processed this way as they are not mutable.
		//
		// tags:
		//		private

		var commands = this.attributeMap[attr];
		dojo.forEach(dojo.isArray(commands) ? commands : [commands], function(command){

			// Get target node and what we are doing to that node
			var mapNode = this[command.node || command || "domNode"];	// DOM node
			var type = command.type || "attribute";	// class, innerHTML, innerText, or attribute

			switch(type){
				case "attribute":
					if(dojo.isFunction(value)){ // functions execute in the context of the widget
						value = dojo.hitch(this, value);
					}

					// Get the name of the DOM node attribute; usually it's the same
					// as the name of the attribute in the widget (attr), but can be overridden.
					// Also maps handler names to lowercase, like onSubmit --> onsubmit
					var attrName = command.attribute ? command.attribute :
						(/^on[A-Z][a-zA-Z]*$/.test(attr) ? attr.toLowerCase() : attr);

					dojo.attr(mapNode, attrName, value);
					break;
				case "innerText":
					mapNode.innerHTML = "";
					mapNode.appendChild(dojo.doc.createTextNode(value));
					break;
				case "innerHTML":
					mapNode.innerHTML = value;
					break;
				case "class":
					dojo.replaceClass(mapNode, value, this[attr]);
					break;
			}
		}, this);
	},

	get: function(name){
		// summary:
		//		Get a property from a widget.
		//	name:
		//		The property to get.
		// description:
		//		Get a named property from a widget. The property may
		//		potentially be retrieved via a getter method. If no getter is defined, this
		// 		just retrieves the object's property.
		// 		For example, if the widget has a properties "foo"
		//		and "bar" and a method named "_getFooAttr", calling:
		//	|	myWidget.get("foo");
		//		would be equivalent to writing:
		//	|	widget._getFooAttr();
		//		and:
		//	|	myWidget.get("bar");
		//		would be equivalent to writing:
		//	|	widget.bar;
		var names = this._getAttrNames(name);
		return this[names.g] ? this[names.g]() : this[name];
	},
	
	set: function(name, value){
		// summary:
		//		Set a property on a widget
		//	name:
		//		The property to set.
		//	value:
		//		The value to set in the property.
		// description:
		//		Sets named properties on a widget which may potentially be handled by a
		// 		setter in the widget.
		// 		For example, if the widget has a properties "foo"
		//		and "bar" and a method named "_setFooAttr", calling:
		//	|	myWidget.set("foo", "Howdy!");
		//		would be equivalent to writing:
		//	|	widget._setFooAttr("Howdy!");
		//		and:
		//	|	myWidget.set("bar", 3);
		//		would be equivalent to writing:
		//	|	widget.bar = 3;
		//
		//	set() may also be called with a hash of name/value pairs, ex:
		//	|	myWidget.set({
		//	|		foo: "Howdy",
		//	|		bar: 3
		//	|	})
		//	This is equivalent to calling set(foo, "Howdy") and set(bar, 3)

		if(typeof name === "object"){
			for(var x in name){
				this.set(x, name[x]);
			}
			return this;
		}
		var names = this._getAttrNames(name);
		if(this[names.s]){
			// use the explicit setter
			var result = this[names.s].apply(this, Array.prototype.slice.call(arguments, 1));
		}else{
			// if param is specified as DOM node attribute, copy it
			if(name in this.attributeMap){
				this._attrToDom(name, value);
			}
			this._set(name, value);
		}
		return result || this;
	},
	
	_attrPairNames: {},		// shared between all widgets
	_getAttrNames: function(name){
		// summary:
		//		Helper function for get() and set().
		//		Caches attribute name values so we don't do the string ops every time.
		// tags:
		//		private

		var apn = this._attrPairNames;
		if(apn[name]){ return apn[name]; }
		var uc = name.charAt(0).toUpperCase() + name.substr(1);
		return (apn[name] = {
			n: name+"Node",
			s: "_set"+uc+"Attr",
			g: "_get"+uc+"Attr"
		});
	},

	_set: function(/*String*/ name, /*anything*/ value){
		// summary:
		//		Helper function to set new value for specified attribute, and call handlers
		//		registered with watch() if the value has changed.
		var oldValue = this[name];
		this[name] = value;
		if(this._watchCallbacks && this._created && value !== oldValue){
			this._watchCallbacks(name, oldValue, value);
		}
	},

	toString: function(){
		// summary:
		//		Returns a string that represents the widget
		// description:
		//		When a widget is cast to a string, this method will be used to generate the
		//		output. Currently, it does not implement any sort of reversible
		//		serialization.
		return '[Widget ' + this.declaredClass + ', ' + (this.id || 'NO ID') + ']'; // String
	},

	getDescendants: function(){
		// summary:
		//		Returns all the widgets contained by this, i.e., all widgets underneath this.containerNode.
		//		This method should generally be avoided as it returns widgets declared in templates, which are
		//		supposed to be internal/hidden, but it's left here for back-compat reasons.

		return this.containerNode ? dojo.query('[widgetId]', this.containerNode).map(dijit.byNode) : []; // dijit._Widget[]
	},

	getChildren: function(){
		// summary:
		//		Returns all the widgets contained by this, i.e., all widgets underneath this.containerNode.
		//		Does not return nested widgets, nor widgets that are part of this widget's template.
		return this.containerNode ? dijit.findWidgets(this.containerNode) : []; // dijit._Widget[]
	},

	connect: function(
			/*Object|null*/ obj,
			/*String|Function*/ event,
			/*String|Function*/ method){
		// summary:
		//		Connects specified obj/event to specified method of this object
		//		and registers for disconnect() on widget destroy.
		// description:
		//		Provide widget-specific analog to dojo.connect, except with the
		//		implicit use of this widget as the target object.
		//		Events connected with `this.connect` are disconnected upon
		//		destruction.
		// returns:
		//		A handle that can be passed to `disconnect` in order to disconnect before
		//		the widget is destroyed.
		// example:
		//	|	var btn = new dijit.form.Button();
		//	|	// when foo.bar() is called, call the listener we're going to
		//	|	// provide in the scope of btn
		//	|	btn.connect(foo, "bar", function(){
		//	|		console.debug(this.toString());
		//	|	});
		// tags:
		//		protected

		var handles = [dojo._connect(obj, event, this, method)];
		this._connects.push(handles);
		return handles;		// _Widget.Handle
	},

	disconnect: function(/* _Widget.Handle */ handles){
		// summary:
		//		Disconnects handle created by `connect`.
		//		Also removes handle from this widget's list of connects.
		// tags:
		//		protected
		for(var i=0; i<this._connects.length; i++){
			if(this._connects[i] == handles){
				dojo.forEach(handles, dojo.disconnect);
				this._connects.splice(i, 1);
				return;
			}
		}
	},

	subscribe: function(
			/*String*/ topic,
			/*String|Function*/ method){
		// summary:
		//		Subscribes to the specified topic and calls the specified method
		//		of this object and registers for unsubscribe() on widget destroy.
		// description:
		//		Provide widget-specific analog to dojo.subscribe, except with the
		//		implicit use of this widget as the target object.
		// example:
		//	|	var btn = new dijit.form.Button();
		//	|	// when /my/topic is published, this button changes its label to
		//	|   // be the parameter of the topic.
		//	|	btn.subscribe("/my/topic", function(v){
		//	|		this.set("label", v);
		//	|	});
		var handle = dojo.subscribe(topic, this, method);

		// return handles for Any widget that may need them
		this._subscribes.push(handle);
		return handle;
	},

	unsubscribe: function(/*Object*/ handle){
		// summary:
		//		Unsubscribes handle created by this.subscribe.
		//		Also removes handle from this widget's list of subscriptions
		for(var i=0; i<this._subscribes.length; i++){
			if(this._subscribes[i] == handle){
				dojo.unsubscribe(handle);
				this._subscribes.splice(i, 1);
				return;
			}
		}
	},

	isLeftToRight: function(){
		// summary:
		//		Return this widget's explicit or implicit orientation (true for LTR, false for RTL)
		// tags:
		//		protected
		return this.dir ? (this.dir == "ltr") : dojo._isBodyLtr(); //Boolean
	},

	placeAt: function(/* String|DomNode|_Widget */reference, /* String?|Int? */position){
		// summary:
		//		Place this widget's domNode reference somewhere in the DOM based
		//		on standard dojo.place conventions, or passing a Widget reference that
		//		contains and addChild member.
		//
		// description:
		//		A convenience function provided in all _Widgets, providing a simple
		//		shorthand mechanism to put an existing (or newly created) Widget
		//		somewhere in the dom, and allow chaining.
		//
		// reference:
		//		The String id of a domNode, a domNode reference, or a reference to a Widget posessing
		//		an addChild method.
		//
		// position:
		//		If passed a string or domNode reference, the position argument
		//		accepts a string just as dojo.place does, one of: "first", "last",
		//		"before", or "after".
		//
		//		If passed a _Widget reference, and that widget reference has an ".addChild" method,
		//		it will be called passing this widget instance into that method, supplying the optional
		//		position index passed.
		//
		// returns:
		//		dijit._Widget
		//		Provides a useful return of the newly created dijit._Widget instance so you
		//		can "chain" this function by instantiating, placing, then saving the return value
		//		to a variable.
		//
		// example:
		// | 	// create a Button with no srcNodeRef, and place it in the body:
		// | 	var button = new dijit.form.Button({ label:"click" }).placeAt(dojo.body());
		// | 	// now, 'button' is still the widget reference to the newly created button
		// | 	dojo.connect(button, "onClick", function(e){ console.log('click'); });
		//
		// example:
		// |	// create a button out of a node with id="src" and append it to id="wrapper":
		// | 	var button = new dijit.form.Button({},"src").placeAt("wrapper");
		//
		// example:
		// |	// place a new button as the first element of some div
		// |	var button = new dijit.form.Button({ label:"click" }).placeAt("wrapper","first");
		//
		// example:
		// |	// create a contentpane and add it to a TabContainer
		// |	var tc = dijit.byId("myTabs");
		// |	new dijit.layout.ContentPane({ href:"foo.html", title:"Wow!" }).placeAt(tc)

		if(reference.declaredClass && reference.addChild){
			reference.addChild(this, position);
		}else{
			dojo.place(this.domNode, reference, position);
		}
		return this;
	}
});

})();

}

if(!dojo._hasResource["dojo.window"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.window"] = true;
dojo.provide("dojo.window");

dojo.getObject("window", true, dojo);

dojo.window.getBox = function(){
	// summary:
	//		Returns the dimensions and scroll position of the viewable area of a browser window

	var scrollRoot = (dojo.doc.compatMode == 'BackCompat') ? dojo.body() : dojo.doc.documentElement;

	// get scroll position
	var scroll = dojo._docScroll(); // scrollRoot.scrollTop/Left should work
	return { w: scrollRoot.clientWidth, h: scrollRoot.clientHeight, l: scroll.x, t: scroll.y };
};

dojo.window.get = function(doc){
	// summary:
	// 		Get window object associated with document doc

	// In some IE versions (at least 6.0), document.parentWindow does not return a
	// reference to the real window object (maybe a copy), so we must fix it as well
	// We use IE specific execScript to attach the real window reference to
	// document._parentWindow for later use
	if(dojo.isIE && window !== document.parentWindow){
		/*
		In IE 6, only the variable "window" can be used to connect events (others
		may be only copies).
		*/
		doc.parentWindow.execScript("document._parentWindow = window;", "Javascript");
		//to prevent memory leak, unset it after use
		//another possibility is to add an onUnload handler which seems overkill to me (liucougar)
		var win = doc._parentWindow;
		doc._parentWindow = null;
		return win;	//	Window
	}

	return doc.parentWindow || doc.defaultView;	//	Window
};

dojo.window.scrollIntoView = function(/*DomNode*/ node, /*Object?*/ pos){
	// summary:
	//		Scroll the passed node into view, if it is not already.
	
	// don't rely on node.scrollIntoView working just because the function is there

	try{ // catch unexpected/unrecreatable errors (#7808) since we can recover using a semi-acceptable native method
		node = dojo.byId(node);
		var doc = node.ownerDocument || dojo.doc,
			body = doc.body || dojo.body(),
			html = doc.documentElement || body.parentNode,
			isIE = dojo.isIE, isWK = dojo.isWebKit;
		// if an untested browser, then use the native method
		if((!(dojo.isMoz || isIE || isWK || dojo.isOpera) || node == body || node == html) && (typeof node.scrollIntoView != "undefined")){
			node.scrollIntoView(false); // short-circuit to native if possible
			return;
		}
		var backCompat = doc.compatMode == 'BackCompat',
			clientAreaRoot = (isIE >= 9 && node.ownerDocument.parentWindow.frameElement)
				? ((html.clientHeight > 0 && html.clientWidth > 0 && (body.clientHeight == 0 || body.clientWidth == 0 || body.clientHeight > html.clientHeight || body.clientWidth > html.clientWidth)) ? html : body)
				: (backCompat ? body : html),
			scrollRoot = isWK ? body : clientAreaRoot,
			rootWidth = clientAreaRoot.clientWidth,
			rootHeight = clientAreaRoot.clientHeight,
			rtl = !dojo._isBodyLtr(),
			nodePos = pos || dojo.position(node),
			el = node.parentNode,
			isFixed = function(el){
				return ((isIE <= 6 || (isIE && backCompat))? false : (dojo.style(el, 'position').toLowerCase() == "fixed"));
			};
		if(isFixed(node)){ return; } // nothing to do

		while(el){
			if(el == body){ el = scrollRoot; }
			var elPos = dojo.position(el),
				fixedPos = isFixed(el);
	
			if(el == scrollRoot){
				elPos.w = rootWidth; elPos.h = rootHeight;
				if(scrollRoot == html && isIE && rtl){ elPos.x += scrollRoot.offsetWidth-elPos.w; } // IE workaround where scrollbar causes negative x
				if(elPos.x < 0 || !isIE){ elPos.x = 0; } // IE can have values > 0
				if(elPos.y < 0 || !isIE){ elPos.y = 0; }
			}else{
				var pb = dojo._getPadBorderExtents(el);
				elPos.w -= pb.w; elPos.h -= pb.h; elPos.x += pb.l; elPos.y += pb.t;
				var clientSize = el.clientWidth,
					scrollBarSize = elPos.w - clientSize;
				if(clientSize > 0 && scrollBarSize > 0){
					elPos.w = clientSize;
					elPos.x += (rtl && (isIE || el.clientLeft > pb.l/*Chrome*/)) ? scrollBarSize : 0;
				}
				clientSize = el.clientHeight;
				scrollBarSize = elPos.h - clientSize;
				if(clientSize > 0 && scrollBarSize > 0){
					elPos.h = clientSize;
				}
			}
			if(fixedPos){ // bounded by viewport, not parents
				if(elPos.y < 0){
					elPos.h += elPos.y; elPos.y = 0;
				}
				if(elPos.x < 0){
					elPos.w += elPos.x; elPos.x = 0;
				}
				if(elPos.y + elPos.h > rootHeight){
					elPos.h = rootHeight - elPos.y;
				}
				if(elPos.x + elPos.w > rootWidth){
					elPos.w = rootWidth - elPos.x;
				}
			}
			// calculate overflow in all 4 directions
			var l = nodePos.x - elPos.x, // beyond left: < 0
				t = nodePos.y - Math.max(elPos.y, 0), // beyond top: < 0
				r = l + nodePos.w - elPos.w, // beyond right: > 0
				bot = t + nodePos.h - elPos.h; // beyond bottom: > 0
			if(r * l > 0){
				var s = Math[l < 0? "max" : "min"](l, r);
				if(rtl && ((isIE == 8 && !backCompat) || isIE >= 9)){ s = -s; }
				nodePos.x += el.scrollLeft;
				el.scrollLeft += s;
				nodePos.x -= el.scrollLeft;
			}
			if(bot * t > 0){
				nodePos.y += el.scrollTop;
				el.scrollTop += Math[t < 0? "max" : "min"](t, bot);
				nodePos.y -= el.scrollTop;
			}
			el = (el != scrollRoot) && !fixedPos && el.parentNode;
		}
	}catch(error){
		console.error('scrollIntoView: ' + error);
		node.scrollIntoView(false);
	}
};

}

if(!dojo._hasResource["dijit._base.focus"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._base.focus"] = true;
dojo.provide("dijit._base.focus");




// summary:
//		These functions are used to query or set the focus and selection.
//
//		Also, they trace when widgets become activated/deactivated,
//		so that the widget can fire _onFocus/_onBlur events.
//		"Active" here means something similar to "focused", but
//		"focus" isn't quite the right word because we keep track of
//		a whole stack of "active" widgets.  Example: ComboButton --> Menu -->
//		MenuItem.  The onBlur event for ComboButton doesn't fire due to focusing
//		on the Menu or a MenuItem, since they are considered part of the
//		ComboButton widget.  It only happens when focus is shifted
//		somewhere completely different.

dojo.mixin(dijit, {
	// _curFocus: DomNode
	//		Currently focused item on screen
	_curFocus: null,

	// _prevFocus: DomNode
	//		Previously focused item on screen
	_prevFocus: null,

	isCollapsed: function(){
		// summary:
		//		Returns true if there is no text selected
		return dijit.getBookmark().isCollapsed;
	},

	getBookmark: function(){
		// summary:
		//		Retrieves a bookmark that can be used with moveToBookmark to return to the same range
		var bm, rg, tg, sel = dojo.doc.selection, cf = dijit._curFocus;

		if(dojo.global.getSelection){
			//W3C Range API for selections.
			sel = dojo.global.getSelection();
			if(sel){
				if(sel.isCollapsed){
					tg = cf? cf.tagName : "";
					if(tg){
						//Create a fake rangelike item to restore selections.
						tg = tg.toLowerCase();
						if(tg == "textarea" ||
								(tg == "input" && (!cf.type || cf.type.toLowerCase() == "text"))){
							sel = {
								start: cf.selectionStart,
								end: cf.selectionEnd,
								node: cf,
								pRange: true
							};
							return {isCollapsed: (sel.end <= sel.start), mark: sel}; //Object.
						}
					}
					bm = {isCollapsed:true};
					if(sel.rangeCount){
						bm.mark = sel.getRangeAt(0).cloneRange();
					}
				}else{
					rg = sel.getRangeAt(0);
					bm = {isCollapsed: false, mark: rg.cloneRange()};
				}
			}
		}else if(sel){
			// If the current focus was a input of some sort and no selection, don't bother saving
			// a native bookmark.  This is because it causes issues with dialog/page selection restore.
			// So, we need to create psuedo bookmarks to work with.
			tg = cf ? cf.tagName : "";
			tg = tg.toLowerCase();
			if(cf && tg && (tg == "button" || tg == "textarea" || tg == "input")){
				if(sel.type && sel.type.toLowerCase() == "none"){
					return {
						isCollapsed: true,
						mark: null
					}
				}else{
					rg = sel.createRange();
					return {
						isCollapsed: rg.text && rg.text.length?false:true,
						mark: {
							range: rg,
							pRange: true
						}
					};
				}
			}
			bm = {};

			//'IE' way for selections.
			try{
				// createRange() throws exception when dojo in iframe
				//and nothing selected, see #9632
				rg = sel.createRange();
				bm.isCollapsed = !(sel.type == 'Text' ? rg.htmlText.length : rg.length);
			}catch(e){
				bm.isCollapsed = true;
				return bm;
			}
			if(sel.type.toUpperCase() == 'CONTROL'){
				if(rg.length){
					bm.mark=[];
					var i=0,len=rg.length;
					while(i<len){
						bm.mark.push(rg.item(i++));
					}
				}else{
					bm.isCollapsed = true;
					bm.mark = null;
				}
			}else{
				bm.mark = rg.getBookmark();
			}
		}else{
			console.warn("No idea how to store the current selection for this browser!");
		}
		return bm; // Object
	},

	moveToBookmark: function(/*Object*/bookmark){
		// summary:
		//		Moves current selection to a bookmark
		// bookmark:
		//		This should be a returned object from dijit.getBookmark()

		var _doc = dojo.doc,
			mark = bookmark.mark;
		if(mark){
			if(dojo.global.getSelection){
				//W3C Rangi API (FF, WebKit, Opera, etc)
				var sel = dojo.global.getSelection();
				if(sel && sel.removeAllRanges){
					if(mark.pRange){
						var r = mark;
						var n = r.node;
						n.selectionStart = r.start;
						n.selectionEnd = r.end;
					}else{
						sel.removeAllRanges();
						sel.addRange(mark);
					}
				}else{
					console.warn("No idea how to restore selection for this browser!");
				}
			}else if(_doc.selection && mark){
				//'IE' way.
				var rg;
				if(mark.pRange){
					rg = mark.range;
				}else if(dojo.isArray(mark)){
					rg = _doc.body.createControlRange();
					//rg.addElement does not have call/apply method, so can not call it directly
					//rg is not available in "range.addElement(item)", so can't use that either
					dojo.forEach(mark, function(n){
						rg.addElement(n);
					});
				}else{
					rg = _doc.body.createTextRange();
					rg.moveToBookmark(mark);
				}
				rg.select();
			}
		}
	},

	getFocus: function(/*Widget?*/ menu, /*Window?*/ openedForWindow){
		// summary:
		//		Called as getFocus(), this returns an Object showing the current focus
		//		and selected text.
		//
		//		Called as getFocus(widget), where widget is a (widget representing) a button
		//		that was just pressed, it returns where focus was before that button
		//		was pressed.   (Pressing the button may have either shifted focus to the button,
		//		or removed focus altogether.)   In this case the selected text is not returned,
		//		since it can't be accurately determined.
		//
		// menu: dijit._Widget or {domNode: DomNode} structure
		//		The button that was just pressed.  If focus has disappeared or moved
		//		to this button, returns the previous focus.  In this case the bookmark
		//		information is already lost, and null is returned.
		//
		// openedForWindow:
		//		iframe in which menu was opened
		//
		// returns:
		//		A handle to restore focus/selection, to be passed to `dijit.focus`
		var node = !dijit._curFocus || (menu && dojo.isDescendant(dijit._curFocus, menu.domNode)) ? dijit._prevFocus : dijit._curFocus;
		return {
			node: node,
			bookmark: (node == dijit._curFocus) && dojo.withGlobal(openedForWindow || dojo.global, dijit.getBookmark),
			openedForWindow: openedForWindow
		}; // Object
	},

	focus: function(/*Object || DomNode */ handle){
		// summary:
		//		Sets the focused node and the selection according to argument.
		//		To set focus to an iframe's content, pass in the iframe itself.
		// handle:
		//		object returned by get(), or a DomNode

		if(!handle){ return; }

		var node = "node" in handle ? handle.node : handle,		// because handle is either DomNode or a composite object
			bookmark = handle.bookmark,
			openedForWindow = handle.openedForWindow,
			collapsed = bookmark ? bookmark.isCollapsed : false;

		// Set the focus
		// Note that for iframe's we need to use the <iframe> to follow the parentNode chain,
		// but we need to set focus to iframe.contentWindow
		if(node){
			var focusNode = (node.tagName.toLowerCase() == "iframe") ? node.contentWindow : node;
			if(focusNode && focusNode.focus){
				try{
					// Gecko throws sometimes if setting focus is impossible,
					// node not displayed or something like that
					focusNode.focus();
				}catch(e){/*quiet*/}
			}
			dijit._onFocusNode(node);
		}

		// set the selection
		// do not need to restore if current selection is not empty
		// (use keyboard to select a menu item) or if previous selection was collapsed
		// as it may cause focus shift (Esp in IE).
		if(bookmark && dojo.withGlobal(openedForWindow || dojo.global, dijit.isCollapsed) && !collapsed){
			if(openedForWindow){
				openedForWindow.focus();
			}
			try{
				dojo.withGlobal(openedForWindow || dojo.global, dijit.moveToBookmark, null, [bookmark]);
			}catch(e2){
				/*squelch IE internal error, see http://trac.dojotoolkit.org/ticket/1984 */
			}
		}
	},

	// _activeStack: dijit._Widget[]
	//		List of currently active widgets (focused widget and it's ancestors)
	_activeStack: [],

	registerIframe: function(/*DomNode*/ iframe){
		// summary:
		//		Registers listeners on the specified iframe so that any click
		//		or focus event on that iframe (or anything in it) is reported
		//		as a focus/click event on the <iframe> itself.
		// description:
		//		Currently only used by editor.
		// returns:
		//		Handle to pass to unregisterIframe()
		return dijit.registerWin(iframe.contentWindow, iframe);
	},

	unregisterIframe: function(/*Object*/ handle){
		// summary:
		//		Unregisters listeners on the specified iframe created by registerIframe.
		//		After calling be sure to delete or null out the handle itself.
		// handle:
		//		Handle returned by registerIframe()

		dijit.unregisterWin(handle);
	},

	registerWin: function(/*Window?*/targetWindow, /*DomNode?*/ effectiveNode){
		// summary:
		//		Registers listeners on the specified window (either the main
		//		window or an iframe's window) to detect when the user has clicked somewhere
		//		or focused somewhere.
		// description:
		//		Users should call registerIframe() instead of this method.
		// targetWindow:
		//		If specified this is the window associated with the iframe,
		//		i.e. iframe.contentWindow.
		// effectiveNode:
		//		If specified, report any focus events inside targetWindow as
		//		an event on effectiveNode, rather than on evt.target.
		// returns:
		//		Handle to pass to unregisterWin()

		// TODO: make this function private in 2.0; Editor/users should call registerIframe(),

		var mousedownListener = function(evt){
			dijit._justMouseDowned = true;
			setTimeout(function(){ dijit._justMouseDowned = false; }, 0);
			
			// workaround weird IE bug where the click is on an orphaned node
			// (first time clicking a Select/DropDownButton inside a TooltipDialog)
			if(dojo.isIE && evt && evt.srcElement && evt.srcElement.parentNode == null){
				return;
			}

			dijit._onTouchNode(effectiveNode || evt.target || evt.srcElement, "mouse");
		};
		//dojo.connect(targetWindow, "onscroll", ???);

		// Listen for blur and focus events on targetWindow's document.
		// IIRC, I'm using attachEvent() rather than dojo.connect() because focus/blur events don't bubble
		// through dojo.connect(), and also maybe to catch the focus events early, before onfocus handlers
		// fire.
		// Connect to <html> (rather than document) on IE to avoid memory leaks, but document on other browsers because
		// (at least for FF) the focus event doesn't fire on <html> or <body>.
		var doc = dojo.isIE ? targetWindow.document.documentElement : targetWindow.document;
		if(doc){
			if(dojo.isIE){
				targetWindow.document.body.attachEvent('onmousedown', mousedownListener);
				var activateListener = function(evt){
					// IE reports that nodes like <body> have gotten focus, even though they have tabIndex=-1,
					// Should consider those more like a mouse-click than a focus....
					if(evt.srcElement.tagName.toLowerCase() != "#document" &&
						dijit.isTabNavigable(evt.srcElement)){
						dijit._onFocusNode(effectiveNode || evt.srcElement);
					}else{
						dijit._onTouchNode(effectiveNode || evt.srcElement);
					}
				};
				doc.attachEvent('onactivate', activateListener);
				var deactivateListener =  function(evt){
					dijit._onBlurNode(effectiveNode || evt.srcElement);
				};
				doc.attachEvent('ondeactivate', deactivateListener);

				return function(){
					targetWindow.document.detachEvent('onmousedown', mousedownListener);
					doc.detachEvent('onactivate', activateListener);
					doc.detachEvent('ondeactivate', deactivateListener);
					doc = null;	// prevent memory leak (apparent circular reference via closure)
				};
			}else{
				doc.body.addEventListener('mousedown', mousedownListener, true);
				var focusListener = function(evt){
					dijit._onFocusNode(effectiveNode || evt.target);
				};
				doc.addEventListener('focus', focusListener, true);
				var blurListener = function(evt){
					dijit._onBlurNode(effectiveNode || evt.target);
				};
				doc.addEventListener('blur', blurListener, true);

				return function(){
					doc.body.removeEventListener('mousedown', mousedownListener, true);
					doc.removeEventListener('focus', focusListener, true);
					doc.removeEventListener('blur', blurListener, true);
					doc = null;	// prevent memory leak (apparent circular reference via closure)
				};
			}
		}
	},

	unregisterWin: function(/*Handle*/ handle){
		// summary:
		//		Unregisters listeners on the specified window (either the main
		//		window or an iframe's window) according to handle returned from registerWin().
		//		After calling be sure to delete or null out the handle itself.

		// Currently our handle is actually a function
		handle && handle();
	},

	_onBlurNode: function(/*DomNode*/ node){
		// summary:
		// 		Called when focus leaves a node.
		//		Usually ignored, _unless_ it *isn't* follwed by touching another node,
		//		which indicates that we tabbed off the last field on the page,
		//		in which case every widget is marked inactive
		dijit._prevFocus = dijit._curFocus;
		dijit._curFocus = null;

		if(dijit._justMouseDowned){
			// the mouse down caused a new widget to be marked as active; this blur event
			// is coming late, so ignore it.
			return;
		}

		// if the blur event isn't followed by a focus event then mark all widgets as inactive.
		if(dijit._clearActiveWidgetsTimer){
			clearTimeout(dijit._clearActiveWidgetsTimer);
		}
		dijit._clearActiveWidgetsTimer = setTimeout(function(){
			delete dijit._clearActiveWidgetsTimer;
			dijit._setStack([]);
			dijit._prevFocus = null;
		}, 100);
	},

	_onTouchNode: function(/*DomNode*/ node, /*String*/ by){
		// summary:
		//		Callback when node is focused or mouse-downed
		// node:
		//		The node that was touched.
		// by:
		//		"mouse" if the focus/touch was caused by a mouse down event

		// ignore the recent blurNode event
		if(dijit._clearActiveWidgetsTimer){
			clearTimeout(dijit._clearActiveWidgetsTimer);
			delete dijit._clearActiveWidgetsTimer;
		}

		// compute stack of active widgets (ex: ComboButton --> Menu --> MenuItem)
		var newStack=[];
		try{
			while(node){
				var popupParent = dojo.attr(node, "dijitPopupParent");
				if(popupParent){
					node=dijit.byId(popupParent).domNode;
				}else if(node.tagName && node.tagName.toLowerCase() == "body"){
					// is this the root of the document or just the root of an iframe?
					if(node === dojo.body()){
						// node is the root of the main document
						break;
					}
					// otherwise, find the iframe this node refers to (can't access it via parentNode,
					// need to do this trick instead). window.frameElement is supported in IE/FF/Webkit
					node=dojo.window.get(node.ownerDocument).frameElement;
				}else{
					// if this node is the root node of a widget, then add widget id to stack,
					// except ignore clicks on disabled widgets (actually focusing a disabled widget still works,
					// to support MenuItem)
					var id = node.getAttribute && node.getAttribute("widgetId"),
						widget = id && dijit.byId(id);
					if(widget && !(by == "mouse" && widget.get("disabled"))){
						newStack.unshift(id);
					}
					node=node.parentNode;
				}
			}
		}catch(e){ /* squelch */ }

		dijit._setStack(newStack, by);
	},

	_onFocusNode: function(/*DomNode*/ node){
		// summary:
		//		Callback when node is focused

		if(!node){
			return;
		}

		if(node.nodeType == 9){
			// Ignore focus events on the document itself.  This is here so that
			// (for example) clicking the up/down arrows of a spinner
			// (which don't get focus) won't cause that widget to blur. (FF issue)
			return;
		}

		dijit._onTouchNode(node);

		if(node == dijit._curFocus){ return; }
		if(dijit._curFocus){
			dijit._prevFocus = dijit._curFocus;
		}
		dijit._curFocus = node;
		dojo.publish("focusNode", [node]);
	},

	_setStack: function(/*String[]*/ newStack, /*String*/ by){
		// summary:
		//		The stack of active widgets has changed.  Send out appropriate events and records new stack.
		// newStack:
		//		array of widget id's, starting from the top (outermost) widget
		// by:
		//		"mouse" if the focus/touch was caused by a mouse down event

		var oldStack = dijit._activeStack;
		dijit._activeStack = newStack;

		// compare old stack to new stack to see how many elements they have in common
		for(var nCommon=0; nCommon<Math.min(oldStack.length, newStack.length); nCommon++){
			if(oldStack[nCommon] != newStack[nCommon]){
				break;
			}
		}

		var widget;
		// for all elements that have gone out of focus, send blur event
		for(var i=oldStack.length-1; i>=nCommon; i--){
			widget = dijit.byId(oldStack[i]);
			if(widget){
				widget._focused = false;
				widget.set("focused", false);
				widget._hasBeenBlurred = true;
				if(widget._onBlur){
					widget._onBlur(by);
				}
				dojo.publish("widgetBlur", [widget, by]);
			}
		}

		// for all element that have come into focus, send focus event
		for(i=nCommon; i<newStack.length; i++){
			widget = dijit.byId(newStack[i]);
			if(widget){
				widget._focused = true;
				widget.set("focused", true);
				if(widget._onFocus){
					widget._onFocus(by);
				}
				dojo.publish("widgetFocus", [widget, by]);
			}
		}
	}
});

// register top window and all the iframes it contains
dojo.addOnLoad(function(){
	var handle = dijit.registerWin(window);
	if(dojo.isIE){
		dojo.addOnWindowUnload(function(){
			dijit.unregisterWin(handle);
			handle = null;
		})
	}
});

}

if(!dojo._hasResource["dojo.AdapterRegistry"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.AdapterRegistry"] = true;
dojo.provide("dojo.AdapterRegistry");


dojo.AdapterRegistry = function(/*Boolean?*/ returnWrappers){
	//	summary:
	//		A registry to make contextual calling/searching easier.
	//	description:
	//		Objects of this class keep list of arrays in the form [name, check,
	//		wrap, directReturn] that are used to determine what the contextual
	//		result of a set of checked arguments is. All check/wrap functions
	//		in this registry should be of the same arity.
	//	example:
	//	|	// create a new registry
	//	|	var reg = new dojo.AdapterRegistry();
	//	|	reg.register("handleString",
	//	|		dojo.isString,
	//	|		function(str){
	//	|			// do something with the string here
	//	|		}
	//	|	);
	//	|	reg.register("handleArr",
	//	|		dojo.isArray,
	//	|		function(arr){
	//	|			// do something with the array here
	//	|		}
	//	|	);
	//	|
	//	|	// now we can pass reg.match() *either* an array or a string and
	//	|	// the value we pass will get handled by the right function
	//	|	reg.match("someValue"); // will call the first function
	//	|	reg.match(["someValue"]); // will call the second

	this.pairs = [];
	this.returnWrappers = returnWrappers || false; // Boolean
};

dojo.extend(dojo.AdapterRegistry, {
	register: function(/*String*/ name, /*Function*/ check, /*Function*/ wrap, /*Boolean?*/ directReturn, /*Boolean?*/ override){
		//	summary:
		//		register a check function to determine if the wrap function or
		//		object gets selected
		//	name:
		//		a way to identify this matcher.
		//	check:
		//		a function that arguments are passed to from the adapter's
		//		match() function.  The check function should return true if the
		//		given arguments are appropriate for the wrap function.
		//	directReturn:
		//		If directReturn is true, the value passed in for wrap will be
		//		returned instead of being called. Alternately, the
		//		AdapterRegistry can be set globally to "return not call" using
		//		the returnWrappers property. Either way, this behavior allows
		//		the registry to act as a "search" function instead of a
		//		function interception library.
		//	override:
		//		If override is given and true, the check function will be given
		//		highest priority. Otherwise, it will be the lowest priority
		//		adapter.
		this.pairs[((override) ? "unshift" : "push")]([name, check, wrap, directReturn]);
	},

	match: function(/* ... */){
		// summary:
		//		Find an adapter for the given arguments. If no suitable adapter
		//		is found, throws an exception. match() accepts any number of
		//		arguments, all of which are passed to all matching functions
		//		from the registered pairs.
		for(var i = 0; i < this.pairs.length; i++){
			var pair = this.pairs[i];
			if(pair[1].apply(this, arguments)){
				if((pair[3])||(this.returnWrappers)){
					return pair[2];
				}else{
					return pair[2].apply(this, arguments);
				}
			}
		}
		throw new Error("No match found");
	},

	unregister: function(name){
		// summary: Remove a named adapter from the registry

		// FIXME: this is kind of a dumb way to handle this. On a large
		// registry this will be slow-ish and we can use the name as a lookup
		// should we choose to trade memory for speed.
		for(var i = 0; i < this.pairs.length; i++){
			var pair = this.pairs[i];
			if(pair[0] == name){
				this.pairs.splice(i, 1);
				return true;
			}
		}
		return false;
	}
});

}

if(!dojo._hasResource["dijit._base.place"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._base.place"] = true;
dojo.provide("dijit._base.place");




dijit.getViewport = function(){
	// summary:
	//		Returns the dimensions and scroll position of the viewable area of a browser window

	return dojo.window.getBox();
};

/*=====
dijit.__Position = function(){
	// x: Integer
	//		horizontal coordinate in pixels, relative to document body
	// y: Integer
	//		vertical coordinate in pixels, relative to document body

	thix.x = x;
	this.y = y;
}
=====*/


dijit.placeOnScreen = function(
	/* DomNode */			node,
	/* dijit.__Position */	pos,
	/* String[] */			corners,
	/* dijit.__Position? */	padding){
	// summary:
	//		Positions one of the node's corners at specified position
	//		such that node is fully visible in viewport.
	// description:
	//		NOTE: node is assumed to be absolutely or relatively positioned.
	//	pos:
	//		Object like {x: 10, y: 20}
	//	corners:
	//		Array of Strings representing order to try corners in, like ["TR", "BL"].
	//		Possible values are:
	//			* "BL" - bottom left
	//			* "BR" - bottom right
	//			* "TL" - top left
	//			* "TR" - top right
	//	padding:
	//		set padding to put some buffer around the element you want to position.
	// example:
	//		Try to place node's top right corner at (10,20).
	//		If that makes node go (partially) off screen, then try placing
	//		bottom left corner at (10,20).
	//	|	placeOnScreen(node, {x: 10, y: 20}, ["TR", "BL"])

	var choices = dojo.map(corners, function(corner){
		var c = { corner: corner, pos: {x:pos.x,y:pos.y} };
		if(padding){
			c.pos.x += corner.charAt(1) == 'L' ? padding.x : -padding.x;
			c.pos.y += corner.charAt(0) == 'T' ? padding.y : -padding.y;
		}
		return c;
	});

	return dijit._place(node, choices);
}

dijit._place = function(/*DomNode*/ node, choices, layoutNode, /*Object*/ aroundNodeCoords){
	// summary:
	//		Given a list of spots to put node, put it at the first spot where it fits,
	//		of if it doesn't fit anywhere then the place with the least overflow
	// choices: Array
	//		Array of elements like: {corner: 'TL', pos: {x: 10, y: 20} }
	//		Above example says to put the top-left corner of the node at (10,20)
	// layoutNode: Function(node, aroundNodeCorner, nodeCorner, size)
	//		for things like tooltip, they are displayed differently (and have different dimensions)
	//		based on their orientation relative to the parent.   This adjusts the popup based on orientation.
	//		It also passes in the available size for the popup, which is useful for tooltips to
	//		tell them that their width is limited to a certain amount.   layoutNode() may return a value expressing
	//		how much the popup had to be modified to fit into the available space.   This is used to determine
	//		what the best placement is.
	// aroundNodeCoords: Object
	//		Size of aroundNode, ex: {w: 200, h: 50}

	// get {x: 10, y: 10, w: 100, h:100} type obj representing position of
	// viewport over document
	var view = dojo.window.getBox();

	// This won't work if the node is inside a <div style="position: relative">,
	// so reattach it to dojo.doc.body.   (Otherwise, the positioning will be wrong
	// and also it might get cutoff)
	if(!node.parentNode || String(node.parentNode.tagName).toLowerCase() != "body"){
		dojo.body().appendChild(node);
	}

	var best = null;
	dojo.some(choices, function(choice){
		var corner = choice.corner;
		var pos = choice.pos;
		var overflow = 0;

		// calculate amount of space available given specified position of node
		var spaceAvailable = {
			w: corner.charAt(1) == 'L' ? (view.l + view.w) - pos.x : pos.x - view.l,
			h: corner.charAt(1) == 'T' ? (view.t + view.h) - pos.y : pos.y - view.t
		};

		// configure node to be displayed in given position relative to button
		// (need to do this in order to get an accurate size for the node, because
		// a tooltip's size changes based on position, due to triangle)
		if(layoutNode){
			var res = layoutNode(node, choice.aroundCorner, corner, spaceAvailable, aroundNodeCoords);
			overflow = typeof res == "undefined" ? 0 : res;
		}

		// get node's size
		var style = node.style;
		var oldDisplay = style.display;
		var oldVis = style.visibility;
		style.visibility = "hidden";
		style.display = "";
		var mb = dojo.marginBox(node);
		style.display = oldDisplay;
		style.visibility = oldVis;

		// coordinates and size of node with specified corner placed at pos,
		// and clipped by viewport
		var startX = Math.max(view.l, corner.charAt(1) == 'L' ? pos.x : (pos.x - mb.w)),
			startY = Math.max(view.t, corner.charAt(0) == 'T' ? pos.y : (pos.y - mb.h)),
			endX = Math.min(view.l + view.w, corner.charAt(1) == 'L' ? (startX + mb.w) : pos.x),
			endY = Math.min(view.t + view.h, corner.charAt(0) == 'T' ? (startY + mb.h) : pos.y),
			width = endX - startX,
			height = endY - startY;

		overflow += (mb.w - width) + (mb.h - height);

		if(best == null || overflow < best.overflow){
			best = {
				corner: corner,
				aroundCorner: choice.aroundCorner,
				x: startX,
				y: startY,
				w: width,
				h: height,
				overflow: overflow,
				spaceAvailable: spaceAvailable
			};
		}
		
		return !overflow;
	});

	// In case the best position is not the last one we checked, need to call
	// layoutNode() again.
	if(best.overflow && layoutNode){
		layoutNode(node, best.aroundCorner, best.corner, best.spaceAvailable, aroundNodeCoords);
	}

	// And then position the node.   Do this last, after the layoutNode() above
	// has sized the node, due to browser quirks when the viewport is scrolled
	// (specifically that a Tooltip will shrink to fit as though the window was
	// scrolled to the left).
	//
	// In RTL mode, set style.right rather than style.left so in the common case,
	// window resizes move the popup along with the aroundNode.
	var l = dojo._isBodyLtr(),
		s = node.style;
	s.top = best.y + "px";
	s[l ? "left" : "right"] = (l ? best.x : view.w - best.x - best.w) + "px";
	
	return best;
}

dijit.placeOnScreenAroundNode = function(
	/* DomNode */		node,
	/* DomNode */		aroundNode,
	/* Object */		aroundCorners,
	/* Function? */		layoutNode){

	// summary:
	//		Position node adjacent or kitty-corner to aroundNode
	//		such that it's fully visible in viewport.
	//
	// description:
	//		Place node such that corner of node touches a corner of
	//		aroundNode, and that node is fully visible.
	//
	// aroundCorners:
	//		Ordered list of pairs of corners to try matching up.
	//		Each pair of corners is represented as a key/value in the hash,
	//		where the key corresponds to the aroundNode's corner, and
	//		the value corresponds to the node's corner:
	//
	//	|	{ aroundNodeCorner1: nodeCorner1, aroundNodeCorner2: nodeCorner2, ...}
	//
	//		The following strings are used to represent the four corners:
	//			* "BL" - bottom left
	//			* "BR" - bottom right
	//			* "TL" - top left
	//			* "TR" - top right
	//
	// layoutNode: Function(node, aroundNodeCorner, nodeCorner)
	//		For things like tooltip, they are displayed differently (and have different dimensions)
	//		based on their orientation relative to the parent.   This adjusts the popup based on orientation.
	//
	// example:
	//	|	dijit.placeOnScreenAroundNode(node, aroundNode, {'BL':'TL', 'TR':'BR'});
	//		This will try to position node such that node's top-left corner is at the same position
	//		as the bottom left corner of the aroundNode (ie, put node below
	//		aroundNode, with left edges aligned).  If that fails it will try to put
	// 		the bottom-right corner of node where the top right corner of aroundNode is
	//		(ie, put node above aroundNode, with right edges aligned)
	//

	// get coordinates of aroundNode
	aroundNode = dojo.byId(aroundNode);
	var aroundNodePos = dojo.position(aroundNode, true);

	// place the node around the calculated rectangle
	return dijit._placeOnScreenAroundRect(node,
		aroundNodePos.x, aroundNodePos.y, aroundNodePos.w, aroundNodePos.h,	// rectangle
		aroundCorners, layoutNode);
};

/*=====
dijit.__Rectangle = function(){
	// x: Integer
	//		horizontal offset in pixels, relative to document body
	// y: Integer
	//		vertical offset in pixels, relative to document body
	// width: Integer
	//		width in pixels
	// height: Integer
	//		height in pixels

	this.x = x;
	this.y = y;
	this.width = width;
	this.height = height;
}
=====*/


dijit.placeOnScreenAroundRectangle = function(
	/* DomNode */			node,
	/* dijit.__Rectangle */	aroundRect,
	/* Object */			aroundCorners,
	/* Function */			layoutNode){

	// summary:
	//		Like dijit.placeOnScreenAroundNode(), except that the "around"
	//		parameter is an arbitrary rectangle on the screen (x, y, width, height)
	//		instead of a dom node.

	return dijit._placeOnScreenAroundRect(node,
		aroundRect.x, aroundRect.y, aroundRect.width, aroundRect.height,	// rectangle
		aroundCorners, layoutNode);
};

dijit._placeOnScreenAroundRect = function(
	/* DomNode */		node,
	/* Number */		x,
	/* Number */		y,
	/* Number */		width,
	/* Number */		height,
	/* Object */		aroundCorners,
	/* Function */		layoutNode){

	// summary:
	//		Like dijit.placeOnScreenAroundNode(), except it accepts coordinates
	//		of a rectangle to place node adjacent to.

	// TODO: combine with placeOnScreenAroundRectangle()

	// Generate list of possible positions for node
	var choices = [];
	for(var nodeCorner in aroundCorners){
		choices.push( {
			aroundCorner: nodeCorner,
			corner: aroundCorners[nodeCorner],
			pos: {
				x: x + (nodeCorner.charAt(1) == 'L' ? 0 : width),
				y: y + (nodeCorner.charAt(0) == 'T' ? 0 : height)
			}
		});
	}

	return dijit._place(node, choices, layoutNode, {w: width, h: height});
};

dijit.placementRegistry= new dojo.AdapterRegistry();
dijit.placementRegistry.register("node",
	function(n, x){
		return typeof x == "object" &&
			typeof x.offsetWidth != "undefined" && typeof x.offsetHeight != "undefined";
	},
	dijit.placeOnScreenAroundNode);
dijit.placementRegistry.register("rect",
	function(n, x){
		return typeof x == "object" &&
			"x" in x && "y" in x && "width" in x && "height" in x;
	},
	dijit.placeOnScreenAroundRectangle);

dijit.placeOnScreenAroundElement = function(
	/* DomNode */		node,
	/* Object */		aroundElement,
	/* Object */		aroundCorners,
	/* Function */		layoutNode){

	// summary:
	//		Like dijit.placeOnScreenAroundNode(), except it accepts an arbitrary object
	//		for the "around" argument and finds a proper processor to place a node.

	return dijit.placementRegistry.match.apply(dijit.placementRegistry, arguments);
};

dijit.getPopupAroundAlignment = function(/*Array*/ position, /*Boolean*/ leftToRight){
	// summary:
	//		Transforms the passed array of preferred positions into a format suitable for passing as the aroundCorners argument to dijit.placeOnScreenAroundElement.
	//
	// position: String[]
	//		This variable controls the position of the drop down.
	//		It's an array of strings with the following values:
	//
	//			* before: places drop down to the left of the target node/widget, or to the right in
	//			  the case of RTL scripts like Hebrew and Arabic
	//			* after: places drop down to the right of the target node/widget, or to the left in
	//			  the case of RTL scripts like Hebrew and Arabic
	//			* above: drop down goes above target node
	//			* below: drop down goes below target node
	//
	//		The list is positions is tried, in order, until a position is found where the drop down fits
	//		within the viewport.
	//
	// leftToRight: Boolean
	//		Whether the popup will be displaying in leftToRight mode.
	//
	var align = {};
	dojo.forEach(position, function(pos){
		switch(pos){
			case "after":
				align[leftToRight ? "BR" : "BL"] = leftToRight ? "BL" : "BR";
				break;
			case "before":
				align[leftToRight ? "BL" : "BR"] = leftToRight ? "BR" : "BL";
				break;
			case "below-alt":
				leftToRight = !leftToRight;
				// fall through
			case "below":
				// first try to align left borders, next try to align right borders (or reverse for RTL mode)
				align[leftToRight ? "BL" : "BR"] = leftToRight ? "TL" : "TR";
				align[leftToRight ? "BR" : "BL"] = leftToRight ? "TR" : "TL";
				break;
			case "above-alt":
				leftToRight = !leftToRight;
				// fall through
			case "above":
			default:
				// first try to align left borders, next try to align right borders (or reverse for RTL mode)
				align[leftToRight ? "TL" : "TR"] = leftToRight ? "BL" : "BR";
				align[leftToRight ? "TR" : "TL"] = leftToRight ? "BR" : "BL";
				break;
		}
	});
	return align;
};

}

if(!dojo._hasResource["dijit._base.window"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._base.window"] = true;
dojo.provide("dijit._base.window");



dijit.getDocumentWindow = function(doc){
	return dojo.window.get(doc);
};

}

if(!dojo._hasResource["dijit._base.popup"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._base.popup"] = true;
dojo.provide("dijit._base.popup");





/*=====
dijit.popup.__OpenArgs = function(){
	// popup: Widget
	//		widget to display
	// parent: Widget
	//		the button etc. that is displaying this popup
	// around: DomNode
	//		DOM node (typically a button); place popup relative to this node.  (Specify this *or* "x" and "y" parameters.)
	// x: Integer
	//		Absolute horizontal position (in pixels) to place node at.  (Specify this *or* "around" parameter.)
	// y: Integer
	//		Absolute vertical position (in pixels) to place node at.  (Specify this *or* "around" parameter.)
	// orient: Object|String
	//		When the around parameter is specified, orient should be an
	//		ordered list of tuples of the form (around-node-corner, popup-node-corner).
	//		dijit.popup.open() tries to position the popup according to each tuple in the list, in order,
	//		until the popup appears fully within the viewport.
	//
	//		The default value is {BL:'TL', TL:'BL'}, which represents a list of two tuples:
	//			1. (BL, TL)
	//			2. (TL, BL)
	//		where BL means "bottom left" and "TL" means "top left".
	//		So by default, it first tries putting the popup below the around node, left-aligning them,
	//		and then tries to put it above the around node, still left-aligning them.   Note that the
	//		default is horizontally reversed when in RTL mode.
	//
	//		When an (x,y) position is specified rather than an around node, orient is either
	//		"R" or "L".  R (for right) means that it tries to put the popup to the right of the mouse,
	//		specifically positioning the popup's top-right corner at the mouse position, and if that doesn't
	//		fit in the viewport, then it tries, in order, the bottom-right corner, the top left corner,
	//		and the top-right corner.
	// onCancel: Function
	//		callback when user has canceled the popup by
	//			1. hitting ESC or
	//			2. by using the popup widget's proprietary cancel mechanism (like a cancel button in a dialog);
	//			   i.e. whenever popupWidget.onCancel() is called, args.onCancel is called
	// onClose: Function
	//		callback whenever this popup is closed
	// onExecute: Function
	//		callback when user "executed" on the popup/sub-popup by selecting a menu choice, etc. (top menu only)
	// padding: dijit.__Position
	//		adding a buffer around the opening position. This is only useful when around is not set.
	this.popup = popup;
	this.parent = parent;
	this.around = around;
	this.x = x;
	this.y = y;
	this.orient = orient;
	this.onCancel = onCancel;
	this.onClose = onClose;
	this.onExecute = onExecute;
	this.padding = padding;
}
=====*/

dijit.popup = {
	// summary:
	//		This singleton is used to show/hide widgets as popups.

	// _stack: dijit._Widget[]
	//		Stack of currently popped up widgets.
	//		(someone opened _stack[0], and then it opened _stack[1], etc.)
	_stack: [],
	
	// _beginZIndex: Number
	//		Z-index of the first popup.   (If first popup opens other
	//		popups they get a higher z-index.)
	_beginZIndex: 1000,

	_idGen: 1,

	_createWrapper: function(/*Widget || DomNode*/ widget){
		// summary:
		//		Initialization for widgets that will be used as popups.
		//		Puts widget inside a wrapper DIV (if not already in one),
		//		and returns pointer to that wrapper DIV.

		var wrapper = widget.declaredClass ? widget._popupWrapper : (widget.parentNode && dojo.hasClass(widget.parentNode, "dijitPopup")),
			node = widget.domNode || widget;

		if(!wrapper){
			// Create wrapper <div> for when this widget [in the future] will be used as a popup.
			// This is done early because of IE bugs where creating/moving DOM nodes causes focus
			// to go wonky, see tests/robot/Toolbar.html to reproduce
			wrapper = dojo.create("div",{
				"class":"dijitPopup",
				style:{ display: "none"},
				role: "presentation"
			}, dojo.body());
			wrapper.appendChild(node);

			var s = node.style;
			s.display = "";
			s.visibility = "";
			s.position = "";
			s.top = "0px";

			if(widget.declaredClass){		// TODO: in 2.0 change signature to always take widget, then remove if()
				widget._popupWrapper = wrapper;
				dojo.connect(widget, "destroy", function(){
					dojo.destroy(wrapper);
					delete widget._popupWrapper;
				});
			}
		}
		
		return wrapper;
	},

	moveOffScreen: function(/*Widget || DomNode*/ widget){
		// summary:
		//		Moves the popup widget off-screen.
		//		Do not use this method to hide popups when not in use, because
		//		that will create an accessibility issue: the offscreen popup is
		//		still in the tabbing order.

		// Create wrapper if not already there
		var wrapper = this._createWrapper(widget);

		dojo.style(wrapper, {
			visibility: "hidden",
			top: "-9999px",		// prevent transient scrollbar causing misalign (#5776), and initial flash in upper left (#10111)
			display: ""
		});
	},

	hide: function(/*dijit._Widget*/ widget){
		// summary:
		//		Hide this popup widget (until it is ready to be shown).
		//		Initialization for widgets that will be used as popups
		//
		// 		Also puts widget inside a wrapper DIV (if not already in one)
		//
		//		If popup widget needs to layout it should
		//		do so when it is made visible, and popup._onShow() is called.

		// Create wrapper if not already there
		var wrapper = this._createWrapper(widget);

		dojo.style(wrapper, "display", "none");
	},
		
	getTopPopup: function(){
		// summary:
		//		Compute the closest ancestor popup that's *not* a child of another popup.
		//		Ex: For a TooltipDialog with a button that spawns a tree of menus, find the popup of the button.
		var stack = this._stack;
		for(var pi=stack.length-1; pi > 0 && stack[pi].parent === stack[pi-1].widget; pi--){
			/* do nothing, just trying to get right value for pi */
		}
		return stack[pi];
	},

	open: function(/*dijit.popup.__OpenArgs*/ args){
		// summary:
		//		Popup the widget at the specified position
		//
		// example:
		//		opening at the mouse position
		//		|		dijit.popup.open({popup: menuWidget, x: evt.pageX, y: evt.pageY});
		//
		// example:
		//		opening the widget as a dropdown
		//		|		dijit.popup.open({parent: this, popup: menuWidget, around: this.domNode, onClose: function(){...}});
		//
		//		Note that whatever widget called dijit.popup.open() should also listen to its own _onBlur callback
		//		(fired from _base/focus.js) to know that focus has moved somewhere else and thus the popup should be closed.

		var stack = this._stack,
			widget = args.popup,
			orient = args.orient || (
				(args.parent ? args.parent.isLeftToRight() : dojo._isBodyLtr()) ?
				{'BL':'TL', 'BR':'TR', 'TL':'BL', 'TR':'BR'} :
				{'BR':'TR', 'BL':'TL', 'TR':'BR', 'TL':'BL'}
			),
			around = args.around,
			id = (args.around && args.around.id) ? (args.around.id+"_dropdown") : ("popup_"+this._idGen++);

		// If we are opening a new popup that isn't a child of a currently opened popup, then
		// close currently opened popup(s).   This should happen automatically when the old popups
		// gets the _onBlur() event, except that the _onBlur() event isn't reliable on IE, see [22198].
		while(stack.length && (!args.parent || !dojo.isDescendant(args.parent.domNode, stack[stack.length-1].widget.domNode))){
			dijit.popup.close(stack[stack.length-1].widget);
		}

		// Get pointer to popup wrapper, and create wrapper if it doesn't exist
		var wrapper = this._createWrapper(widget);


		dojo.attr(wrapper, {
			id: id,
			style: {
				zIndex: this._beginZIndex + stack.length
			},
			"class": "dijitPopup " + (widget.baseClass || widget["class"] || "").split(" ")[0] +"Popup",
			dijitPopupParent: args.parent ? args.parent.id : ""
		});

		if(dojo.isIE || dojo.isMoz){
			if(!widget.bgIframe){
				// setting widget.bgIframe triggers cleanup in _Widget.destroy()
				widget.bgIframe = new dijit.BackgroundIframe(wrapper);
			}
		}

		// position the wrapper node and make it visible
		var best = around ?
			dijit.placeOnScreenAroundElement(wrapper, around, orient, widget.orient ? dojo.hitch(widget, "orient") : null) :
			dijit.placeOnScreen(wrapper, args, orient == 'R' ? ['TR','BR','TL','BL'] : ['TL','BL','TR','BR'], args.padding);

		wrapper.style.display = "";
		wrapper.style.visibility = "visible";
		widget.domNode.style.visibility = "visible";	// counteract effects from _HasDropDown

		var handlers = [];

		// provide default escape and tab key handling
		// (this will work for any widget, not just menu)
		handlers.push(dojo.connect(wrapper, "onkeypress", this, function(evt){
			if(evt.charOrCode == dojo.keys.ESCAPE && args.onCancel){
				dojo.stopEvent(evt);
				args.onCancel();
			}else if(evt.charOrCode === dojo.keys.TAB){
				dojo.stopEvent(evt);
				var topPopup = this.getTopPopup();
				if(topPopup && topPopup.onCancel){
					topPopup.onCancel();
				}
			}
		}));

		// watch for cancel/execute events on the popup and notify the caller
		// (for a menu, "execute" means clicking an item)
		if(widget.onCancel){
			handlers.push(dojo.connect(widget, "onCancel", args.onCancel));
		}

		handlers.push(dojo.connect(widget, widget.onExecute ? "onExecute" : "onChange", this, function(){
			var topPopup = this.getTopPopup();
			if(topPopup && topPopup.onExecute){
				topPopup.onExecute();
			}
		}));

		stack.push({
			widget: widget,
			parent: args.parent,
			onExecute: args.onExecute,
			onCancel: args.onCancel,
 			onClose: args.onClose,
			handlers: handlers
		});

		if(widget.onOpen){
			// TODO: in 2.0 standardize onShow() (used by StackContainer) and onOpen() (used here)
			widget.onOpen(best);
		}

		return best;
	},

	close: function(/*dijit._Widget?*/ popup){
		// summary:
		//		Close specified popup and any popups that it parented.
		//		If no popup is specified, closes all popups.

		var stack = this._stack;

		// Basically work backwards from the top of the stack closing popups
		// until we hit the specified popup, but IIRC there was some issue where closing
		// a popup would cause others to close too.  Thus if we are trying to close B in [A,B,C]
		// closing C might close B indirectly and then the while() condition will run where stack==[A]...
		// so the while condition is constructed defensively.
		while((popup && dojo.some(stack, function(elem){return elem.widget == popup;})) ||
			(!popup && stack.length)){
			var top = stack.pop(),
				widget = top.widget,
				onClose = top.onClose;

			if(widget.onClose){
				// TODO: in 2.0 standardize onHide() (used by StackContainer) and onClose() (used here)
				widget.onClose();
			}
			dojo.forEach(top.handlers, dojo.disconnect);

			// Hide the widget and it's wrapper unless it has already been destroyed in above onClose() etc.
			if(widget && widget.domNode){
				this.hide(widget);
			}
                        
			if(onClose){
				onClose();
			}
		}
	}
};

// TODO: remove dijit._frames, it isn't being used much, since popups never release their
// iframes (see [22236])
dijit._frames = new function(){
	// summary:
	//		cache of iframes

	var queue = [];

	this.pop = function(){
		var iframe;
		if(queue.length){
			iframe = queue.pop();
			iframe.style.display="";
		}else{
			if(dojo.isIE < 9){
				var burl = dojo.config["dojoBlankHtmlUrl"] || (dojo.moduleUrl("dojo", "resources/blank.html")+"") || "javascript:\"\"";
				var html="<iframe src='" + burl + "'"
					+ " style='position: absolute; left: 0px; top: 0px;"
					+ "z-index: -1; filter:Alpha(Opacity=\"0\");'>";
				iframe = dojo.doc.createElement(html);
			}else{
			 	iframe = dojo.create("iframe");
				iframe.src = 'javascript:""';
				iframe.className = "dijitBackgroundIframe";
				dojo.style(iframe, "opacity", 0.1);
			}
			iframe.tabIndex = -1; // Magic to prevent iframe from getting focus on tab keypress - as style didn't work.
			dijit.setWaiRole(iframe,"presentation");
		}
		return iframe;
	};

	this.push = function(iframe){
		iframe.style.display="none";
		queue.push(iframe);
	}
}();


dijit.BackgroundIframe = function(/*DomNode*/ node){
	// summary:
	//		For IE/FF z-index schenanigans. id attribute is required.
	//
	// description:
	//		new dijit.BackgroundIframe(node)
	//			Makes a background iframe as a child of node, that fills
	//			area (and position) of node

	if(!node.id){ throw new Error("no id"); }
	if(dojo.isIE || dojo.isMoz){
		var iframe = (this.iframe = dijit._frames.pop());
		node.appendChild(iframe);
		if(dojo.isIE<7 || dojo.isQuirks){
			this.resize(node);
			this._conn = dojo.connect(node, 'onresize', this, function(){
				this.resize(node);
			});
		}else{
			dojo.style(iframe, {
				width: '100%',
				height: '100%'
			});
		}
	}
};

dojo.extend(dijit.BackgroundIframe, {
	resize: function(node){
		// summary:
		// 		Resize the iframe so it's the same size as node.
		//		Needed on IE6 and IE/quirks because height:100% doesn't work right.
		if(this.iframe){
			dojo.style(this.iframe, {
				width: node.offsetWidth + 'px',
				height: node.offsetHeight + 'px'
			});
		}
	},
	destroy: function(){
		// summary:
		//		destroy the iframe
		if(this._conn){
			dojo.disconnect(this._conn);
			this._conn = null;
		}
		if(this.iframe){
			dijit._frames.push(this.iframe);
			delete this.iframe;
		}
	}
});

}

if(!dojo._hasResource["dijit._base.scroll"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._base.scroll"] = true;
dojo.provide("dijit._base.scroll");



dijit.scrollIntoView = function(/*DomNode*/ node, /*Object?*/ pos){
	// summary:
	//		Scroll the passed node into view, if it is not already.
	//		Deprecated, use `dojo.window.scrollIntoView` instead.
	
	dojo.window.scrollIntoView(node, pos);
};

}

if(!dojo._hasResource["dojo.uacss"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.uacss"] = true;
dojo.provide("dojo.uacss");


(function(){
	// summary:
	//		Applies pre-set CSS classes to the top-level HTML node, based on:
	// 			- browser (ex: dj_ie)
	//			- browser version (ex: dj_ie6)
	//			- box model (ex: dj_contentBox)
	//			- text direction (ex: dijitRtl)
	//
	//		In addition, browser, browser version, and box model are
	//		combined with an RTL flag when browser text is RTL.  ex: dj_ie-rtl.

	var d = dojo,
		html = d.doc.documentElement,
		ie = d.isIE,
		opera = d.isOpera,
		maj = Math.floor,
		ff = d.isFF,
		boxModel = d.boxModel.replace(/-/,''),

		classes = {
			dj_ie: ie,
			dj_ie6: maj(ie) == 6,
			dj_ie7: maj(ie) == 7,
			dj_ie8: maj(ie) == 8,
			dj_ie9: maj(ie) == 9,
			dj_quirks: d.isQuirks,
			dj_iequirks: ie && d.isQuirks,

			// NOTE: Opera not supported by dijit
			dj_opera: opera,

			dj_khtml: d.isKhtml,

			dj_webkit: d.isWebKit,
			dj_safari: d.isSafari,
			dj_chrome: d.isChrome,

			dj_gecko: d.isMozilla,
			dj_ff3: maj(ff) == 3
		}; // no dojo unsupported browsers

	classes["dj_" + boxModel] = true;

	// apply browser, browser version, and box model class names
	var classStr = "";
	for(var clz in classes){
		if(classes[clz]){
			classStr += clz + " ";
		}
	}
	html.className = d.trim(html.className + " " + classStr);

	// If RTL mode, then add dj_rtl flag plus repeat existing classes with -rtl extension.
	// We can't run the code below until the <body> tag has loaded (so we can check for dir=rtl).
	// Unshift() is to run sniff code before the parser.
	dojo._loaders.unshift(function(){
		if(!dojo._isBodyLtr()){
			var rtlClassStr = "dj_rtl dijitRtl " + classStr.replace(/ /g, "-rtl ")
			html.className = d.trim(html.className + " " + rtlClassStr);
		}
	});
})();

}

if(!dojo._hasResource["dijit._base.sniff"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._base.sniff"] = true;
dojo.provide("dijit._base.sniff");



// summary:
//		Applies pre-set CSS classes to the top-level HTML node, see
//		`dojo.uacss` for details.
//
//		Simply doing a require on this module will
//		establish this CSS.  Modified version of Morris' CSS hack.

}

if(!dojo._hasResource["dijit._base.typematic"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._base.typematic"] = true;
dojo.provide("dijit._base.typematic");


dijit.typematic = {
	// summary:
	//		These functions are used to repetitively call a user specified callback
	//		method when a specific key or mouse click over a specific DOM node is
	//		held down for a specific amount of time.
	//		Only 1 such event is allowed to occur on the browser page at 1 time.

	_fireEventAndReload: function(){
		this._timer = null;
		this._callback(++this._count, this._node, this._evt);
		
		// Schedule next event, timer is at most minDelay (default 10ms) to avoid
		// browser overload (particularly avoiding starving DOH robot so it never gets to send a mouseup)
		this._currentTimeout = Math.max(
			this._currentTimeout < 0 ? this._initialDelay :
				(this._subsequentDelay > 1 ? this._subsequentDelay : Math.round(this._currentTimeout * this._subsequentDelay)),
			this._minDelay);
		this._timer = setTimeout(dojo.hitch(this, "_fireEventAndReload"), this._currentTimeout);
	},

	trigger: function(/*Event*/ evt, /*Object*/ _this, /*DOMNode*/ node, /*Function*/ callback, /*Object*/ obj, /*Number*/ subsequentDelay, /*Number*/ initialDelay, /*Number?*/ minDelay){
		// summary:
		//		Start a timed, repeating callback sequence.
		//		If already started, the function call is ignored.
		//		This method is not normally called by the user but can be
		//		when the normal listener code is insufficient.
		// evt:
		//		key or mouse event object to pass to the user callback
		// _this:
		//		pointer to the user's widget space.
		// node:
		//		the DOM node object to pass the the callback function
		// callback:
		//		function to call until the sequence is stopped called with 3 parameters:
		// count:
		//		integer representing number of repeated calls (0..n) with -1 indicating the iteration has stopped
		// node:
		//		the DOM node object passed in
		// evt:
		//		key or mouse event object
		// obj:
		//		user space object used to uniquely identify each typematic sequence
		// subsequentDelay (optional):
		//		if > 1, the number of milliseconds until the 3->n events occur
		//		or else the fractional time multiplier for the next event's delay, default=0.9
		// initialDelay (optional):
		//		the number of milliseconds until the 2nd event occurs, default=500ms
		// minDelay (optional):
		//		the maximum delay in milliseconds for event to fire, default=10ms
		if(obj != this._obj){
			this.stop();
			this._initialDelay = initialDelay || 500;
			this._subsequentDelay = subsequentDelay || 0.90;
			this._minDelay = minDelay || 10;
			this._obj = obj;
			this._evt = evt;
			this._node = node;
			this._currentTimeout = -1;
			this._count = -1;
			this._callback = dojo.hitch(_this, callback);
			this._fireEventAndReload();
			this._evt = dojo.mixin({faux: true}, evt);
		}
	},

	stop: function(){
		// summary:
		//		Stop an ongoing timed, repeating callback sequence.
		if(this._timer){
			clearTimeout(this._timer);
			this._timer = null;
		}
		if(this._obj){
			this._callback(-1, this._node, this._evt);
			this._obj = null;
		}
	},

	addKeyListener: function(/*DOMNode*/ node, /*Object*/ keyObject, /*Object*/ _this, /*Function*/ callback, /*Number*/ subsequentDelay, /*Number*/ initialDelay, /*Number?*/ minDelay){
		// summary:
		//		Start listening for a specific typematic key.
		//		See also the trigger method for other parameters.
		// keyObject:
		//		an object defining the key to listen for:
		// 		charOrCode:
		//			the printable character (string) or keyCode (number) to listen for.
		// 		keyCode:
		//			(deprecated - use charOrCode) the keyCode (number) to listen for (implies charCode = 0).
		// 		charCode:
		//			(deprecated - use charOrCode) the charCode (number) to listen for.
		// 		ctrlKey:
		//			desired ctrl key state to initiate the callback sequence:
		//			- pressed (true)
		//			- released (false)
		//			- either (unspecified)
		// 		altKey:
		//			same as ctrlKey but for the alt key
		// 		shiftKey:
		//			same as ctrlKey but for the shift key
		// returns:
		//		an array of dojo.connect handles
		if(keyObject.keyCode){
			keyObject.charOrCode = keyObject.keyCode;
			dojo.deprecated("keyCode attribute parameter for dijit.typematic.addKeyListener is deprecated. Use charOrCode instead.", "", "2.0");
		}else if(keyObject.charCode){
			keyObject.charOrCode = String.fromCharCode(keyObject.charCode);
			dojo.deprecated("charCode attribute parameter for dijit.typematic.addKeyListener is deprecated. Use charOrCode instead.", "", "2.0");
		}
		return [
			dojo.connect(node, "onkeypress", this, function(evt){
				if(evt.charOrCode == keyObject.charOrCode &&
				(keyObject.ctrlKey === undefined || keyObject.ctrlKey == evt.ctrlKey) &&
				(keyObject.altKey === undefined || keyObject.altKey == evt.altKey) &&
				(keyObject.metaKey === undefined || keyObject.metaKey == (evt.metaKey || false)) && // IE doesn't even set metaKey
				(keyObject.shiftKey === undefined || keyObject.shiftKey == evt.shiftKey)){
					dojo.stopEvent(evt);
					dijit.typematic.trigger(evt, _this, node, callback, keyObject, subsequentDelay, initialDelay, minDelay);
				}else if(dijit.typematic._obj == keyObject){
					dijit.typematic.stop();
				}
			}),
			dojo.connect(node, "onkeyup", this, function(evt){
				if(dijit.typematic._obj == keyObject){
					dijit.typematic.stop();
				}
			})
		];
	},

	addMouseListener: function(/*DOMNode*/ node, /*Object*/ _this, /*Function*/ callback, /*Number*/ subsequentDelay, /*Number*/ initialDelay, /*Number?*/ minDelay){
		// summary:
		//		Start listening for a typematic mouse click.
		//		See the trigger method for other parameters.
		// returns:
		//		an array of dojo.connect handles
		var dc = dojo.connect;
		return [
			dc(node, "mousedown", this, function(evt){
				dojo.stopEvent(evt);
				dijit.typematic.trigger(evt, _this, node, callback, node, subsequentDelay, initialDelay, minDelay);
			}),
			dc(node, "mouseup", this, function(evt){
				dojo.stopEvent(evt);
				dijit.typematic.stop();
			}),
			dc(node, "mouseout", this, function(evt){
				dojo.stopEvent(evt);
				dijit.typematic.stop();
			}),
			dc(node, "mousemove", this, function(evt){
				evt.preventDefault();
			}),
			dc(node, "dblclick", this, function(evt){
				dojo.stopEvent(evt);
				if(dojo.isIE){
					dijit.typematic.trigger(evt, _this, node, callback, node, subsequentDelay, initialDelay, minDelay);
					setTimeout(dojo.hitch(this, dijit.typematic.stop), 50);
				}
			})
		];
	},

	addListener: function(/*Node*/ mouseNode, /*Node*/ keyNode, /*Object*/ keyObject, /*Object*/ _this, /*Function*/ callback, /*Number*/ subsequentDelay, /*Number*/ initialDelay, /*Number?*/ minDelay){
		// summary:
		//		Start listening for a specific typematic key and mouseclick.
		//		This is a thin wrapper to addKeyListener and addMouseListener.
		//		See the addMouseListener and addKeyListener methods for other parameters.
		// mouseNode:
		//		the DOM node object to listen on for mouse events.
		// keyNode:
		//		the DOM node object to listen on for key events.
		// returns:
		//		an array of dojo.connect handles
		return this.addKeyListener(keyNode, keyObject, _this, callback, subsequentDelay, initialDelay, minDelay).concat(
			this.addMouseListener(mouseNode, _this, callback, subsequentDelay, initialDelay, minDelay));
	}
};

}

if(!dojo._hasResource["dijit._base.wai"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._base.wai"] = true;
dojo.provide("dijit._base.wai");


dijit.wai = {
	onload: function(){
		// summary:
		//		Detects if we are in high-contrast mode or not

		// This must be a named function and not an anonymous
		// function, so that the widget parsing code can make sure it
		// registers its onload function after this function.
		// DO NOT USE "this" within this function.

		// create div for testing if high contrast mode is on or images are turned off
		var div = dojo.create("div",{
			id: "a11yTestNode",
			style:{
				cssText:'border: 1px solid;'
					+ 'border-color:red green;'
					+ 'position: absolute;'
					+ 'height: 5px;'
					+ 'top: -999px;'
					+ 'background-image: url("' + (dojo.config.blankGif || dojo.moduleUrl("dojo", "resources/blank.gif")) + '");'
			}
		}, dojo.body());

		// test it
		var cs = dojo.getComputedStyle(div);
		if(cs){
			var bkImg = cs.backgroundImage;
			var needsA11y = (cs.borderTopColor == cs.borderRightColor) || (bkImg != null && (bkImg == "none" || bkImg == "url(invalid-url:)" ));
			dojo[needsA11y ? "addClass" : "removeClass"](dojo.body(), "dijit_a11y");
			if(dojo.isIE){
				div.outerHTML = "";		// prevent mixed-content warning, see http://support.microsoft.com/kb/925014
			}else{
				dojo.body().removeChild(div);
			}
		}
	}
};

// Test if computer is in high contrast mode.
// Make sure the a11y test runs first, before widgets are instantiated.
if(dojo.isIE || dojo.isMoz){	// NOTE: checking in Safari messes things up
	dojo._loaders.unshift(dijit.wai.onload);
}

dojo.mixin(dijit, {
	hasWaiRole: function(/*Element*/ elem, /*String?*/ role){
		// summary:
		//		Determines if an element has a particular role.
		// returns:
		//		True if elem has the specific role attribute and false if not.
		// 		For backwards compatibility if role parameter not provided,
		// 		returns true if has a role
		var waiRole = this.getWaiRole(elem);
		return role ? (waiRole.indexOf(role) > -1) : (waiRole.length > 0);
	},

	getWaiRole: function(/*Element*/ elem){
		// summary:
		//		Gets the role for an element (which should be a wai role).
		// returns:
		//		The role of elem or an empty string if elem
		//		does not have a role.
		 return dojo.trim((dojo.attr(elem, "role") || "").replace("wairole:",""));
	},

	setWaiRole: function(/*Element*/ elem, /*String*/ role){
		// summary:
		//		Sets the role on an element.
		// description:
		//		Replace existing role attribute with new role.

			dojo.attr(elem, "role", role);
	},

	removeWaiRole: function(/*Element*/ elem, /*String*/ role){
		// summary:
		//		Removes the specified role from an element.
		// 		Removes role attribute if no specific role provided (for backwards compat.)

		var roleValue = dojo.attr(elem, "role");
		if(!roleValue){ return; }
		if(role){
			var t = dojo.trim((" " + roleValue + " ").replace(" " + role + " ", " "));
			dojo.attr(elem, "role", t);
		}else{
			elem.removeAttribute("role");
		}
	},

	hasWaiState: function(/*Element*/ elem, /*String*/ state){
		// summary:
		//		Determines if an element has a given state.
		// description:
		//		Checks for an attribute called "aria-"+state.
		// returns:
		//		true if elem has a value for the given state and
		//		false if it does not.

		return elem.hasAttribute ? elem.hasAttribute("aria-"+state) : !!elem.getAttribute("aria-"+state);
	},

	getWaiState: function(/*Element*/ elem, /*String*/ state){
		// summary:
		//		Gets the value of a state on an element.
		// description:
		//		Checks for an attribute called "aria-"+state.
		// returns:
		//		The value of the requested state on elem
		//		or an empty string if elem has no value for state.

		return elem.getAttribute("aria-"+state) || "";
	},

	setWaiState: function(/*Element*/ elem, /*String*/ state, /*String*/ value){
		// summary:
		//		Sets a state on an element.
		// description:
		//		Sets an attribute called "aria-"+state.

		elem.setAttribute("aria-"+state, value);
	},

	removeWaiState: function(/*Element*/ elem, /*String*/ state){
		// summary:
		//		Removes a state from an element.
		// description:
		//		Sets an attribute called "aria-"+state.

		elem.removeAttribute("aria-"+state);
	}
});

}

if(!dojo._hasResource["dijit._base"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._base"] = true;
dojo.provide("dijit._base");












}

if(!dojo._hasResource["dijit._Widget"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._Widget"] = true;
dojo.provide("dijit._Widget");





////////////////// DEFERRED CONNECTS ///////////////////

// This code is to assist deferring dojo.connect() calls in widgets (connecting to events on the widgets'
// DOM nodes) until someone actually needs to monitor that event.
dojo.connect(dojo, "_connect",
	function(/*dijit._Widget*/ widget, /*String*/ event){
		if(widget && dojo.isFunction(widget._onConnect)){
			widget._onConnect(event);
		}
	});

dijit._connectOnUseEventHandler = function(/*Event*/ event){};

////////////////// ONDIJITCLICK SUPPORT ///////////////////

// Keep track of where the last keydown event was, to help avoid generating
// spurious ondijitclick events when:
// 1. focus is on a <button> or <a>
// 2. user presses then releases the ENTER key
// 3. onclick handler fires and shifts focus to another node, with an ondijitclick handler
// 4. onkeyup event fires, causing the ondijitclick handler to fire
dijit._lastKeyDownNode = null;
if(dojo.isIE){
	(function(){
		var keydownCallback = function(evt){
			dijit._lastKeyDownNode = evt.srcElement;
		};
		dojo.doc.attachEvent('onkeydown', keydownCallback);
		dojo.addOnWindowUnload(function(){
			dojo.doc.detachEvent('onkeydown', keydownCallback);
		});
	})();
}else{
	dojo.doc.addEventListener('keydown', function(evt){
		dijit._lastKeyDownNode = evt.target;
	}, true);
}

(function(){

dojo.declare("dijit._Widget", dijit._WidgetBase, {
	// summary:
	//		Base class for all Dijit widgets.
	//
	//		Extends _WidgetBase, adding support for:
	//			- deferred connections
	//				A call like dojo.connect(myWidget, "onMouseMove", func)
	//				will essentially do a dojo.connect(myWidget.domNode, "onMouseMove", func)
	//			- ondijitclick
	//				Support new dojoAttachEvent="ondijitclick: ..." that is triggered by a mouse click or a SPACE/ENTER keypress
	//			- focus related functions
	//				In particular, the onFocus()/onBlur() callbacks.   Driven internally by
	//				dijit/_base/focus.js.
	//			- deprecated methods
	//			- onShow(), onHide(), onClose()
	//
	//		Also, by loading code in dijit/_base, turns on:
	//			- browser sniffing (putting browser id like .dj_ie on <html> node)
	//			- high contrast mode sniffing (add .dijit_a11y class to <body> if machine is in high contrast mode)
	

	////////////////// DEFERRED CONNECTS ///////////////////

	// _deferredConnects: [protected] Object
	//		attributeMap addendum for event handlers that should be connected only on first use
	_deferredConnects: {
		onClick: "",
		onDblClick: "",
		onKeyDown: "",
		onKeyPress: "",
		onKeyUp: "",
		onMouseMove: "",
		onMouseDown: "",
		onMouseOut: "",
		onMouseOver: "",
		onMouseLeave: "",
		onMouseEnter: "",
		onMouseUp: ""
	},

	onClick: dijit._connectOnUseEventHandler,
	/*=====
	onClick: function(event){
		// summary:
		//		Connect to this function to receive notifications of mouse click events.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onDblClick: dijit._connectOnUseEventHandler,
	/*=====
	onDblClick: function(event){
		// summary:
		//		Connect to this function to receive notifications of mouse double click events.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onKeyDown: dijit._connectOnUseEventHandler,
	/*=====
	onKeyDown: function(event){
		// summary:
		//		Connect to this function to receive notifications of keys being pressed down.
		// event:
		//		key Event
		// tags:
		//		callback
	},
	=====*/
	onKeyPress: dijit._connectOnUseEventHandler,
	/*=====
	onKeyPress: function(event){
		// summary:
		//		Connect to this function to receive notifications of printable keys being typed.
		// event:
		//		key Event
		// tags:
		//		callback
	},
	=====*/
	onKeyUp: dijit._connectOnUseEventHandler,
	/*=====
	onKeyUp: function(event){
		// summary:
		//		Connect to this function to receive notifications of keys being released.
		// event:
		//		key Event
		// tags:
		//		callback
	},
	=====*/
	onMouseDown: dijit._connectOnUseEventHandler,
	/*=====
	onMouseDown: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse button is pressed down.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseMove: dijit._connectOnUseEventHandler,
	/*=====
	onMouseMove: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse moves over nodes contained within this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseOut: dijit._connectOnUseEventHandler,
	/*=====
	onMouseOut: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse moves off of nodes contained within this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseOver: dijit._connectOnUseEventHandler,
	/*=====
	onMouseOver: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse moves onto nodes contained within this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseLeave: dijit._connectOnUseEventHandler,
	/*=====
	onMouseLeave: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse moves off of this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseEnter: dijit._connectOnUseEventHandler,
	/*=====
	onMouseEnter: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse moves onto this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseUp: dijit._connectOnUseEventHandler,
	/*=====
	onMouseUp: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse button is released.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/

	create: function(/*Object?*/params, /*DomNode|String?*/srcNodeRef){
		// To avoid double-connects, remove entries from _deferredConnects
		// that have been setup manually by a subclass (ex, by dojoAttachEvent).
		// If a subclass has redefined a callback (ex: onClick) then assume it's being
		// connected to manually.
		this._deferredConnects = dojo.clone(this._deferredConnects);
		for(var attr in this.attributeMap){
			delete this._deferredConnects[attr]; // can't be in both attributeMap and _deferredConnects
		}
		for(attr in this._deferredConnects){
			if(this[attr] !== dijit._connectOnUseEventHandler){
				delete this._deferredConnects[attr];	// redefined, probably dojoAttachEvent exists
			}
		}

		this.inherited(arguments);

		if(this.domNode){
			// If the developer has specified a handler as a widget parameter
			// (ex: new Button({onClick: ...})
			// then naturally need to connect from DOM node to that handler immediately,
			for(attr in this.params){
				this._onConnect(attr);
			}
		}
	},

	_onConnect: function(/*String*/ event){
		// summary:
		//		Called when someone connects to one of my handlers.
		//		"Turn on" that handler if it isn't active yet.
		//
		//		This is also called for every single initialization parameter
		//		so need to do nothing for parameters like "id".
		// tags:
		//		private
		if(event in this._deferredConnects){
			var mapNode = this[this._deferredConnects[event] || 'domNode'];
			this.connect(mapNode, event.toLowerCase(), event);
			delete this._deferredConnects[event];
		}
	},

	////////////////// FOCUS RELATED ///////////////////
	// _onFocus() and _onBlur() are called by the focus manager

	// focused: [readonly] Boolean
	//		This widget or a widget it contains has focus, or is "active" because
	//		it was recently clicked.
	focused: false,

	isFocusable: function(){
		// summary:
		//		Return true if this widget can currently be focused
		//		and false if not
		return this.focus && (dojo.style(this.domNode, "display") != "none");
	},

	onFocus: function(){
		// summary:
		//		Called when the widget becomes "active" because
		//		it or a widget inside of it either has focus, or has recently
		//		been clicked.
		// tags:
		//		callback
	},

	onBlur: function(){
		// summary:
		//		Called when the widget stops being "active" because
		//		focus moved to something outside of it, or the user
		//		clicked somewhere outside of it, or the widget was
		//		hidden.
		// tags:
		//		callback
	},

	_onFocus: function(e){
		// summary:
		//		This is where widgets do processing for when they are active,
		//		such as changing CSS classes.  See onFocus() for more details.
		// tags:
		//		protected
		this.onFocus();
	},

	_onBlur: function(){
		// summary:
		//		This is where widgets do processing for when they stop being active,
		//		such as changing CSS classes.  See onBlur() for more details.
		// tags:
		//		protected
		this.onBlur();
	},

	////////////////// DEPRECATED METHODS ///////////////////

	setAttribute: function(/*String*/ attr, /*anything*/ value){
		// summary:
		//		Deprecated.  Use set() instead.
		// tags:
		//		deprecated
		dojo.deprecated(this.declaredClass+"::setAttribute(attr, value) is deprecated. Use set() instead.", "", "2.0");
		this.set(attr, value);
	},

	attr: function(/*String|Object*/name, /*Object?*/value){
		// summary:
		//		Set or get properties on a widget instance.
		//	name:
		//		The property to get or set. If an object is passed here and not
		//		a string, its keys are used as names of attributes to be set
		//		and the value of the object as values to set in the widget.
		//	value:
		//		Optional. If provided, attr() operates as a setter. If omitted,
		//		the current value of the named property is returned.
		// description:
		//		This method is deprecated, use get() or set() directly.

		// Print deprecation warning but only once per calling function
		if(dojo.config.isDebug){
			var alreadyCalledHash = arguments.callee._ach || (arguments.callee._ach = {}),
				caller = (arguments.callee.caller || "unknown caller").toString();
			if(!alreadyCalledHash[caller]){
				dojo.deprecated(this.declaredClass + "::attr() is deprecated. Use get() or set() instead, called from " +
				caller, "", "2.0");
				alreadyCalledHash[caller] = true;
			}
		}

		var args = arguments.length;
		if(args >= 2 || typeof name === "object"){ // setter
			return this.set.apply(this, arguments);
		}else{ // getter
			return this.get(name);
		}
	},
	
	////////////////// ONDIJITCLICK SUPPORT ///////////////////

	// nodesWithKeyClick: [private] String[]
	//		List of nodes that correctly handle click events via native browser support,
	//		and don't need dijit's help
	nodesWithKeyClick: ["input", "button"],

	connect: function(
			/*Object|null*/ obj,
			/*String|Function*/ event,
			/*String|Function*/ method){
		// summary:
		//		Connects specified obj/event to specified method of this object
		//		and registers for disconnect() on widget destroy.
		// description:
		//		Provide widget-specific analog to dojo.connect, except with the
		//		implicit use of this widget as the target object.
		//		This version of connect also provides a special "ondijitclick"
		//		event which triggers on a click or space or enter keyup.
		//		Events connected with `this.connect` are disconnected upon
		//		destruction.
		// returns:
		//		A handle that can be passed to `disconnect` in order to disconnect before
		//		the widget is destroyed.
		// example:
		//	|	var btn = new dijit.form.Button();
		//	|	// when foo.bar() is called, call the listener we're going to
		//	|	// provide in the scope of btn
		//	|	btn.connect(foo, "bar", function(){
		//	|		console.debug(this.toString());
		//	|	});
		// tags:
		//		protected

		var d = dojo,
			dc = d._connect,
			handles = this.inherited(arguments, [obj, event == "ondijitclick" ? "onclick" : event, method]);

		if(event == "ondijitclick"){
			// add key based click activation for unsupported nodes.
			// do all processing onkey up to prevent spurious clicks
			// for details see comments at top of this file where _lastKeyDownNode is defined
			if(d.indexOf(this.nodesWithKeyClick, obj.nodeName.toLowerCase()) == -1){ // is NOT input or button
				var m = d.hitch(this, method);
				handles.push(
					dc(obj, "onkeydown", this, function(e){
						//console.log(this.id + ": onkeydown, e.target = ", e.target, ", lastKeyDownNode was ", dijit._lastKeyDownNode, ", equality is ", (e.target === dijit._lastKeyDownNode));
						if((e.keyCode == d.keys.ENTER || e.keyCode == d.keys.SPACE) &&
							!e.ctrlKey && !e.shiftKey && !e.altKey && !e.metaKey){
							// needed on IE for when focus changes between keydown and keyup - otherwise dropdown menus do not work
							dijit._lastKeyDownNode = e.target;
							
							// Stop event to prevent scrolling on space key in IE.
							// But don't do this for _HasDropDown because it surpresses the onkeypress
							// event needed to open the drop down when the user presses the SPACE key.
							if(!("openDropDown" in this && obj == this._buttonNode)){
								e.preventDefault();
							}
						}
			 		}),
					dc(obj, "onkeyup", this, function(e){
						//console.log(this.id + ": onkeyup, e.target = ", e.target, ", lastKeyDownNode was ", dijit._lastKeyDownNode, ", equality is ", (e.target === dijit._lastKeyDownNode));
						if( (e.keyCode == d.keys.ENTER || e.keyCode == d.keys.SPACE) &&
							e.target == dijit._lastKeyDownNode &&	// === breaks greasemonkey
							!e.ctrlKey && !e.shiftKey && !e.altKey && !e.metaKey){
								//need reset here or have problems in FF when focus returns to trigger element after closing popup/alert
								dijit._lastKeyDownNode = null;
								return m(e);
						}
					})
				);
			}
		}

		return handles;		// _Widget.Handle
	},

	////////////////// MISCELLANEOUS METHODS ///////////////////

	_onShow: function(){
		// summary:
		//		Internal method called when this widget is made visible.
		//		See `onShow` for details.
		this.onShow();
	},

	onShow: function(){
		// summary:
		//		Called when this widget becomes the selected pane in a
		//		`dijit.layout.TabContainer`, `dijit.layout.StackContainer`,
		//		`dijit.layout.AccordionContainer`, etc.
		//
		//		Also called to indicate display of a `dijit.Dialog`, `dijit.TooltipDialog`, or `dijit.TitlePane`.
		// tags:
		//		callback
	},

	onHide: function(){
		// summary:
			//		Called when another widget becomes the selected pane in a
			//		`dijit.layout.TabContainer`, `dijit.layout.StackContainer`,
			//		`dijit.layout.AccordionContainer`, etc.
			//
			//		Also called to indicate hide of a `dijit.Dialog`, `dijit.TooltipDialog`, or `dijit.TitlePane`.
			// tags:
			//		callback
	},

	onClose: function(){
		// summary:
		//		Called when this widget is being displayed as a popup (ex: a Calendar popped
		//		up from a DateTextBox), and it is hidden.
		//		This is called from the dijit.popup code, and should not be called directly.
		//
		//		Also used as a parameter for children of `dijit.layout.StackContainer` or subclasses.
		//		Callback if a user tries to close the child.   Child will be closed if this function returns true.
		// tags:
		//		extension

		return true;		// Boolean
	}
});

})();

}

if(!dojo._hasResource["dijit._Contained"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._Contained"] = true;
dojo.provide("dijit._Contained");


dojo.declare("dijit._Contained",
		null,
		{
			// summary:
			//		Mixin for widgets that are children of a container widget
			//
			// example:
			// | 	// make a basic custom widget that knows about it's parents
			// |	dojo.declare("my.customClass",[dijit._Widget,dijit._Contained],{});

			getParent: function(){
				// summary:
				//		Returns the parent widget of this widget, assuming the parent
				//		specifies isContainer
				var parent = dijit.getEnclosingWidget(this.domNode.parentNode);
				return parent && parent.isContainer ? parent : null;
			},

			_getSibling: function(/*String*/ which){
				// summary:
				//      Returns next or previous sibling
				// which:
				//      Either "next" or "previous"
				// tags:
				//      private
				var node = this.domNode;
				do{
					node = node[which+"Sibling"];
				}while(node && node.nodeType != 1);
				return node && dijit.byNode(node);	// dijit._Widget
			},

			getPreviousSibling: function(){
				// summary:
				//		Returns null if this is the first child of the parent,
				//		otherwise returns the next element sibling to the "left".

				return this._getSibling("previous"); // dijit._Widget
			},

			getNextSibling: function(){
				// summary:
				//		Returns null if this is the last child of the parent,
				//		otherwise returns the next element sibling to the "right".

				return this._getSibling("next"); // dijit._Widget
			},

			getIndexInParent: function(){
				// summary:
				//		Returns the index of this widget within its container parent.
				//		It returns -1 if the parent does not exist, or if the parent
				//		is not a dijit._Container

				var p = this.getParent();
				if(!p || !p.getIndexOfChild){
					return -1; // int
				}
				return p.getIndexOfChild(this); // int
			}
		}
	);

}

if(!dojo._hasResource["dijit._Container"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._Container"] = true;
dojo.provide("dijit._Container");


dojo.declare("dijit._Container",
	null,
	{
		// summary:
		//		Mixin for widgets that contain a set of widget children.
		// description:
		//		Use this mixin for widgets that needs to know about and
		//		keep track of their widget children. Suitable for widgets like BorderContainer
		//		and TabContainer which contain (only) a set of child widgets.
		//
		//		It's not suitable for widgets like ContentPane
		//		which contains mixed HTML (plain DOM nodes in addition to widgets),
		//		and where contained widgets are not necessarily directly below
		//		this.containerNode.   In that case calls like addChild(node, position)
		//		wouldn't make sense.

		// isContainer: [protected] Boolean
		//		Indicates that this widget acts as a "parent" to the descendant widgets.
		//		When the parent is started it will call startup() on the child widgets.
		//		See also `isLayoutContainer`.
		isContainer: true,

		buildRendering: function(){
			this.inherited(arguments);
			if(!this.containerNode){
				// all widgets with descendants must set containerNode
	 				this.containerNode = this.domNode;
			}
		},

		addChild: function(/*dijit._Widget*/ widget, /*int?*/ insertIndex){
			// summary:
			//		Makes the given widget a child of this widget.
			// description:
			//		Inserts specified child widget's dom node as a child of this widget's
			//		container node, and possibly does other processing (such as layout).

			var refNode = this.containerNode;
			if(insertIndex && typeof insertIndex == "number"){
				var children = this.getChildren();
				if(children && children.length >= insertIndex){
					refNode = children[insertIndex-1].domNode;
					insertIndex = "after";
				}
			}
			dojo.place(widget.domNode, refNode, insertIndex);

			// If I've been started but the child widget hasn't been started,
			// start it now.  Make sure to do this after widget has been
			// inserted into the DOM tree, so it can see that it's being controlled by me,
			// so it doesn't try to size itself.
			if(this._started && !widget._started){
				widget.startup();
			}
		},

		removeChild: function(/*Widget or int*/ widget){
			// summary:
			//		Removes the passed widget instance from this widget but does
			//		not destroy it.  You can also pass in an integer indicating
			//		the index within the container to remove

			if(typeof widget == "number"){
				widget = this.getChildren()[widget];
			}

			if(widget){
				var node = widget.domNode;
				if(node && node.parentNode){
					node.parentNode.removeChild(node); // detach but don't destroy
				}
			}
		},

		hasChildren: function(){
			// summary:
			//		Returns true if widget has children, i.e. if this.containerNode contains something.
			return this.getChildren().length > 0;	// Boolean
		},

		destroyDescendants: function(/*Boolean*/ preserveDom){
			// summary:
			//      Destroys all the widgets inside this.containerNode,
			//      but not this widget itself
			dojo.forEach(this.getChildren(), function(child){ child.destroyRecursive(preserveDom); });
		},

		_getSiblingOfChild: function(/*dijit._Widget*/ child, /*int*/ dir){
			// summary:
			//		Get the next or previous widget sibling of child
			// dir:
			//		if 1, get the next sibling
			//		if -1, get the previous sibling
			// tags:
			//      private
			var node = child.domNode,
				which = (dir>0 ? "nextSibling" : "previousSibling");
			do{
				node = node[which];
			}while(node && (node.nodeType != 1 || !dijit.byNode(node)));
			return node && dijit.byNode(node);	// dijit._Widget
		},

		getIndexOfChild: function(/*dijit._Widget*/ child){
			// summary:
			//		Gets the index of the child in this container or -1 if not found
			return dojo.indexOf(this.getChildren(), child);	// int
		},

		startup: function(){
			// summary:
			//		Called after all the widgets have been instantiated and their
			//		dom nodes have been inserted somewhere under dojo.doc.body.
			//
			//		Widgets should override this method to do any initialization
			//		dependent on other widgets existing, and then call
			//		this superclass method to finish things off.
			//
			//		startup() in subclasses shouldn't do anything
			//		size related because the size of the widget hasn't been set yet.

			if(this._started){ return; }

			// Startup all children of this widget
			dojo.forEach(this.getChildren(), function(child){ child.startup(); });

			this.inherited(arguments);
		}
	}
);

}

if(!dojo._hasResource["dijit.layout._LayoutWidget"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.layout._LayoutWidget"] = true;
dojo.provide("dijit.layout._LayoutWidget");





dojo.declare("dijit.layout._LayoutWidget",
	[dijit._Widget, dijit._Container, dijit._Contained],
	{
		// summary:
		//		Base class for a _Container widget which is responsible for laying out its children.
		//		Widgets which mixin this code must define layout() to manage placement and sizing of the children.

		// baseClass: [protected extension] String
		//		This class name is applied to the widget's domNode
		//		and also may be used to generate names for sub nodes,
		//		for example dijitTabContainer-content.
		baseClass: "dijitLayoutContainer",

		// isLayoutContainer: [protected] Boolean
		//		Indicates that this widget is going to call resize() on its
		//		children widgets, setting their size, when they become visible.
		isLayoutContainer: true,

		buildRendering: function(){
			this.inherited(arguments);
			dojo.addClass(this.domNode, "dijitContainer");
		},

		startup: function(){
			// summary:
			//		Called after all the widgets have been instantiated and their
			//		dom nodes have been inserted somewhere under dojo.doc.body.
			//
			//		Widgets should override this method to do any initialization
			//		dependent on other widgets existing, and then call
			//		this superclass method to finish things off.
			//
			//		startup() in subclasses shouldn't do anything
			//		size related because the size of the widget hasn't been set yet.

			if(this._started){ return; }

			// Need to call inherited first - so that child widgets get started
			// up correctly
			this.inherited(arguments);

			// If I am a not being controlled by a parent layout widget...
			var parent = this.getParent && this.getParent()
			if(!(parent && parent.isLayoutContainer)){
				// Do recursive sizing and layout of all my descendants
				// (passing in no argument to resize means that it has to glean the size itself)
				this.resize();

				// Since my parent isn't a layout container, and my style *may be* width=height=100%
				// or something similar (either set directly or via a CSS class),
				// monitor when my size changes so that I can re-layout.
				// For browsers where I can't directly monitor when my size changes,
				// monitor when the viewport changes size, which *may* indicate a size change for me.
				this.connect(dojo.isIE ? this.domNode : dojo.global, 'onresize', function(){
					// Using function(){} closure to ensure no arguments to resize.
					this.resize();
				});
			}
		},

		resize: function(changeSize, resultSize){
			// summary:
			//		Call this to resize a widget, or after its size has changed.
			// description:
			//		Change size mode:
			//			When changeSize is specified, changes the marginBox of this widget
			//			and forces it to relayout its contents accordingly.
			//			changeSize may specify height, width, or both.
			//
			//			If resultSize is specified it indicates the size the widget will
			//			become after changeSize has been applied.
			//
			//		Notification mode:
			//			When changeSize is null, indicates that the caller has already changed
			//			the size of the widget, or perhaps it changed because the browser
			//			window was resized.  Tells widget to relayout its contents accordingly.
			//
			//			If resultSize is also specified it indicates the size the widget has
			//			become.
			//
			//		In either mode, this method also:
			//			1. Sets this._borderBox and this._contentBox to the new size of
			//				the widget.  Queries the current domNode size if necessary.
			//			2. Calls layout() to resize contents (and maybe adjust child widgets).
			//
			// changeSize: Object?
			//		Sets the widget to this margin-box size and position.
			//		May include any/all of the following properties:
			//	|	{w: int, h: int, l: int, t: int}
			//
			// resultSize: Object?
			//		The margin-box size of this widget after applying changeSize (if
			//		changeSize is specified).  If caller knows this size and
			//		passes it in, we don't need to query the browser to get the size.
			//	|	{w: int, h: int}

			var node = this.domNode;

			// set margin box size, unless it wasn't specified, in which case use current size
			if(changeSize){
				dojo.marginBox(node, changeSize);

				// set offset of the node
				if(changeSize.t){ node.style.top = changeSize.t + "px"; }
				if(changeSize.l){ node.style.left = changeSize.l + "px"; }
			}

			// If either height or width wasn't specified by the user, then query node for it.
			// But note that setting the margin box and then immediately querying dimensions may return
			// inaccurate results, so try not to depend on it.
			var mb = resultSize || {};
			dojo.mixin(mb, changeSize || {});	// changeSize overrides resultSize
			if( !("h" in mb) || !("w" in mb) ){
				mb = dojo.mixin(dojo.marginBox(node), mb);	// just use dojo.marginBox() to fill in missing values
			}

			// Compute and save the size of my border box and content box
			// (w/out calling dojo.contentBox() since that may fail if size was recently set)
			var cs = dojo.getComputedStyle(node);
			var me = dojo._getMarginExtents(node, cs);
			var be = dojo._getBorderExtents(node, cs);
			var bb = (this._borderBox = {
				w: mb.w - (me.w + be.w),
				h: mb.h - (me.h + be.h)
			});
			var pe = dojo._getPadExtents(node, cs);
			this._contentBox = {
				l: dojo._toPixelValue(node, cs.paddingLeft),
				t: dojo._toPixelValue(node, cs.paddingTop),
				w: bb.w - pe.w,
				h: bb.h - pe.h
			};

			// Callback for widget to adjust size of its children
			this.layout();
		},

		layout: function(){
			// summary:
			//		Widgets override this method to size and position their contents/children.
			//		When this is called this._contentBox is guaranteed to be set (see resize()).
			//
			//		This is called after startup(), and also when the widget's size has been
			//		changed.
			// tags:
			//		protected extension
		},

		_setupChild: function(/*dijit._Widget*/child){
			// summary:
			//		Common setup for initial children and children which are added after startup
			// tags:
			//		protected extension

			var cls = this.baseClass + "-child "
				+ (child.baseClass ? this.baseClass + "-" + child.baseClass : "");
			dojo.addClass(child.domNode, cls);
		},

		addChild: function(/*dijit._Widget*/ child, /*Integer?*/ insertIndex){
			// Overrides _Container.addChild() to call _setupChild()
			this.inherited(arguments);
			if(this._started){
				this._setupChild(child);
			}
		},

		removeChild: function(/*dijit._Widget*/ child){
			// Overrides _Container.removeChild() to remove class added by _setupChild()
			var cls = this.baseClass + "-child"
					+ (child.baseClass ?
						" " + this.baseClass + "-" + child.baseClass : "");
			dojo.removeClass(child.domNode, cls);
			
			this.inherited(arguments);
		}
	}
);

dijit.layout.marginBox2contentBox = function(/*DomNode*/ node, /*Object*/ mb){
	// summary:
	//		Given the margin-box size of a node, return its content box size.
	//		Functions like dojo.contentBox() but is more reliable since it doesn't have
	//		to wait for the browser to compute sizes.
	var cs = dojo.getComputedStyle(node);
	var me = dojo._getMarginExtents(node, cs);
	var pb = dojo._getPadBorderExtents(node, cs);
	return {
		l: dojo._toPixelValue(node, cs.paddingLeft),
		t: dojo._toPixelValue(node, cs.paddingTop),
		w: mb.w - (me.w + pb.w),
		h: mb.h - (me.h + pb.h)
	};
};

(function(){
	var capitalize = function(word){
	//console.log("dijit.layout._LayoutWidget word: " + word);
		if ( word == null )	return '';
		return word.substring(0,1).toUpperCase() + word.substring(1);
	};

	var size = function(widget, dim){
		// size the child
		var newSize = widget.resize ? widget.resize(dim) : dojo.marginBox(widget.domNode, dim);

		// record child's size
		if(newSize){
			// if the child returned it's new size then use that
			dojo.mixin(widget, newSize);
		}else{
			// otherwise, call marginBox(), but favor our own numbers when we have them.
			// the browser lies sometimes
			dojo.mixin(widget, dojo.marginBox(widget.domNode));
			dojo.mixin(widget, dim);
		}
	};

	dijit.layout.layoutChildren = function(/*DomNode*/ container, /*Object*/ dim, /*Widget[]*/ children,
			/*String?*/ changedRegionId, /*Number?*/ changedRegionSize){
		// summary
		//		Layout a bunch of child dom nodes within a parent dom node
		// container:
		//		parent node
		// dim:
		//		{l, t, w, h} object specifying dimensions of container into which to place children
		// children:
		//		an array of Widgets or at least objects containing:
		//			* domNode: pointer to DOM node to position
		//			* region or layoutAlign: position to place DOM node
		//			* resize(): (optional) method to set size of node
		//			* id: (optional) Id of widgets, referenced from resize object, below.
		// changedRegionId:
		//		If specified, the slider for the region with the specified id has been dragged, and thus
		//		the region's height or width should be adjusted according to changedRegionSize
		// changedRegionSize:
		//		See changedRegionId.

		// copy dim because we are going to modify it
		dim = dojo.mixin({}, dim);

		dojo.addClass(container, "dijitLayoutContainer");

		// Move "client" elements to the end of the array for layout.  a11y dictates that the author
		// needs to be able to put them in the document in tab-order, but this algorithm requires that
		// client be last.    TODO: move these lines to LayoutContainer?   Unneeded other places I think.
		children = dojo.filter(children, function(item){ return item.region != "center" && item.layoutAlign != "client"; })
			.concat(dojo.filter(children, function(item){ return item.region == "center" || item.layoutAlign == "client"; }));

		// set positions/sizes
		dojo.forEach(children, function(child){

//console.log("Doing pos for child: " + child);
//console.dir({child:child});

			var elm = child.domNode,
				pos = (child.region || child.layoutAlign);

			// set elem to upper left corner of unused space; may move it later
			var elmStyle = elm.style;
			elmStyle.left = dim.l+"px";
			elmStyle.top = dim.t+"px";
			elmStyle.position = "absolute";

			dojo.addClass(elm, "dijitAlign" + capitalize(pos));

			// Size adjustments to make to this child widget
			var sizeSetting = {};

			// Check for optional size adjustment due to splitter drag (height adjustment for top/bottom align
			// panes and width adjustment for left/right align panes.
			if(changedRegionId && changedRegionId == child.id){
				sizeSetting[child.region == "top" || child.region == "bottom" ? "h" : "w"] = changedRegionSize;
			}

			// set size && adjust record of remaining space.
			// note that setting the width of a <div> may affect its height.
			if(pos == "top" || pos == "bottom"){
				sizeSetting.w = dim.w;
				size(child, sizeSetting);
				dim.h -= child.h;
				if(pos == "top"){
					dim.t += child.h;
				}else{
					elmStyle.top = dim.t + dim.h + "px";
				}
			}else if(pos == "left" || pos == "right"){
				sizeSetting.h = dim.h;
				size(child, sizeSetting);
				dim.w -= child.w;
				if(pos == "left"){
					dim.l += child.w;
				}else{
					elmStyle.left = dim.l + dim.w + "px";
				}
			}else if(pos == "client" || pos == "center"){
				size(child, dim);
			}
		});
	};

})();

}

if(!dojo._hasResource["dijit.layout._ContentPaneResizeMixin"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.layout._ContentPaneResizeMixin"] = true;
dojo.provide("dijit.layout._ContentPaneResizeMixin");




dojo.declare("dijit.layout._ContentPaneResizeMixin", null, {
	// summary:
	//		Resize() functionality of ContentPane.   If there's a single layout widget
	//		child then it will call resize() with the same dimensions as the ContentPane.
	//		Otherwise just calls resize on each child.
	//
	//		Also implements basic startup() functionality, where starting the parent
	//		will start the children

	// doLayout: Boolean
	//		- false - don't adjust size of children
	//		- true - if there is a single visible child widget, set it's size to
	//				however big the ContentPane is
	doLayout: true,

	// isContainer: [protected] Boolean
	//		Indicates that this widget acts as a "parent" to the descendant widgets.
	//		When the parent is started it will call startup() on the child widgets.
	//		See also `isLayoutContainer`.
	isContainer: true,

	// isLayoutContainer: [protected] Boolean
	//		Indicates that this widget will call resize() on it's child widgets
	//		when they become visible.
	isLayoutContainer: true,

	_startChildren: function(){
		// summary:
		//		Call startup() on all children including non _Widget ones like dojo.dnd.Source objects

		// This starts all the widgets
		dojo.forEach(this.getChildren(), function(child){
			child.startup();
			child._started = true;
		});
	},

	startup: function(){
		// summary:
		//		See `dijit.layout._LayoutWidget.startup` for description.
		//		Although ContentPane doesn't extend _LayoutWidget, it does implement
		//		the same API.

		if(this._started){ return; }

		var parent = dijit._Contained.prototype.getParent.call(this);
		this._childOfLayoutWidget = parent && parent.isLayoutContainer;

		// I need to call resize() on my child/children (when I become visible), unless
		// I'm the child of a layout widget in which case my parent will call resize() on me and I'll do it then.
		this._needLayout = !this._childOfLayoutWidget;

		this.inherited(arguments);

		this._startChildren();

		if(this._isShown()){
			this._onShow();
		}

		if(!this._childOfLayoutWidget){
			// If my parent isn't a layout container, since my style *may be* width=height=100%
			// or something similar (either set directly or via a CSS class),
			// monitor when my size changes so that I can re-layout.
			// For browsers where I can't directly monitor when my size changes,
			// monitor when the viewport changes size, which *may* indicate a size change for me.
			this.connect(dojo.isIE ? this.domNode : dojo.global, 'onresize', function(){
				// Using function(){} closure to ensure no arguments to resize.
				this._needLayout = !this._childOfLayoutWidget;
				this.resize();
			});
		}
	},

	_checkIfSingleChild: function(){
		// summary:
		//		Test if we have exactly one visible widget as a child,
		//		and if so assume that we are a container for that widget,
		//		and should propagate startup() and resize() calls to it.
		//		Skips over things like data stores since they aren't visible.

		var childNodes = dojo.query("> *", this.containerNode).filter(function(node){
				return node.tagName !== "SCRIPT"; // or a regexp for hidden elements like script|area|map|etc..
			}),
			childWidgetNodes = childNodes.filter(function(node){
				return dojo.hasAttr(node, "data-dojo-type") || dojo.hasAttr(node, "dojoType") || dojo.hasAttr(node, "widgetId");
			}),
			candidateWidgets = dojo.filter(childWidgetNodes.map(dijit.byNode), function(widget){
				return widget && widget.domNode && widget.resize;
			});

		if(
			// all child nodes are widgets
			childNodes.length == childWidgetNodes.length &&

			// all but one are invisible (like dojo.data)
			candidateWidgets.length == 1
		){
			this._singleChild = candidateWidgets[0];
		}else{
			delete this._singleChild;
		}

		// So we can set overflow: hidden to avoid a safari bug w/scrollbars showing up (#9449)
		dojo.toggleClass(this.containerNode, this.baseClass + "SingleChild", !!this._singleChild);
	},

	resize: function(changeSize, resultSize){
		// summary:
		//		See `dijit.layout._LayoutWidget.resize` for description.
		//		Although ContentPane doesn't extend _LayoutWidget, it does implement
		//		the same API.

		// For the TabContainer --> BorderContainer --> ContentPane case, _onShow() is
		// never called, so resize() is our trigger to do the initial href download (see [20099]).
		// However, don't load href for closed TitlePanes.
		if(!this._wasShown && this.open !== false){
			this._onShow();
		}

		this._resizeCalled = true;

		this._scheduleLayout(changeSize, resultSize);
	},

	_scheduleLayout: function(changeSize, resultSize){
		// summary:
		//		Resize myself, and call resize() on each of my child layout widgets, either now
		//		(if I'm currently visible) or when I become visible
		if(this._isShown()){
			this._layout(changeSize, resultSize);
		}else{
			this._needLayout = true;
			this._changeSize = changeSize;
			this._resultSize = resultSize;
		}
	},

	_layout: function(changeSize, resultSize){
		// summary:
		//		Resize myself according to optional changeSize/resultSize parameters, like a layout widget.
		//		Also, since I am a Container widget, each of my children expects me to
		//		call resize() or layout() on them.
		//
		//		Should be called on initialization and also whenever we get new content
		//		(from an href, or from set('content', ...))... but deferred until
		//		the ContentPane is visible

		// Set margin box size, unless it wasn't specified, in which case use current size.
		if(changeSize){
			dojo.marginBox(this.domNode, changeSize);
		}

		// Compute content box size of containerNode in case we [later] need to size our single child.
		var cn = this.containerNode;
		if(cn === this.domNode){
			// If changeSize or resultSize was passed to this method and this.containerNode ==
			// this.domNode then we can compute the content-box size without querying the node,
			// which is more reliable (similar to LayoutWidget.resize) (see for example #9449).
			var mb = resultSize || {};
			dojo.mixin(mb, changeSize || {}); // changeSize overrides resultSize
			if(!("h" in mb) || !("w" in mb)){
				mb = dojo.mixin(dojo.marginBox(cn), mb); // just use dojo.marginBox() to fill in missing values
			}
			this._contentBox = dijit.layout.marginBox2contentBox(cn, mb);
		}else{
			this._contentBox = dojo.contentBox(cn);
		}

		this._layoutChildren();

		delete this._needLayout;
	},
	
	_layoutChildren: function(){
		// Call _checkIfSingleChild() again in case app has manually mucked w/the content
		// of the ContentPane (rather than changing it through the set("content", ...) API.
		if(this.doLayout){
			this._checkIfSingleChild();
		}

		if(this._singleChild && this._singleChild.resize){
			var cb = this._contentBox || dojo.contentBox(this.containerNode);

			// note: if widget has padding this._contentBox will have l and t set,
			// but don't pass them to resize() or it will doubly-offset the child
			this._singleChild.resize({w: cb.w, h: cb.h});
		}else{
			// All my child widgets are independently sized (rather than matching my size),
			// but I still need to call resize() on each child to make it layout.
			dojo.forEach(this.getChildren(), function(widget){
				if(widget.resize){
					widget.resize();
				}
			});
		}
	},

	_isShown: function(){
		// summary:
		//		Returns true if the content is currently shown.
		// description:
		//		If I am a child of a layout widget then it actually returns true if I've ever been visible,
		//		not whether I'm currently visible, since that's much faster than tracing up the DOM/widget
		//		tree every call, and at least solves the performance problem on page load by deferring loading
		//		hidden ContentPanes until they are first shown

		if(this._childOfLayoutWidget){
			// If we are TitlePane, etc - we return that only *IF* we've been resized
			if(this._resizeCalled && "open" in this){
				return this.open;
			}
			return this._resizeCalled;
		}else if("open" in this){
			return this.open;		// for TitlePane, etc.
		}else{
			var node = this.domNode, parent = this.domNode.parentNode;
			return (node.style.display != 'none') && (node.style.visibility != 'hidden') && !dojo.hasClass(node, "dijitHidden") &&
					parent && parent.style && (parent.style.display != 'none');
		}
	},

	_onShow: function(){
		// summary:
		//		Called when the ContentPane is made visible
		// description:
		//		For a plain ContentPane, this is called on initialization, from startup().
		//		If the ContentPane is a hidden pane of a TabContainer etc., then it's
		//		called whenever the pane is made visible.
		//
		//		Does layout/resize of child widget(s)

		if(this._needLayout){
			// If a layout has been scheduled for when we become visible, do it now
			this._layout(this._changeSize, this._resultSize);
		}

		this.inherited(arguments);

		// Need to keep track of whether ContentPane has been shown (which is different than
		// whether or not it's currently visible).
		this._wasShown = true;
	}
});

}

if(!dojo._hasResource["dojo.string"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.string"] = true;
dojo.provide("dojo.string");

dojo.getObject("string", true, dojo);

/*=====
dojo.string = {
	// summary: String utilities for Dojo
};
=====*/

dojo.string.rep = function(/*String*/str, /*Integer*/num){
	//	summary:
	//		Efficiently replicate a string `n` times.
	//	str:
	//		the string to replicate
	//	num:
	//		number of times to replicate the string
	
	if(num <= 0 || !str){ return ""; }
	
	var buf = [];
	for(;;){
		if(num & 1){
			buf.push(str);
		}
		if(!(num >>= 1)){ break; }
		str += str;
	}
	return buf.join("");	// String
};

dojo.string.pad = function(/*String*/text, /*Integer*/size, /*String?*/ch, /*Boolean?*/end){
	//	summary:
	//		Pad a string to guarantee that it is at least `size` length by
	//		filling with the character `ch` at either the start or end of the
	//		string. Pads at the start, by default.
	//	text:
	//		the string to pad
	//	size:
	//		length to provide padding
	//	ch:
	//		character to pad, defaults to '0'
	//	end:
	//		adds padding at the end if true, otherwise pads at start
	//	example:
	//	|	// Fill the string to length 10 with "+" characters on the right.  Yields "Dojo++++++".
	//	|	dojo.string.pad("Dojo", 10, "+", true);

	if(!ch){
		ch = '0';
	}
	var out = String(text),
		pad = dojo.string.rep(ch, Math.ceil((size - out.length) / ch.length));
	return end ? out + pad : pad + out;	// String
};

dojo.string.substitute = function(	/*String*/		template,
									/*Object|Array*/map,
									/*Function?*/	transform,
									/*Object?*/		thisObject){
	//	summary:
	//		Performs parameterized substitutions on a string. Throws an
	//		exception if any parameter is unmatched.
	//	template:
	//		a string with expressions in the form `${key}` to be replaced or
	//		`${key:format}` which specifies a format function. keys are case-sensitive.
	//	map:
	//		hash to search for substitutions
	//	transform:
	//		a function to process all parameters before substitution takes
	//		place, e.g. mylib.encodeXML
	//	thisObject:
	//		where to look for optional format function; default to the global
	//		namespace
	//	example:
	//		Substitutes two expressions in a string from an Array or Object
	//	|	// returns "File 'foo.html' is not found in directory '/temp'."
	//	|	// by providing substitution data in an Array
	//	|	dojo.string.substitute(
	//	|		"File '${0}' is not found in directory '${1}'.",
	//	|		["foo.html","/temp"]
	//	|	);
	//	|
	//	|	// also returns "File 'foo.html' is not found in directory '/temp'."
	//	|	// but provides substitution data in an Object structure.  Dotted
	//	|	// notation may be used to traverse the structure.
	//	|	dojo.string.substitute(
	//	|		"File '${name}' is not found in directory '${info.dir}'.",
	//	|		{ name: "foo.html", info: { dir: "/temp" } }
	//	|	);
	//	example:
	//		Use a transform function to modify the values:
	//	|	// returns "file 'foo.html' is not found in directory '/temp'."
	//	|	dojo.string.substitute(
	//	|		"${0} is not found in ${1}.",
	//	|		["foo.html","/temp"],
	//	|		function(str){
	//	|			// try to figure out the type
	//	|			var prefix = (str.charAt(0) == "/") ? "directory": "file";
	//	|			return prefix + " '" + str + "'";
	//	|		}
	//	|	);
	//	example:
	//		Use a formatter
	//	|	// returns "thinger -- howdy"
	//	|	dojo.string.substitute(
	//	|		"${0:postfix}", ["thinger"], null, {
	//	|			postfix: function(value, key){
	//	|				return value + " -- howdy";
	//	|			}
	//	|		}
	//	|	);

	thisObject = thisObject || dojo.global;
	transform = transform ?
		dojo.hitch(thisObject, transform) : function(v){ return v; };

	return template.replace(/\$\{([^\s\:\}]+)(?:\:([^\s\:\}]+))?\}/g,
		function(match, key, format){
			var value = dojo.getObject(key, false, map);
			if(format){
				value = dojo.getObject(format, false, thisObject).call(thisObject, value, key);
			}
			return transform(value, key).toString();
		}); // String
};

/*=====
dojo.string.trim = function(str){
	//	summary:
	//		Trims whitespace from both sides of the string
	//	str: String
	//		String to be trimmed
	//	returns: String
	//		Returns the trimmed string
	//	description:
	//		This version of trim() was taken from [Steven Levithan's blog](http://blog.stevenlevithan.com/archives/faster-trim-javascript).
	//		The short yet performant version of this function is dojo.trim(),
	//		which is part of Dojo base.  Uses String.prototype.trim instead, if available.
	return "";	// String
}
=====*/

dojo.string.trim = String.prototype.trim ?
	dojo.trim : // aliasing to the native function
	function(str){
		str = str.replace(/^\s+/, '');
		for(var i = str.length - 1; i >= 0; i--){
			if(/\S/.test(str.charAt(i))){
				str = str.substring(0, i + 1);
				break;
			}
		}
		return str;
	};

}

if(!dojo._hasResource["dojo.date.stamp"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.date.stamp"] = true;
dojo.provide("dojo.date.stamp");

dojo.getObject("date.stamp", true, dojo);

// Methods to convert dates to or from a wire (string) format using well-known conventions

dojo.date.stamp.fromISOString = function(/*String*/formattedString, /*Number?*/defaultTime){
	//	summary:
	//		Returns a Date object given a string formatted according to a subset of the ISO-8601 standard.
	//
	//	description:
	//		Accepts a string formatted according to a profile of ISO8601 as defined by
	//		[RFC3339](http://www.ietf.org/rfc/rfc3339.txt), except that partial input is allowed.
	//		Can also process dates as specified [by the W3C](http://www.w3.org/TR/NOTE-datetime)
	//		The following combinations are valid:
	//
	//			* dates only
	//			|	* yyyy
	//			|	* yyyy-MM
	//			|	* yyyy-MM-dd
	// 			* times only, with an optional time zone appended
	//			|	* THH:mm
	//			|	* THH:mm:ss
	//			|	* THH:mm:ss.SSS
	// 			* and "datetimes" which could be any combination of the above
	//
	//		timezones may be specified as Z (for UTC) or +/- followed by a time expression HH:mm
	//		Assumes the local time zone if not specified.  Does not validate.  Improperly formatted
	//		input may return null.  Arguments which are out of bounds will be handled
	// 		by the Date constructor (e.g. January 32nd typically gets resolved to February 1st)
	//		Only years between 100 and 9999 are supported.
	//
  	//	formattedString:
	//		A string such as 2005-06-30T08:05:00-07:00 or 2005-06-30 or T08:05:00
	//
	//	defaultTime:
	//		Used for defaults for fields omitted in the formattedString.
	//		Uses 1970-01-01T00:00:00.0Z by default.

	if(!dojo.date.stamp._isoRegExp){
		dojo.date.stamp._isoRegExp =
//TODO: could be more restrictive and check for 00-59, etc.
			/^(?:(\d{4})(?:-(\d{2})(?:-(\d{2}))?)?)?(?:T(\d{2}):(\d{2})(?::(\d{2})(.\d+)?)?((?:[+-](\d{2}):(\d{2}))|Z)?)?$/;
	}

	var match = dojo.date.stamp._isoRegExp.exec(formattedString),
		result = null;

	if(match){
		match.shift();
		if(match[1]){match[1]--;} // Javascript Date months are 0-based
		if(match[6]){match[6] *= 1000;} // Javascript Date expects fractional seconds as milliseconds

		if(defaultTime){
			// mix in defaultTime.  Relatively expensive, so use || operators for the fast path of defaultTime === 0
			defaultTime = new Date(defaultTime);
			dojo.forEach(dojo.map(["FullYear", "Month", "Date", "Hours", "Minutes", "Seconds", "Milliseconds"], function(prop){
				return defaultTime["get" + prop]();
			}), function(value, index){
				match[index] = match[index] || value;
			});
		}
		result = new Date(match[0]||1970, match[1]||0, match[2]||1, match[3]||0, match[4]||0, match[5]||0, match[6]||0); //TODO: UTC defaults
		if(match[0] < 100){
			result.setFullYear(match[0] || 1970);
		}

		var offset = 0,
			zoneSign = match[7] && match[7].charAt(0);
		if(zoneSign != 'Z'){
			offset = ((match[8] || 0) * 60) + (Number(match[9]) || 0);
			if(zoneSign != '-'){ offset *= -1; }
		}
		if(zoneSign){
			offset -= result.getTimezoneOffset();
		}
		if(offset){
			result.setTime(result.getTime() + offset * 60000);
		}
	}

	return result; // Date or null
};

/*=====
	dojo.date.stamp.__Options = function(){
		//	selector: String
		//		"date" or "time" for partial formatting of the Date object.
		//		Both date and time will be formatted by default.
		//	zulu: Boolean
		//		if true, UTC/GMT is used for a timezone
		//	milliseconds: Boolean
		//		if true, output milliseconds
		this.selector = selector;
		this.zulu = zulu;
		this.milliseconds = milliseconds;
	}
=====*/

dojo.date.stamp.toISOString = function(/*Date*/dateObject, /*dojo.date.stamp.__Options?*/options){
	//	summary:
	//		Format a Date object as a string according a subset of the ISO-8601 standard
	//
	//	description:
	//		When options.selector is omitted, output follows [RFC3339](http://www.ietf.org/rfc/rfc3339.txt)
	//		The local time zone is included as an offset from GMT, except when selector=='time' (time without a date)
	//		Does not check bounds.  Only years between 100 and 9999 are supported.
	//
	//	dateObject:
	//		A Date object

	var _ = function(n){ return (n < 10) ? "0" + n : n; };
	options = options || {};
	var formattedDate = [],
		getter = options.zulu ? "getUTC" : "get",
		date = "";
	if(options.selector != "time"){
		var year = dateObject[getter+"FullYear"]();
		date = ["0000".substr((year+"").length)+year, _(dateObject[getter+"Month"]()+1), _(dateObject[getter+"Date"]())].join('-');
	}
	formattedDate.push(date);
	if(options.selector != "date"){
		var time = [_(dateObject[getter+"Hours"]()), _(dateObject[getter+"Minutes"]()), _(dateObject[getter+"Seconds"]())].join(':');
		var millis = dateObject[getter+"Milliseconds"]();
		if(options.milliseconds){
			time += "."+ (millis < 100 ? "0" : "") + _(millis);
		}
		if(options.zulu){
			time += "Z";
		}else if(options.selector != "time"){
			var timezoneOffset = dateObject.getTimezoneOffset();
			var absOffset = Math.abs(timezoneOffset);
			time += (timezoneOffset > 0 ? "-" : "+") +
				_(Math.floor(absOffset/60)) + ":" + _(absOffset%60);
		}
		formattedDate.push(time);
	}
	return formattedDate.join('T'); // String
};

}

if(!dojo._hasResource["dojo.parser"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.parser"] = true;
dojo.provide("dojo.parser");



new Date("X"); // workaround for #11279, new Date("") == NaN

dojo.parser = new function(){
	// summary:
	//		The Dom/Widget parsing package

	var d = dojo;

	function val2type(/*Object*/ value){
		// summary:
		//		Returns name of type of given value.

		if(d.isString(value)){ return "string"; }
		if(typeof value == "number"){ return "number"; }
		if(typeof value == "boolean"){ return "boolean"; }
		if(d.isFunction(value)){ return "function"; }
		if(d.isArray(value)){ return "array"; } // typeof [] == "object"
		if(value instanceof Date) { return "date"; } // assume timestamp
		if(value instanceof d._Url){ return "url"; }
		return "object";
	}

	function str2obj(/*String*/ value, /*String*/ type){
		// summary:
		//		Convert given string value to given type
		switch(type){
			case "string":
				return value;
			case "number":
				return value.length ? Number(value) : NaN;
			case "boolean":
				// for checked/disabled value might be "" or "checked".	 interpret as true.
				return typeof value == "boolean" ? value : !(value.toLowerCase()=="false");
			case "function":
				if(d.isFunction(value)){
					// IE gives us a function, even when we say something like onClick="foo"
					// (in which case it gives us an invalid function "function(){ foo }").
					//	Therefore, convert to string
					value=value.toString();
					value=d.trim(value.substring(value.indexOf('{')+1, value.length-1));
				}
				try{
					if(value === "" || value.search(/[^\w\.]+/i) != -1){
						// The user has specified some text for a function like "return x+5"
						return new Function(value);
					}else{
						// The user has specified the name of a function like "myOnClick"
						// or a single word function "return"
						return d.getObject(value, false) || new Function(value);
					}
				}catch(e){ return new Function(); }
			case "array":
				return value ? value.split(/\s*,\s*/) : [];
			case "date":
				switch(value){
					case "": return new Date("");	// the NaN of dates
					case "now": return new Date();	// current date
					default: return d.date.stamp.fromISOString(value);
				}
			case "url":
				return d.baseUrl + value;
			default:
				return d.fromJson(value);
		}
	}

	var dummyClass = {}, instanceClasses = {
		// map from fully qualified name (like "dijit.Button") to structure like
		// { cls: dijit.Button, params: {label: "string", disabled: "boolean"} }
	};

	// Widgets like BorderContainer add properties to _Widget via dojo.extend().
	// If BorderContainer is loaded after _Widget's parameter list has been cached,
	// we need to refresh that parameter list (for _Widget and all widgets that extend _Widget).
	// TODO: remove this in 2.0, when we stop caching parameters.
	d.connect(d, "extend", function(){
		instanceClasses = {};
	});

	function getProtoInfo(cls, params){
		// cls: A prototype
		//		The prototype of the class to check props on
		// params: Object
		//		The parameters object to mix found parameters onto.
		for(var name in cls){
			if(name.charAt(0)=="_"){ continue; }	// skip internal properties
			if(name in dummyClass){ continue; }		// skip "constructor" and "toString"
			params[name] = val2type(cls[name]);
		}
		return params;
	}

	function getClassInfo(/*String*/ className, /*Boolean*/ skipParamsLookup){
		// summary:
		//		Maps a widget name string like "dijit.form.Button" to the widget constructor itself,
		//		and a list of that widget's parameters and their types
		// className:
		//		fully qualified name (like "dijit.form.Button")
		// returns:
		//		structure like
		//			{
		//				cls: dijit.Button,
		//				params: { label: "string", disabled: "boolean"}
		//			}

		var c = instanceClasses[className];
		if(!c){
			// get pointer to widget class
			var cls = d.getObject(className), params = null;
			if(!cls){ return null; }		// class not defined [yet]
			if(!skipParamsLookup){ // from fastpath, we don't need to lookup the attrs on the proto because they are explicit
				params = getProtoInfo(cls.prototype, {})
			}
			c = { cls: cls, params: params };
			
		}else if(!skipParamsLookup && !c.params){
			// if we're calling getClassInfo and have a cls proto, but no params info, scan that cls for params now
			// and update the pointer in instanceClasses[className]. This happens when a widget appears in another
			// widget's template which still uses dojoType, but an instance of the widget appears prior with a data-dojo-type,
			// skipping this lookup the first time.
			c.params = getProtoInfo(c.cls.prototype, {});
		}
		
		return c;
	}

	this._functionFromScript = function(script, attrData){
		// summary:
		//		Convert a <script type="dojo/method" args="a, b, c"> ... </script>
		//		into a function
		// script: DOMNode
		//		The <script> DOMNode
		// attrData: String
		//		For HTML5 compliance, searches for attrData + "args" (typically
		//		"data-dojo-args") instead of "args"
		var preamble = "";
		var suffix = "";
		var argsStr = (script.getAttribute(attrData + "args") || script.getAttribute("args"));
		if(argsStr){
			d.forEach(argsStr.split(/\s*,\s*/), function(part, idx){
				preamble += "var "+part+" = arguments["+idx+"]; ";
			});
		}
		var withStr = script.getAttribute("with");
		if(withStr && withStr.length){
			d.forEach(withStr.split(/\s*,\s*/), function(part){
				preamble += "with("+part+"){";
				suffix += "}";
			});
		}
		return new Function(preamble+script.innerHTML+suffix);
	};

	this.instantiate = function(/* Array */nodes, /* Object? */mixin, /* Object? */args){
		// summary:
		//		Takes array of nodes, and turns them into class instances and
		//		potentially calls a startup method to allow them to connect with
		//		any children.
		// nodes: Array
		//		Array of nodes or objects like
		//	|		{
		//	|			type: "dijit.form.Button",
		//	|			node: DOMNode,
		//	|			scripts: [ ... ],	// array of <script type="dojo/..."> children of node
		//	|			inherited: { ... }	// settings inherited from ancestors like dir, theme, etc.
		//	|		}
		// mixin: Object?
		//		An object that will be mixed in with each node in the array.
		//		Values in the mixin will override values in the node, if they
		//		exist.
		// args: Object?
		//		An object used to hold kwArgs for instantiation.
		//		See parse.args argument for details.

		var thelist = [],
		mixin = mixin||{};
		args = args||{};

		// TODO: for 2.0 default to data-dojo- regardless of scopeName (or maybe scopeName won't exist in 2.0)
		var attrName = (args.scope || d._scopeName) + "Type",	// typically "dojoType"
			attrData = "data-" + (args.scope || d._scopeName) + "-";	// typically "data-dojo-"

		d.forEach(nodes, function(obj){
			if(!obj){ return; }

			// Get pointers to DOMNode, dojoType string, and clsInfo (metadata about the dojoType), etc.
			var node, type, clsInfo, clazz, scripts, fastpath;
			if(obj.node){
				// new format of nodes[] array, object w/lots of properties pre-computed for me
				node = obj.node;
				type = obj.type;
				fastpath = obj.fastpath;
				clsInfo = obj.clsInfo || (type && getClassInfo(type, fastpath));
				clazz = clsInfo && clsInfo.cls;
				scripts = obj.scripts;
			}else{
				// old (backwards compatible) format of nodes[] array, simple array of DOMNodes. no fastpath/data-dojo-type support here.
				node = obj;
				type = attrName in mixin ? mixin[attrName] : node.getAttribute(attrName);
				clsInfo = type && getClassInfo(type);
				clazz = clsInfo && clsInfo.cls;
				scripts = (clazz && (clazz._noScript || clazz.prototype._noScript) ? [] :
							d.query("> script[type^='dojo/']", node));
			}
			if(!clsInfo){
				throw new Error("Could not load class '" + type);
			}

			// Setup hash to hold parameter settings for this widget.	Start with the parameter
			// settings inherited from ancestors ("dir" and "lang").
			// Inherited setting may later be overridden by explicit settings on node itself.
			var params = {};
				
			if(args.defaults){
				// settings for the document itself (or whatever subtree is being parsed)
				d._mixin(params, args.defaults);
			}
			if(obj.inherited){
				// settings from dir=rtl or lang=... on a node above this node
				d._mixin(params, obj.inherited);
			}
			
			// mix things found in data-dojo-props into the params
			if(fastpath){
				var extra = node.getAttribute(attrData + "props");
				if(extra && extra.length){
					try{
						extra = d.fromJson.call(args.propsThis, "{" + extra + "}");
						d._mixin(params, extra);
					}catch(e){
						// give the user a pointer to their invalid parameters. FIXME: can we kill this in production?
						throw new Error(e.toString() + " in data-dojo-props='" + extra + "'");
					}
				}

				// For the benefit of _Templated, check if node has data-dojo-attach-point/data-dojo-attach-event
				// and mix those in as though they were parameters
				var attachPoint = node.getAttribute(attrData + "attach-point");
				if(attachPoint){
					params.dojoAttachPoint = attachPoint;
				}
				var attachEvent = node.getAttribute(attrData + "attach-event");
				if(attachEvent){
					params.dojoAttachEvent = attachEvent;
				}
				dojo.mixin(params, mixin);
			}else{
				// FIXME: we need something like "deprecateOnce()" to throw dojo.deprecation for something.
				// remove this logic in 2.0
				// read parameters (ie, attributes) specified on DOMNode

				var attributes = node.attributes;

				// clsInfo.params lists expected params like {"checked": "boolean", "n": "number"}
				for(var name in clsInfo.params){
					var item = name in mixin ? { value:mixin[name], specified:true } : attributes.getNamedItem(name);
					if(!item || (!item.specified && (!dojo.isIE || name.toLowerCase()!="value"))){ continue; }
					var value = item.value;
					// Deal with IE quirks for 'class' and 'style'
					switch(name){
					case "class":
						value = "className" in mixin ? mixin.className : node.className;
						break;
					case "style":
						value = "style" in mixin ? mixin.style : (node.style && node.style.cssText); // FIXME: Opera?
					}
					var _type = clsInfo.params[name];
					if(typeof value == "string"){
						params[name] = str2obj(value, _type);
					}else{
						params[name] = value;
					}
				}
			}

			// Process <script type="dojo/*"> script tags
			// <script type="dojo/method" event="foo"> tags are added to params, and passed to
			// the widget on instantiation.
			// <script type="dojo/method"> tags (with no event) are executed after instantiation
			// <script type="dojo/connect" event="foo"> tags are dojo.connected after instantiation
			// note: dojo/* script tags cannot exist in self closing widgets, like <input />
			var connects = [],	// functions to connect after instantiation
				calls = [];		// functions to call after instantiation

			d.forEach(scripts, function(script){
				node.removeChild(script);
				// FIXME: drop event="" support in 2.0. use data-dojo-event="" instead
				var event = (script.getAttribute(attrData + "event") || script.getAttribute("event")),
					type = script.getAttribute("type"),
					nf = d.parser._functionFromScript(script, attrData);
				if(event){
					if(type == "dojo/connect"){
						connects.push({event: event, func: nf});
					}else{
						params[event] = nf;
					}
				}else{
					calls.push(nf);
				}
			});

			var markupFactory = clazz.markupFactory || clazz.prototype && clazz.prototype.markupFactory;
			// create the instance
			var instance = markupFactory ? markupFactory(params, node, clazz) : new clazz(params, node);
			thelist.push(instance);

			// map it to the JS namespace if that makes sense
			// FIXME: in 2.0, drop jsId support. use data-dojo-id instead
			var jsname = (node.getAttribute(attrData + "id") || node.getAttribute("jsId"));
			if(jsname){
				d.setObject(jsname, instance);
			}

			// process connections and startup functions
			d.forEach(connects, function(connect){
				d.connect(instance, connect.event, null, connect.func);
			});
			d.forEach(calls, function(func){
				func.call(instance);
			});
		});

		// Call startup on each top level instance if it makes sense (as for
		// widgets).  Parent widgets will recursively call startup on their
		// (non-top level) children
		if(!mixin._started){
			// TODO: for 2.0, when old instantiate() API is desupported, store parent-child
			// relationships in the nodes[] array so that no getParent() call is needed.
			// Note that will  require a parse() call from ContentPane setting a param that the
			// ContentPane is the parent widget (so that the parse doesn't call startup() on the
			// ContentPane's children)
			d.forEach(thelist, function(instance){
				if( !args.noStart && instance  &&
					dojo.isFunction(instance.startup) &&
					!instance._started &&
					(!instance.getParent || !instance.getParent())
				){
					instance.startup();
				}
			});
		}
		return thelist;
	};

	this.parse = function(rootNode, args){
		// summary:
		//		Scan the DOM for class instances, and instantiate them.
		//
		// description:
		//		Search specified node (or root node) recursively for class instances,
		//		and instantiate them. Searches for either data-dojo-type="Class" or
		//		dojoType="Class" where "Class" is a a fully qualified class name,
		//		like `dijit.form.Button`
		//
		//		Using `data-dojo-type`:
		//		Attributes using can be mixed into the parameters used to instantitate the
		//		Class by using a `data-dojo-props` attribute on the node being converted.
		//		`data-dojo-props` should be a string attribute to be converted from JSON.
		//
		//		Using `dojoType`:
		//		Attributes are read from the original domNode and converted to appropriate
		//		types by looking up the Class prototype values. This is the default behavior
		//		from Dojo 1.0 to Dojo 1.5. `dojoType` support is deprecated, and will
		//		go away in Dojo 2.0.
		//
		// rootNode: DomNode?
		//		A default starting root node from which to start the parsing. Can be
		//		omitted, defaulting to the entire document. If omitted, the `args`
		//		object can be passed in this place. If the `args` object has a
		//		`rootNode` member, that is used.
		//
		// args: Object
		//		a kwArgs object passed along to instantiate()
		//
		//			* noStart: Boolean?
		//				when set will prevent the parser from calling .startup()
		//				when locating the nodes.
		//			* rootNode: DomNode?
		//				identical to the function's `rootNode` argument, though
		//				allowed to be passed in via this `args object.
		//			* template: Boolean
		//				If true, ignores ContentPane's stopParser flag and parses contents inside of
		//				a ContentPane inside of a template.   This allows dojoAttachPoint on widgets/nodes
		//				nested inside the ContentPane to work.
		//			* inherited: Object
		//				Hash possibly containing dir and lang settings to be applied to
		//				parsed widgets, unless there's another setting on a sub-node that overrides
		//			* scope: String
		//				Root for attribute names to search for.   If scopeName is dojo,
		//				will search for data-dojo-type (or dojoType).   For backwards compatibility
		//				reasons defaults to dojo._scopeName (which is "dojo" except when
		//				multi-version support is used, when it will be something like dojo16, dojo20, etc.)
		//			* propsThis: Object
		//				If specified, "this" referenced from data-dojo-props will refer to propsThis.
		//				Intended for use from the widgets-in-template feature of `dijit._Templated`
		//
		// example:
		//		Parse all widgets on a page:
		//	|		dojo.parser.parse();
		//
		// example:
		//		Parse all classes within the node with id="foo"
		//	|		dojo.parser.parse(dojo.byId('foo'));
		//
		// example:
		//		Parse all classes in a page, but do not call .startup() on any
		//		child
		//	|		dojo.parser.parse({ noStart: true })
		//
		// example:
		//		Parse all classes in a node, but do not call .startup()
		//	|		dojo.parser.parse(someNode, { noStart:true });
		//	|		// or
		//	|		dojo.parser.parse({ noStart:true, rootNode: someNode });

		// determine the root node based on the passed arguments.
		var root;
		if(!args && rootNode && rootNode.rootNode){
			args = rootNode;
			root = args.rootNode;
		}else{
			root = rootNode;
		}
		root = root ? dojo.byId(root) : dojo.body();
		args = args || {};

		var attrName = (args.scope || d._scopeName) + "Type",		// typically "dojoType"
			attrData = "data-" + (args.scope || d._scopeName) + "-";	// typically "data-dojo-"

		function scan(parent, list){
			// summary:
			//		Parent is an Object representing a DOMNode, with or without a dojoType specified.
			//		Scan parent's children looking for nodes with dojoType specified, storing in list[].
			//		If parent has a dojoType, also collects <script type=dojo/*> children and stores in parent.scripts[].
			// parent: Object
			//		Object representing the parent node, like
			//	|	{
			//	|		node: DomNode,			// scan children of this node
			//	|		inherited: {dir: "rtl"},	// dir/lang setting inherited from above node
			//	|
			//	|		// attributes only set if node has dojoType specified
			//	|		scripts: [],			// empty array, put <script type=dojo/*> in here
			//	|		clsInfo: { cls: dijit.form.Button, ...}
			//	|	}
			// list: DomNode[]
			//		Output array of objects (same format as parent) representing nodes to be turned into widgets

			// Effective dir and lang settings on parent node, either set directly or inherited from grandparent
			var inherited = dojo.clone(parent.inherited);
			dojo.forEach(["dir", "lang"], function(name){
				// TODO: what if this is a widget and dir/lang are declared in data-dojo-props?
				var val = parent.node.getAttribute(name);
				if(val){
					inherited[name] = val;
				}
			});

			// if parent is a widget, then search for <script type=dojo/*> tags and put them in scripts[].
			var scripts = parent.clsInfo && !parent.clsInfo.cls.prototype._noScript ? parent.scripts : null;

			// unless parent is a widget with the stopParser flag set, continue search for dojoType, recursively
			var recurse = (!parent.clsInfo || !parent.clsInfo.cls.prototype.stopParser) || (args && args.template);

			// scan parent's children looking for dojoType and <script type=dojo/*>
			for(var child = parent.node.firstChild; child; child = child.nextSibling){
				if(child.nodeType == 1){
					// FIXME: desupport dojoType in 2.0. use data-dojo-type instead
					var type, html5 = recurse && child.getAttribute(attrData + "type");
					if(html5){
						type = html5;
					}else{
						// fallback to backward compatible mode, using dojoType. remove in 2.0
						type = recurse && child.getAttribute(attrName);
					}
					
					var fastpath = html5 == type;

					if(type){
						// if dojoType/data-dojo-type specified, add to output array of nodes to instantiate
						var params = {
							"type": type,
							fastpath: fastpath,
							clsInfo: getClassInfo(type, fastpath), // note: won't find classes declared via dojo.Declaration
							node: child,
							scripts: [], // <script> nodes that are parent's children
							inherited: inherited // dir & lang attributes inherited from parent
						};
						list.push(params);

						// Recurse, collecting <script type="dojo/..."> children, and also looking for
						// descendant nodes with dojoType specified (unless the widget has the stopParser flag),
						scan(params, list);
					}else if(scripts && child.nodeName.toLowerCase() == "script"){
						// if <script type="dojo/...">, save in scripts[]
						type = child.getAttribute("type");
						if (type && /^dojo\/\w/i.test(type)) {
							scripts.push(child);
						}
					}else if(recurse){
						// Recurse, looking for grandchild nodes with dojoType specified
						scan({
							node: child,
							inherited: inherited
						}, list);
					}
				}
			}
		}

		// Ignore bogus entries in inherited hash like {dir: ""}
		var inherited = {};
		if(args && args.inherited){
			for(var key in args.inherited){
				if(args.inherited[key]){ inherited[key] = args.inherited[key]; }
			}
		}

		// Make list of all nodes on page w/dojoType specified
		var list = [];
		scan({
			node: root,
			inherited: inherited
		}, list);

		// go build the object instances
		var mixin = args && args.template ? {template: true} : null;
		return this.instantiate(list, mixin, args); // Array
	};
}();

//Register the parser callback. It should be the first callback
//after the a11y test.

(function(){
	var parseRunner = function(){
		if(dojo.config.parseOnLoad){
			dojo.parser.parse();
		}
	};

	// FIXME: need to clobber cross-dependency!!
	if(dojo.getObject("dijit.wai.onload") === dojo._loaders[0]){
		dojo._loaders.splice(1, 0, parseRunner);
	}else{
		dojo._loaders.unshift(parseRunner);
	}
})();

}

if(!dojo._hasResource["dojo.html"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.html"] = true;
dojo.provide("dojo.html");


dojo.getObject("html", true, dojo);

// the parser might be needed..
(function(){ // private scope, sort of a namespace

	// idCounter is incremented with each instantiation to allow asignment of a unique id for tracking, logging purposes
	var idCounter = 0,
		d = dojo;
	
	dojo.html._secureForInnerHtml = function(/*String*/ cont){
		// summary:
		//		removes !DOCTYPE and title elements from the html string.
		//
		//		khtml is picky about dom faults, you can't attach a style or <title> node as child of body
		//		must go into head, so we need to cut out those tags
		//	cont:
		//		An html string for insertion into the dom
		//
		return cont.replace(/(?:\s*<!DOCTYPE\s[^>]+>|<title[^>]*>[\s\S]*?<\/title>)/ig, ""); // String
	};

/*====
	dojo.html._emptyNode = function(node){
		// summary:
		//		removes all child nodes from the given node
		//	node: DOMNode
		//		the parent element
	};
=====*/
	dojo.html._emptyNode = dojo.empty;

	dojo.html._setNodeContent = function(/* DomNode */ node, /* String|DomNode|NodeList */ cont){
		// summary:
		//		inserts the given content into the given node
		//	node:
		//		the parent element
		//	content:
		//		the content to be set on the parent element.
		//		This can be an html string, a node reference or a NodeList, dojo.NodeList, Array or other enumerable list of nodes
		
		// always empty
		d.empty(node);

		if(cont) {
			if(typeof cont == "string") {
				cont = d._toDom(cont, node.ownerDocument);
			}
			if(!cont.nodeType && d.isArrayLike(cont)) {
				// handle as enumerable, but it may shrink as we enumerate it
				for(var startlen=cont.length, i=0; i<cont.length; i=startlen==cont.length ? i+1 : 0) {
					d.place( cont[i], node, "last");
				}
			} else {
				// pass nodes, documentFragments and unknowns through to dojo.place
				d.place(cont, node, "last");
			}
		}

		// return DomNode
		return node;
	};

	// we wrap up the content-setting operation in a object
	dojo.declare("dojo.html._ContentSetter", null,
		{
			// node: DomNode|String
			//		An node which will be the parent element that we set content into
			node: "",

			// content: String|DomNode|DomNode[]
			//		The content to be placed in the node. Can be an HTML string, a node reference, or a enumerable list of nodes
			content: "",
			
			// id: String?
			//		Usually only used internally, and auto-generated with each instance
			id: "",

			// cleanContent: Boolean
			//		Should the content be treated as a full html document,
			//		and the real content stripped of <html>, <body> wrapper before injection
			cleanContent: false,
			
			// extractContent: Boolean
			//		Should the content be treated as a full html document, and the real content stripped of <html>, <body> wrapper before injection
			extractContent: false,

			// parseContent: Boolean
			//		Should the node by passed to the parser after the new content is set
			parseContent: false,

			// parserScope: String
			//		Flag passed to parser.  Root for attribute names to search for.   If scopeName is dojo,
			//		will search for data-dojo-type (or dojoType).  For backwards compatibility
			//		reasons defaults to dojo._scopeName (which is "dojo" except when
			//		multi-version support is used, when it will be something like dojo16, dojo20, etc.)
			parserScope: dojo._scopeName,

			// startup: Boolean
			//		Start the child widgets after parsing them.   Only obeyed if parseContent is true.
			startup: true,
			
			// lifecyle methods
			constructor: function(/* Object */params, /* String|DomNode */node){
				//	summary:
				//		Provides a configurable, extensible object to wrap the setting on content on a node
				//		call the set() method to actually set the content..
 
				// the original params are mixed directly into the instance "this"
				dojo.mixin(this, params || {});

				// give precedence to params.node vs. the node argument
				// and ensure its a node, not an id string
				node = this.node = dojo.byId( this.node || node );
	
				if(!this.id){
					this.id = [
						"Setter",
						(node) ? node.id || node.tagName : "",
						idCounter++
					].join("_");
				}
			},
			set: function(/* String|DomNode|NodeList? */ cont, /* Object? */ params){
				// summary:
				//		front-end to the set-content sequence
				//	cont:
				//		An html string, node or enumerable list of nodes for insertion into the dom
				//		If not provided, the object's content property will be used
				if(undefined !== cont){
					this.content = cont;
				}
				// in the re-use scenario, set needs to be able to mixin new configuration
				if(params){
					this._mixin(params);
				}

				this.onBegin();
				this.setContent();
				this.onEnd();

				return this.node;
			},
			setContent: function(){
				// summary:
				//		sets the content on the node

				var node = this.node;
				if(!node) {
				    // can't proceed
					throw new Error(this.declaredClass + ": setContent given no node");
				}
				try{
					node = dojo.html._setNodeContent(node, this.content);
				}catch(e){
					// check if a domfault occurs when we are appending this.errorMessage
					// like for instance if domNode is a UL and we try append a DIV
	
					// FIXME: need to allow the user to provide a content error message string
					var errMess = this.onContentError(e);
					try{
						node.innerHTML = errMess;
					}catch(e){
						console.error('Fatal ' + this.declaredClass + '.setContent could not change content due to '+e.message, e);
					}
				}
				// always put back the node for the next method
				this.node = node; // DomNode
			},
			
			empty: function() {
				// summary
				//	cleanly empty out existing content

				// destroy any widgets from a previous run
				// NOTE: if you dont want this you'll need to empty
				// the parseResults array property yourself to avoid bad things happenning
				if(this.parseResults && this.parseResults.length) {
					dojo.forEach(this.parseResults, function(w) {
						if(w.destroy){
							w.destroy();
						}
					});
					delete this.parseResults;
				}
				// this is fast, but if you know its already empty or safe, you could
				// override empty to skip this step
				dojo.html._emptyNode(this.node);
			},
	
			onBegin: function(){
				// summary
				//		Called after instantiation, but before set();
				//		It allows modification of any of the object properties
				//		- including the node and content provided - before the set operation actually takes place
				//		This default implementation checks for cleanContent and extractContent flags to
				//		optionally pre-process html string content
				var cont = this.content;
	
				if(dojo.isString(cont)){
					if(this.cleanContent){
						cont = dojo.html._secureForInnerHtml(cont);
					}
  
					if(this.extractContent){
						var match = cont.match(/<body[^>]*>\s*([\s\S]+)\s*<\/body>/im);
						if(match){ cont = match[1]; }
					}
				}

				// clean out the node and any cruft associated with it - like widgets
				this.empty();
				
				this.content = cont;
				return this.node; /* DomNode */
			},
	
			onEnd: function(){
				// summary
				//		Called after set(), when the new content has been pushed into the node
				//		It provides an opportunity for post-processing before handing back the node to the caller
				//		This default implementation checks a parseContent flag to optionally run the dojo parser over the new content
				if(this.parseContent){
					// populates this.parseResults if you need those..
					this._parse();
				}
				return this.node; /* DomNode */
			},
	
			tearDown: function(){
				// summary
				//		manually reset the Setter instance if its being re-used for example for another set()
				// description
				//		tearDown() is not called automatically.
				//		In normal use, the Setter instance properties are simply allowed to fall out of scope
				//		but the tearDown method can be called to explicitly reset this instance.
				delete this.parseResults;
				delete this.node;
				delete this.content;
			},
  
			onContentError: function(err){
				return "Error occured setting content: " + err;
			},
			
			_mixin: function(params){
				// mix properties/methods into the instance
				// TODO: the intention with tearDown is to put the Setter's state
				// back to that of the original constructor (vs. deleting/resetting everything regardless of ctor params)
				// so we could do something here to move the original properties aside for later restoration
				var empty = {}, key;
				for(key in params){
					if(key in empty){ continue; }
					// TODO: here's our opportunity to mask the properties we dont consider configurable/overridable
					// .. but history shows we'll almost always guess wrong
					this[key] = params[key];
				}
			},
			_parse: function(){
				// summary:
				//		runs the dojo parser over the node contents, storing any results in this.parseResults
				//		Any errors resulting from parsing are passed to _onError for handling

				var rootNode = this.node;
				try{
					// store the results (widgets, whatever) for potential retrieval
					var inherited = {};
					dojo.forEach(["dir", "lang", "textDir"], function(name){
						if(this[name]){
							inherited[name] = this[name];
						}
					}, this);
					this.parseResults = dojo.parser.parse({
						rootNode: rootNode,
						noStart: !this.startup,
						inherited: inherited,
						scope: this.parserScope
					});
				}catch(e){
					this._onError('Content', e, "Error parsing in _ContentSetter#"+this.id);
				}
			},
  
			_onError: function(type, err, consoleText){
				// summary:
				//		shows user the string that is returned by on[type]Error
				//		overide/implement on[type]Error and return your own string to customize
				var errText = this['on' + type + 'Error'].call(this, err);
				if(consoleText){
					console.error(consoleText, err);
				}else if(errText){ // a empty string won't change current content
					dojo.html._setNodeContent(this.node, errText, true);
				}
			}
	}); // end dojo.declare()

	dojo.html.set = function(/* DomNode */ node, /* String|DomNode|NodeList */ cont, /* Object? */ params){
			// summary:
			//		inserts (replaces) the given content into the given node. dojo.place(cont, node, "only")
			//		may be a better choice for simple HTML insertion.
			// description:
			//		Unless you need to use the params capabilities of this method, you should use
			//		dojo.place(cont, node, "only"). dojo.place() has more robust support for injecting
			//		an HTML string into the DOM, but it only handles inserting an HTML string as DOM
			//		elements, or inserting a DOM node. dojo.place does not handle NodeList insertions
			//		or the other capabilities as defined by the params object for this method.
			//	node:
			//		the parent element that will receive the content
			//	cont:
			//		the content to be set on the parent element.
			//		This can be an html string, a node reference or a NodeList, dojo.NodeList, Array or other enumerable list of nodes
			//	params:
			//		Optional flags/properties to configure the content-setting. See dojo.html._ContentSetter
			//	example:
			//		A safe string/node/nodelist content replacement/injection with hooks for extension
			//		Example Usage:
			//		dojo.html.set(node, "some string");
			//		dojo.html.set(node, contentNode, {options});
			//		dojo.html.set(node, myNode.childNodes, {options});
		if(undefined == cont){
			console.warn("dojo.html.set: no cont argument provided, using empty string");
			cont = "";
		}
		if(!params){
			// simple and fast
			return dojo.html._setNodeContent(node, cont, true);
		}else{
			// more options but slower
			// note the arguments are reversed in order, to match the convention for instantiation via the parser
			var op = new dojo.html._ContentSetter(dojo.mixin(
					params,
					{ content: cont, node: node }
			));
			return op.set();
		}
	};
})();

}

if(!dojo._hasResource["dojo.i18n"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.i18n"] = true;
dojo.provide("dojo.i18n");

dojo.getObject("i18n", true, dojo);

/*=====
dojo.i18n = {
	// summary: Utility classes to enable loading of resources for internationalization (i18n)
};
=====*/

// when using a real AMD loader, dojo.i18n.getLocalization is already defined by dojo/lib/backCompat
dojo.i18n.getLocalization = dojo.i18n.getLocalization || function(/*String*/packageName, /*String*/bundleName, /*String?*/locale){
	//	summary:
	//		Returns an Object containing the localization for a given resource
	//		bundle in a package, matching the specified locale.
	//	description:
	//		Returns a hash containing name/value pairs in its prototypesuch
	//		that values can be easily overridden.  Throws an exception if the
	//		bundle is not found.  Bundle must have already been loaded by
	//		`dojo.requireLocalization()` or by a build optimization step.  NOTE:
	//		try not to call this method as part of an object property
	//		definition (`var foo = { bar: dojo.i18n.getLocalization() }`).  In
	//		some loading situations, the bundle may not be available in time
	//		for the object definition.  Instead, call this method inside a
	//		function that is run after all modules load or the page loads (like
	//		in `dojo.addOnLoad()`), or in a widget lifecycle method.
	//	packageName:
	//		package which is associated with this resource
	//	bundleName:
	//		the base filename of the resource bundle (without the ".js" suffix)
	//	locale:
	//		the variant to load (optional).  By default, the locale defined by
	//		the host environment: dojo.locale

	locale = dojo.i18n.normalizeLocale(locale);

	// look for nearest locale match
	var elements = locale.split('-');
	var module = [packageName,"nls",bundleName].join('.');
		var bundle = dojo._loadedModules[module];
	if(bundle){
		var localization;
		for(var i = elements.length; i > 0; i--){
			var loc = elements.slice(0, i).join('_');
			if(bundle[loc]){
				localization = bundle[loc];
				break;
			}
		}
		if(!localization){
			localization = bundle.ROOT;
		}

		// make a singleton prototype so that the caller won't accidentally change the values globally
		if(localization){
			var clazz = function(){};
			clazz.prototype = localization;
			return new clazz(); // Object
		}
	}

	throw new Error("Bundle not found: " + bundleName + " in " + packageName+" , locale=" + locale);
};

dojo.i18n.normalizeLocale = function(/*String?*/locale){
	//	summary:
	//		Returns canonical form of locale, as used by Dojo.
	//
	//  description:
	//		All variants are case-insensitive and are separated by '-' as specified in [RFC 3066](http://www.ietf.org/rfc/rfc3066.txt).
	//		If no locale is specified, the dojo.locale is returned.  dojo.locale is defined by
	//		the user agent's locale unless overridden by djConfig.

	var result = locale ? locale.toLowerCase() : dojo.locale;
	if(result == "root"){
		result = "ROOT";
	}
	return result; // String
};

dojo.i18n._requireLocalization = function(/*String*/moduleName, /*String*/bundleName, /*String?*/locale, /*String?*/availableFlatLocales){
	//	summary:
	//		See dojo.requireLocalization()
	//	description:
	// 		Called by the bootstrap, but factored out so that it is only
	// 		included in the build when needed.

	var targetLocale = dojo.i18n.normalizeLocale(locale);
 	var bundlePackage = [moduleName, "nls", bundleName].join(".");
	// NOTE:
	//		When loading these resources, the packaging does not match what is
	//		on disk.  This is an implementation detail, as this is just a
	//		private data structure to hold the loaded resources.  e.g.
	//		`tests/hello/nls/en-us/salutations.js` is loaded as the object
	//		`tests.hello.nls.salutations.en_us={...}` The structure on disk is
	//		intended to be most convenient for developers and translators, but
	//		in memory it is more logical and efficient to store in a different
	//		order.  Locales cannot use dashes, since the resulting path will
	//		not evaluate as valid JS, so we translate them to underscores.

	//Find the best-match locale to load if we have available flat locales.
	var bestLocale = "";
	if(availableFlatLocales){
		var flatLocales = availableFlatLocales.split(",");
		for(var i = 0; i < flatLocales.length; i++){
			//Locale must match from start of string.
			//Using ["indexOf"] so customBase builds do not see
			//this as a dojo._base.array dependency.
			if(targetLocale["indexOf"](flatLocales[i]) == 0){
				if(flatLocales[i].length > bestLocale.length){
					bestLocale = flatLocales[i];
				}
			}
		}
		if(!bestLocale){
			bestLocale = "ROOT";
		}
	}

	//See if the desired locale is already loaded.
	var tempLocale = availableFlatLocales ? bestLocale : targetLocale;
	var bundle = dojo._loadedModules[bundlePackage];
	var localizedBundle = null;
	if(bundle){
		if(dojo.config.localizationComplete && bundle._built){return;}
		var jsLoc = tempLocale.replace(/-/g, '_');
		var translationPackage = bundlePackage+"."+jsLoc;
		localizedBundle = dojo._loadedModules[translationPackage];
	}

	if(!localizedBundle){
		bundle = dojo["provide"](bundlePackage);
		var syms = dojo._getModuleSymbols(moduleName);
		var modpath = syms.concat("nls").join("/");
		var parent;

		dojo.i18n._searchLocalePath(tempLocale, availableFlatLocales, function(loc){
			var jsLoc = loc.replace(/-/g, '_');
			var translationPackage = bundlePackage + "." + jsLoc;
			var loaded = false;
			if(!dojo._loadedModules[translationPackage]){
				// Mark loaded whether it's found or not, so that further load attempts will not be made
				dojo["provide"](translationPackage);
				var module = [modpath];
				if(loc != "ROOT"){module.push(loc);}
				module.push(bundleName);
				var filespec = module.join("/") + '.js';
				loaded = dojo._loadPath(filespec, null, function(hash){
					hash = hash.root || hash;
					// Use singleton with prototype to point to parent bundle, then mix-in result from loadPath
					var clazz = function(){};
					clazz.prototype = parent;
					bundle[jsLoc] = new clazz();
					for(var j in hash){ bundle[jsLoc][j] = hash[j]; }
				});
			}else{
				loaded = true;
			}
			if(loaded && bundle[jsLoc]){
				parent = bundle[jsLoc];
			}else{
				bundle[jsLoc] = parent;
			}

			if(availableFlatLocales){
				//Stop the locale path searching if we know the availableFlatLocales, since
				//the first call to this function will load the only bundle that is needed.
				return true;
			}
		});
	}

	//Save the best locale bundle as the target locale bundle when we know the
	//the available bundles.
	if(availableFlatLocales && targetLocale != bestLocale){
		bundle[targetLocale.replace(/-/g, '_')] = bundle[bestLocale.replace(/-/g, '_')];
	}
};

(function(){
	// If other locales are used, dojo.requireLocalization should load them as
	// well, by default.
	//
	// Override dojo.requireLocalization to do load the default bundle, then
	// iterate through the extraLocale list and load those translations as
	// well, unless a particular locale was requested.

	var extra = dojo.config.extraLocale;
	if(extra){
		if(!extra instanceof Array){
			extra = [extra];
		}

		var req = dojo.i18n._requireLocalization;
		dojo.i18n._requireLocalization = function(m, b, locale, availableFlatLocales){
			req(m,b,locale, availableFlatLocales);
			if(locale){return;}
			for(var i=0; i<extra.length; i++){
				req(m,b,extra[i], availableFlatLocales);
			}
		};
	}
})();

dojo.i18n._searchLocalePath = function(/*String*/locale, /*Boolean*/down, /*Function*/searchFunc){
	//	summary:
	//		A helper method to assist in searching for locale-based resources.
	//		Will iterate through the variants of a particular locale, either up
	//		or down, executing a callback function.  For example, "en-us" and
	//		true will try "en-us" followed by "en" and finally "ROOT".

	locale = dojo.i18n.normalizeLocale(locale);

	var elements = locale.split('-');
	var searchlist = [];
	for(var i = elements.length; i > 0; i--){
		searchlist.push(elements.slice(0, i).join('-'));
	}
	searchlist.push(false);
	if(down){searchlist.reverse();}

	for(var j = searchlist.length - 1; j >= 0; j--){
		var loc = searchlist[j] || "ROOT";
		var stop = searchFunc(loc);
		if(stop){ break; }
	}
};

dojo.i18n._preloadLocalizations = function(/*String*/bundlePrefix, /*Array*/localesGenerated){
	//	summary:
	//		Load built, flattened resource bundles, if available for all
	//		locales used in the page. Only called by built layer files.

	function preload(locale){
		locale = dojo.i18n.normalizeLocale(locale);
		dojo.i18n._searchLocalePath(locale, true, function(loc){
			for(var i=0; i<localesGenerated.length;i++){
				if(localesGenerated[i] == loc){
					dojo["require"](bundlePrefix+"_"+loc);
					return true; // Boolean
				}
			}
			return false; // Boolean
		});
	}
	preload();
	var extra = dojo.config.extraLocale||[];
	for(var i=0; i<extra.length; i++){
		preload(extra[i]);
	}
};

}

if(!dojo._hasResource["dijit.layout.ContentPane"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.layout.ContentPane"] = true;
dojo.provide("dijit.layout.ContentPane");







dojo.declare(
	"dijit.layout.ContentPane", [dijit._Widget, dijit.layout._ContentPaneResizeMixin],
{
	// summary:
	//		A widget containing an HTML fragment, specified inline
	//		or by uri.  Fragment may include widgets.
	//
	// description:
	//		This widget embeds a document fragment in the page, specified
	//		either by uri, javascript generated markup or DOM reference.
	//		Any widgets within this content are instantiated and managed,
	//		but laid out according to the HTML structure.  Unlike IFRAME,
	//		ContentPane embeds a document fragment as would be found
	//		inside the BODY tag of a full HTML document.  It should not
	//		contain the HTML, HEAD, or BODY tags.
	//		For more advanced functionality with scripts and
	//		stylesheets, see dojox.layout.ContentPane.  This widget may be
	//		used stand alone or as a base class for other widgets.
	//		ContentPane is useful as a child of other layout containers
	//		such as BorderContainer or TabContainer, but note that those
	//		widgets can contain any widget as a child.
	//
	// example:
	//		Some quick samples:
	//		To change the innerHTML: cp.set('content', '<b>new content</b>')
	//
	//		Or you can send it a NodeList: cp.set('content', dojo.query('div [class=selected]', userSelection))
	//
	//		To do an ajax update: cp.set('href', url)

	// href: String
	//		The href of the content that displays now.
	//		Set this at construction if you want to load data externally when the
	//		pane is shown.  (Set preload=true to load it immediately.)
	//		Changing href after creation doesn't have any effect; Use set('href', ...);
	href: "",

/*=====
	// content: String || DomNode || NodeList || dijit._Widget
	//		The innerHTML of the ContentPane.
	//		Note that the initialization parameter / argument to set("content", ...)
	//		can be a String, DomNode, Nodelist, or _Widget.
	content: "",
=====*/

	// extractContent: Boolean
	//		Extract visible content from inside of <body> .... </body>.
	//		I.e., strip <html> and <head> (and it's contents) from the href
	extractContent: false,

	// parseOnLoad: Boolean
	//		Parse content and create the widgets, if any.
	parseOnLoad: true,

	// parserScope: String
	//		Flag passed to parser.  Root for attribute names to search for.   If scopeName is dojo,
	//		will search for data-dojo-type (or dojoType).  For backwards compatibility
	//		reasons defaults to dojo._scopeName (which is "dojo" except when
	//		multi-version support is used, when it will be something like dojo16, dojo20, etc.)
	parserScope: dojo._scopeName,

	// preventCache: Boolean
	//		Prevent caching of data from href's by appending a timestamp to the href.
	preventCache: false,

	// preload: Boolean
	//		Force load of data on initialization even if pane is hidden.
	preload: false,

	// refreshOnShow: Boolean
	//		Refresh (re-download) content when pane goes from hidden to shown
	refreshOnShow: false,

	// loadingMessage: String
	//		Message that shows while downloading
	loadingMessage: "<span class='dijitContentPaneLoading'>${loadingState}</span>",

	// errorMessage: String
	//		Message that shows if an error occurs
	errorMessage: "<span class='dijitContentPaneError'>${errorState}</span>",

	// isLoaded: [readonly] Boolean
	//		True if the ContentPane has data in it, either specified
	//		during initialization (via href or inline content), or set
	//		via set('content', ...) / set('href', ...)
	//
	//		False if it doesn't have any content, or if ContentPane is
	//		still in the process of downloading href.
	isLoaded: false,

	baseClass: "dijitContentPane",

	// ioArgs: Object
	//		Parameters to pass to xhrGet() request, for example:
	// |	<div dojoType="dijit.layout.ContentPane" href="./bar" ioArgs="{timeout: 500}">
	ioArgs: {},

	// onLoadDeferred: [readonly] dojo.Deferred
	//		This is the `dojo.Deferred` returned by set('href', ...) and refresh().
	//		Calling onLoadDeferred.addCallback() or addErrback() registers your
	//		callback to be called only once, when the prior set('href', ...) call or
	//		the initial href parameter to the constructor finishes loading.
	//
	//		This is different than an onLoad() handler which gets called any time any href
	//		or content is loaded.
	onLoadDeferred: null,

	// Override _Widget's attributeMap because we don't want the title attribute (used to specify
	// tab labels) to be copied to ContentPane.domNode... otherwise a tooltip shows up over the
	// entire pane.
	attributeMap: dojo.delegate(dijit._Widget.prototype.attributeMap, {
		title: []
	}),

	// Flag to parser that I'll parse my contents, so it shouldn't.
	stopParser: true,

	// template: [private] Boolean
	//		Flag from the parser that this ContentPane is inside a template
	//		so the contents are pre-parsed.
	// (TODO: this declaration can be commented out in 2.0)
	template: false,

	create: function(params, srcNodeRef){
		// Convert a srcNodeRef argument into a content parameter, so that the original contents are
		// processed in the same way as contents set via set("content", ...), calling the parser etc.
		// Avoid modifying original params object since that breaks NodeList instantiation, see #11906.
		if((!params || !params.template) && srcNodeRef && !("href" in params) && !("content" in params)){
			var df = dojo.doc.createDocumentFragment();
			srcNodeRef = dojo.byId(srcNodeRef)
			while(srcNodeRef.firstChild){
				df.appendChild(srcNodeRef.firstChild);
			}
			params = dojo.delegate(params, {content: df});
		}
		this.inherited(arguments, [params, srcNodeRef]);
	},

	postMixInProperties: function(){
		this.inherited(arguments);
		var messages = dojo.i18n.getLocalization("dijit", "loading", this.lang);
		this.loadingMessage = dojo.string.substitute(this.loadingMessage, messages);
		this.errorMessage = dojo.string.substitute(this.errorMessage, messages);
	},

	buildRendering: function(){
		this.inherited(arguments);

		// Since we have no template we need to set this.containerNode ourselves, to make getChildren() work.
		// For subclasses of ContentPane that do have a template, does nothing.
		if(!this.containerNode){
			this.containerNode = this.domNode;
		}

		// remove the title attribute so it doesn't show up when hovering
		// over a node  (TODO: remove in 2.0, no longer needed after #11490)
		this.domNode.title = "";

		if(!dojo.attr(this.domNode,"role")){
			dijit.setWaiRole(this.domNode, "group");
		}
	},

	_startChildren: function(){
		// summary:
		//		Call startup() on all children including non _Widget ones like dojo.dnd.Source objects

		// This starts all the widgets
		this.inherited(arguments);

		// And this catches stuff like dojo.dnd.Source
		if(this._contentSetter){
			dojo.forEach(this._contentSetter.parseResults, function(obj){
				if(!obj._started && !obj._destroyed && dojo.isFunction(obj.startup)){
					obj.startup();
					obj._started = true;
				}
			}, this);
		}
	},

	setHref: function(/*String|Uri*/ href){
		// summary:
		//		Deprecated.   Use set('href', ...) instead.
		dojo.deprecated("dijit.layout.ContentPane.setHref() is deprecated. Use set('href', ...) instead.", "", "2.0");
		return this.set("href", href);
	},
	_setHrefAttr: function(/*String|Uri*/ href){
		// summary:
		//		Hook so set("href", ...) works.
		// description:
		//		Reset the (external defined) content of this pane and replace with new url
		//		Note: It delays the download until widget is shown if preload is false.
		//	href:
		//		url to the page you want to get, must be within the same domain as your mainpage

		// Cancel any in-flight requests (a set('href', ...) will cancel any in-flight set('href', ...))
		this.cancel();

		this.onLoadDeferred = new dojo.Deferred(dojo.hitch(this, "cancel"));
		this.onLoadDeferred.addCallback(dojo.hitch(this, "onLoad"));

		this._set("href", href);

		// _setHrefAttr() is called during creation and by the user, after creation.
		// Assuming preload == false, only in the second case do we actually load the URL;
		// otherwise it's done in startup(), and only if this widget is shown.
		if(this.preload || (this._created && this._isShown())){
			this._load();
		}else{
			// Set flag to indicate that href needs to be loaded the next time the
			// ContentPane is made visible
			this._hrefChanged = true;
		}

		return this.onLoadDeferred;		// dojo.Deferred
	},

	setContent: function(/*String|DomNode|Nodelist*/data){
		// summary:
		//		Deprecated.   Use set('content', ...) instead.
		dojo.deprecated("dijit.layout.ContentPane.setContent() is deprecated.  Use set('content', ...) instead.", "", "2.0");
		this.set("content", data);
	},
	_setContentAttr: function(/*String|DomNode|Nodelist*/data){
		// summary:
		//		Hook to make set("content", ...) work.
		//		Replaces old content with data content, include style classes from old content
		//	data:
		//		the new Content may be String, DomNode or NodeList
		//
		//		if data is a NodeList (or an array of nodes) nodes are copied
		//		so you can import nodes from another document implicitly

		// clear href so we can't run refresh and clear content
		// refresh should only work if we downloaded the content
		this._set("href", "");

		// Cancel any in-flight requests (a set('content', ...) will cancel any in-flight set('href', ...))
		this.cancel();

		// Even though user is just setting content directly, still need to define an onLoadDeferred
		// because the _onLoadHandler() handler is still getting called from setContent()
		this.onLoadDeferred = new dojo.Deferred(dojo.hitch(this, "cancel"));
		if(this._created){
			// For back-compat reasons, call onLoad() for set('content', ...)
			// calls but not for content specified in srcNodeRef (ie: <div dojoType=ContentPane>...</div>)
			// or as initialization parameter (ie: new ContentPane({content: ...})
			this.onLoadDeferred.addCallback(dojo.hitch(this, "onLoad"));
		}

		this._setContent(data || "");

		this._isDownloaded = false; // mark that content is from a set('content') not a set('href')

		return this.onLoadDeferred; 	// dojo.Deferred
	},
	_getContentAttr: function(){
		// summary:
		//		Hook to make get("content") work
		return this.containerNode.innerHTML;
	},

	cancel: function(){
		// summary:
		//		Cancels an in-flight download of content
		if(this._xhrDfd && (this._xhrDfd.fired == -1)){
			this._xhrDfd.cancel();
		}
		delete this._xhrDfd; // garbage collect

		this.onLoadDeferred = null;
	},

	uninitialize: function(){
		if(this._beingDestroyed){
			this.cancel();
		}
		this.inherited(arguments);
	},

	destroyRecursive: function(/*Boolean*/ preserveDom){
		// summary:
		//		Destroy the ContentPane and its contents

		// if we have multiple controllers destroying us, bail after the first
		if(this._beingDestroyed){
			return;
		}
		this.inherited(arguments);
	},

	_onShow: function(){
		// summary:
		//		Called when the ContentPane is made visible
		// description:
		//		For a plain ContentPane, this is called on initialization, from startup().
		//		If the ContentPane is a hidden pane of a TabContainer etc., then it's
		//		called whenever the pane is made visible.
		//
		//		Does necessary processing, including href download and layout/resize of
		//		child widget(s)

		this.inherited(arguments);

		if(this.href){
			if(!this._xhrDfd && // if there's an href that isn't already being loaded
				(!this.isLoaded || this._hrefChanged || this.refreshOnShow)
			){
				return this.refresh();	// If child has an href, promise that fires when the load is complete
			}
		}
	},

	refresh: function(){
		// summary:
		//		[Re]download contents of href and display
		// description:
		//		1. cancels any currently in-flight requests
		//		2. posts "loading..." message
		//		3. sends XHR to download new data

		// Cancel possible prior in-flight request
		this.cancel();

		this.onLoadDeferred = new dojo.Deferred(dojo.hitch(this, "cancel"));
		this.onLoadDeferred.addCallback(dojo.hitch(this, "onLoad"));
		this._load();
		return this.onLoadDeferred;		// If child has an href, promise that fires when refresh is complete
	},

	_load: function(){
		// summary:
		//		Load/reload the href specified in this.href

		// display loading message
		this._setContent(this.onDownloadStart(), true);

		var self = this;
		var getArgs = {
			preventCache: (this.preventCache || this.refreshOnShow),
			url: this.href,
			handleAs: "text"
		};
		if(dojo.isObject(this.ioArgs)){
			dojo.mixin(getArgs, this.ioArgs);
		}

		var hand = (this._xhrDfd = (this.ioMethod || dojo.xhrGet)(getArgs));

		hand.addCallback(function(html){
			try{
				self._isDownloaded = true;
				self._setContent(html, false);
				self.onDownloadEnd();
			}catch(err){
				self._onError('Content', err); // onContentError
			}
			delete self._xhrDfd;
			return html;
		});

		hand.addErrback(function(err){
			if(!hand.canceled){
				// show error message in the pane
				self._onError('Download', err); // onDownloadError
			}
			delete self._xhrDfd;
			return err;
		});

		// Remove flag saying that a load is needed
		delete this._hrefChanged;
	},

	_onLoadHandler: function(data){
		// summary:
		//		This is called whenever new content is being loaded
		this._set("isLoaded", true);
		try{
			this.onLoadDeferred.callback(data);
		}catch(e){
			console.error('Error '+this.widgetId+' running custom onLoad code: ' + e.message);
		}
	},

	_onUnloadHandler: function(){
		// summary:
		//		This is called whenever the content is being unloaded
		this._set("isLoaded", false);
		try{
			this.onUnload();
		}catch(e){
			console.error('Error '+this.widgetId+' running custom onUnload code: ' + e.message);
		}
	},

	destroyDescendants: function(){
		// summary:
		//		Destroy all the widgets inside the ContentPane and empty containerNode

		// Make sure we call onUnload (but only when the ContentPane has real content)
		if(this.isLoaded){
			this._onUnloadHandler();
		}

		// Even if this.isLoaded == false there might still be a "Loading..." message
		// to erase, so continue...

		// For historical reasons we need to delete all widgets under this.containerNode,
		// even ones that the user has created manually.
		var setter = this._contentSetter;
		dojo.forEach(this.getChildren(), function(widget){
			if(widget.destroyRecursive){
				widget.destroyRecursive();
			}
		});
		if(setter){
			// Most of the widgets in setter.parseResults have already been destroyed, but
			// things like Menu that have been moved to <body> haven't yet
			dojo.forEach(setter.parseResults, function(widget){
				if(widget.destroyRecursive && widget.domNode && widget.domNode.parentNode == dojo.body()){
					widget.destroyRecursive();
				}
			});
			delete setter.parseResults;
		}

		// And then clear away all the DOM nodes
		dojo.html._emptyNode(this.containerNode);

		// Delete any state information we have about current contents
		delete this._singleChild;
	},

	_setContent: function(/*String|DocumentFragment*/ cont, /*Boolean*/ isFakeContent){
		// summary:
		//		Insert the content into the container node

		// first get rid of child widgets
		this.destroyDescendants();

		// dojo.html.set will take care of the rest of the details
		// we provide an override for the error handling to ensure the widget gets the errors
		// configure the setter instance with only the relevant widget instance properties
		// NOTE: unless we hook into attr, or provide property setters for each property,
		// we need to re-configure the ContentSetter with each use
		var setter = this._contentSetter;
		if(! (setter && setter instanceof dojo.html._ContentSetter)){
			setter = this._contentSetter = new dojo.html._ContentSetter({
				node: this.containerNode,
				_onError: dojo.hitch(this, this._onError),
				onContentError: dojo.hitch(this, function(e){
					// fires if a domfault occurs when we are appending this.errorMessage
					// like for instance if domNode is a UL and we try append a DIV
					var errMess = this.onContentError(e);
					try{
						this.containerNode.innerHTML = errMess;
					}catch(e){
						console.error('Fatal '+this.id+' could not change content due to '+e.message, e);
					}
				})/*,
				_onError */
			});
		};

		var setterParams = dojo.mixin({
			cleanContent: this.cleanContent,
			extractContent: this.extractContent,
			parseContent: this.parseOnLoad,
			parserScope: this.parserScope,
			startup: false,
			dir: this.dir,
			lang: this.lang
		}, this._contentSetterParams || {});

		setter.set( (dojo.isObject(cont) && cont.domNode) ? cont.domNode : cont, setterParams );

		// setter params must be pulled afresh from the ContentPane each time
		delete this._contentSetterParams;

		if(this.doLayout){
			this._checkIfSingleChild();
		}

		if(!isFakeContent){
			if(this._started){
				// Startup each top level child widget (and they will start their children, recursively)
				this._startChildren();
	
				// Call resize() on each of my child layout widgets,
				// or resize() on my single child layout widget...
				// either now (if I'm currently visible) or when I become visible
				this._scheduleLayout();
			}

			this._onLoadHandler(cont);
		}
	},

	_onError: function(type, err, consoleText){
		this.onLoadDeferred.errback(err);

		// shows user the string that is returned by on[type]Error
		// override on[type]Error and return your own string to customize
		var errText = this['on' + type + 'Error'].call(this, err);
		if(consoleText){
			console.error(consoleText, err);
		}else if(errText){// a empty string won't change current content
			this._setContent(errText, true);
		}
	},

	// EVENT's, should be overide-able
	onLoad: function(data){
		// summary:
		//		Event hook, is called after everything is loaded and widgetified
		// tags:
		//		callback

		console.log("dijit.layout.ContentPane.onLoad    caller: " + this.onLoad.caller.nom);
		
	},

	onUnload: function(){
		// summary:
		//		Event hook, is called before old content is cleared
		// tags:
		//		callback
	},

	onDownloadStart: function(){
		// summary:
		//		Called before download starts.
		// description:
		//		The string returned by this function will be the html
		//		that tells the user we are loading something.
		//		Override with your own function if you want to change text.
		// tags:
		//		extension
		return this.loadingMessage;
	},

	onContentError: function(/*Error*/ error){
		// summary:
		//		Called on DOM faults, require faults etc. in content.
		//
		//		In order to display an error message in the pane, return
		//		the error message from this method, as an HTML string.
		//
		//		By default (if this method is not overriden), it returns
		//		nothing, so the error message is just printed to the console.
		// tags:
		//		extension
	},

	onDownloadError: function(/*Error*/ error){
		// summary:
		//		Called when download error occurs.
		//
		//		In order to display an error message in the pane, return
		//		the error message from this method, as an HTML string.
		//
		//		Default behavior (if this method is not overriden) is to display
		//		the error message inside the pane.
		// tags:
		//		extension
		return this.errorMessage;
	},

	onDownloadEnd: function(){
		// summary:
		//		Called when download is finished.
		// tags:
		//		callback
	}
});

}

if(!dojo._hasResource["dojo.cache"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.cache"] = true;
dojo.provide("dojo.cache");


/*=====
dojo.cache = {
	// summary:
	// 		A way to cache string content that is fetchable via `dojo.moduleUrl`.
};
=====*/

	var cache = {};
	dojo.cache = function(/*String||Object*/module, /*String*/url, /*String||Object?*/value){
		// summary:
		// 		A getter and setter for storing the string content associated with the
		// 		module and url arguments.
		// description:
		// 		module and url are used to call `dojo.moduleUrl()` to generate a module URL.
		// 		If value is specified, the cache value for the moduleUrl will be set to
		// 		that value. Otherwise, dojo.cache will fetch the moduleUrl and store it
		// 		in its internal cache and return that cached value for the URL. To clear
		// 		a cache value pass null for value. Since XMLHttpRequest (XHR) is used to fetch the
		// 		the URL contents, only modules on the same domain of the page can use this capability.
		// 		The build system can inline the cache values though, to allow for xdomain hosting.
		// module: String||Object
		// 		If a String, the module name to use for the base part of the URL, similar to module argument
		// 		to `dojo.moduleUrl`. If an Object, something that has a .toString() method that
		// 		generates a valid path for the cache item. For example, a dojo._Url object.
		// url: String
		// 		The rest of the path to append to the path derived from the module argument. If
		// 		module is an object, then this second argument should be the "value" argument instead.
		// value: String||Object?
		// 		If a String, the value to use in the cache for the module/url combination.
		// 		If an Object, it can have two properties: value and sanitize. The value property
		// 		should be the value to use in the cache, and sanitize can be set to true or false,
		// 		to indicate if XML declarations should be removed from the value and if the HTML
		// 		inside a body tag in the value should be extracted as the real value. The value argument
		// 		or the value property on the value argument are usually only used by the build system
		// 		as it inlines cache content.
		//	example:
		//		To ask dojo.cache to fetch content and store it in the cache (the dojo["cache"] style
		// 		of call is used to avoid an issue with the build system erroneously trying to intern
		// 		this example. To get the build system to intern your dojo.cache calls, use the
		// 		"dojo.cache" style of call):
		// 		|	//If template.html contains "<h1>Hello</h1>" that will be
		// 		|	//the value for the text variable.
		//		|	var text = dojo["cache"]("my.module", "template.html");
		//	example:
		//		To ask dojo.cache to fetch content and store it in the cache, and sanitize the input
		// 		 (the dojo["cache"] style of call is used to avoid an issue with the build system
		// 		erroneously trying to intern this example. To get the build system to intern your
		// 		dojo.cache calls, use the "dojo.cache" style of call):
		// 		|	//If template.html contains "<html><body><h1>Hello</h1></body></html>", the
		// 		|	//text variable will contain just "<h1>Hello</h1>".
		//		|	var text = dojo["cache"]("my.module", "template.html", {sanitize: true});
		//	example:
		//		Same example as previous, but demostrates how an object can be passed in as
		//		the first argument, then the value argument can then be the second argument.
		// 		|	//If template.html contains "<html><body><h1>Hello</h1></body></html>", the
		// 		|	//text variable will contain just "<h1>Hello</h1>".
		//		|	var text = dojo["cache"](new dojo._Url("my/module/template.html"), {sanitize: true});

		//Module could be a string, or an object that has a toString() method
		//that will return a useful path. If it is an object, then the "url" argument
		//will actually be the value argument.
		if(typeof module == "string"){
			var pathObj = dojo.moduleUrl(module, url);
		}else{
			pathObj = module;
			value = url;
		}
		var key = pathObj.toString();

		var val = value;
		if(value != undefined && !dojo.isString(value)){
			val = ("value" in value ? value.value : undefined);
		}

		var sanitize = value && value.sanitize ? true : false;

		if(typeof val == "string"){
			//We have a string, set cache value
			val = cache[key] = sanitize ? dojo.cache._sanitize(val) : val;
		}else if(val === null){
			//Remove cached value
			delete cache[key];
		}else{
			//Allow cache values to be empty strings. If key property does
			//not exist, fetch it.
			if(!(key in cache)){
				val = dojo._getText(key);
				cache[key] = sanitize ? dojo.cache._sanitize(val) : val;
			}
			val = cache[key];
		}
		return val; //String
	};

	dojo.cache._sanitize = function(/*String*/val){
		// summary:
		//		Strips <?xml ...?> declarations so that external SVG and XML
		// 		documents can be added to a document without worry. Also, if the string
		//		is an HTML document, only the part inside the body tag is returned.
		// description:
		// 		Copied from dijit._Templated._sanitizeTemplateString.
		if(val){
			val = val.replace(/^\s*<\?xml(\s)+version=[\'\"](\d)*.(\d)*[\'\"](\s)*\?>/im, "");
			var matches = val.match(/<body[^>]*>\s*([\s\S]+)\s*<\/body>/im);
			if(matches){
				val = matches[1];
			}
		}else{
			val = "";
		}
		return val; //String
	};

}

if(!dojo._hasResource["dijit._Templated"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._Templated"] = true;
dojo.provide("dijit._Templated");






dojo.declare("dijit._Templated",
	null,
	{
		// summary:
		//		Mixin for widgets that are instantiated from a template

		// templateString: [protected] String
		//		A string that represents the widget template. Pre-empts the
		//		templatePath. In builds that have their strings "interned", the
		//		templatePath is converted to an inline templateString, thereby
		//		preventing a synchronous network call.
		//
		//		Use in conjunction with dojo.cache() to load from a file.
		templateString: null,

		// templatePath: [protected deprecated] String
		//		Path to template (HTML file) for this widget relative to dojo.baseUrl.
		//		Deprecated: use templateString with dojo.cache() instead.
		templatePath: null,

		// widgetsInTemplate: [protected] Boolean
		//		Should we parse the template to find widgets that might be
		//		declared in markup inside it?  False by default.
		widgetsInTemplate: false,

		// skipNodeCache: [protected] Boolean
		//		If using a cached widget template node poses issues for a
		//		particular widget class, it can set this property to ensure
		//		that its template is always re-built from a string
		_skipNodeCache: false,

		// _earlyTemplatedStartup: Boolean
		//		A fallback to preserve the 1.0 - 1.3 behavior of children in
		//		templates having their startup called before the parent widget
		//		fires postCreate. Defaults to 'false', causing child widgets to
		//		have their .startup() called immediately before a parent widget
		//		.startup(), but always after the parent .postCreate(). Set to
		//		'true' to re-enable to previous, arguably broken, behavior.
		_earlyTemplatedStartup: false,

/*=====
		// _attachPoints: [private] String[]
		//		List of widget attribute names associated with dojoAttachPoint=... in the
		//		template, ex: ["containerNode", "labelNode"]
 		_attachPoints: [],
 =====*/

/*=====
		// _attachEvents: [private] Handle[]
		//		List of connections associated with dojoAttachEvent=... in the
		//		template
 		_attachEvents: [],
 =====*/

		constructor: function(){
			this._attachPoints = [];
			this._attachEvents = [];
		},

		_stringRepl: function(tmpl){
			// summary:
			//		Does substitution of ${foo} type properties in template string
			// tags:
			//		private
			var className = this.declaredClass, _this = this;
			// Cache contains a string because we need to do property replacement
			// do the property replacement
			return dojo.string.substitute(tmpl, this, function(value, key){
				if(key.charAt(0) == '!'){ value = dojo.getObject(key.substr(1), false, _this); }
				if(typeof value == "undefined"){ throw new Error(className+" template:"+key); } // a debugging aide
				if(value == null){ return ""; }

				// Substitution keys beginning with ! will skip the transform step,
				// in case a user wishes to insert unescaped markup, e.g. ${!foo}
				return key.charAt(0) == "!" ? value :
					// Safer substitution, see heading "Attribute values" in
					// http://www.w3.org/TR/REC-html40/appendix/notes.html#h-B.3.2
					value.toString().replace(/"/g,"&quot;"); //TODO: add &amp? use encodeXML method?
			}, this);
		},

		buildRendering: function(){
			// summary:
			//		Construct the UI for this widget from a template, setting this.domNode.
			// tags:
			//		protected

			// Lookup cached version of template, and download to cache if it
			// isn't there already.  Returns either a DomNode or a string, depending on
			// whether or not the template contains ${foo} replacement parameters.
			var cached = dijit._Templated.getCachedTemplate(this.templatePath, this.templateString, this._skipNodeCache);

			var node;
			if(dojo.isString(cached)){
				node = dojo._toDom(this._stringRepl(cached));
				if(node.nodeType != 1){
					// Flag common problems such as templates with multiple top level nodes (nodeType == 11)
					throw new Error("Invalid template: " + cached);
				}
			}else{
				// if it's a node, all we have to do is clone it
				node = cached.cloneNode(true);
			}

			this.domNode = node;

			// Call down to _Widget.buildRendering() to get base classes assigned
			// TODO: change the baseClass assignment to attributeMap
			this.inherited(arguments);

			// recurse through the node, looking for, and attaching to, our
			// attachment points and events, which should be defined on the template node.
			this._attachTemplateNodes(node);

			if(this.widgetsInTemplate){
				// Store widgets that we need to start at a later point in time
				var cw = (this._startupWidgets = dojo.parser.parse(node, {
					noStart: !this._earlyTemplatedStartup,
					template: true,
					inherited: {dir: this.dir, lang: this.lang},
					propsThis: this,	// so data-dojo-props of widgets in the template can reference "this" to refer to me
					scope: "dojo"	// even in multi-version mode templates use dojoType/data-dojo-type
				}));

				this._supportingWidgets = dijit.findWidgets(node);

				this._attachTemplateNodes(cw, function(n,p){
					return n[p];
				});
			}

			this._fillContent(this.srcNodeRef);
		},

		_fillContent: function(/*DomNode*/ source){
			// summary:
			//		Relocate source contents to templated container node.
			//		this.containerNode must be able to receive children, or exceptions will be thrown.
			// tags:
			//		protected
			var dest = this.containerNode;
			if(source && dest){
				while(source.hasChildNodes()){
					dest.appendChild(source.firstChild);
				}
			}
		},

		_attachTemplateNodes: function(rootNode, getAttrFunc){
			// summary:
			//		Iterate through the template and attach functions and nodes accordingly.
			//		Alternately, if rootNode is an array of widgets, then will process dojoAttachPoint
			//		etc. for those widgets.
			// description:
			//		Map widget properties and functions to the handlers specified in
			//		the dom node and it's descendants. This function iterates over all
			//		nodes and looks for these properties:
			//			* dojoAttachPoint
			//			* dojoAttachEvent
			//			* waiRole
			//			* waiState
			// rootNode: DomNode|Array[Widgets]
			//		the node to search for properties. All children will be searched.
			// getAttrFunc: Function?
			//		a function which will be used to obtain property for a given
			//		DomNode/Widget
			// tags:
			//		private

			getAttrFunc = getAttrFunc || function(n,p){ return n.getAttribute(p); };

			var nodes = dojo.isArray(rootNode) ? rootNode : (rootNode.all || rootNode.getElementsByTagName("*"));
			var x = dojo.isArray(rootNode) ? 0 : -1;
			for(; x<nodes.length; x++){
				var baseNode = (x == -1) ? rootNode : nodes[x];
				if(this.widgetsInTemplate && (getAttrFunc(baseNode, "dojoType") || getAttrFunc(baseNode, "data-dojo-type"))){
					continue;
				}
				// Process dojoAttachPoint
				var attachPoint = getAttrFunc(baseNode, "dojoAttachPoint") || getAttrFunc(baseNode, "data-dojo-attach-point");
				if(attachPoint){
					var point, points = attachPoint.split(/\s*,\s*/);
					while((point = points.shift())){
						if(dojo.isArray(this[point])){
							this[point].push(baseNode);
						}else{
							this[point]=baseNode;
						}
						this._attachPoints.push(point);
					}
				}

				// Process dojoAttachEvent
				var attachEvent = getAttrFunc(baseNode, "dojoAttachEvent") || getAttrFunc(baseNode, "data-dojo-attach-event");;
				if(attachEvent){
					// NOTE: we want to support attributes that have the form
					// "domEvent: nativeEvent; ..."
					var event, events = attachEvent.split(/\s*,\s*/);
					var trim = dojo.trim;
					while((event = events.shift())){
						if(event){
							var thisFunc = null;
							if(event.indexOf(":") != -1){
								// oh, if only JS had tuple assignment
								var funcNameArr = event.split(":");
								event = trim(funcNameArr[0]);
								thisFunc = trim(funcNameArr[1]);
							}else{
								event = trim(event);
							}
							if(!thisFunc){
								thisFunc = event;
							}
							this._attachEvents.push(this.connect(baseNode, event, thisFunc));
						}
					}
				}

				// waiRole, waiState
				// TODO: remove this in 2.0, templates are now using role=... and aria-XXX=... attributes directicly
				var role = getAttrFunc(baseNode, "waiRole");
				if(role){
					dijit.setWaiRole(baseNode, role);
				}
				var values = getAttrFunc(baseNode, "waiState");
				if(values){
					dojo.forEach(values.split(/\s*,\s*/), function(stateValue){
						if(stateValue.indexOf('-') != -1){
							var pair = stateValue.split('-');
							dijit.setWaiState(baseNode, pair[0], pair[1]);
						}
					});
				}
			}
		},

		startup: function(){
			dojo.forEach(this._startupWidgets, function(w){
				if(w && !w._started && w.startup){
					w.startup();
				}
			});
			this.inherited(arguments);
		},

		destroyRendering: function(){
			// Delete all attach points to prevent IE6 memory leaks.
			dojo.forEach(this._attachPoints, function(point){
				delete this[point];
			}, this);
			this._attachPoints = [];

			// And same for event handlers
			dojo.forEach(this._attachEvents, this.disconnect, this);
			this._attachEvents = [];
			
			this.inherited(arguments);
		}
	}
);

// key is either templatePath or templateString; object is either string or DOM tree
dijit._Templated._templateCache = {};

dijit._Templated.getCachedTemplate = function(templatePath, templateString, alwaysUseString){
	// summary:
	//		Static method to get a template based on the templatePath or
	//		templateString key
	// templatePath: String||dojo.uri.Uri
	//		The URL to get the template from.
	// templateString: String?
	//		a string to use in lieu of fetching the template from a URL. Takes precedence
	//		over templatePath
	// returns: Mixed
	//		Either string (if there are ${} variables that need to be replaced) or just
	//		a DOM tree (if the node can be cloned directly)

	// is it already cached?
	var tmplts = dijit._Templated._templateCache;
	var key = templateString || templatePath;
	var cached = tmplts[key];
	if(cached){
		try{
			// if the cached value is an innerHTML string (no ownerDocument) or a DOM tree created within the current document, then use the current cached value
			if(!cached.ownerDocument || cached.ownerDocument == dojo.doc){
				// string or node of the same document
				return cached;
			}
		}catch(e){ /* squelch */ } // IE can throw an exception if cached.ownerDocument was reloaded
		dojo.destroy(cached);
	}

	// If necessary, load template string from template path
	if(!templateString){
		templateString = dojo.cache(templatePath, {sanitize: true});
	}
	templateString = dojo.string.trim(templateString);

	if(alwaysUseString || templateString.match(/\$\{([^\}]+)\}/g)){
		// there are variables in the template so all we can do is cache the string
		return (tmplts[key] = templateString); //String
	}else{
		// there are no variables in the template so we can cache the DOM tree
		var node = dojo._toDom(templateString);
		if(node.nodeType != 1){
			throw new Error("Invalid template: " + templateString);
		}
		return (tmplts[key] = node); //Node
	}
};

if(dojo.isIE){
	dojo.addOnWindowUnload(function(){
		var cache = dijit._Templated._templateCache;
		for(var key in cache){
			var value = cache[key];
			if(typeof value == "object"){ // value is either a string or a DOM node template
				dojo.destroy(value);
			}
			delete cache[key];
		}
	});
}

// These arguments can be specified for widgets which are used in templates.
// Since any widget can be specified as sub widgets in template, mix it
// into the base widget class.  (This is a hack, but it's effective.)
dojo.extend(dijit._Widget,{
	dojoAttachEvent: "",
	dojoAttachPoint: "",
	waiRole: "",
	waiState:""
});

}

if(!dojo._hasResource["dijit._CssStateMixin"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._CssStateMixin"] = true;
dojo.provide("dijit._CssStateMixin");


dojo.declare("dijit._CssStateMixin", [], {
	// summary:
	//		Mixin for widgets to set CSS classes on the widget DOM nodes depending on hover/mouse press/focus
	//		state changes, and also higher-level state changes such becoming disabled or selected.
	//
	// description:
	//		By mixing this class into your widget, and setting the this.baseClass attribute, it will automatically
	//		maintain CSS classes on the widget root node (this.domNode) depending on hover,
	//		active, focus, etc. state.   Ex: with a baseClass of dijitButton, it will apply the classes
	//		dijitButtonHovered and dijitButtonActive, as the user moves the mouse over the widget and clicks it.
	//
	//		It also sets CSS like dijitButtonDisabled based on widget semantic state.
	//
	//		By setting the cssStateNodes attribute, a widget can also track events on subnodes (like buttons
	//		within the widget).

	// cssStateNodes: [protected] Object
	//		List of sub-nodes within the widget that need CSS classes applied on mouse hover/press and focus
	//.
	//		Each entry in the hash is a an attachpoint names (like "upArrowButton") mapped to a CSS class names
	//		(like "dijitUpArrowButton"). Example:
	//	|		{
	//	|			"upArrowButton": "dijitUpArrowButton",
	//	|			"downArrowButton": "dijitDownArrowButton"
	//	|		}
	//		The above will set the CSS class dijitUpArrowButton to the this.upArrowButton DOMNode when it
	//		is hovered, etc.
	cssStateNodes: {},

	// hovering: [readonly] Boolean
	//		True if cursor is over this widget
	hovering: false,
	
	// active: [readonly] Boolean
	//		True if mouse was pressed while over this widget, and hasn't been released yet
	active: false,

	_applyAttributes: function(){
		// This code would typically be in postCreate(), but putting in _applyAttributes() for
		// performance: so the class changes happen before DOM is inserted into the document.
		// Change back to postCreate() in 2.0.  See #11635.

		this.inherited(arguments);

		// Automatically monitor mouse events (essentially :hover and :active) on this.domNode
		dojo.forEach(["onmouseenter", "onmouseleave", "onmousedown"], function(e){
			this.connect(this.domNode, e, "_cssMouseEvent");
		}, this);
		
		// Monitoring changes to disabled, readonly, etc. state, and update CSS class of root node
		dojo.forEach(["disabled", "readOnly", "checked", "selected", "focused", "state", "hovering", "active"], function(attr){
			this.watch(attr, dojo.hitch(this, "_setStateClass"));
		}, this);

		// Events on sub nodes within the widget
		for(var ap in this.cssStateNodes){
			this._trackMouseState(this[ap], this.cssStateNodes[ap]);
		}
		// Set state initially; there's probably no hover/active/focus state but widget might be
		// disabled/readonly/checked/selected so we want to set CSS classes for those conditions.
		this._setStateClass();
	},

	_cssMouseEvent: function(/*Event*/ event){
		// summary:
		//	Sets hovering and active properties depending on mouse state,
		//	which triggers _setStateClass() to set appropriate CSS classes for this.domNode.

		if(!this.disabled){
			switch(event.type){
				case "mouseenter":
				case "mouseover":	// generated on non-IE browsers even though we connected to mouseenter
					this._set("hovering", true);
					this._set("active", this._mouseDown);
					break;

				case "mouseleave":
				case "mouseout":	// generated on non-IE browsers even though we connected to mouseleave
					this._set("hovering", false);
					this._set("active", false);
					break;

				case "mousedown" :
					this._set("active", true);
					this._mouseDown = true;
					// Set a global event to handle mouseup, so it fires properly
					// even if the cursor leaves this.domNode before the mouse up event.
					// Alternately could set active=false on mouseout.
					var mouseUpConnector = this.connect(dojo.body(), "onmouseup", function(){
						this._mouseDown = false;
						this._set("active", false);
						this.disconnect(mouseUpConnector);
					});
					break;
			}
		}
	},

	_setStateClass: function(){
		
		//console.log("dijit._CssStateMixin._setStateClass   XXXXXXXXXXxxx");
		// summary:
		//		Update the visual state of the widget by setting the css classes on this.domNode
		//		(or this.stateNode if defined) by combining this.baseClass with
		//		various suffixes that represent the current widget state(s).
		//
		// description:
		//		In the case where a widget has multiple
		//		states, it sets the class based on all possible
		//	 	combinations.  For example, an invalid form widget that is being hovered
		//		will be "dijitInput dijitInputInvalid dijitInputHover dijitInputInvalidHover".
		//
		//		The widget may have one or more of the following states, determined
		//		by this.state, this.checked, this.valid, and this.selected:
		//			- Error - ValidationTextBox sets this.state to "Error" if the current input value is invalid
		//			- Incomplete - ValidationTextBox sets this.state to "Incomplete" if the current input value is not finished yet
		//			- Checked - ex: a checkmark or a ToggleButton in a checked state, will have this.checked==true
		//			- Selected - ex: currently selected tab will have this.selected==true
		//
		//		In addition, it may have one or more of the following states,
		//		based on this.disabled and flags set in _onMouse (this.active, this.hovering) and from focus manager (this.focused):
		//			- Disabled	- if the widget is disabled
		//			- Active		- if the mouse (or space/enter key?) is being pressed down
		//			- Focused		- if the widget has focus
		//			- Hover		- if the mouse is over the widget

		// Compute new set of classes
		var newStateClasses = this.baseClass.split(" ");

		function multiply(modifier){
			newStateClasses = newStateClasses.concat(dojo.map(newStateClasses, function(c){ return c+modifier; }), "dijit"+modifier);
		}

		if(!this.isLeftToRight()){
			// For RTL mode we need to set an addition class like dijitTextBoxRtl.
			multiply("Rtl");
		}

		if(this.checked){
			multiply("Checked");
		}
		if(this.state){
			multiply(this.state);
		}
		if(this.selected){
			multiply("Selected");
		}

		if(this.disabled){
			multiply("Disabled");
		}else if(this.readOnly){
			multiply("ReadOnly");
		}else{
			if(this.active){
				multiply("Active");
			}else if(this.hovering){
				multiply("Hover");
			}
		}

		if(this._focused){
			multiply("Focused");
		}

		// Remove old state classes and add new ones.
		// For performance concerns we only write into domNode.className once.
		var tn = this.stateNode || this.domNode,
			classHash = {};	// set of all classes (state and otherwise) for node

		dojo.forEach(tn.className.split(" "), function(c){ classHash[c] = true; });

		if("_stateClasses" in this){
			dojo.forEach(this._stateClasses, function(c){ delete classHash[c]; });
		}

		dojo.forEach(newStateClasses, function(c){ classHash[c] = true; });

		var newClasses = [];
		for(var c in classHash){
			newClasses.push(c);
		}
		tn.className = newClasses.join(" ");

		this._stateClasses = newStateClasses;
	},

	_trackMouseState: function(/*DomNode*/ node, /*String*/ clazz){
		// summary:
		//		Track mouse/focus events on specified node and set CSS class on that node to indicate
		//		current state.   Usually not called directly, but via cssStateNodes attribute.
		// description:
		//		Given class=foo, will set the following CSS class on the node
		//			- fooActive: if the user is currently pressing down the mouse button while over the node
		//			- fooHover: if the user is hovering the mouse over the node, but not pressing down a button
		//			- fooFocus: if the node is focused
		//
		//		Note that it won't set any classes if the widget is disabled.
		// node: DomNode
		//		Should be a sub-node of the widget, not the top node (this.domNode), since the top node
		//		is handled specially and automatically just by mixing in this class.
		// clazz: String
		//		CSS class name (ex: dijitSliderUpArrow).

		// Current state of node (initially false)
		// NB: setting specifically to false because dojo.toggleClass() needs true boolean as third arg
		var hovering=false, active=false, focused=false;

		var self = this,
			cn = dojo.hitch(this, "connect", node);

		function setClass(){
			var disabled = ("disabled" in self && self.disabled) || ("readonly" in self && self.readonly);
			dojo.toggleClass(node, clazz+"Hover", hovering && !active && !disabled);
			dojo.toggleClass(node, clazz+"Active", active && !disabled);
			dojo.toggleClass(node, clazz+"Focused", focused && !disabled);
		}

		// Mouse
		cn("onmouseenter", function(){
			hovering = true;
			setClass();
		});
		cn("onmouseleave", function(){
			hovering = false;
			active = false;
			setClass();
		});
		cn("onmousedown", function(){
			active = true;
			setClass();
		});
		cn("onmouseup", function(){
			active = false;
			setClass();
		});

		// Focus
		cn("onfocus", function(){
			focused = true;
			setClass();
		});
		cn("onblur", function(){
			focused = false;
			setClass();
		});

		// Just in case widget is enabled/disabled while it has focus/hover/active state.
		// Maybe this is overkill.
		this.watch("disabled", setClass);
		this.watch("readOnly", setClass);
	}
});

}

if(!dojo._hasResource["dijit.form._FormWidget"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form._FormWidget"] = true;
dojo.provide("dijit.form._FormWidget");






dojo.declare("dijit.form._FormWidget", [dijit._Widget, dijit._Templated, dijit._CssStateMixin],
	{
	// summary:
	//		Base class for widgets corresponding to native HTML elements such as <checkbox> or <button>,
	//		which can be children of a <form> node or a `dijit.form.Form` widget.
	//
	// description:
	//		Represents a single HTML element.
	//		All these widgets should have these attributes just like native HTML input elements.
	//		You can set them during widget construction or afterwards, via `dijit._Widget.attr`.
	//
	//		They also share some common methods.

	// name: [const] String
	//		Name used when submitting form; same as "name" attribute or plain HTML elements
	name: "",

	// alt: String
	//		Corresponds to the native HTML <input> element's attribute.
	alt: "",

	// value: String
	//		Corresponds to the native HTML <input> element's attribute.
	value: "",

	// type: String
	//		Corresponds to the native HTML <input> element's attribute.
	type: "text",

	// tabIndex: Integer
	//		Order fields are traversed when user hits the tab key
	tabIndex: "0",

	// disabled: Boolean
	//		Should this widget respond to user input?
	//		In markup, this is specified as "disabled='disabled'", or just "disabled".
	disabled: false,

	// intermediateChanges: Boolean
	//		Fires onChange for each value change or only on demand
	intermediateChanges: false,

	// scrollOnFocus: Boolean
	//		On focus, should this widget scroll into view?
	scrollOnFocus: true,

	// These mixins assume that the focus node is an INPUT, as many but not all _FormWidgets are.
	attributeMap: dojo.delegate(dijit._Widget.prototype.attributeMap, {
		value: "focusNode",
		id: "focusNode",
		tabIndex: "focusNode",
		alt: "focusNode",
		title: "focusNode"
	}),

	postMixInProperties: function(){
		// Setup name=foo string to be referenced from the template (but only if a name has been specified)
		// Unfortunately we can't use attributeMap to set the name due to IE limitations, see #8660
		// Regarding escaping, see heading "Attribute values" in
		// http://www.w3.org/TR/REC-html40/appendix/notes.html#h-B.3.2
		this.nameAttrSetting = this.name ? ('name="' + this.name.replace(/'/g, "&quot;") + '"') : '';
		this.inherited(arguments);
	},

	postCreate: function(){
		this.inherited(arguments);
		this.connect(this.domNode, "onmousedown", "_onMouseDown");
	},

	_setDisabledAttr: function(/*Boolean*/ value){
		this._set("disabled", value);
		dojo.attr(this.focusNode, 'disabled', value);
		if(this.valueNode){
			dojo.attr(this.valueNode, 'disabled', value);
		}
		dijit.setWaiState(this.focusNode, "disabled", value);

		if(value){
			// reset these, because after the domNode is disabled, we can no longer receive
			// mouse related events, see #4200
			this._set("hovering", false);
			this._set("active", false);

			// clear tab stop(s) on this widget's focusable node(s)  (ComboBox has two focusable nodes)
			var attachPointNames = "tabIndex" in this.attributeMap ? this.attributeMap.tabIndex : "focusNode";
			dojo.forEach(dojo.isArray(attachPointNames) ? attachPointNames : [attachPointNames], function(attachPointName){
				var node = this[attachPointName];
				// complex code because tabIndex=-1 on a <div> doesn't work on FF
				if(dojo.isWebKit || dijit.hasDefaultTabStop(node)){	// see #11064 about webkit bug
					node.setAttribute('tabIndex', "-1");
				}else{
					node.removeAttribute('tabIndex');
				}
			}, this);
		}else{
			if(this.tabIndex != ""){
				this.focusNode.setAttribute('tabIndex', this.tabIndex);
			}
		}
	},

	setDisabled: function(/*Boolean*/ disabled){
		// summary:
		//		Deprecated.  Use set('disabled', ...) instead.
		dojo.deprecated("setDisabled("+disabled+") is deprecated. Use set('disabled',"+disabled+") instead.", "", "2.0");
		this.set('disabled', disabled);
	},

	_onFocus: function(e){
		if(this.scrollOnFocus){
			dojo.window.scrollIntoView(this.domNode);
		}
		this.inherited(arguments);
	},

	isFocusable: function(){
		// summary:
		//		Tells if this widget is focusable or not.  Used internally by dijit.
		// tags:
		//		protected
		return !this.disabled && this.focusNode && (dojo.style(this.domNode, "display") != "none");
	},

	focus: function(){
		// summary:
		//		Put focus on this widget
		if(!this.disabled){
			dijit.focus(this.focusNode);
		}
	},

	compare: function(/*anything*/ val1, /*anything*/ val2){
		// summary:
		//		Compare 2 values (as returned by get('value') for this widget).
		// tags:
		//		protected
		if(typeof val1 == "number" && typeof val2 == "number"){
			return (isNaN(val1) && isNaN(val2)) ? 0 : val1 - val2;
		}else if(val1 > val2){
			return 1;
		}else if(val1 < val2){
			return -1;
		}else{
			return 0;
		}
	},

	onChange: function(newValue){
		// summary:
		//		Callback when this widget's value is changed.
		// tags:
		//		callback
	},

	// _onChangeActive: [private] Boolean
	//		Indicates that changes to the value should call onChange() callback.
	//		This is false during widget initialization, to avoid calling onChange()
	//		when the initial value is set.
	_onChangeActive: false,

	_handleOnChange: function(/*anything*/ newValue, /*Boolean?*/ priorityChange){
		// summary:
		//		Called when the value of the widget is set.  Calls onChange() if appropriate
		// newValue:
		//		the new value
		// priorityChange:
		//		For a slider, for example, dragging the slider is priorityChange==false,
		//		but on mouse up, it's priorityChange==true.  If intermediateChanges==false,
		//		onChange is only called form priorityChange=true events.
		// tags:
		//		private
		if(this._lastValueReported == undefined && (priorityChange === null || !this._onChangeActive)){
			// this block executes not for a change, but during initialization,
			// and is used to store away the original value (or for ToggleButton, the original checked state)
			this._resetValue = this._lastValueReported = newValue;
		}
		this._pendingOnChange = this._pendingOnChange
			|| (typeof newValue != typeof this._lastValueReported)
			|| (this.compare(newValue, this._lastValueReported) != 0);
		if((this.intermediateChanges || priorityChange || priorityChange === undefined) && this._pendingOnChange){
			this._lastValueReported = newValue;
			this._pendingOnChange = false;
			if(this._onChangeActive){
				if(this._onChangeHandle){
					clearTimeout(this._onChangeHandle);
				}
				// setTimout allows hidden value processing to run and
				// also the onChange handler can safely adjust focus, etc
				this._onChangeHandle = setTimeout(dojo.hitch(this,
					function(){
						this._onChangeHandle = null;
						this.onChange(newValue);
					}), 0); // try to collapse multiple onChange's fired faster than can be processed
			}
		}
	},

	create: function(){
		// Overrides _Widget.create()
		this.inherited(arguments);
		this._onChangeActive = true;
	},

	destroy: function(){
		if(this._onChangeHandle){ // destroy called before last onChange has fired
			clearTimeout(this._onChangeHandle);
			this.onChange(this._lastValueReported);
		}
		this.inherited(arguments);
	},

	setValue: function(/*String*/ value){
		// summary:
		//		Deprecated.  Use set('value', ...) instead.
		dojo.deprecated("dijit.form._FormWidget:setValue("+value+") is deprecated.  Use set('value',"+value+") instead.", "", "2.0");
		this.set('value', value);
	},

	getValue: function(){
		// summary:
		//		Deprecated.  Use get('value') instead.
		dojo.deprecated(this.declaredClass+"::getValue() is deprecated. Use get('value') instead.", "", "2.0");
		return this.get('value');
	},
	
	_onMouseDown: function(e){
		// If user clicks on the button, even if the mouse is released outside of it,
		// this button should get focus (to mimics native browser buttons).
		// This is also needed on chrome because otherwise buttons won't get focus at all,
		// which leads to bizarre focus restore on Dialog close etc.
		if(!e.ctrlKey && dojo.mouseButtons.isLeft(e) && this.isFocusable()){ // !e.ctrlKey to ignore right-click on mac
			// Set a global event to handle mouseup, so it fires properly
			// even if the cursor leaves this.domNode before the mouse up event.
			var mouseUpConnector = this.connect(dojo.body(), "onmouseup", function(){
				if (this.isFocusable()) {
					this.focus();
				}
				this.disconnect(mouseUpConnector);
			});
		}
	}
});

dojo.declare("dijit.form._FormValueWidget", dijit.form._FormWidget,
{
	// summary:
	//		Base class for widgets corresponding to native HTML elements such as <input> or <select> that have user changeable values.
	// description:
	//		Each _FormValueWidget represents a single input value, and has a (possibly hidden) <input> element,
	//		to which it serializes it's input value, so that form submission (either normal submission or via FormBind?)
	//		works as expected.

	// Don't attempt to mixin the 'type', 'name' attributes here programatically -- they must be declared
	// directly in the template as read by the parser in order to function. IE is known to specifically
	// require the 'name' attribute at element creation time.  See #8484, #8660.
	// TODO: unclear what that {value: ""} is for; FormWidget.attributeMap copies value to focusNode,
	// so maybe {value: ""} is so the value *doesn't* get copied to focusNode?
	// Seems like we really want value removed from attributeMap altogether
	// (although there's no easy way to do that now)

	// readOnly: Boolean
	//		Should this widget respond to user input?
	//		In markup, this is specified as "readOnly".
	//		Similar to disabled except readOnly form values are submitted.
	readOnly: false,

	attributeMap: dojo.delegate(dijit.form._FormWidget.prototype.attributeMap, {
		value: "",
		readOnly: "focusNode"
	}),

	_setReadOnlyAttr: function(/*Boolean*/ value){
		dojo.attr(this.focusNode, 'readOnly', value);
		dijit.setWaiState(this.focusNode, "readonly", value);
		this._set("readOnly", value);
	},

	postCreate: function(){
		this.inherited(arguments);

		if(dojo.isIE < 9 || (dojo.isIE && dojo.isQuirks)){ // IE won't stop the event with keypress
			this.connect(this.focusNode || this.domNode, "onkeydown", this._onKeyDown);
		}
		// Update our reset value if it hasn't yet been set (because this.set()
		// is only called when there *is* a value)
		if(this._resetValue === undefined){
			this._lastValueReported = this._resetValue = this.value;
		}
	},

	_setValueAttr: function(/*anything*/ newValue, /*Boolean?*/ priorityChange){
		// summary:
		//		Hook so set('value', value) works.
		// description:
		//		Sets the value of the widget.
		//		If the value has changed, then fire onChange event, unless priorityChange
		//		is specified as null (or false?)
		this._handleOnChange(newValue, priorityChange);
	},

	_handleOnChange: function(/*anything*/ newValue, /*Boolean?*/ priorityChange){
		// summary:
		//		Called when the value of the widget has changed.  Saves the new value in this.value,
		//		and calls onChange() if appropriate.   See _FormWidget._handleOnChange() for details.
		this._set("value", newValue);
		this.inherited(arguments);
	},

	undo: function(){
		// summary:
		//		Restore the value to the last value passed to onChange
		this._setValueAttr(this._lastValueReported, false);
	},

	reset: function(){
		// summary:
		//		Reset the widget's value to what it was at initialization time
		this._hasBeenBlurred = false;
		this._setValueAttr(this._resetValue, true);
	},

	_onKeyDown: function(e){
		if(e.keyCode == dojo.keys.ESCAPE && !(e.ctrlKey || e.altKey || e.metaKey)){
			var te;
			if(dojo.isIE){
				e.preventDefault(); // default behavior needs to be stopped here since keypress is too late
				te = document.createEventObject();
				te.keyCode = dojo.keys.ESCAPE;
				te.shiftKey = e.shiftKey;
				e.srcElement.fireEvent('onkeypress', te);
			}
		}
	},

	_layoutHackIE7: function(){
		// summary:
		//		Work around table sizing bugs on IE7 by forcing redraw

		if(dojo.isIE == 7){ // fix IE7 layout bug when the widget is scrolled out of sight
			var domNode = this.domNode;
			var parent = domNode.parentNode;
			var pingNode = domNode.firstChild || domNode; // target node most unlikely to have a custom filter
			var origFilter = pingNode.style.filter; // save custom filter, most likely nothing
			var _this = this;
			while(parent && parent.clientHeight == 0){ // search for parents that haven't rendered yet
				(function ping(){
					var disconnectHandle = _this.connect(parent, "onscroll",
						function(e){
							_this.disconnect(disconnectHandle); // only call once
							pingNode.style.filter = (new Date()).getMilliseconds(); // set to anything that's unique
							setTimeout(function(){ pingNode.style.filter = origFilter }, 0); // restore custom filter, if any
						}
					);
				})();
				parent = parent.parentNode;
			}
		}
	}
});

}

if(!dojo._hasResource["dijit._HasDropDown"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._HasDropDown"] = true;
dojo.provide("dijit._HasDropDown");



dojo.declare("dijit._HasDropDown",
	null,
	{
		// summary:
		//		Mixin for widgets that need drop down ability.

		// _buttonNode: [protected] DomNode
		//		The button/icon/node to click to display the drop down.
		//		Can be set via a dojoAttachPoint assignment.
		//		If missing, then either focusNode or domNode (if focusNode is also missing) will be used.
		_buttonNode: null,

		// _arrowWrapperNode: [protected] DomNode
		//		Will set CSS class dijitUpArrow, dijitDownArrow, dijitRightArrow etc. on this node depending
		//		on where the drop down is set to be positioned.
		//		Can be set via a dojoAttachPoint assignment.
		//		If missing, then _buttonNode will be used.
		_arrowWrapperNode: null,

		// _popupStateNode: [protected] DomNode
		//		The node to set the popupActive class on.
		//		Can be set via a dojoAttachPoint assignment.
		//		If missing, then focusNode or _buttonNode (if focusNode is missing) will be used.
		_popupStateNode: null,

		// _aroundNode: [protected] DomNode
		//		The node to display the popup around.
		//		Can be set via a dojoAttachPoint assignment.
		//		If missing, then domNode will be used.
		_aroundNode: null,

		// dropDown: [protected] Widget
		//		The widget to display as a popup.  This widget *must* be
		//		defined before the startup function is called.
		dropDown: null,

		// autoWidth: [protected] Boolean
		//		Set to true to make the drop down at least as wide as this
		//		widget.  Set to false if the drop down should just be its
		//		default width
		autoWidth: true,

		// forceWidth: [protected] Boolean
		//		Set to true to make the drop down exactly as wide as this
		//		widget.  Overrides autoWidth.
		forceWidth: false,

		// maxHeight: [protected] Integer
		//		The max height for our dropdown.
		//		Any dropdown taller than this will have scrollbars.
		//		Set to 0 for no max height, or -1 to limit height to available space in viewport
		maxHeight: 0,

		// dropDownPosition: [const] String[]
		//		This variable controls the position of the drop down.
		//		It's an array of strings with the following values:
		//
		//			* before: places drop down to the left of the target node/widget, or to the right in
		//			  the case of RTL scripts like Hebrew and Arabic
		//			* after: places drop down to the right of the target node/widget, or to the left in
		//			  the case of RTL scripts like Hebrew and Arabic
		//			* above: drop down goes above target node
		//			* below: drop down goes below target node
		//
		//		The list is positions is tried, in order, until a position is found where the drop down fits
		//		within the viewport.
		//
		dropDownPosition: ["below","above"],

		// _stopClickEvents: Boolean
		//		When set to false, the click events will not be stopped, in
		//		case you want to use them in your subwidget
		_stopClickEvents: true,

		_onDropDownMouseDown: function(/*Event*/ e){
			// summary:
			//		Callback when the user mousedown's on the arrow icon

			if(this.disabled || this.readOnly){ return; }

			dojo.stopEvent(e);

			this._docHandler = this.connect(dojo.doc, "onmouseup", "_onDropDownMouseUp");

			this.toggleDropDown();
		},

		_onDropDownMouseUp: function(/*Event?*/ e){
			// summary:
			//		Callback when the user lifts their mouse after mouse down on the arrow icon.
			//		If the drop is a simple menu and the mouse is over the menu, we execute it, otherwise, we focus our
			//		dropDown node.  If the event is missing, then we are not
			//		a mouseup event.
			//
			//		This is useful for the common mouse movement pattern
			//		with native browser <select> nodes:
			//			1. mouse down on the select node (probably on the arrow)
			//			2. move mouse to a menu item while holding down the mouse button
			//			3. mouse up.  this selects the menu item as though the user had clicked it.
			if(e && this._docHandler){
				this.disconnect(this._docHandler);
			}
			var dropDown = this.dropDown, overMenu = false;

			if(e && this._opened){
				// This code deals with the corner-case when the drop down covers the original widget,
				// because it's so large.  In that case mouse-up shouldn't select a value from the menu.
				// Find out if our target is somewhere in our dropdown widget,
				// but not over our _buttonNode (the clickable node)
				var c = dojo.position(this._buttonNode, true);
				if(!(e.pageX >= c.x && e.pageX <= c.x + c.w) ||
					!(e.pageY >= c.y && e.pageY <= c.y + c.h)){
					var t = e.target;
					while(t && !overMenu){
						if(dojo.hasClass(t, "dijitPopup")){
							overMenu = true;
						}else{
							t = t.parentNode;
						}
					}
					if(overMenu){
						t = e.target;
						if(dropDown.onItemClick){
							var menuItem;
							while(t && !(menuItem = dijit.byNode(t))){
								t = t.parentNode;
							}
							if(menuItem && menuItem.onClick && menuItem.getParent){
								menuItem.getParent().onItemClick(menuItem, e);
							}
						}
						return;
					}
				}
			}
			if(this._opened && dropDown.focus && dropDown.autoFocus !== false){
				// Focus the dropdown widget - do it on a delay so that we
				// don't steal our own focus.
				window.setTimeout(dojo.hitch(dropDown, "focus"), 1);
			}
		},

		_onDropDownClick: function(/*Event*/ e){
			// the drop down was already opened on mousedown/keydown; just need to call stopEvent()
			if(this._stopClickEvents){
				dojo.stopEvent(e);
			}
		},

		buildRendering: function(){
			this.inherited(arguments);

			this._buttonNode = this._buttonNode || this.focusNode || this.domNode;
			this._popupStateNode = this._popupStateNode || this.focusNode || this._buttonNode;

			// Add a class to the "dijitDownArrowButton" type class to _buttonNode so theme can set direction of arrow
			// based on where drop down will normally appear
			var defaultPos = {
					"after" : this.isLeftToRight() ? "Right" : "Left",
					"before" : this.isLeftToRight() ? "Left" : "Right",
					"above" : "Up",
					"below" : "Down",
					"left" : "Left",
					"right" : "Right"
			}[this.dropDownPosition[0]] || this.dropDownPosition[0] || "Down";
			dojo.addClass(this._arrowWrapperNode || this._buttonNode, "dijit" + defaultPos + "ArrowButton");
		},

		postCreate: function(){
			// summary:
			//		set up nodes and connect our mouse and keypress events

			this.inherited(arguments);

			this.connect(this._buttonNode, "onmousedown", "_onDropDownMouseDown");
			this.connect(this._buttonNode, "onclick", "_onDropDownClick");
			this.connect(this.focusNode, "onkeypress", "_onKey");
			this.connect(this.focusNode, "onkeyup", "_onKeyUp");
		},

		destroy: function(){
			if(this.dropDown){
				// Destroy the drop down, unless it's already been destroyed.  This can happen because
				// the drop down is a direct child of <body> even though it's logically my child.
				if(!this.dropDown._destroyed){
					this.dropDown.destroyRecursive();
				}
				delete this.dropDown;
			}
			this.inherited(arguments);
		},

		_onKey: function(/*Event*/ e){
			// summary:
			//		Callback when the user presses a key while focused on the button node

			if(this.disabled || this.readOnly){ return; }

			var d = this.dropDown, target = e.target;
			if(d && this._opened && d.handleKey){
				if(d.handleKey(e) === false){
					/* false return code means that the drop down handled the key */
					dojo.stopEvent(e);
					return;
				}
			}
			if(d && this._opened && e.charOrCode == dojo.keys.ESCAPE){
				this.closeDropDown();
				dojo.stopEvent(e);
			}else if(!this._opened &&
					(e.charOrCode == dojo.keys.DOWN_ARROW ||
						( (e.charOrCode == dojo.keys.ENTER || e.charOrCode == " ") &&
						  //ignore enter and space if the event is for a text input
						  ((target.tagName || "").toLowerCase() !== 'input' ||
						     (target.type && target.type.toLowerCase() !== 'text'))))){
				// Toggle the drop down, but wait until keyup so that the drop down doesn't
				// get a stray keyup event, or in the case of key-repeat (because user held
				// down key for too long), stray keydown events
				this._toggleOnKeyUp = true;
				dojo.stopEvent(e);
			}
		},

		_onKeyUp: function(){
			if(this._toggleOnKeyUp){
				delete this._toggleOnKeyUp;
				this.toggleDropDown();
				var d = this.dropDown;	// drop down may not exist until toggleDropDown() call
				if(d && d.focus){
					setTimeout(dojo.hitch(d, "focus"), 1);
				}
			}
		},

		_onBlur: function(){
			// summary:
			//		Called magically when focus has shifted away from this widget and it's dropdown

			// Don't focus on button if the user has explicitly focused on something else (happens
			// when user clicks another control causing the current popup to close)..
			// But if focus is inside of the drop down then reset focus to me, because IE doesn't like
			// it when you display:none a node with focus.
			var focusMe = dijit._curFocus && this.dropDown && dojo.isDescendant(dijit._curFocus, this.dropDown.domNode);

			this.closeDropDown(focusMe);

			this.inherited(arguments);
		},

		isLoaded: function(){
			// summary:
			//		Returns whether or not the dropdown is loaded.  This can
			//		be overridden in order to force a call to loadDropDown().
			// tags:
			//		protected

			return true;
		},

		loadDropDown: function(/* Function */ loadCallback){
			// summary:
			//		Loads the data for the dropdown, and at some point, calls
			//		the given callback.   This is basically a callback when the
			//		user presses the down arrow button to open the drop down.
			// tags:
			//		protected

			loadCallback();
		},

		toggleDropDown: function(){
			// summary:
			//		Callback when the user presses the down arrow button or presses
			//		the down arrow key to open/close the drop down.
			//		Toggle the drop-down widget; if it is up, close it, if not, open it
			// tags:
			//		protected

			if(this.disabled || this.readOnly){ return; }
			if(!this._opened){
				// If we aren't loaded, load it first so there isn't a flicker
				if(!this.isLoaded()){
					this.loadDropDown(dojo.hitch(this, "openDropDown"));
					return;
				}else{
					this.openDropDown();
				}
			}else{
				this.closeDropDown();
			}
		},

		openDropDown: function(){
			// summary:
			//		Opens the dropdown for this widget.   To be called only when this.dropDown
			//		has been created and is ready to display (ie, it's data is loaded).
			// returns:
			//		return value of dijit.popup.open()
			// tags:
			//		protected

			var dropDown = this.dropDown,
				ddNode = dropDown.domNode,
				aroundNode = this._aroundNode || this.domNode,
				self = this;

			// Prepare our popup's height and honor maxHeight if it exists.

			// TODO: isn't maxHeight dependent on the return value from dijit.popup.open(),
			// ie, dependent on how much space is available (BK)

			if(!this._preparedNode){
				this._preparedNode = true;
				// Check if we have explicitly set width and height on the dropdown widget dom node
				if(ddNode.style.width){
					this._explicitDDWidth = true;
				}
				if(ddNode.style.height){
					this._explicitDDHeight = true;
				}
			}

			// Code for resizing dropdown (height limitation, or increasing width to match my width)
			if(this.maxHeight || this.forceWidth || this.autoWidth){
				var myStyle = {
					display: "",
					visibility: "hidden"
				};
				if(!this._explicitDDWidth){
					myStyle.width = "";
				}
				if(!this._explicitDDHeight){
					myStyle.height = "";
				}
				dojo.style(ddNode, myStyle);
				
				// Figure out maximum height allowed (if there is a height restriction)
				var maxHeight = this.maxHeight;
				if(maxHeight == -1){
					// limit height to space available in viewport either above or below my domNode
					// (whichever side has more room)
					var viewport = dojo.window.getBox(),
						position = dojo.position(aroundNode, false);
					maxHeight = Math.floor(Math.max(position.y, viewport.h - (position.y + position.h)));
				}

				// Attach dropDown to DOM and make make visibility:hidden rather than display:none
				// so we call startup() and also get the size
				if(dropDown.startup && !dropDown._started){
					dropDown.startup();
				}

				dijit.popup.moveOffScreen(dropDown);
				// Get size of drop down, and determine if vertical scroll bar needed
				var mb = dojo._getMarginSize(ddNode);
				var overHeight = (maxHeight && mb.h > maxHeight);
				dojo.style(ddNode, {
					overflowX: "hidden",
					overflowY: overHeight ? "auto" : "hidden"
				});
				if(overHeight){
					mb.h = maxHeight;
					if("w" in mb){
						mb.w += 16;	// room for vertical scrollbar
					}
				}else{
					delete mb.h;
				}

				// Adjust dropdown width to match or be larger than my width
				if(this.forceWidth){
					mb.w = aroundNode.offsetWidth;
				}else if(this.autoWidth){
					mb.w = Math.max(mb.w, aroundNode.offsetWidth);
				}else{
					delete mb.w;
				}
				
				// And finally, resize the dropdown to calculated height and width
				if(dojo.isFunction(dropDown.resize)){
					dropDown.resize(mb);
				}else{
					dojo.marginBox(ddNode, mb);
				}
			}

			var retVal = dijit.popup.open({
				parent: this,
				popup: dropDown,
				around: aroundNode,
				orient: dijit.getPopupAroundAlignment((this.dropDownPosition && this.dropDownPosition.length) ? this.dropDownPosition : ["below"],this.isLeftToRight()),
				onExecute: function(){
					self.closeDropDown(true);
				},
				onCancel: function(){
					self.closeDropDown(true);
				},
				onClose: function(){
					dojo.attr(self._popupStateNode, "popupActive", false);
					dojo.removeClass(self._popupStateNode, "dijitHasDropDownOpen");
					self._opened = false;
				}
			});
			dojo.attr(this._popupStateNode, "popupActive", "true");
			dojo.addClass(self._popupStateNode, "dijitHasDropDownOpen");
			this._opened=true;

			// TODO: set this.checked and call setStateClass(), to affect button look while drop down is shown
			return retVal;
		},

		closeDropDown: function(/*Boolean*/ focus){
			// summary:
			//		Closes the drop down on this widget
			// focus:
			//		If true, refocuses the button widget
			// tags:
			//		protected

			if(this._opened){
				if(focus){ this.focus(); }
				dijit.popup.close(this.dropDown);
				this._opened = false;
			}
		}

	}
);

}

if(!dojo._hasResource["dijit.form.Button"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.Button"] = true;
dojo.provide("dijit.form.Button");





dojo.declare("dijit.form.Button",
	dijit.form._FormWidget,
	{
	// summary:
	//		Basically the same thing as a normal HTML button, but with special styling.
	// description:
	//		Buttons can display a label, an icon, or both.
	//		A label should always be specified (through innerHTML) or the label
	//		attribute.  It can be hidden via showLabel=false.
	// example:
	// |	<button dojoType="dijit.form.Button" onClick="...">Hello world</button>
	//
	// example:
	// |	var button1 = new dijit.form.Button({label: "hello world", onClick: foo});
	// |	dojo.body().appendChild(button1.domNode);

	// label: HTML String
	//		Text to display in button.
	//		If the label is hidden (showLabel=false) then and no title has
	//		been specified, then label is also set as title attribute of icon.
	label: "",

	// showLabel: Boolean
	//		Set this to true to hide the label text and display only the icon.
	//		(If showLabel=false then iconClass must be specified.)
	//		Especially useful for toolbars.
	//		If showLabel=true, the label will become the title (a.k.a. tooltip/hint) of the icon.
	//
	//		The exception case is for computers in high-contrast mode, where the label
	//		will still be displayed, since the icon doesn't appear.
	showLabel: true,

	// iconClass: String
	//		Class to apply to DOMNode in button to make it display an icon
	iconClass: "",

	// type: String
	//		Defines the type of button.  "button", "submit", or "reset".
	type: "button",

	baseClass: "dijitButton",

	templateString: dojo.cache("dijit.form", "templates/Button.html", "<span class=\"dijit dijitReset dijitInline\"\n\t><span class=\"dijitReset dijitInline dijitButtonNode\"\n\t\tdojoAttachEvent=\"ondijitclick:_onButtonClick\"\n\t\t><span class=\"dijitReset dijitStretch dijitButtonContents\"\n\t\t\tdojoAttachPoint=\"titleNode,focusNode\"\n\t\t\trole=\"button\" aria-labelledby=\"${id}_label\"\n\t\t\t><span class=\"dijitReset dijitInline dijitIcon\" dojoAttachPoint=\"iconNode\"></span\n\t\t\t><span class=\"dijitReset dijitToggleButtonIconChar\">&#x25CF;</span\n\t\t\t><span class=\"dijitReset dijitInline dijitButtonText\"\n\t\t\t\tid=\"${id}_label\"\n\t\t\t\tdojoAttachPoint=\"containerNode\"\n\t\t\t></span\n\t\t></span\n\t></span\n\t><input ${!nameAttrSetting} type=\"${type}\" value=\"${value}\" class=\"dijitOffScreen\" tabIndex=\"-1\"\n\t\tdojoAttachPoint=\"valueNode\"\n/></span>\n"),

	attributeMap: dojo.delegate(dijit.form._FormWidget.prototype.attributeMap, {
		value: "valueNode"
	}),

	_onClick: function(/*Event*/ e){
		// summary:
		//		Internal function to handle click actions
		if(this.disabled){
			return false;
		}
		this._clicked(); // widget click actions
		return this.onClick(e); // user click actions
	},

	_onButtonClick: function(/*Event*/ e){
		// summary:
		//		Handler when the user activates the button portion.
		if(this._onClick(e) === false){ // returning nothing is same as true
			e.preventDefault(); // needed for checkbox
		}else if(this.type == "submit" && !(this.valueNode||this.focusNode).form){ // see if a nonform widget needs to be signalled
			for(var node=this.domNode; node.parentNode/*#5935*/; node=node.parentNode){
				var widget=dijit.byNode(node);
				if(widget && typeof widget._onSubmit == "function"){
					widget._onSubmit(e);
					break;
				}
			}
		}else if(this.valueNode){
			this.valueNode.click();
			e.preventDefault(); // cancel BUTTON click and continue with hidden INPUT click
		}
	},

	buildRendering: function(){
		this.inherited(arguments);
		dojo.setSelectable(this.focusNode, false);
	},

	_fillContent: function(/*DomNode*/ source){
		// Overrides _Templated._fillContent().
		// If button label is specified as srcNodeRef.innerHTML rather than
		// this.params.label, handle it here.
		// TODO: remove the method in 2.0, parser will do it all for me
		if(source && (!this.params || !("label" in this.params))){
			this.set('label', source.innerHTML);
		}
	},

	_setShowLabelAttr: function(val){
		if(this.containerNode){
			dojo.toggleClass(this.containerNode, "dijitDisplayNone", !val);
		}
		this._set("showLabel", val);
	},

	onClick: function(/*Event*/ e){
		// summary:
		//		Callback for when button is clicked.
		//		If type="submit", return true to perform submit, or false to cancel it.
		// type:
		//		callback
		return true;		// Boolean
	},

	_clicked: function(/*Event*/ e){
		// summary:
		//		Internal overridable function for when the button is clicked
	},

	setLabel: function(/*String*/ content){
		// summary:
		//		Deprecated.  Use set('label', ...) instead.
		dojo.deprecated("dijit.form.Button.setLabel() is deprecated.  Use set('label', ...) instead.", "", "2.0");
		this.set("label", content);
	},

	_setLabelAttr: function(/*String*/ content){
		// summary:
		//		Hook for set('label', ...) to work.
		// description:
		//		Set the label (text) of the button; takes an HTML string.
		this._set("label", content);
		this.containerNode.innerHTML = content;
		if(this.showLabel == false && !this.params.title){
			this.titleNode.title = dojo.trim(this.containerNode.innerText || this.containerNode.textContent || '');
		}
	},

	_setIconClassAttr: function(/*String*/ val){
		// Custom method so that icon node is hidden when not in use, to avoid excess padding/margin
		// appearing around it (even if it's a 0x0 sized <img> node)

		var oldVal = this.iconClass || "dijitNoIcon",
			newVal = val || "dijitNoIcon";
		dojo.replaceClass(this.iconNode, newVal, oldVal);
		this._set("iconClass", val);
	}
});


dojo.declare("dijit.form.DropDownButton", [dijit.form.Button, dijit._Container, dijit._HasDropDown], {
	// summary:
	//		A button with a drop down
	//
	// example:
	// |	<button dojoType="dijit.form.DropDownButton" label="Hello world">
	// |		<div dojotype="dijit.Menu">...</div>
	// |	</button>
	//
	// example:
	// |	var button1 = new dijit.form.DropDownButton({ label: "hi", dropDown: new dijit.Menu(...) });
	// |	dojo.body().appendChild(button1);
	//

	baseClass : "dijitDropDownButton",

	templateString: dojo.cache("dijit.form", "templates/DropDownButton.html", "<span class=\"dijit dijitReset dijitInline\"\n\t><span class='dijitReset dijitInline dijitButtonNode'\n\t\tdojoAttachEvent=\"ondijitclick:_onButtonClick\" dojoAttachPoint=\"_buttonNode\"\n\t\t><span class=\"dijitReset dijitStretch dijitButtonContents\"\n\t\t\tdojoAttachPoint=\"focusNode,titleNode,_arrowWrapperNode\"\n\t\t\trole=\"button\" aria-haspopup=\"true\" aria-labelledby=\"${id}_label\"\n\t\t\t><span class=\"dijitReset dijitInline dijitIcon\"\n\t\t\t\tdojoAttachPoint=\"iconNode\"\n\t\t\t></span\n\t\t\t><span class=\"dijitReset dijitInline dijitButtonText\"\n\t\t\t\tdojoAttachPoint=\"containerNode,_popupStateNode\"\n\t\t\t\tid=\"${id}_label\"\n\t\t\t></span\n\t\t\t><span class=\"dijitReset dijitInline dijitArrowButtonInner\"></span\n\t\t\t><span class=\"dijitReset dijitInline dijitArrowButtonChar\">&#9660;</span\n\t\t></span\n\t></span\n\t><input ${!nameAttrSetting} type=\"${type}\" value=\"${value}\" class=\"dijitOffScreen\" tabIndex=\"-1\"\n\t\tdojoAttachPoint=\"valueNode\"\n/></span>\n"),

	_fillContent: function(){
		// Overrides Button._fillContent().
		//
		// My inner HTML contains both the button contents and a drop down widget, like
		// <DropDownButton>  <span>push me</span>  <Menu> ... </Menu> </DropDownButton>
		// The first node is assumed to be the button content. The widget is the popup.

		if(this.srcNodeRef){ // programatically created buttons might not define srcNodeRef
			//FIXME: figure out how to filter out the widget and use all remaining nodes as button
			//	content, not just nodes[0]
			var nodes = dojo.query("*", this.srcNodeRef);
			dijit.form.DropDownButton.superclass._fillContent.call(this, nodes[0]);

			// save pointer to srcNode so we can grab the drop down widget after it's instantiated
			this.dropDownContainer = this.srcNodeRef;
		}
	},

	startup: function(){
		if(this._started){ return; }

		// the child widget from srcNodeRef is the dropdown widget.  Insert it in the page DOM,
		// make it invisible, and store a reference to pass to the popup code.
		if(!this.dropDown && this.dropDownContainer){
			var dropDownNode = dojo.query("[widgetId]", this.dropDownContainer)[0];
			this.dropDown = dijit.byNode(dropDownNode);
			delete this.dropDownContainer;
		}
		if(this.dropDown){
			dijit.popup.hide(this.dropDown);
		}

		this.inherited(arguments);
	},

	isLoaded: function(){
		// Returns whether or not we are loaded - if our dropdown has an href,
		// then we want to check that.
		var dropDown = this.dropDown;
		return (!!dropDown && (!dropDown.href || dropDown.isLoaded));
	},

	loadDropDown: function(){
		// Loads our dropdown
		var dropDown = this.dropDown;
		if(!dropDown){ return; }
		if(!this.isLoaded()){
			var handler = dojo.connect(dropDown, "onLoad", this, function(){
				dojo.disconnect(handler);
				this.openDropDown();
			});
			dropDown.refresh();
		}else{
			this.openDropDown();
		}
	},

	isFocusable: function(){
		// Overridden so that focus is handled by the _HasDropDown mixin, not by
		// the _FormWidget mixin.
		return this.inherited(arguments) && !this._mouseDown;
	}
});

dojo.declare("dijit.form.ComboButton", dijit.form.DropDownButton, {
	// summary:
	//		A combination button and drop-down button.
	//		Users can click one side to "press" the button, or click an arrow
	//		icon to display the drop down.
	//
	// example:
	// |	<button dojoType="dijit.form.ComboButton" onClick="...">
	// |		<span>Hello world</span>
	// |		<div dojoType="dijit.Menu">...</div>
	// |	</button>
	//
	// example:
	// |	var button1 = new dijit.form.ComboButton({label: "hello world", onClick: foo, dropDown: "myMenu"});
	// |	dojo.body().appendChild(button1.domNode);
	//

	templateString: dojo.cache("dijit.form", "templates/ComboButton.html", "<table class=\"dijit dijitReset dijitInline dijitLeft\"\n\tcellspacing='0' cellpadding='0' role=\"presentation\"\n\t><tbody role=\"presentation\"><tr role=\"presentation\"\n\t\t><td class=\"dijitReset dijitStretch dijitButtonNode\" dojoAttachPoint=\"buttonNode\" dojoAttachEvent=\"ondijitclick:_onButtonClick,onkeypress:_onButtonKeyPress\"\n\t\t><div id=\"${id}_button\" class=\"dijitReset dijitButtonContents\"\n\t\t\tdojoAttachPoint=\"titleNode\"\n\t\t\trole=\"button\" aria-labelledby=\"${id}_label\"\n\t\t\t><div class=\"dijitReset dijitInline dijitIcon\" dojoAttachPoint=\"iconNode\" role=\"presentation\"></div\n\t\t\t><div class=\"dijitReset dijitInline dijitButtonText\" id=\"${id}_label\" dojoAttachPoint=\"containerNode\" role=\"presentation\"></div\n\t\t></div\n\t\t></td\n\t\t><td id=\"${id}_arrow\" class='dijitReset dijitRight dijitButtonNode dijitArrowButton'\n\t\t\tdojoAttachPoint=\"_popupStateNode,focusNode,_buttonNode\"\n\t\t\tdojoAttachEvent=\"onkeypress:_onArrowKeyPress\"\n\t\t\ttitle=\"${optionsTitle}\"\n\t\t\trole=\"button\" aria-haspopup=\"true\"\n\t\t\t><div class=\"dijitReset dijitArrowButtonInner\" role=\"presentation\"></div\n\t\t\t><div class=\"dijitReset dijitArrowButtonChar\" role=\"presentation\">&#9660;</div\n\t\t></td\n\t\t><td style=\"display:none !important;\"\n\t\t\t><input ${!nameAttrSetting} type=\"${type}\" value=\"${value}\" dojoAttachPoint=\"valueNode\"\n\t\t/></td></tr></tbody\n></table>\n"),

	attributeMap: dojo.mixin(dojo.clone(dijit.form.Button.prototype.attributeMap), {
		id: "",
		tabIndex: ["focusNode", "titleNode"],
		title: "titleNode"
	}),

	// optionsTitle: String
	//		Text that describes the options menu (accessibility)
	optionsTitle: "",

	baseClass: "dijitComboButton",

	// Set classes like dijitButtonContentsHover or dijitArrowButtonActive depending on
	// mouse action over specified node
	cssStateNodes: {
		"buttonNode": "dijitButtonNode",
		"titleNode": "dijitButtonContents",
		"_popupStateNode": "dijitDownArrowButton"
	},

	_focusedNode: null,

	_onButtonKeyPress: function(/*Event*/ evt){
		// summary:
		//		Handler for right arrow key when focus is on left part of button
		if(evt.charOrCode == dojo.keys[this.isLeftToRight() ? "RIGHT_ARROW" : "LEFT_ARROW"]){
			dijit.focus(this._popupStateNode);
			dojo.stopEvent(evt);
		}
	},

	_onArrowKeyPress: function(/*Event*/ evt){
		// summary:
		//		Handler for left arrow key when focus is on right part of button
		if(evt.charOrCode == dojo.keys[this.isLeftToRight() ? "LEFT_ARROW" : "RIGHT_ARROW"]){
			dijit.focus(this.titleNode);
			dojo.stopEvent(evt);
		}
	},
	
	focus: function(/*String*/ position){
		// summary:
		//		Focuses this widget to according to position, if specified,
		//		otherwise on arrow node
		// position:
		//		"start" or "end"
		if(!this.disabled){
			dijit.focus(position == "start" ? this.titleNode : this._popupStateNode);
		}
	}
});

dojo.declare("dijit.form.ToggleButton", dijit.form.Button, {
	// summary:
	//		A button that can be in two states (checked or not).
	//		Can be base class for things like tabs or checkbox or radio buttons

	baseClass: "dijitToggleButton",

	// checked: Boolean
	//		Corresponds to the native HTML <input> element's attribute.
	//		In markup, specified as "checked='checked'" or just "checked".
	//		True if the button is depressed, or the checkbox is checked,
	//		or the radio button is selected, etc.
	checked: false,

	attributeMap: dojo.mixin(dojo.clone(dijit.form.Button.prototype.attributeMap), {
		checked:"focusNode"
	}),

	_clicked: function(/*Event*/ evt){
		this.set('checked', !this.checked);
	},

	_setCheckedAttr: function(/*Boolean*/ value, /*Boolean?*/ priorityChange){
		this._set("checked", value);
		dojo.attr(this.focusNode || this.domNode, "checked", value);
		dijit.setWaiState(this.focusNode || this.domNode, "pressed", value);
		this._handleOnChange(value, priorityChange);
	},

	setChecked: function(/*Boolean*/ checked){
		// summary:
		//		Deprecated.  Use set('checked', true/false) instead.
		dojo.deprecated("setChecked("+checked+") is deprecated. Use set('checked',"+checked+") instead.", "", "2.0");
		this.set('checked', checked);
	},

	reset: function(){
		// summary:
		//		Reset the widget's value to what it was at initialization time

		this._hasBeenBlurred = false;

		// set checked state to original setting
		this.set('checked', this.params.checked || false);
	}
});

}

if(!dojo._hasResource["dijit.form.ToggleButton"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.ToggleButton"] = true;
dojo.provide("dijit.form.ToggleButton");




}

if(!dojo._hasResource["dijit.form.CheckBox"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.CheckBox"] = true;
dojo.provide("dijit.form.CheckBox");



dojo.declare(
	"dijit.form.CheckBox",
	dijit.form.ToggleButton,
	{
		// summary:
		// 		Same as an HTML checkbox, but with fancy styling.
		//
		// description:
		//		User interacts with real html inputs.
		//		On onclick (which occurs by mouse click, space-bar, or
		//		using the arrow keys to switch the selected radio button),
		//		we update the state of the checkbox/radio.
		//
		//		There are two modes:
		//			1. High contrast mode
		//			2. Normal mode
		//
		//		In case 1, the regular html inputs are shown and used by the user.
		//		In case 2, the regular html inputs are invisible but still used by
		//		the user. They are turned quasi-invisible and overlay the background-image.

		templateString: dojo.cache("dijit.form", "templates/CheckBox.html", "<div class=\"dijit dijitReset dijitInline\" role=\"presentation\"\n\t><input\n\t \t${!nameAttrSetting} type=\"${type}\" ${checkedAttrSetting}\n\t\tclass=\"dijitReset dijitCheckBoxInput\"\n\t\tdojoAttachPoint=\"focusNode\"\n\t \tdojoAttachEvent=\"onclick:_onClick\"\n/></div>\n"),

		baseClass: "dijitCheckBox",

		// type: [private] String
		//		type attribute on <input> node.
		//		Overrides `dijit.form.Button.type`.  Users should not change this value.
		type: "checkbox",

		// value: String
		//		As an initialization parameter, equivalent to value field on normal checkbox
		//		(if checked, the value is passed as the value when form is submitted).
		//
		//		However, get('value') will return either the string or false depending on
		//		whether or not the checkbox is checked.
		//
		//		set('value', string) will check the checkbox and change the value to the
		//		specified string
		//
		//		set('value', boolean) will change the checked state.
		value: "on",

		// readOnly: Boolean
		//		Should this widget respond to user input?
		//		In markup, this is specified as "readOnly".
		//		Similar to disabled except readOnly form values are submitted.
		readOnly: false,
		
		// the attributeMap should inherit from dijit.form._FormWidget.prototype.attributeMap
		// instead of ToggleButton as the icon mapping has no meaning for a CheckBox
		attributeMap: dojo.delegate(dijit.form._FormWidget.prototype.attributeMap, {
			readOnly: "focusNode"
		}),

		_setReadOnlyAttr: function(/*Boolean*/ value){
			this._set("readOnly", value);
			dojo.attr(this.focusNode, 'readOnly', value);
			dijit.setWaiState(this.focusNode, "readonly", value);
		},

		_setValueAttr: function(/*String|Boolean*/ newValue, /*Boolean*/ priorityChange){
			// summary:
			//		Handler for value= attribute to constructor, and also calls to
			//		set('value', val).
			// description:
			//		During initialization, just saves as attribute to the <input type=checkbox>.
			//
			//		After initialization,
			//		when passed a boolean, controls whether or not the CheckBox is checked.
			//		If passed a string, changes the value attribute of the CheckBox (the one
			//		specified as "value" when the CheckBox was constructed (ex: <input
			//		dojoType="dijit.CheckBox" value="chicken">)
			if(typeof newValue == "string"){
				this._set("value", newValue);
				dojo.attr(this.focusNode, 'value', newValue);
				newValue = true;
			}
			if(this._created){
				this.set('checked', newValue, priorityChange);
			}
		},
		_getValueAttr: function(){
			// summary:
			//		Hook so get('value') works.
			// description:
			//		If the CheckBox is checked, returns the value attribute.
			//		Otherwise returns false.
			return (this.checked ? this.value : false);
		},

		// Override dijit.form.Button._setLabelAttr() since we don't even have a containerNode.
		// Normally users won't try to set label, except when CheckBox or RadioButton is the child of a dojox.layout.TabContainer
		_setLabelAttr: undefined,

		postMixInProperties: function(){
			if(this.value == ""){
				this.value = "on";
			}

			// Need to set initial checked state as part of template, so that form submit works.
			// dojo.attr(node, "checked", bool) doesn't work on IEuntil node has been attached
			// to <body>, see #8666
			this.checkedAttrSetting = this.checked ? "checked" : "";

			this.inherited(arguments);
		},

		 _fillContent: function(/*DomNode*/ source){
			// Override Button::_fillContent() since it doesn't make sense for CheckBox,
			// since CheckBox doesn't even have a container
		},

		reset: function(){
			// Override ToggleButton.reset()

			this._hasBeenBlurred = false;

			this.set('checked', this.params.checked || false);

			// Handle unlikely event that the <input type=checkbox> value attribute has changed
			this._set("value", this.params.value || "on");
			dojo.attr(this.focusNode, 'value', this.value);
		},

		_onFocus: function(){
			if(this.id){
				dojo.query("label[for='"+this.id+"']").addClass("dijitFocusedLabel");
			}
			this.inherited(arguments);
		},

		_onBlur: function(){
			if(this.id){
				dojo.query("label[for='"+this.id+"']").removeClass("dijitFocusedLabel");
			}
			this.inherited(arguments);
		},

		_onClick: function(/*Event*/ e){
			// summary:
			//		Internal function to handle click actions - need to check
			//		readOnly, since button no longer does that check.
			if(this.readOnly){
				dojo.stopEvent(e);
				return false;
			}
			return this.inherited(arguments);
		}
	}
);

dojo.declare(
	"dijit.form.RadioButton",
	dijit.form.CheckBox,
	{
		// summary:
		// 		Same as an HTML radio, but with fancy styling.

		type: "radio",
		baseClass: "dijitRadio",

		_setCheckedAttr: function(/*Boolean*/ value){
			// If I am being checked then have to deselect currently checked radio button
			this.inherited(arguments);
			if(!this._created){ return; }
			if(value){
				var _this = this;
				// search for radio buttons with the same name that need to be unchecked
				dojo.query("INPUT[type=radio]", this.focusNode.form || dojo.doc).forEach( // can't use name= since dojo.query doesn't support [] in the name
					function(inputNode){
						if(inputNode.name == _this.name && inputNode != _this.focusNode && inputNode.form == _this.focusNode.form){
							var widget = dijit.getEnclosingWidget(inputNode);
							if(widget && widget.checked){
								widget.set('checked', false);
							}
						}
					}
				);
			}
		},

		_clicked: function(/*Event*/ e){
			if(!this.checked){
				this.set('checked', true);
			}
		}
	}
);

}

if(!dojo._hasResource["dijit.form.TextBox"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.TextBox"] = true;
dojo.provide("dijit.form.TextBox");



dojo.declare(
	"dijit.form.TextBox",
	dijit.form._FormValueWidget,
	{
		// summary:
		//		A base class for textbox form inputs

		// trim: Boolean
		//		Removes leading and trailing whitespace if true.  Default is false.
		trim: false,

		// uppercase: Boolean
		//		Converts all characters to uppercase if true.  Default is false.
		uppercase: false,

		// lowercase: Boolean
		//		Converts all characters to lowercase if true.  Default is false.
		lowercase: false,

		// propercase: Boolean
		//		Converts the first character of each word to uppercase if true.
		propercase: false,

		// maxLength: String
		//		HTML INPUT tag maxLength declaration.
		maxLength: "",

		// selectOnClick: [const] Boolean
		//		If true, all text will be selected when focused with mouse
		selectOnClick: false,

		// placeHolder: String
		//		Defines a hint to help users fill out the input field (as defined in HTML 5).
		//		This should only contain plain text (no html markup).
		placeHolder: "",
		
		templateString: dojo.cache("dijit.form", "templates/TextBox.html", "<div class=\"dijit dijitReset dijitInline dijitLeft\" id=\"widget_${id}\" role=\"presentation\"\n\t><div class=\"dijitReset dijitInputField dijitInputContainer\"\n\t\t><input class=\"dijitReset dijitInputInner\" dojoAttachPoint='textbox,focusNode' autocomplete=\"off\"\n\t\t\t${!nameAttrSetting} type='${type}'\n\t/></div\n></div>\n"),
		_singleNodeTemplate: '<input class="dijit dijitReset dijitLeft dijitInputField" dojoAttachPoint="textbox,focusNode" autocomplete="off" type="${type}" ${!nameAttrSetting} />',

		_buttonInputDisabled: dojo.isIE ? "disabled" : "", // allows IE to disallow focus, but Firefox cannot be disabled for mousedown events

		baseClass: "dijitTextBox",

		attributeMap: dojo.delegate(dijit.form._FormValueWidget.prototype.attributeMap, {
			maxLength: "focusNode"
		}),
		
		postMixInProperties: function(){
			var type = this.type.toLowerCase();
			if(this.templateString && this.templateString.toLowerCase() == "input" || ((type == "hidden" || type == "file") && this.templateString == dijit.form.TextBox.prototype.templateString)){
				this.templateString = this._singleNodeTemplate;
			}
			this.inherited(arguments);
		},

		_setPlaceHolderAttr: function(v){
			this._set("placeHolder", v);
			if(!this._phspan){
				this._attachPoints.push('_phspan');
				/* dijitInputField class gives placeHolder same padding as the input field
				 * parent node already has dijitInputField class but it doesn't affect this <span>
				 * since it's position: absolute.
				 */
				this._phspan = dojo.create('span',{className:'dijitPlaceHolder dijitInputField'},this.textbox,'after');
			}
			this._phspan.innerHTML="";
			this._phspan.appendChild(document.createTextNode(v));
			
			this._updatePlaceHolder();
		},
		
		_updatePlaceHolder: function(){
			if(this._phspan){
				this._phspan.style.display=(this.placeHolder&&!this._focused&&!this.textbox.value)?"":"none";
			}
		},

		_getValueAttr: function(){
			// summary:
			//		Hook so get('value') works as we like.
			// description:
			//		For `dijit.form.TextBox` this basically returns the value of the <input>.
			//
			//		For `dijit.form.MappedTextBox` subclasses, which have both
			//		a "displayed value" and a separate "submit value",
			//		This treats the "displayed value" as the master value, computing the
			//		submit value from it via this.parse().
			return this.parse(this.get('displayedValue'), this.constraints);
		},

		_setValueAttr: function(value, /*Boolean?*/ priorityChange, /*String?*/ formattedValue){
			// summary:
			//		Hook so set('value', ...) works.
			//
			// description:
			//		Sets the value of the widget to "value" which can be of
			//		any type as determined by the widget.
			//
			// value:
			//		The visual element value is also set to a corresponding,
			//		but not necessarily the same, value.
			//
			// formattedValue:
			//		If specified, used to set the visual element value,
			//		otherwise a computed visual value is used.
			//
			// priorityChange:
			//		If true, an onChange event is fired immediately instead of
			//		waiting for the next blur event.

			var filteredValue;
			if(value !== undefined){
				// TODO: this is calling filter() on both the display value and the actual value.
				// I added a comment to the filter() definition about this, but it should be changed.
				filteredValue = this.filter(value);
				if(typeof formattedValue != "string"){
					if(filteredValue !== null && ((typeof filteredValue != "number") || !isNaN(filteredValue))){
						formattedValue = this.filter(this.format(filteredValue, this.constraints));
					}else{ formattedValue = ''; }
				}
			}
			if(formattedValue != null && formattedValue != undefined && ((typeof formattedValue) != "number" || !isNaN(formattedValue)) && this.textbox.value != formattedValue){
				this.textbox.value = formattedValue;
				this._set("displayedValue", this.get("displayedValue"));
			}

			this._updatePlaceHolder();

			this.inherited(arguments, [filteredValue, priorityChange]);
		},

		// displayedValue: String
		//		For subclasses like ComboBox where the displayed value
		//		(ex: Kentucky) and the serialized value (ex: KY) are different,
		//		this represents the displayed value.
		//
		//		Setting 'displayedValue' through set('displayedValue', ...)
		//		updates 'value', and vice-versa.  Otherwise 'value' is updated
		//		from 'displayedValue' periodically, like onBlur etc.
		//
		//		TODO: move declaration to MappedTextBox?
		//		Problem is that ComboBox references displayedValue,
		//		for benefit of FilteringSelect.
		displayedValue: "",

		getDisplayedValue: function(){
			// summary:
			//		Deprecated.  Use get('displayedValue') instead.
			// tags:
			//		deprecated
			dojo.deprecated(this.declaredClass+"::getDisplayedValue() is deprecated. Use set('displayedValue') instead.", "", "2.0");
			return this.get('displayedValue');
		},

		_getDisplayedValueAttr: function(){
			// summary:
			//		Hook so get('displayedValue') works.
			// description:
			//		Returns the displayed value (what the user sees on the screen),
			// 		after filtering (ie, trimming spaces etc.).
			//
			//		For some subclasses of TextBox (like ComboBox), the displayed value
			//		is different from the serialized value that's actually
			//		sent to the server (see dijit.form.ValidationTextBox.serialize)

			// TODO: maybe we should update this.displayedValue on every keystroke so that we don't need
			// this method
			// TODO: this isn't really the displayed value when the user is typing
			return this.filter(this.textbox.value);
		},

		setDisplayedValue: function(/*String*/ value){
			// summary:
			//		Deprecated.  Use set('displayedValue', ...) instead.
			// tags:
			//		deprecated
			dojo.deprecated(this.declaredClass+"::setDisplayedValue() is deprecated. Use set('displayedValue', ...) instead.", "", "2.0");
			this.set('displayedValue', value);
		},

		_setDisplayedValueAttr: function(/*String*/ value){
			// summary:
			//		Hook so set('displayedValue', ...) works.
			// description:
			//		Sets the value of the visual element to the string "value".
			//		The widget value is also set to a corresponding,
			//		but not necessarily the same, value.

			if(value === null || value === undefined){ value = '' }
			else if(typeof value != "string"){ value = String(value) }

			this.textbox.value = value;

			// sets the serialized value to something corresponding to specified displayedValue
			// (if possible), and also updates the textbox.value, for example converting "123"
			// to "123.00"
			this._setValueAttr(this.get('value'), undefined);

			this._set("displayedValue", this.get('displayedValue'));
		},

		format: function(/*String*/ value, /*Object*/ constraints){
			// summary:
			//		Replacable function to convert a value to a properly formatted string.
			// tags:
			//		protected extension
			return ((value == null || value == undefined) ? "" : (value.toString ? value.toString() : value));
		},

		parse: function(/*String*/ value, /*Object*/ constraints){
			// summary:
			//		Replacable function to convert a formatted string to a value
			// tags:
			//		protected extension

			return value;	// String
		},

		_refreshState: function(){
			// summary:
			//		After the user types some characters, etc., this method is
			//		called to check the field for validity etc.  The base method
			//		in `dijit.form.TextBox` does nothing, but subclasses override.
			// tags:
			//		protected
		},

		_onInput: function(e){
			if(e && e.type && /key/i.test(e.type) && e.keyCode){
				switch(e.keyCode){
					case dojo.keys.SHIFT:
					case dojo.keys.ALT:
					case dojo.keys.CTRL:
					case dojo.keys.TAB:
						return;
				}
			}
			if(this.intermediateChanges){
				var _this = this;
				// the setTimeout allows the key to post to the widget input box
				setTimeout(function(){ _this._handleOnChange(_this.get('value'), false); }, 0);
			}
			this._refreshState();

			// In case someone is watch()'ing for changes to displayedValue
			this._set("displayedValue", this.get("displayedValue"));
		},

		postCreate: function(){
			if(dojo.isIE){ // IE INPUT tag fontFamily has to be set directly using STYLE
				// the setTimeout gives IE a chance to render the TextBox and to deal with font inheritance
				setTimeout(dojo.hitch(this, function(){
				var s = dojo.getComputedStyle(this.domNode);
				if(s){
					var ff = s.fontFamily;
					if(ff){
						var inputs = this.domNode.getElementsByTagName("INPUT");
						if(inputs){
							for(var i=0; i < inputs.length; i++){
								inputs[i].style.fontFamily = ff;
							}
						}
					}
				}
				}), 0);
			}

			// setting the value here is needed since value="" in the template causes "undefined"
			// and setting in the DOM (instead of the JS object) helps with form reset actions
			this.textbox.setAttribute("value", this.textbox.value); // DOM and JS values should be the same

			this.inherited(arguments);

			if(dojo.isMoz || dojo.isOpera){
				this.connect(this.textbox, "oninput", "_onInput");
			}else{
				this.connect(this.textbox, "onkeydown", "_onInput");
				this.connect(this.textbox, "onkeyup", "_onInput");
				this.connect(this.textbox, "onpaste", "_onInput");
				this.connect(this.textbox, "oncut", "_onInput");
			}
		},

		_blankValue: '', // if the textbox is blank, what value should be reported
		filter: function(val){
			// summary:
			//		Auto-corrections (such as trimming) that are applied to textbox
			//		value on blur or form submit.
			// description:
			//		For MappedTextBox subclasses, this is called twice
			// 			- once with the display value
			//			- once the value as set/returned by set('value', ...)
			//		and get('value'), ex: a Number for NumberTextBox.
			//
			//		In the latter case it does corrections like converting null to NaN.  In
			//		the former case the NumberTextBox.filter() method calls this.inherited()
			//		to execute standard trimming code in TextBox.filter().
			//
			//		TODO: break this into two methods in 2.0
			//
			// tags:
			//		protected extension
			if(val === null){ return this._blankValue; }
			if(typeof val != "string"){ return val; }
			if(this.trim){
				val = dojo.trim(val);
			}
			if(this.uppercase){
				val = val.toUpperCase();
			}
			if(this.lowercase){
				val = val.toLowerCase();
			}
			if(this.propercase){
				val = val.replace(/[^\s]+/g, function(word){
					return word.substring(0,1).toUpperCase() + word.substring(1);
				});
			}
			return val;
		},

		_setBlurValue: function(){
			this._setValueAttr(this.get('value'), true);
		},

		_onBlur: function(e){
			if(this.disabled){ return; }
			this._setBlurValue();
			this.inherited(arguments);

			if(this._selectOnClickHandle){
				this.disconnect(this._selectOnClickHandle);
			}
			if(this.selectOnClick && dojo.isMoz){
				this.textbox.selectionStart = this.textbox.selectionEnd = undefined; // clear selection so that the next mouse click doesn't reselect
			}
			
			this._updatePlaceHolder();
		},

		_onFocus: function(/*String*/ by){
			if(this.disabled || this.readOnly){ return; }

			// Select all text on focus via click if nothing already selected.
			// Since mouse-up will clear the selection need to defer selection until after mouse-up.
			// Don't do anything on focus by tabbing into the widget since there's no associated mouse-up event.
			if(this.selectOnClick && by == "mouse"){
				this._selectOnClickHandle = this.connect(this.domNode, "onmouseup", function(){
					// Only select all text on first click; otherwise users would have no way to clear
					// the selection.
					this.disconnect(this._selectOnClickHandle);

					// Check if the user selected some text manually (mouse-down, mouse-move, mouse-up)
					// and if not, then select all the text
					var textIsNotSelected;
					if(dojo.isIE){
						var range = dojo.doc.selection.createRange();
						var parent = range.parentElement();
						textIsNotSelected = parent == this.textbox && range.text.length == 0;
					}else{
						textIsNotSelected = this.textbox.selectionStart == this.textbox.selectionEnd;
					}
					if(textIsNotSelected){
						dijit.selectInputText(this.textbox);
					}
				});
			}

			this._updatePlaceHolder();
			
			// call this.inherited() before refreshState(), since this.inherited() will possibly scroll the viewport
			// (to scroll the TextBox into view), which will affect how _refreshState() positions the tooltip
			this.inherited(arguments);

			this._refreshState();
		},

		reset: function(){
			// Overrides dijit._FormWidget.reset().
			// Additionally resets the displayed textbox value to ''
			this.textbox.value = '';
			this.inherited(arguments);
		}
	}
);

dijit.selectInputText = function(/*DomNode*/ element, /*Number?*/ start, /*Number?*/ stop){
	// summary:
	//		Select text in the input element argument, from start (default 0), to stop (default end).

	// TODO: use functions in _editor/selection.js?
	var _window = dojo.global;
	var _document = dojo.doc;
	element = dojo.byId(element);
	if(isNaN(start)){ start = 0; }
	if(isNaN(stop)){ stop = element.value ? element.value.length : 0; }
	dijit.focus(element);
	if(_document["selection"] && dojo.body()["createTextRange"]){ // IE
		if(element.createTextRange){
			var r = element.createTextRange();
			r.collapse(true);
			r.moveStart("character", -99999); // move to 0
			r.moveStart("character", start); // delta from 0 is the correct position
			r.moveEnd("character", stop-start);
			r.select();
		}
	}else if(_window["getSelection"]){
		if(element.setSelectionRange){
			element.setSelectionRange(start, stop);
		}
	}
};

}

if(!dojo._hasResource["dijit.form.SimpleTextarea"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.SimpleTextarea"] = true;
dojo.provide("dijit.form.SimpleTextarea");



dojo.declare("dijit.form.SimpleTextarea",
	dijit.form.TextBox,
	{
	// summary:
	//		A simple textarea that degrades, and responds to
	// 		minimal LayoutContainer usage, and works with dijit.form.Form.
	//		Doesn't automatically size according to input, like Textarea.
	//
	// example:
	//	|	<textarea dojoType="dijit.form.SimpleTextarea" name="foo" value="bar" rows=30 cols=40></textarea>
	//
	// example:
	//	|	new dijit.form.SimpleTextarea({ rows:20, cols:30 }, "foo");

	baseClass: "dijitTextBox dijitTextArea",

	attributeMap: dojo.delegate(dijit.form._FormValueWidget.prototype.attributeMap, {
		rows:"textbox", cols: "textbox"
	}),

	// rows: Number
	//		The number of rows of text.
	rows: "3",

	// rows: Number
	//		The number of characters per line.
	cols: "20",

	templateString: "<textarea ${!nameAttrSetting} dojoAttachPoint='focusNode,containerNode,textbox' autocomplete='off'></textarea>",

	postMixInProperties: function(){
		// Copy value from srcNodeRef, unless user specified a value explicitly (or there is no srcNodeRef)
		// TODO: parser will handle this in 2.0
		if(!this.value && this.srcNodeRef){
			this.value = this.srcNodeRef.value;
		}
		this.inherited(arguments);
	},

	buildRendering: function(){
		this.inherited(arguments);
		if(dojo.isIE && this.cols){ // attribute selectors is not supported in IE6
			dojo.addClass(this.textbox, "dijitTextAreaCols");
		}
	},

	filter: function(/*String*/ value){
		// Override TextBox.filter to deal with newlines... specifically (IIRC) this is for IE which writes newlines
		// as \r\n instead of just \n
		if(value){
			value = value.replace(/\r/g,"");
		}
		return this.inherited(arguments);
	},

	_previousValue: "",
	_onInput: function(/*Event?*/ e){
		// Override TextBox._onInput() to enforce maxLength restriction
		if(this.maxLength){
			var maxLength = parseInt(this.maxLength);
			var value = this.textbox.value.replace(/\r/g,'');
			var overflow = value.length - maxLength;
			if(overflow > 0){
				if(e){ dojo.stopEvent(e); }
				var textarea = this.textbox;
				if(textarea.selectionStart){
					var pos = textarea.selectionStart;
					var cr = 0;
					if(dojo.isOpera){
						cr = (this.textbox.value.substring(0,pos).match(/\r/g) || []).length;
					}
					this.textbox.value = value.substring(0,pos-overflow-cr)+value.substring(pos-cr);
					textarea.setSelectionRange(pos-overflow, pos-overflow);
				}else if(dojo.doc.selection){ //IE
					textarea.focus();
					var range = dojo.doc.selection.createRange();
					// delete overflow characters
					range.moveStart("character", -overflow);
					range.text = '';
					// show cursor
					range.select();
				}
			}
			this._previousValue = this.textbox.value;
		}
		this.inherited(arguments);
	}
});

}

if(!dojo._hasResource["dijit.form.Textarea"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.Textarea"] = true;
dojo.provide("dijit.form.Textarea");



dojo.declare(
	"dijit.form.Textarea",
	dijit.form.SimpleTextarea,
	{
	// summary:
	//		A textarea widget that adjusts it's height according to the amount of data.
	//
	// description:
	//		A textarea that dynamically expands/contracts (changing it's height) as
	//		the user types, to display all the text without requiring a scroll bar.
	//
	//		Takes nearly all the parameters (name, value, etc.) that a vanilla textarea takes.
	//		Rows is not supported since this widget adjusts the height.
	//
	// example:
	// |	<textarea dojoType="dijit.form.TextArea">...</textarea>


	// TODO: for 2.0, rename this to ExpandingTextArea, and rename SimpleTextarea to Textarea

	baseClass: "dijitTextBox dijitTextArea dijitExpandingTextArea",

	// Override SimpleTextArea.cols to default to width:100%, for backward compatibility
	cols: "",

	_previousNewlines: 0,
	_strictMode: (dojo.doc.compatMode != 'BackCompat'), // not the same as !dojo.isQuirks

	_getHeight: function(textarea){
		var newH = textarea.scrollHeight;
		if(dojo.isIE){
			newH += textarea.offsetHeight - textarea.clientHeight - ((dojo.isIE < 8 && this._strictMode) ? dojo._getPadBorderExtents(textarea).h : 0);
		}else if(dojo.isMoz){
			newH += textarea.offsetHeight - textarea.clientHeight; // creates room for horizontal scrollbar
		}else if(dojo.isWebKit){
			newH += dojo._getBorderExtents(textarea).h;
		}else{ // Opera 9.6 (TODO: test if this is still needed)
			newH += dojo._getPadBorderExtents(textarea).h;
		}
		return newH;
	},

	_estimateHeight: function(textarea){
		// summary:
		// 		Approximate the height when the textarea is invisible with the number of lines in the text.
		// 		Fails when someone calls setValue with a long wrapping line, but the layout fixes itself when the user clicks inside so . . .
		// 		In IE, the resize event is supposed to fire when the textarea becomes visible again and that will correct the size automatically.
		//
		textarea.style.maxHeight = "";
		textarea.style.height = "auto";
		// #rows = #newlines+1
		// Note: on Moz, the following #rows appears to be 1 too many.
		// Actually, Moz is reserving room for the scrollbar.
		// If you increase the font size, this behavior becomes readily apparent as the last line gets cut off without the +1.
		textarea.rows = (textarea.value.match(/\n/g) || []).length + 1;
	},

	_needsHelpShrinking: dojo.isMoz || dojo.isWebKit,

	_onInput: function(){
		// Override SimpleTextArea._onInput() to deal with height adjustment
		this.inherited(arguments);
		if(this._busyResizing){ return; }
		this._busyResizing = true;
		var textarea = this.textbox;
		if(textarea.scrollHeight && textarea.offsetHeight && textarea.clientHeight){
			var newH = this._getHeight(textarea) + "px";
			if(textarea.style.height != newH){
				textarea.style.maxHeight = textarea.style.height = newH;
			}
			if(this._needsHelpShrinking){
				if(this._setTimeoutHandle){
					clearTimeout(this._setTimeoutHandle);
				}
				this._setTimeoutHandle = setTimeout(dojo.hitch(this, "_shrink"), 0); // try to collapse multiple shrinks into 1
			}
		}else{
			// hidden content of unknown size
			this._estimateHeight(textarea);
		}
		this._busyResizing = false;
	},

	_busyResizing: false,
	_shrink: function(){
		// grow paddingBottom to see if scrollHeight shrinks (when it is unneccesarily big)
		this._setTimeoutHandle = null;
		if(this._needsHelpShrinking && !this._busyResizing){
			this._busyResizing = true;
			var textarea = this.textbox;
			var empty = false;
			if(textarea.value == ''){
				textarea.value = ' '; // prevent collapse all the way back to 0
				empty = true;
			}
			var scrollHeight = textarea.scrollHeight;
			if(!scrollHeight){
				this._estimateHeight(textarea);
			}else{
				var oldPadding = textarea.style.paddingBottom;
				var newPadding = dojo._getPadExtents(textarea);
				newPadding = newPadding.h - newPadding.t;
				textarea.style.paddingBottom = newPadding + 1 + "px"; // tweak padding to see if height can be reduced
				var newH = this._getHeight(textarea) - 1 + "px"; // see if the height changed by the 1px added
				if(textarea.style.maxHeight != newH){ // if can be reduced, so now try a big chunk
					textarea.style.paddingBottom = newPadding + scrollHeight + "px";
					textarea.scrollTop = 0;
					textarea.style.maxHeight = this._getHeight(textarea) - scrollHeight + "px"; // scrollHeight is the added padding
				}
				textarea.style.paddingBottom = oldPadding;
			}
			if(empty){
				textarea.value = '';
			}
			this._busyResizing = false;
		}
	},

	resize: function(){
		// summary:
		//		Resizes the textarea vertically (should be called after a style/value change)
		this._onInput();
	},

	_setValueAttr: function(){
		this.inherited(arguments);
		this.resize();
	},

	buildRendering: function(){
		this.inherited(arguments);

		// tweak textarea style to reduce browser differences
		dojo.style(this.textbox, { overflowY: 'hidden', overflowX: 'auto', boxSizing: 'border-box', MsBoxSizing: 'border-box', WebkitBoxSizing: 'border-box', MozBoxSizing: 'border-box' });
	},

	postCreate: function(){
		this.inherited(arguments);

		this.connect(this.textbox, "onscroll", "_onInput");
		this.connect(this.textbox, "onresize", "_onInput");
		this.connect(this.textbox, "onfocus", "_onInput"); // useful when a previous estimate was off a bit
		this._setTimeoutHandle = setTimeout(dojo.hitch(this, "resize"), 0);
	},

	uninitialize: function(){
		if(this._setTimeoutHandle){
			clearTimeout(this._setTimeoutHandle);
		}
		this.inherited(arguments);
	}
});

}

if(!dojo._hasResource["dojo.dnd.common"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.common"] = true;
dojo.provide("dojo.dnd.common");

dojo.getObject("dnd", true, dojo);

dojo.dnd.getCopyKeyState = dojo.isCopyKey;

dojo.dnd._uniqueId = 0;
dojo.dnd.getUniqueId = function(){
	// summary:
	//		returns a unique string for use with any DOM element
	var id;
	do{
		id = dojo._scopeName + "Unique" + (++dojo.dnd._uniqueId);
	}while(dojo.byId(id));
	return id;
};

dojo.dnd._empty = {};

dojo.dnd.isFormElement = function(/*Event*/ e){
	// summary:
	//		returns true if user clicked on a form element
	var t = e.target;
	if(t.nodeType == 3 /*TEXT_NODE*/){
		t = t.parentNode;
	}
	return " button textarea input select option ".indexOf(" " + t.tagName.toLowerCase() + " ") >= 0;	// Boolean
};

}

if(!dojo._hasResource["dojo.dnd.Container"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.Container"] = true;
dojo.provide("dojo.dnd.Container");




/*
	Container states:
		""		- normal state
		"Over"	- mouse over a container
	Container item states:
		""		- normal state
		"Over"	- mouse over a container item
*/

/*=====
dojo.declare("dojo.dnd.__ContainerArgs", [], {
	creator: function(){
		// summary:
		//		a creator function, which takes a data item, and returns an object like that:
		//		{node: newNode, data: usedData, type: arrayOfStrings}
	},

	// skipForm: Boolean
	//		don't start the drag operation, if clicked on form elements
	skipForm: false,

	// dropParent: Node||String
	//		node or node's id to use as the parent node for dropped items
	//		(must be underneath the 'node' parameter in the DOM)
	dropParent: null,

	// _skipStartup: Boolean
	//		skip startup(), which collects children, for deferred initialization
	//		(this is used in the markup mode)
	_skipStartup: false
});

dojo.dnd.Item = function(){
	// summary:
	//		Represents (one of) the source node(s) being dragged.
	//		Contains (at least) the "type" and "data" attributes.
	// type: String[]
	//		Type(s) of this item, by default this is ["text"]
	// data: Object
	//		Logical representation of the object being dragged.
	//		If the drag object's type is "text" then data is a String,
	//		if it's another type then data could be a different Object,
	//		perhaps a name/value hash.
	
	this.type = type;
	this.data = data;
}
=====*/

dojo.declare("dojo.dnd.Container", null, {
	// summary:
	//		a Container object, which knows when mouse hovers over it,
	//		and over which element it hovers
	
	// object attributes (for markup)
	skipForm: false,
	
	/*=====
	// current: DomNode
	//		The DOM node the mouse is currently hovered over
	current: null,
	
	// map: Hash<String, dojo.dnd.Item>
	//		Map from an item's id (which is also the DOMNode's id) to
	//		the dojo.dnd.Item itself.
	map: {},
	=====*/
	
	constructor: function(node, params){
		// summary:
		//		a constructor of the Container
		// node: Node
		//		node or node's id to build the container on
		// params: dojo.dnd.__ContainerArgs
		//		a dictionary of parameters
		this.node = dojo.byId(node);
		if(!params){ params = {}; }
		this.creator = params.creator || null;
		this.skipForm = params.skipForm;
		this.parent = params.dropParent && dojo.byId(params.dropParent);
		
		// class-specific variables
		this.map = {};
		this.current = null;

		// states
		this.containerState = "";
		dojo.addClass(this.node, "dojoDndContainer");
		
		// mark up children
		if(!(params && params._skipStartup)){
			this.startup();
		}

		// set up events
		this.events = [
			dojo.connect(this.node, "onmouseover", this, "onMouseOver"),
			dojo.connect(this.node, "onmouseout",  this, "onMouseOut"),
			// cancel text selection and text dragging
			dojo.connect(this.node, "ondragstart",   this, "onSelectStart"),
			dojo.connect(this.node, "onselectstart", this, "onSelectStart")
		];
	},
	
	// object attributes (for markup)
	creator: function(){
		// summary:
		//		creator function, dummy at the moment
	},
	
	// abstract access to the map
	getItem: function(/*String*/ key){
		// summary:
		//		returns a data item by its key (id)
		return this.map[key];	// dojo.dnd.Item
	},
	setItem: function(/*String*/ key, /*dojo.dnd.Item*/ data){
		// summary:
		//		associates a data item with its key (id)
		this.map[key] = data;
	},
	delItem: function(/*String*/ key){
		// summary:
		//		removes a data item from the map by its key (id)
		delete this.map[key];
	},
	forInItems: function(/*Function*/ f, /*Object?*/ o){
		// summary:
		//		iterates over a data map skipping members that
		//		are present in the empty object (IE and/or 3rd-party libraries).
		o = o || dojo.global;
		var m = this.map, e = dojo.dnd._empty;
		for(var i in m){
			if(i in e){ continue; }
			f.call(o, m[i], i, this);
		}
		return o;	// Object
	},
	clearItems: function(){
		// summary:
		//		removes all data items from the map
		this.map = {};
	},
	
	// methods
	getAllNodes: function(){
		// summary:
		//		returns a list (an array) of all valid child nodes
		return dojo.query("> .dojoDndItem", this.parent);	// NodeList
	},
	sync: function(){
		// summary:
		//		sync up the node list with the data map
		var map = {};
		this.getAllNodes().forEach(function(node){
			if(node.id){
				var item = this.getItem(node.id);
				if(item){
					map[node.id] = item;
					return;
				}
			}else{
				node.id = dojo.dnd.getUniqueId();
			}
			var type = node.getAttribute("dndType"),
				data = node.getAttribute("dndData");
			map[node.id] = {
				data: data || node.innerHTML,
				type: type ? type.split(/\s*,\s*/) : ["text"]
			};
		}, this);
		this.map = map;
		return this;	// self
	},
	insertNodes: function(data, before, anchor){
		// summary:
		//		inserts an array of new nodes before/after an anchor node
		// data: Array
		//		a list of data items, which should be processed by the creator function
		// before: Boolean
		//		insert before the anchor, if true, and after the anchor otherwise
		// anchor: Node
		//		the anchor node to be used as a point of insertion
		if(!this.parent.firstChild){
			anchor = null;
		}else if(before){
			if(!anchor){
				anchor = this.parent.firstChild;
			}
		}else{
			if(anchor){
				anchor = anchor.nextSibling;
			}
		}
		if(anchor){
			for(var i = 0; i < data.length; ++i){
				var t = this._normalizedCreator(data[i]);
				this.setItem(t.node.id, {data: t.data, type: t.type});
				this.parent.insertBefore(t.node, anchor);
			}
		}else{
			for(var i = 0; i < data.length; ++i){
				var t = this._normalizedCreator(data[i]);
				this.setItem(t.node.id, {data: t.data, type: t.type});
				this.parent.appendChild(t.node);
			}
		}
		return this;	// self
	},
	destroy: function(){
		// summary:
		//		prepares this object to be garbage-collected
		dojo.forEach(this.events, dojo.disconnect);
		this.clearItems();
		this.node = this.parent = this.current = null;
	},

	// markup methods
	markupFactory: function(params, node){
		params._skipStartup = true;
		return new dojo.dnd.Container(node, params);
	},

	startup: function(){
		// summary:
		//		collects valid child items and populate the map
		
		// set up the real parent node
		if(!this.parent){
			// use the standard algorithm, if not assigned
			this.parent = this.node;
			
			//console.log("dojo.dnd.Container.startup    dojo.dnd.Container.startup()");
			//console.log("dojo.dnd.Container.startup    console.dir(this.parent):");
			//console.dir({parent: this.parent});

			if(this.parent.tagName.toLowerCase() == "table"){
				var c = this.parent.getElementsByTagName("tbody");
				if(c && c.length){ this.parent = c[0]; }
			}
		}
		this.defaultCreator = dojo.dnd._defaultCreator(this.parent);

		// process specially marked children
		this.sync();
	},

	// mouse events
	onMouseOver: function(e){
		// summary:
		//		event processor for onmouseover
		// e: Event
		//		mouse event
		var n = e.relatedTarget;
		while(n){
			if(n == this.node){ break; }
			try{
				n = n.parentNode;
			}catch(x){
				n = null;
			}
		}
		if(!n){
			this._changeState("Container", "Over");
			this.onOverEvent();
		}
		n = this._getChildByEvent(e);
		if(this.current == n){ return; }
		if(this.current){ this._removeItemClass(this.current, "Over"); }
		if(n){ this._addItemClass(n, "Over"); }
		this.current = n;
	},
	onMouseOut: function(e){
		// summary:
		//		event processor for onmouseout
		// e: Event
		//		mouse event
		for(var n = e.relatedTarget; n;){
			if(n == this.node){ return; }
			try{
				n = n.parentNode;
			}catch(x){
				n = null;
			}
		}
		if(this.current){
			this._removeItemClass(this.current, "Over");
			this.current = null;
		}
		this._changeState("Container", "");
		this.onOutEvent();
	},
	onSelectStart: function(e){
		// summary:
		//		event processor for onselectevent and ondragevent
		// e: Event
		//		mouse event
		if(!this.skipForm || !dojo.dnd.isFormElement(e)){
			dojo.stopEvent(e);
		}
	},
	
	// utilities
	onOverEvent: function(){
		// summary:
		//		this function is called once, when mouse is over our container
	},
	onOutEvent: function(){
		// summary:
		//		this function is called once, when mouse is out of our container
	},
	_changeState: function(type, newState){
		// summary:
		//		changes a named state to new state value
		// type: String
		//		a name of the state to change
		// newState: String
		//		new state
		var prefix = "dojoDnd" + type;
		var state  = type.toLowerCase() + "State";
		//dojo.replaceClass(this.node, prefix + newState, prefix + this[state]);
		dojo.replaceClass(this.node, prefix + newState, prefix + this[state]);
		this[state] = newState;
	},
	_addItemClass: function(node, type){
		// summary:
		//		adds a class with prefix "dojoDndItem"
		// node: Node
		//		a node
		// type: String
		//		a variable suffix for a class name
		dojo.addClass(node, "dojoDndItem" + type);
	},
	_removeItemClass: function(node, type){
		// summary:
		//		removes a class with prefix "dojoDndItem"
		// node: Node
		//		a node
		// type: String
		//		a variable suffix for a class name
		dojo.removeClass(node, "dojoDndItem" + type);
	},
	_getChildByEvent: function(e){
		// summary:
		//		gets a child, which is under the mouse at the moment, or null
		// e: Event
		//		a mouse event
		var node = e.target;
		if(node){
			for(var parent = node.parentNode; parent; node = parent, parent = node.parentNode){
				if(parent == this.parent && dojo.hasClass(node, "dojoDndItem")){ return node; }
			}
		}
		return null;
	},
	_normalizedCreator: function(/*dojo.dnd.Item*/ item, /*String*/ hint){
		// summary:
		//		adds all necessary data to the output of the user-supplied creator function
		var t = (this.creator || this.defaultCreator).call(this, item, hint);
		if(!dojo.isArray(t.type)){ t.type = ["text"]; }
		if(!t.node.id){ t.node.id = dojo.dnd.getUniqueId(); }
		dojo.addClass(t.node, "dojoDndItem");
		return t;
	}
});

dojo.dnd._createNode = function(tag){
	// summary:
	//		returns a function, which creates an element of given tag
	//		(SPAN by default) and sets its innerHTML to given text
	// tag: String
	//		a tag name or empty for SPAN
	if(!tag){ return dojo.dnd._createSpan; }
	return function(text){	// Function
		return dojo.create(tag, {innerHTML: text});	// Node
	};
};

dojo.dnd._createTrTd = function(text){
	// summary:
	//		creates a TR/TD structure with given text as an innerHTML of TD
	// text: String
	//		a text for TD
	var tr = dojo.create("tr");
	dojo.create("td", {innerHTML: text}, tr);
	return tr;	// Node
};

dojo.dnd._createSpan = function(text){
	// summary:
	//		creates a SPAN element with given text as its innerHTML
	// text: String
	//		a text for SPAN
	return dojo.create("span", {innerHTML: text});	// Node
};

// dojo.dnd._defaultCreatorNodes: Object
//		a dictionary that maps container tag names to child tag names
dojo.dnd._defaultCreatorNodes = {ul: "li", ol: "li", div: "div", p: "div"};

dojo.dnd._defaultCreator = function(node){
	// summary:
	//		takes a parent node, and returns an appropriate creator function
	// node: Node
	//		a container node
	var tag = node.tagName.toLowerCase();
	var c = tag == "tbody" || tag == "thead" ? dojo.dnd._createTrTd :
			dojo.dnd._createNode(dojo.dnd._defaultCreatorNodes[tag]);
	return function(item, hint){	// Function
		var isObj = item && dojo.isObject(item), data, type, n;
		if(isObj && item.tagName && item.nodeType && item.getAttribute){
			// process a DOM node
			data = item.getAttribute("dndData") || item.innerHTML;
			type = item.getAttribute("dndType");
			type = type ? type.split(/\s*,\s*/) : ["text"];
			n = item;	// this node is going to be moved rather than copied
		}else{
			// process a DnD item object or a string
			data = (isObj && item.data) ? item.data : item;
			type = (isObj && item.type) ? item.type : ["text"];
			n = (hint == "avatar" ? dojo.dnd._createSpan : c)(String(data));
		}
		if(!n.id){
			n.id = dojo.dnd.getUniqueId();
		}
		return {node: n, data: data, type: type};
	};
};

}

if(!dojo._hasResource["dojo.dnd.Selector"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.Selector"] = true;
dojo.provide("dojo.dnd.Selector");




/*
	Container item states:
		""			- an item is not selected
		"Selected"	- an item is selected
		"Anchor"	- an item is selected, and is an anchor for a "shift" selection
*/

/*=====
dojo.declare("dojo.dnd.__SelectorArgs", [dojo.dnd.__ContainerArgs], {
	//	singular: Boolean
	//		allows selection of only one element, if true
	singular: false,

	//	autoSync: Boolean
	//		autosynchronizes the source with its list of DnD nodes,
	autoSync: false
});
=====*/

dojo.declare("dojo.dnd.Selector", dojo.dnd.Container, {
	// summary:
	//		a Selector object, which knows how to select its children
	
	/*=====
	// selection: Set<String>
	//		The set of id's that are currently selected, such that this.selection[id] == 1
	//		if the node w/that id is selected.  Can iterate over selected node's id's like:
	//	|		for(var id in this.selection)
	selection: {},
	=====*/

	constructor: function(node, params){
		// summary:
		//		constructor of the Selector
		// node: Node||String
		//		node or node's id to build the selector on
		// params: dojo.dnd.__SelectorArgs?
		//		a dictionary of parameters
		if(!params){ params = {}; }
		this.singular = params.singular;
		this.autoSync = params.autoSync;
		// class-specific variables
		this.selection = {};
		this.anchor = null;
		this.simpleSelection = false;
		// set up events
		this.events.push(
			dojo.connect(this.node, "onmousedown", this, "onMouseDown"),
			dojo.connect(this.node, "onmouseup",   this, "onMouseUp"));
	},
	
	// object attributes (for markup)
	singular: false,	// is singular property
	
	// methods
	getSelectedNodes: function(){
		// summary:
		//		returns a list (an array) of selected nodes
		var t = new dojo.NodeList();
		var e = dojo.dnd._empty;
		for(var i in this.selection){
			if(i in e){ continue; }
			t.push(dojo.byId(i));
		}
		return t;	// NodeList
	},
	selectNone: function(){
		// summary:
		//		unselects all items
		return this._removeSelection()._removeAnchor();	// self
	},
	selectAll: function(){
		// summary:
		//		selects all items
		this.forInItems(function(data, id){
			this._addItemClass(dojo.byId(id), "Selected");
			this.selection[id] = 1;
		}, this);
		return this._removeAnchor();	// self
	},
	deleteSelectedNodes: function(){
		// summary:
		//		deletes all selected items
		var e = dojo.dnd._empty;
		for(var i in this.selection){
			if(i in e){ continue; }
			var n = dojo.byId(i);
			this.delItem(i);
			dojo.destroy(n);
		}
		this.anchor = null;
		this.selection = {};
		return this;	// self
	},
	forInSelectedItems: function(/*Function*/ f, /*Object?*/ o){
		// summary:
		//		iterates over selected items;
		//		see `dojo.dnd.Container.forInItems()` for details
		o = o || dojo.global;
		var s = this.selection, e = dojo.dnd._empty;
		for(var i in s){
			if(i in e){ continue; }
			f.call(o, this.getItem(i), i, this);
		}
	},
	sync: function(){
		// summary:
		//		sync up the node list with the data map
		
		dojo.dnd.Selector.superclass.sync.call(this);
		
		// fix the anchor
		if(this.anchor){
			if(!this.getItem(this.anchor.id)){
				this.anchor = null;
			}
		}
		
		// fix the selection
		var t = [], e = dojo.dnd._empty;
		for(var i in this.selection){
			if(i in e){ continue; }
			if(!this.getItem(i)){
				t.push(i);
			}
		}
		dojo.forEach(t, function(i){
			delete this.selection[i];
		}, this);
		
		return this;	// self
	},
	insertNodes: function(addSelected, data, before, anchor){
		// summary:
		//		inserts new data items (see `dojo.dnd.Container.insertNodes()` method for details)
		// addSelected: Boolean
		//		all new nodes will be added to selected items, if true, no selection change otherwise
		// data: Array
		//		a list of data items, which should be processed by the creator function
		// before: Boolean
		//		insert before the anchor, if true, and after the anchor otherwise
		// anchor: Node
		//		the anchor node to be used as a point of insertion
		var oldCreator = this._normalizedCreator;
		this._normalizedCreator = function(item, hint){
			var t = oldCreator.call(this, item, hint);
			if(addSelected){
				if(!this.anchor){
					this.anchor = t.node;
					this._removeItemClass(t.node, "Selected");
					this._addItemClass(this.anchor, "Anchor");
				}else if(this.anchor != t.node){
					this._removeItemClass(t.node, "Anchor");
					this._addItemClass(t.node, "Selected");
				}
				this.selection[t.node.id] = 1;
			}else{
				this._removeItemClass(t.node, "Selected");
				this._removeItemClass(t.node, "Anchor");
			}
			return t;
		};
		dojo.dnd.Selector.superclass.insertNodes.call(this, data, before, anchor);
		this._normalizedCreator = oldCreator;
		return this;	// self
	},
	destroy: function(){
		// summary:
		//		prepares the object to be garbage-collected
		dojo.dnd.Selector.superclass.destroy.call(this);
		this.selection = this.anchor = null;
	},

	// markup methods
	markupFactory: function(params, node){
		params._skipStartup = true;
		return new dojo.dnd.Selector(node, params);
	},

	// mouse events
	onMouseDown: function(e){
		// summary:
		//		event processor for onmousedown
		// e: Event
		//		mouse event
		if(this.autoSync){ this.sync(); }
		if(!this.current){ return; }
		if(!this.singular && !dojo.isCopyKey(e) && !e.shiftKey && (this.current.id in this.selection)){
			this.simpleSelection = true;
			if(e.button === dojo.mouseButtons.LEFT){
				// accept the left button and stop the event
				// for IE we don't stop event when multiple buttons are pressed
				dojo.stopEvent(e);
			}
			return;
		}
		if(!this.singular && e.shiftKey){
			if(!dojo.isCopyKey(e)){
				this._removeSelection();
			}
			var c = this.getAllNodes();
			if(c.length){
				if(!this.anchor){
					this.anchor = c[0];
					this._addItemClass(this.anchor, "Anchor");
				}
				this.selection[this.anchor.id] = 1;
				if(this.anchor != this.current){
					var i = 0;
					for(; i < c.length; ++i){
						var node = c[i];
						if(node == this.anchor || node == this.current){ break; }
					}
					for(++i; i < c.length; ++i){
						var node = c[i];
						if(node == this.anchor || node == this.current){ break; }
						this._addItemClass(node, "Selected");
						this.selection[node.id] = 1;
					}
					this._addItemClass(this.current, "Selected");
					this.selection[this.current.id] = 1;
				}
			}
		}else{
			if(this.singular){
				if(this.anchor == this.current){
					if(dojo.isCopyKey(e)){
						this.selectNone();
					}
				}else{
					this.selectNone();
					this.anchor = this.current;
					this._addItemClass(this.anchor, "Anchor");
					this.selection[this.current.id] = 1;
				}
			}else{
				if(dojo.isCopyKey(e)){
					if(this.anchor == this.current){
						delete this.selection[this.anchor.id];
						this._removeAnchor();
					}else{
						if(this.current.id in this.selection){
							this._removeItemClass(this.current, "Selected");
							delete this.selection[this.current.id];
						}else{
							if(this.anchor){
								this._removeItemClass(this.anchor, "Anchor");
								this._addItemClass(this.anchor, "Selected");
							}
							this.anchor = this.current;
							this._addItemClass(this.current, "Anchor");
							this.selection[this.current.id] = 1;
						}
					}
				}else{
					if(!(this.current.id in this.selection)){
						this.selectNone();
						this.anchor = this.current;
						this._addItemClass(this.current, "Anchor");
						this.selection[this.current.id] = 1;
					}
				}
			}
		}
		dojo.stopEvent(e);
	},
	onMouseUp: function(e){
		// summary:
		//		event processor for onmouseup
		// e: Event
		//		mouse event
		if(!this.simpleSelection){ return; }
		this.simpleSelection = false;
		this.selectNone();
		if(this.current){
			this.anchor = this.current;
			this._addItemClass(this.anchor, "Anchor");
			this.selection[this.current.id] = 1;
		}
	},
	onMouseMove: function(e){
		// summary
		//		event processor for onmousemove
		// e: Event
		//		mouse event
		this.simpleSelection = false;
	},
	
	// utilities
	onOverEvent: function(){
		// summary:
		//		this function is called once, when mouse is over our container
		this.onmousemoveEvent = dojo.connect(this.node, "onmousemove", this, "onMouseMove");
	},
	onOutEvent: function(){
		// summary:
		//		this function is called once, when mouse is out of our container
		dojo.disconnect(this.onmousemoveEvent);
		delete this.onmousemoveEvent;
	},
	_removeSelection: function(){
		
		console.log("dojo.dnd.Selector._removeSelection    this.selection:");
		console.dir({this_selection:this.selection});
		
		// summary:
		//		unselects all items
		var e = dojo.dnd._empty;
		for(var i in this.selection){
			if(i in e){ continue; }
			var node = dojo.byId(i);
			if(node){ this._removeItemClass(node, "Selected"); }
		}
		this.selection = {};
		return this;	// self
	},
	_removeAnchor: function(){
		if(this.anchor){
			this._removeItemClass(this.anchor, "Anchor");
			this.anchor = null;
		}
		return this;	// self
	}
});

}

if(!dojo._hasResource["dojo.dnd.autoscroll"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.autoscroll"] = true;
dojo.provide("dojo.dnd.autoscroll");


dojo.getObject("dnd", true, dojo);

dojo.dnd.getViewport = dojo.window.getBox;

dojo.dnd.V_TRIGGER_AUTOSCROLL = 32;
dojo.dnd.H_TRIGGER_AUTOSCROLL = 32;

dojo.dnd.V_AUTOSCROLL_VALUE = 16;
dojo.dnd.H_AUTOSCROLL_VALUE = 16;

dojo.dnd.autoScroll = function(e){
	// summary:
	//		a handler for onmousemove event, which scrolls the window, if
	//		necesary
	// e: Event
	//		onmousemove event

	// FIXME: needs more docs!
	var v = dojo.window.getBox(), dx = 0, dy = 0;
	if(e.clientX < dojo.dnd.H_TRIGGER_AUTOSCROLL){
		dx = -dojo.dnd.H_AUTOSCROLL_VALUE;
	}else if(e.clientX > v.w - dojo.dnd.H_TRIGGER_AUTOSCROLL){
		dx = dojo.dnd.H_AUTOSCROLL_VALUE;
	}
	if(e.clientY < dojo.dnd.V_TRIGGER_AUTOSCROLL){
		dy = -dojo.dnd.V_AUTOSCROLL_VALUE;
	}else if(e.clientY > v.h - dojo.dnd.V_TRIGGER_AUTOSCROLL){
		dy = dojo.dnd.V_AUTOSCROLL_VALUE;
	}
	window.scrollBy(dx, dy);
};

dojo.dnd._validNodes = {"div": 1, "p": 1, "td": 1};
dojo.dnd._validOverflow = {"auto": 1, "scroll": 1};

dojo.dnd.autoScrollNodes = function(e){
	// summary:
	//		a handler for onmousemove event, which scrolls the first avaialble
	//		Dom element, it falls back to dojo.dnd.autoScroll()
	// e: Event
	//		onmousemove event

	// FIXME: needs more docs!
	for(var n = e.target; n;){
		if(n.nodeType == 1 && (n.tagName.toLowerCase() in dojo.dnd._validNodes)){
			var s = dojo.getComputedStyle(n);
			if(s.overflow.toLowerCase() in dojo.dnd._validOverflow){
				var b = dojo._getContentBox(n, s), t = dojo.position(n, true);
				//console.log(b.l, b.t, t.x, t.y, n.scrollLeft, n.scrollTop);
				var w = Math.min(dojo.dnd.H_TRIGGER_AUTOSCROLL, b.w / 2),
					h = Math.min(dojo.dnd.V_TRIGGER_AUTOSCROLL, b.h / 2),
					rx = e.pageX - t.x, ry = e.pageY - t.y, dx = 0, dy = 0;
				if(dojo.isWebKit || dojo.isOpera){
					// FIXME: this code should not be here, it should be taken into account
					// either by the event fixing code, or the dojo.position()
					// FIXME: this code doesn't work on Opera 9.5 Beta
					rx += dojo.body().scrollLeft;
					ry += dojo.body().scrollTop;
				}
				if(rx > 0 && rx < b.w){
					if(rx < w){
						dx = -w;
					}else if(rx > b.w - w){
						dx = w;
					}
				}
				//console.log("ry =", ry, "b.h =", b.h, "h =", h);
				if(ry > 0 && ry < b.h){
					if(ry < h){
						dy = -h;
					}else if(ry > b.h - h){
						dy = h;
					}
				}
				var oldLeft = n.scrollLeft, oldTop = n.scrollTop;
				n.scrollLeft = n.scrollLeft + dx;
				n.scrollTop  = n.scrollTop  + dy;
				if(oldLeft != n.scrollLeft || oldTop != n.scrollTop){ return; }
			}
		}
		try{
			n = n.parentNode;
		}catch(x){
			n = null;
		}
	}
	dojo.dnd.autoScroll(e);
};

}

if(!dojo._hasResource["dojo.dnd.Avatar"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.Avatar"] = true;
dojo.provide("dojo.dnd.Avatar");



dojo.declare("dojo.dnd.Avatar", null, {
	// summary:
	//		Object that represents transferred DnD items visually
	// manager: Object
	//		a DnD manager object

	constructor: function(manager){
		this.manager = manager;
		this.construct();
	},

	// methods
	construct: function(){
		// summary:
		//		constructor function;
		//		it is separate so it can be (dynamically) overwritten in case of need
		this.isA11y = dojo.hasClass(dojo.body(),"dijit_a11y");
		var a = dojo.create("table", {
				"class": "dojoDndAvatar",
				style: {
					position: "absolute",
					zIndex:   "1999",
					margin:   "0px"
				}
			}),
			source = this.manager.source, node,
			b = dojo.create("tbody", null, a),
			tr = dojo.create("tr", null, b),
			td = dojo.create("td", null, tr),
			icon = this.isA11y ? dojo.create("span", {
						id : "a11yIcon",
						innerHTML : this.manager.copy ? '+' : "<"
					}, td) : null,
			span = dojo.create("span", {
				innerHTML: source.generateText ? this._generateText() : ""
			}, td),
			k = Math.min(5, this.manager.nodes.length), i = 0;
		// we have to set the opacity on IE only after the node is live
		dojo.attr(tr, {
			"class": "dojoDndAvatarHeader",
			style: {opacity: 0.9}
		});
		for(; i < k; ++i){
			if(source.creator){
				// create an avatar representation of the node
				node = source._normalizedCreator(source.getItem(this.manager.nodes[i].id).data, "avatar").node;
			}else{
				// or just clone the node and hope it works
				node = this.manager.nodes[i].cloneNode(true);
				if(node.tagName.toLowerCase() == "tr"){
					// insert extra table nodes
					var table = dojo.create("table"),
						tbody = dojo.create("tbody", null, table);
					tbody.appendChild(node);
					node = table;
				}
			}
			node.id = "";
			tr = dojo.create("tr", null, b);
			td = dojo.create("td", null, tr);
			td.appendChild(node);
			dojo.attr(tr, {
				"class": "dojoDndAvatarItem",
				style: {opacity: (9 - i) / 10}
			});
		}
		this.node = a;
	},
	destroy: function(){
		// summary:
		//		destructor for the avatar; called to remove all references so it can be garbage-collected
		dojo.destroy(this.node);
		this.node = false;
	},
	update: function(){
		// summary:
		//		updates the avatar to reflect the current DnD state
		dojo[(this.manager.canDropFlag ? "add" : "remove") + "Class"](this.node, "dojoDndAvatarCanDrop");
		if (this.isA11y){
			var icon = dojo.byId("a11yIcon");
			var text = '+';   // assume canDrop && copy
			if (this.manager.canDropFlag && !this.manager.copy) {
				text = '< '; // canDrop && move
			}else if (!this.manager.canDropFlag && !this.manager.copy) {
				text = "o"; //!canDrop && move
			}else if(!this.manager.canDropFlag){
				text = 'x';  // !canDrop && copy
			}
			icon.innerHTML=text;
		}
		// replace text
		dojo.query(("tr.dojoDndAvatarHeader td span" +(this.isA11y ? " span" : "")), this.node).forEach(
			function(node){
				node.innerHTML = this._generateText();
			}, this);
	},
	_generateText: function(){
		// summary: generates a proper text to reflect copying or moving of items
		return this.manager.nodes.length.toString();
	}
});

}

if(!dojo._hasResource["dojo.dnd.Manager"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.Manager"] = true;
dojo.provide("dojo.dnd.Manager");





dojo.declare("dojo.dnd.Manager", null, {
	// summary:
	//		the manager of DnD operations (usually a singleton)
	constructor: function(){
		this.avatar  = null;
		this.source = null;
		this.nodes = [];
		this.copy  = true;
		this.target = null;
		this.canDropFlag = false;
		this.events = [];
	},

	// avatar's offset from the mouse
	OFFSET_X: 16,
	OFFSET_Y: 16,
	
	// methods
	overSource: function(source){
		// summary:
		//		called when a source detected a mouse-over condition
		// source: Object
		//		the reporter
		if(this.avatar){
			this.target = (source && source.targetState != "Disabled") ? source : null;
			this.canDropFlag = Boolean(this.target);
			this.avatar.update();
		}
		dojo.publish("/dnd/source/over", [source]);
	},
	outSource: function(source){
		// summary:
		//		called when a source detected a mouse-out condition
		// source: Object
		//		the reporter
		if(this.avatar){
			if(this.target == source){
				this.target = null;
				this.canDropFlag = false;
				this.avatar.update();
				dojo.publish("/dnd/source/over", [null]);
			}
		}else{
			dojo.publish("/dnd/source/over", [null]);
		}
	},
	startDrag: function(source, nodes, copy){
		// summary:
		//		called to initiate the DnD operation
		// source: Object
		//		the source which provides items
		// nodes: Array
		//		the list of transferred items
		// copy: Boolean
		//		copy items, if true, move items otherwise
		this.source = source;
		this.nodes  = nodes;
		this.copy   = Boolean(copy); // normalizing to true boolean
		this.avatar = this.makeAvatar();
		dojo.body().appendChild(this.avatar.node);
		dojo.publish("/dnd/start", [source, nodes, this.copy]);
		this.events = [
			dojo.connect(dojo.doc, "onmousemove", this, "onMouseMove"),
			dojo.connect(dojo.doc, "onmouseup",   this, "onMouseUp"),
			dojo.connect(dojo.doc, "onkeydown",   this, "onKeyDown"),
			dojo.connect(dojo.doc, "onkeyup",     this, "onKeyUp"),
			// cancel text selection and text dragging
			dojo.connect(dojo.doc, "ondragstart",   dojo.stopEvent),
			dojo.connect(dojo.body(), "onselectstart", dojo.stopEvent)
		];
		var c = "dojoDnd" + (copy ? "Copy" : "Move");
		dojo.addClass(dojo.body(), c);
	},
	canDrop: function(flag){
		// summary:
		//		called to notify if the current target can accept items
		var canDropFlag = Boolean(this.target && flag);
		if(this.canDropFlag != canDropFlag){
			this.canDropFlag = canDropFlag;
			this.avatar.update();
		}
	},
	stopDrag: function(){
		// summary:
		//		stop the DnD in progress
		dojo.removeClass(dojo.body(), ["dojoDndCopy", "dojoDndMove"]);
		dojo.forEach(this.events, dojo.disconnect);
		this.events = [];
		this.avatar.destroy();
		this.avatar = null;
		this.source = this.target = null;
		this.nodes = [];
	},
	makeAvatar: function(){
		// summary:
		//		makes the avatar; it is separate to be overwritten dynamically, if needed
		return new dojo.dnd.Avatar(this);
	},
	updateAvatar: function(){
		// summary:
		//		updates the avatar; it is separate to be overwritten dynamically, if needed
		this.avatar.update();
	},
	
	// mouse event processors
	onMouseMove: function(e){
		// summary:
		//		event processor for onmousemove
		// e: Event
		//		mouse event
		var a = this.avatar;
		if(a){
			dojo.dnd.autoScrollNodes(e);
			//dojo.dnd.autoScroll(e);
			var s = a.node.style;
			s.left = (e.pageX + this.OFFSET_X) + "px";
			s.top  = (e.pageY + this.OFFSET_Y) + "px";
			var copy = Boolean(this.source.copyState(dojo.isCopyKey(e)));
			if(this.copy != copy){
				this._setCopyStatus(copy);
			}
		}
	},
	onMouseUp: function(e){
		// summary:
		//		event processor for onmouseup
		// e: Event
		//		mouse event
		if(this.avatar){
			if(this.target && this.canDropFlag){
				var copy = Boolean(this.source.copyState(dojo.isCopyKey(e))),
				params = [this.source, this.nodes, copy, this.target, e];
				dojo.publish("/dnd/drop/before", params);
				dojo.publish("/dnd/drop", params);
			}else{
				dojo.publish("/dnd/cancel");
			}
			this.stopDrag();
		}
	},
	
	// keyboard event processors
	onKeyDown: function(e){
		// summary:
		//		event processor for onkeydown:
		//		watching for CTRL for copy/move status, watching for ESCAPE to cancel the drag
		// e: Event
		//		keyboard event
		if(this.avatar){
			switch(e.keyCode){
				case dojo.keys.CTRL:
					var copy = Boolean(this.source.copyState(true));
					if(this.copy != copy){
						this._setCopyStatus(copy);
					}
					break;
				case dojo.keys.ESCAPE:
					dojo.publish("/dnd/cancel");
					this.stopDrag();
					break;
			}
		}
	},
	onKeyUp: function(e){
		// summary:
		//		event processor for onkeyup, watching for CTRL for copy/move status
		// e: Event
		//		keyboard event
		if(this.avatar && e.keyCode == dojo.keys.CTRL){
			var copy = Boolean(this.source.copyState(false));
			if(this.copy != copy){
				this._setCopyStatus(copy);
			}
		}
	},
	
	// utilities
	_setCopyStatus: function(copy){
		// summary:
		//		changes the copy status
		// copy: Boolean
		//		the copy status
		this.copy = copy;
		this.source._markDndStatus(this.copy);
		this.updateAvatar();
		dojo.replaceClass(dojo.body(),
			"dojoDnd" + (this.copy ? "Copy" : "Move"),
			"dojoDnd" + (this.copy ? "Move" : "Copy"));
	}
});

// dojo.dnd._manager:
//		The manager singleton variable. Can be overwritten if needed.
dojo.dnd._manager = null;

dojo.dnd.manager = function(){
	// summary:
	//		Returns the current DnD manager.  Creates one if it is not created yet.
	if(!dojo.dnd._manager){
		dojo.dnd._manager = new dojo.dnd.Manager();
	}
	return dojo.dnd._manager;	// Object
};

}

if(!dojo._hasResource["dojo.dnd.Source"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.Source"] = true;
dojo.provide("dojo.dnd.Source");




/////}}}

/*
	Container property:
		"Horizontal"- if this is the horizontal container
	Source states:
		""			- normal state
		"Moved"		- this source is being moved
		"Copied"	- this source is being copied
	Target states:
		""			- normal state
		"Disabled"	- the target cannot accept an avatar
	Target anchor state:
		""			- item is not selected
		"Before"	- insert point is before the anchor
		"After"		- insert point is after the anchor
*/

/*=====
dojo.dnd.__SourceArgs = function(){
	//	summary:
	//		a dict of parameters for DnD Source configuration. Note that any
	//		property on Source elements may be configured, but this is the
	//		short-list
	//	isSource: Boolean?
	//		can be used as a DnD source. Defaults to true.
	//	accept: Array?
	//		list of accepted types (text strings) for a target; defaults to
	//		["text"]
	//	autoSync: Boolean
	//		if true refreshes the node list on every operation; false by default
	//	copyOnly: Boolean?
	//		copy items, if true, use a state of Ctrl key otherwise,
	//		see selfCopy and selfAccept for more details
	//	delay: Number
	//		the move delay in pixels before detecting a drag; 0 by default
	//	horizontal: Boolean?
	//		a horizontal container, if true, vertical otherwise or when omitted
	//	selfCopy: Boolean?
	//		copy items by default when dropping on itself,
	//		false by default, works only if copyOnly is true
	//	selfAccept: Boolean?
	//		accept its own items when copyOnly is true,
	//		true by default, works only if copyOnly is true
	//	withHandles: Boolean?
	//		allows dragging only by handles, false by default
	//  generateText: Boolean?
	//		generate text node for drag and drop, true by default
	this.isSource = isSource;
	this.accept = accept;
	this.autoSync = autoSync;
	this.copyOnly = copyOnly;
	this.delay = delay;
	this.horizontal = horizontal;
	this.selfCopy = selfCopy;
	this.selfAccept = selfAccept;
	this.withHandles = withHandles;
	this.generateText = true;
}
=====*/

dojo.declare("dojo.dnd.Source", dojo.dnd.Selector, {

/////}}}
	// summary:
	//		a Source object, which can be used as a DnD source, or a DnD target
	
	// object attributes (for markup)
	isSource: true,
	horizontal: false,
	copyOnly: false,
	selfCopy: false,
	selfAccept: true,
	skipForm: false,
	withHandles: false,
	autoSync: false,
	delay: 0, // pixels
	accept: ["text"],
	generateText: true,
	
	constructor: function(/*DOMNode|String*/node, /*dojo.dnd.__SourceArgs?*/params){
		// summary:
		//		a constructor of the Source
		// node:
		//		node or node's id to build the source on
		// params:
		//		any property of this class may be configured via the params
		//		object which is mixed-in to the `dojo.dnd.Source` instance
		dojo.mixin(this, dojo.mixin({}, params));
		var type = this.accept;
		if(type.length){
			this.accept = {};
			for(var i = 0; i < type.length; ++i){
				this.accept[type[i]] = 1;
			}
		}
		// class-specific variables
		this.isDragging = false;
		this.mouseDown = false;
		this.targetAnchor = null;
		this.targetBox = null;
		this.before = true;
		this._lastX = 0;
		this._lastY = 0;
		// states
		this.sourceState  = "";
		if(this.isSource){
			dojo.addClass(this.node, "dojoDndSource");
		}
		this.targetState  = "";
		if(this.accept){
			dojo.addClass(this.node, "dojoDndTarget");
		}
		if(this.horizontal){
			dojo.addClass(this.node, "dojoDndHorizontal");
		}
		// set up events
		this.topics = [
			dojo.subscribe("/dnd/source/over", this, "onDndSourceOver"),
			dojo.subscribe("/dnd/start",  this, "onDndStart"),
			dojo.subscribe("/dnd/drop",   this, "onDndDrop"),
			dojo.subscribe("/dnd/cancel", this, "onDndCancel")
		];
	},
	
	// methods
	checkAcceptance: function(source, nodes){
		// summary:
		//		checks if the target can accept nodes from this source
		// source: Object
		//		the source which provides items
		// nodes: Array
		//		the list of transferred items

		//console.log("dojo.dnd.Source.checkAcceptance    source" + source);
		//console.log("dojo.dnd.Source.checkAcceptance    nodes.length" + nodes.length);
		//console.log("dojo.dnd.Source.checkAcceptance    source.getItem(nodes[o].id).type: " + source.getItem(nodes[0].id).type);

		if(this == source){
			//console.log("dojo.dnd.Source.checkAcceptance    this == source. Returning: " + !this.copyOnl7 || this.selfAccept);

			return !this.copyOnly || this.selfAccept;
		}
		
		for(var i = 0; i < nodes.length; ++i){
			var type = source.getItem(nodes[i].id).type;

	//console.log("dojo.dnd.Source.checkAcceptance    source.getItem(nodes[" + i + "].id).type: " + source.getItem(nodes[i].id).type);

			// type instanceof Array
			var flag = false;
			for(var j = 0; j < type.length; ++j){
				if(type[j] in this.accept){
					flag = true;
					break;
				}
			}
			if(!flag){
				return false;	// Boolean
			}
		}
		return true;	// Boolean
	},
	copyState: function(keyPressed, self){
		// summary:
		//		Returns true if we need to copy items, false to move.
		//		It is separated to be overwritten dynamically, if needed.
		// keyPressed: Boolean
		//		the "copy" key was pressed
		// self: Boolean?
		//		optional flag that means that we are about to drop on itself
		
		if(keyPressed){ return true; }
		if(arguments.length < 2){
			self = this == dojo.dnd.manager().target;
		}
		if(self){
			if(this.copyOnly){
				return this.selfCopy;
			}
		}else{
			return this.copyOnly;
		}
		return false;	// Boolean
	},
	destroy: function(){
		// summary:
		//		prepares the object to be garbage-collected
		dojo.dnd.Source.superclass.destroy.call(this);
		dojo.forEach(this.topics, dojo.unsubscribe);
		this.targetAnchor = null;
	},

	// markup methods
	markupFactory: function(params, node){
		params._skipStartup = true;
		return new dojo.dnd.Source(node, params);
	},

	// mouse event processors
	onMouseMove: function(e){
		// summary:
		//		event processor for onmousemove
		// e: Event
		//		mouse event
		if(this.isDragging && this.targetState == "Disabled"){ return; }
		dojo.dnd.Source.superclass.onMouseMove.call(this, e);
		var m = dojo.dnd.manager();
		if(!this.isDragging){
			if(this.mouseDown && this.isSource &&
					(Math.abs(e.pageX - this._lastX) > this.delay || Math.abs(e.pageY - this._lastY) > this.delay)){
				var nodes = this.getSelectedNodes();
				if(nodes.length){
					m.startDrag(this, nodes, this.copyState(dojo.isCopyKey(e), true));
				}
			}
		}
		if(this.isDragging){
			// calculate before/after
			var before = false;
			if(this.current){
				if(!this.targetBox || this.targetAnchor != this.current){
					this.targetBox = dojo.position(this.current, true);
				}
				if(this.horizontal){
					before = (e.pageX - this.targetBox.x) < (this.targetBox.w / 2);
				}else{
					before = (e.pageY - this.targetBox.y) < (this.targetBox.h / 2);
				}
			}
			if(this.current != this.targetAnchor || before != this.before){
				this._markTargetAnchor(before);
				m.canDrop(!this.current || m.source != this || !(this.current.id in this.selection));
			}
		}
	},
	onMouseDown: function(e){
		// summary:
		//		event processor for onmousedown
		// e: Event
		//		mouse event
		if(!this.mouseDown && this._legalMouseDown(e) && (!this.skipForm || !dojo.dnd.isFormElement(e))){
			this.mouseDown = true;
			this._lastX = e.pageX;
			this._lastY = e.pageY;
			dojo.dnd.Source.superclass.onMouseDown.call(this, e);
		}
	},
	onMouseUp: function(e){
		// summary:
		//		event processor for onmouseup
		// e: Event
		//		mouse event
		if(this.mouseDown){
			this.mouseDown = false;
			dojo.dnd.Source.superclass.onMouseUp.call(this, e);
		}
	},
	
	// topic event processors
	onDndSourceOver: function(source){
		// summary:
		//		topic event processor for /dnd/source/over, called when detected a current source
		// source: Object
		//		the source which has the mouse over it

		if(this != source){
			this.mouseDown = false;
			if(this.targetAnchor){
				this._unmarkTargetAnchor();
			}
		}else if(this.isDragging){
			var m = dojo.dnd.manager();
			m.canDrop(this.targetState != "Disabled" && (!this.current || m.source != this || !(this.current.id in this.selection)));
		}
	},
	onDndStart: function(source, nodes, copy){
		// summary:
		//		topic event processor for /dnd/start, called to initiate the DnD operation
		// source: Object
		//		the source which provides items
		// nodes: Array
		//		the list of transferred items
		// copy: Boolean
		//		copy items, if true, move items otherwise
		if(this.autoSync){ this.sync(); }
		if(this.isSource){
			this._changeState("Source", this == source ? (copy ? "Copied" : "Moved") : "");
		}
		var accepted = this.accept && this.checkAcceptance(source, nodes);
		this._changeState("Target", accepted ? "" : "Disabled");
		if(this == source){
			dojo.dnd.manager().overSource(this);
		}
		this.isDragging = true;
	},
	onDndDrop: function(source, nodes, copy, target){
		// summary:
		//		topic event processor for /dnd/drop, called to finish the DnD operation
		// source: Object
		//		the source which provides items
		// nodes: Array
		//		the list of transferred items
		// copy: Boolean
		//		copy items, if true, move items otherwise
		// target: Object
		//		the target which accepts items
		if(this == target){
			// this one is for us => move nodes!
			this.onDrop(source, nodes, copy);
		}
		this.onDndCancel();
	},
	onDndCancel: function(){
		// summary:
		//		topic event processor for /dnd/cancel, called to cancel the DnD operation
		if(this.targetAnchor){
			this._unmarkTargetAnchor();
			this.targetAnchor = null;
		}
		this.before = true;
		this.isDragging = false;
		this.mouseDown = false;
		this._changeState("Source", "");
		this._changeState("Target", "");
	},
	
	// local events
	onDrop: function(source, nodes, copy){
		// summary:
		//		called only on the current target, when drop is performed
		// source: Object
		//		the source which provides items
		// nodes: Array
		//		the list of transferred items
		// copy: Boolean
		//		copy items, if true, move items otherwise
		
		if(this != source){
			this.onDropExternal(source, nodes, copy);
		}else{
			this.onDropInternal(nodes, copy);
		}
	},
	onDropExternal: function(source, nodes, copy){
		// summary:
		//		called only on the current target, when drop is performed
		//		from an external source
		// source: Object
		//		the source which provides items
		// nodes: Array
		//		the list of transferred items
		// copy: Boolean
		//		copy items, if true, move items otherwise
	
	
	console.log("dojo.dnd.Source.onDropExternal    HERE HERE HERE");
	
		var oldCreator = this._normalizedCreator;
		// transferring nodes from the source to the target
		if(this.creator){
			// use defined creator
			this._normalizedCreator = function(node, hint){
				return oldCreator.call(this, source.getItem(node.id).data, hint);
			};
		}else{
			// we have no creator defined => move/clone nodes
			if(copy){
				// clone nodes
				this._normalizedCreator = function(node, hint){
					var t = source.getItem(node.id);
					var n = node.cloneNode(true);
					n.id = dojo.dnd.getUniqueId();
					return {node: n, data: t.data, type: t.type};
				};
			}else{
				// move nodes
				this._normalizedCreator = function(node, hint){
					var t = source.getItem(node.id);
					source.delItem(node.id);
					return {node: node, data: t.data, type: t.type};
				};
			}
		}
		this.selectNone();
		if(!copy && !this.creator){
			source.selectNone();
		}
		this.insertNodes(true, nodes, this.before, this.current);
		if(!copy && this.creator){
			source.deleteSelectedNodes();
		}
		this._normalizedCreator = oldCreator;
	},
	onDropInternal: function(nodes, copy){
		// summary:
		//		called only on the current target, when drop is performed
		//		from the same target/source
		// nodes: Array
		//		the list of transferred items
		// copy: Boolean
		//		copy items, if true, move items otherwise
		
		var oldCreator = this._normalizedCreator;
		// transferring nodes within the single source
		if(this.current && this.current.id in this.selection){
			// do nothing
			return;
		}
		if(copy){
			if(this.creator){
				// create new copies of data items
				this._normalizedCreator = function(node, hint){
					return oldCreator.call(this, this.getItem(node.id).data, hint);
				};
			}else{
				// clone nodes
				this._normalizedCreator = function(node, hint){
					var t = this.getItem(node.id);
					var n = node.cloneNode(true);
					n.id = dojo.dnd.getUniqueId();
					return {node: n, data: t.data, type: t.type};
				};
			}
		}else{
			// move nodes
			if(!this.current){
				// do nothing
				return;
			}
			this._normalizedCreator = function(node, hint){
				var t = this.getItem(node.id);
				return {node: node, data: t.data, type: t.type};
			};
		}
		this._removeSelection();
		this.insertNodes(true, nodes, this.before, this.current);
		this._normalizedCreator = oldCreator;
	},
	onDraggingOver: function(){
		// summary:
		//		called during the active DnD operation, when items
		//		are dragged over this target, and it is not disabled
	},
	onDraggingOut: function(){
		// summary:
		//		called during the active DnD operation, when items
		//		are dragged away from this target, and it is not disabled
	},
	
	// utilities
	onOverEvent: function(){
		// summary:
		//		this function is called once, when mouse is over our container
		dojo.dnd.Source.superclass.onOverEvent.call(this);
		dojo.dnd.manager().overSource(this);
		if(this.isDragging && this.targetState != "Disabled"){
			this.onDraggingOver();
		}
	},
	onOutEvent: function(){
		// summary:
		//		this function is called once, when mouse is out of our container
		dojo.dnd.Source.superclass.onOutEvent.call(this);
		dojo.dnd.manager().outSource(this);
		if(this.isDragging && this.targetState != "Disabled"){
			this.onDraggingOut();
		}
	},
	_markTargetAnchor: function(before){
		// summary:
		//		assigns a class to the current target anchor based on "before" status
		// before: Boolean
		//		insert before, if true, after otherwise
		if(this.current == this.targetAnchor && this.before == before){ return; }
		if(this.targetAnchor){
			this._removeItemClass(this.targetAnchor, this.before ? "Before" : "After");
		}
		this.targetAnchor = this.current;
		this.targetBox = null;
		this.before = before;
		if(this.targetAnchor){
			this._addItemClass(this.targetAnchor, this.before ? "Before" : "After");
		}
	},
	_unmarkTargetAnchor: function(){
		// summary:
		//		removes a class of the current target anchor based on "before" status
		if(!this.targetAnchor){ return; }
		this._removeItemClass(this.targetAnchor, this.before ? "Before" : "After");
		this.targetAnchor = null;
		this.targetBox = null;
		this.before = true;
	},
	_markDndStatus: function(copy){
		// summary:
		//		changes source's state based on "copy" status
		this._changeState("Source", copy ? "Copied" : "Moved");
	},
	_legalMouseDown: function(e){
		// summary:
		//		checks if user clicked on "approved" items
		// e: Event
		//		mouse event
		
		// accept only the left mouse button
		if(!dojo.mouseButtons.isLeft(e)){ return false; }
		
		if(!this.withHandles){ return true; }
		
		// check for handles
		for(var node = e.target; node && node !== this.node; node = node.parentNode){
			if(dojo.hasClass(node, "dojoDndHandle")){ return true; }
			if(dojo.hasClass(node, "dojoDndItem") || dojo.hasClass(node, "dojoDndIgnore")){ break; }
		}
		return false;	// Boolean
	}
});

dojo.declare("dojo.dnd.Target", dojo.dnd.Source, {
	// summary: a Target object, which can be used as a DnD target
	
	constructor: function(node, params){
		// summary:
		//		a constructor of the Target --- see the `dojo.dnd.Source.constructor` for details
		this.isSource = false;
		dojo.removeClass(this.node, "dojoDndSource");
	},

	// markup methods
	markupFactory: function(params, node){
		params._skipStartup = true;
		return new dojo.dnd.Target(node, params);
	}
});

dojo.declare("dojo.dnd.AutoSource", dojo.dnd.Source, {
	// summary:
	//		a source that syncs its DnD nodes by default
	
	constructor: function(node, params){
		// summary:
		//		constructor of the AutoSource --- see the Source constructor for details
		this.autoSync = true;
	},

	// markup methods
	markupFactory: function(params, node){
		params._skipStartup = true;
		return new dojo.dnd.AutoSource(node, params);
	}
});

}

if(!dojo._hasResource["dojo.data.util.filter"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.data.util.filter"] = true;
dojo.provide("dojo.data.util.filter");

dojo.getObject("data.util.filter", true, dojo);

dojo.data.util.filter.patternToRegExp = function(/*String*/pattern, /*boolean?*/ ignoreCase){
	//	summary:
	//		Helper function to convert a simple pattern to a regular expression for matching.
	//	description:
	//		Returns a regular expression object that conforms to the defined conversion rules.
	//		For example:
	//			ca*   -> /^ca.*$/
	//			*ca*  -> /^.*ca.*$/
	//			*c\*a*  -> /^.*c\*a.*$/
	//			*c\*a?*  -> /^.*c\*a..*$/
	//			and so on.
	//
	//	pattern: string
	//		A simple matching pattern to convert that follows basic rules:
	//			* Means match anything, so ca* means match anything starting with ca
	//			? Means match single character.  So, b?b will match to bob and bab, and so on.
	//      	\ is an escape character.  So for example, \* means do not treat * as a match, but literal character *.
	//				To use a \ as a character in the string, it must be escaped.  So in the pattern it should be
	//				represented by \\ to be treated as an ordinary \ character instead of an escape.
	//
	//	ignoreCase:
	//		An optional flag to indicate if the pattern matching should be treated as case-sensitive or not when comparing
	//		By default, it is assumed case sensitive.

	var rxp = "^";
	var c = null;
	for(var i = 0; i < pattern.length; i++){
		c = pattern.charAt(i);
		switch(c){
			case '\\':
				rxp += c;
				i++;
				rxp += pattern.charAt(i);
				break;
			case '*':
				rxp += ".*"; break;
			case '?':
				rxp += "."; break;
			case '$':
			case '^':
			case '/':
			case '+':
			case '.':
			case '|':
			case '(':
			case ')':
			case '{':
			case '}':
			case '[':
			case ']':
				rxp += "\\"; //fallthrough
			default:
				rxp += c;
		}
	}
	rxp += "$";
	if(ignoreCase){
		return new RegExp(rxp,"mi"); //RegExp
	}else{
		return new RegExp(rxp,"m"); //RegExp
	}
	
};

}

if(!dojo._hasResource["dojo.data.util.sorter"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.data.util.sorter"] = true;
dojo.provide("dojo.data.util.sorter");

dojo.getObject("data.util.sorter", true, dojo);

dojo.data.util.sorter.basicComparator = function(	/*anything*/ a,
													/*anything*/ b){
	//	summary:
	//		Basic comparision function that compares if an item is greater or less than another item
	//	description:
	//		returns 1 if a > b, -1 if a < b, 0 if equal.
	//		'null' values (null, undefined) are treated as larger values so that they're pushed to the end of the list.
	//		And compared to each other, null is equivalent to undefined.
	
	//null is a problematic compare, so if null, we set to undefined.
	//Makes the check logic simple, compact, and consistent
	//And (null == undefined) === true, so the check later against null
	//works for undefined and is less bytes.
	var r = -1;
	if(a === null){
		a = undefined;
	}
	if(b === null){
		b = undefined;
	}
	if(a == b){
		r = 0;
	}else if(a > b || a == null){
		r = 1;
	}
	return r; //int {-1,0,1}
};

dojo.data.util.sorter.createSortFunction = function(	/* attributes array */sortSpec,
														/*dojo.data.core.Read*/ store){
	//	summary:
	//		Helper function to generate the sorting function based off the list of sort attributes.
	//	description:
	//		The sort function creation will look for a property on the store called 'comparatorMap'.  If it exists
	//		it will look in the mapping for comparisons function for the attributes.  If one is found, it will
	//		use it instead of the basic comparator, which is typically used for strings, ints, booleans, and dates.
	//		Returns the sorting function for this particular list of attributes and sorting directions.
	//
	//	sortSpec: array
	//		A JS object that array that defines out what attribute names to sort on and whether it should be descenting or asending.
	//		The objects should be formatted as follows:
	//		{
	//			attribute: "attributeName-string" || attribute,
	//			descending: true|false;   // Default is false.
	//		}
	//	store: object
	//		The datastore object to look up item values from.
	//
	var sortFunctions=[];

	function createSortFunction(attr, dir, comp, s){
		//Passing in comp and s (comparator and store), makes this
		//function much faster.
		return function(itemA, itemB){
			var a = s.getValue(itemA, attr);
			var b = s.getValue(itemB, attr);
			return dir * comp(a,b); //int
		};
	}
	var sortAttribute;
	var map = store.comparatorMap;
	var bc = dojo.data.util.sorter.basicComparator;
	for(var i = 0; i < sortSpec.length; i++){
		sortAttribute = sortSpec[i];
		var attr = sortAttribute.attribute;
		if(attr){
			var dir = (sortAttribute.descending) ? -1 : 1;
			var comp = bc;
			if(map){
				if(typeof attr !== "string" && ("toString" in attr)){
					 attr = attr.toString();
				}
				comp = map[attr] || bc;
			}
			sortFunctions.push(createSortFunction(attr,
				dir, comp, store));
		}
	}
	return function(rowA, rowB){
		var i=0;
		while(i < sortFunctions.length){
			var ret = sortFunctions[i++](rowA, rowB);
			if(ret !== 0){
				return ret;//int
			}
		}
		return 0; //int
	}; // Function
};

}

if(!dojo._hasResource["dojo.data.util.simpleFetch"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.data.util.simpleFetch"] = true;
dojo.provide("dojo.data.util.simpleFetch");


dojo.getObject("data.util.simpleFetch", true, dojo);

dojo.data.util.simpleFetch.fetch = function(/* Object? */ request){
	//	summary:
	//		The simpleFetch mixin is designed to serve as a set of function(s) that can
	//		be mixed into other datastore implementations to accelerate their development.
	//		The simpleFetch mixin should work well for any datastore that can respond to a _fetchItems()
	//		call by returning an array of all the found items that matched the query.  The simpleFetch mixin
	//		is not designed to work for datastores that respond to a fetch() call by incrementally
	//		loading items, or sequentially loading partial batches of the result
	//		set.  For datastores that mixin simpleFetch, simpleFetch
	//		implements a fetch method that automatically handles eight of the fetch()
	//		arguments -- onBegin, onItem, onComplete, onError, start, count, sort and scope
	//		The class mixing in simpleFetch should not implement fetch(),
	//		but should instead implement a _fetchItems() method.  The _fetchItems()
	//		method takes three arguments, the keywordArgs object that was passed
	//		to fetch(), a callback function to be called when the result array is
	//		available, and an error callback to be called if something goes wrong.
	//		The _fetchItems() method should ignore any keywordArgs parameters for
	//		start, count, onBegin, onItem, onComplete, onError, sort, and scope.
	//		The _fetchItems() method needs to correctly handle any other keywordArgs
	//		parameters, including the query parameter and any optional parameters
	//		(such as includeChildren).  The _fetchItems() method should create an array of
	//		result items and pass it to the fetchHandler along with the original request object
	//		-- or, the _fetchItems() method may, if it wants to, create an new request object
	//		with other specifics about the request that are specific to the datastore and pass
	//		that as the request object to the handler.
	//
	//		For more information on this specific function, see dojo.data.api.Read.fetch()
	request = request || {};
	if(!request.store){
		request.store = this;
	}
	var self = this;

	var _errorHandler = function(errorData, requestObject){
		if(requestObject.onError){
			var scope = requestObject.scope || dojo.global;
			requestObject.onError.call(scope, errorData, requestObject);
		}
	};

	var _fetchHandler = function(items, requestObject){
		var oldAbortFunction = requestObject.abort || null;
		var aborted = false;

		var startIndex = requestObject.start?requestObject.start:0;
		var endIndex = (requestObject.count && (requestObject.count !== Infinity))?(startIndex + requestObject.count):items.length;

		requestObject.abort = function(){
			aborted = true;
			if(oldAbortFunction){
				oldAbortFunction.call(requestObject);
			}
		};

		var scope = requestObject.scope || dojo.global;
		if(!requestObject.store){
			requestObject.store = self;
		}
		if(requestObject.onBegin){
			requestObject.onBegin.call(scope, items.length, requestObject);
		}
		if(requestObject.sort){
			items.sort(dojo.data.util.sorter.createSortFunction(requestObject.sort, self));
		}
		if(requestObject.onItem){
			for(var i = startIndex; (i < items.length) && (i < endIndex); ++i){
				var item = items[i];
				if(!aborted){
					requestObject.onItem.call(scope, item, requestObject);
				}
			}
		}
		if(requestObject.onComplete && !aborted){
			var subset = null;
			if(!requestObject.onItem){
				subset = items.slice(startIndex, endIndex);
			}
			requestObject.onComplete.call(scope, subset, requestObject);
		}
	};
	this._fetchItems(request, _fetchHandler, _errorHandler);
	return request;	// Object
};

}

if(!dojo._hasResource["dojo.data.ItemFileReadStore"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.data.ItemFileReadStore"] = true;
dojo.provide("dojo.data.ItemFileReadStore");





dojo.declare("dojo.data.ItemFileReadStore", null,{
	//	summary:
	//		The ItemFileReadStore implements the dojo.data.api.Read API and reads
	//		data from JSON files that have contents in this format --
	//		{ items: [
	//			{ name:'Kermit', color:'green', age:12, friends:['Gonzo', {_reference:{name:'Fozzie Bear'}}]},
	//			{ name:'Fozzie Bear', wears:['hat', 'tie']},
	//			{ name:'Miss Piggy', pets:'Foo-Foo'}
	//		]}
	//		Note that it can also contain an 'identifer' property that specified which attribute on the items
	//		in the array of items that acts as the unique identifier for that item.
	//
	constructor: function(/* Object */ keywordParameters){
		//	summary: constructor
		//	keywordParameters: {url: String}
		//	keywordParameters: {data: jsonObject}
		//	keywordParameters: {typeMap: object)
		//		The structure of the typeMap object is as follows:
		//		{
		//			type0: function || object,
		//			type1: function || object,
		//			...
		//			typeN: function || object
		//		}
		//		Where if it is a function, it is assumed to be an object constructor that takes the
		//		value of _value as the initialization parameters.  If it is an object, then it is assumed
		//		to be an object of general form:
		//		{
		//			type: function, //constructor.
		//			deserialize:	function(value) //The function that parses the value and constructs the object defined by type appropriately.
		//		}
	
		this._arrayOfAllItems = [];
		this._arrayOfTopLevelItems = [];
		this._loadFinished = false;
		this._jsonFileUrl = keywordParameters.url;
		this._ccUrl = keywordParameters.url;
		this.url = keywordParameters.url;
		this._jsonData = keywordParameters.data;
		this.data = null;
		this._datatypeMap = keywordParameters.typeMap || {};
		if(!this._datatypeMap['Date']){
			//If no default mapping for dates, then set this as default.
			//We use the dojo.date.stamp here because the ISO format is the 'dojo way'
			//of generically representing dates.
			this._datatypeMap['Date'] = {
											type: Date,
											deserialize: function(value){
												return dojo.date.stamp.fromISOString(value);
											}
										};
		}
		this._features = {'dojo.data.api.Read':true, 'dojo.data.api.Identity':true};
		this._itemsByIdentity = null;
		this._storeRefPropName = "_S"; // Default name for the store reference to attach to every item.
		this._itemNumPropName = "_0"; // Default Item Id for isItem to attach to every item.
		this._rootItemPropName = "_RI"; // Default Item Id for isItem to attach to every item.
		this._reverseRefMap = "_RRM"; // Default attribute for constructing a reverse reference map for use with reference integrity
		this._loadInProgress = false; //Got to track the initial load to prevent duelling loads of the dataset.
		this._queuedFetches = [];
		if(keywordParameters.urlPreventCache !== undefined){
			this.urlPreventCache = keywordParameters.urlPreventCache?true:false;
		}
		if(keywordParameters.hierarchical !== undefined){
			this.hierarchical = keywordParameters.hierarchical?true:false;
		}
		if(keywordParameters.clearOnClose){
			this.clearOnClose = true;
		}
		if("failOk" in keywordParameters){
			this.failOk = keywordParameters.failOk?true:false;
		}
	},
	
	url: "",	// use "" rather than undefined for the benefit of the parser (#3539)

	//Internal var, crossCheckUrl.  Used so that setting either url or _jsonFileUrl, can still trigger a reload
	//when clearOnClose and close is used.
	_ccUrl: "",

	data: null,	// define this so that the parser can populate it

	typeMap: null, //Define so parser can populate.
	
	//Parameter to allow users to specify if a close call should force a reload or not.
	//By default, it retains the old behavior of not clearing if close is called.  But
	//if set true, the store will be reset to default state.  Note that by doing this,
	//all item handles will become invalid and a new fetch must be issued.
	clearOnClose: false,

	//Parameter to allow specifying if preventCache should be passed to the xhrGet call or not when loading data from a url.
	//Note this does not mean the store calls the server on each fetch, only that the data load has preventCache set as an option.
	//Added for tracker: #6072
	urlPreventCache: false,
	
	//Parameter for specifying that it is OK for the xhrGet call to fail silently.
	failOk: false,

	//Parameter to indicate to process data from the url as hierarchical
	//(data items can contain other data items in js form).  Default is true
	//for backwards compatibility.  False means only root items are processed
	//as items, all child objects outside of type-mapped objects and those in
	//specific reference format, are left straight JS data objects.
	hierarchical: true,

	_assertIsItem: function(/* item */ item){
		//	summary:
		//		This function tests whether the item passed in is indeed an item in the store.
		//	item:
		//		The item to test for being contained by the store.
		if(!this.isItem(item)){
			throw new Error("dojo.data.ItemFileReadStore: Invalid item argument.");
		}
	},

	_assertIsAttribute: function(/* attribute-name-string */ attribute){
		//	summary:
		//		This function tests whether the item passed in is indeed a valid 'attribute' like type for the store.
		//	attribute:
		//		The attribute to test for being contained by the store.
		if(typeof attribute !== "string"){
			throw new Error("dojo.data.ItemFileReadStore: Invalid attribute argument.");
		}
	},

	getValue: function(	/* item */ item,
						/* attribute-name-string */ attribute,
						/* value? */ defaultValue){
		//	summary:
		//		See dojo.data.api.Read.getValue()
		var values = this.getValues(item, attribute);
		return (values.length > 0)?values[0]:defaultValue; // mixed
	},

	getValues: function(/* item */ item,
						/* attribute-name-string */ attribute){
		//	summary:
		//		See dojo.data.api.Read.getValues()

		this._assertIsItem(item);
		this._assertIsAttribute(attribute);
		// Clone it before returning.  refs: #10474
		return (item[attribute] || []).slice(0); // Array
	},

	getAttributes: function(/* item */ item){
		//	summary:
		//		See dojo.data.api.Read.getAttributes()
		this._assertIsItem(item);
		var attributes = [];
		for(var key in item){
			// Save off only the real item attributes, not the special id marks for O(1) isItem.
			if((key !== this._storeRefPropName) && (key !== this._itemNumPropName) && (key !== this._rootItemPropName) && (key !== this._reverseRefMap)){
				attributes.push(key);
			}
		}
		return attributes; // Array
	},

	hasAttribute: function(	/* item */ item,
							/* attribute-name-string */ attribute){
		//	summary:
		//		See dojo.data.api.Read.hasAttribute()
		this._assertIsItem(item);
		this._assertIsAttribute(attribute);
		return (attribute in item);
	},

	containsValue: function(/* item */ item,
							/* attribute-name-string */ attribute,
							/* anything */ value){
		//	summary:
		//		See dojo.data.api.Read.containsValue()
		var regexp = undefined;
		if(typeof value === "string"){
			regexp = dojo.data.util.filter.patternToRegExp(value, false);
		}
		return this._containsValue(item, attribute, value, regexp); //boolean.
	},

	_containsValue: function(	/* item */ item,
								/* attribute-name-string */ attribute,
								/* anything */ value,
								/* RegExp?*/ regexp){
		//	summary:
		//		Internal function for looking at the values contained by the item.
		//	description:
		//		Internal function for looking at the values contained by the item.  This
		//		function allows for denoting if the comparison should be case sensitive for
		//		strings or not (for handling filtering cases where string case should not matter)
		//
		//	item:
		//		The data item to examine for attribute values.
		//	attribute:
		//		The attribute to inspect.
		//	value:
		//		The value to match.
		//	regexp:
		//		Optional regular expression generated off value if value was of string type to handle wildcarding.
		//		If present and attribute values are string, then it can be used for comparison instead of 'value'
		return dojo.some(this.getValues(item, attribute), function(possibleValue){
			if(possibleValue !== null && !dojo.isObject(possibleValue) && regexp){
				if(possibleValue.toString().match(regexp)){
					return true; // Boolean
				}
			}else if(value === possibleValue){
				return true; // Boolean
			}
		});
	},

	isItem: function(/* anything */ something){
		//	summary:
		//		See dojo.data.api.Read.isItem()
		if(something && something[this._storeRefPropName] === this){
			if(this._arrayOfAllItems[something[this._itemNumPropName]] === something){
				return true;
			}
		}
		return false; // Boolean
	},

	isItemLoaded: function(/* anything */ something){
		//	summary:
		//		See dojo.data.api.Read.isItemLoaded()
		return this.isItem(something); //boolean
	},

	loadItem: function(/* object */ keywordArgs){
		//	summary:
		//		See dojo.data.api.Read.loadItem()
		this._assertIsItem(keywordArgs.item);
	},

	getFeatures: function(){
		//	summary:
		//		See dojo.data.api.Read.getFeatures()
		return this._features; //Object
	},

	getLabel: function(/* item */ item){
		//	summary:
		//		See dojo.data.api.Read.getLabel()
		if(this._labelAttr && this.isItem(item)){
			return this.getValue(item,this._labelAttr); //String
		}
		return undefined; //undefined
	},

	getLabelAttributes: function(/* item */ item){
		//	summary:
		//		See dojo.data.api.Read.getLabelAttributes()
		if(this._labelAttr){
			return [this._labelAttr]; //array
		}
		return null; //null
	},

	_fetchItems: function(	/* Object */ keywordArgs,
							/* Function */ findCallback,
							/* Function */ errorCallback){
		//	summary:
		//		See dojo.data.util.simpleFetch.fetch()
		var self = this,
		    filter = function(requestArgs, arrayOfItems){
			var items = [],
			    i, key;
			if(requestArgs.query){
				var value,
				    ignoreCase = requestArgs.queryOptions ? requestArgs.queryOptions.ignoreCase : false;

				//See if there are any string values that can be regexp parsed first to avoid multiple regexp gens on the
				//same value for each item examined.  Much more efficient.
				var regexpList = {};
				for(key in requestArgs.query){
					value = requestArgs.query[key];
					if(typeof value === "string"){
						regexpList[key] = dojo.data.util.filter.patternToRegExp(value, ignoreCase);
					}else if(value instanceof RegExp){
						regexpList[key] = value;
					}
				}
				for(i = 0; i < arrayOfItems.length; ++i){
					var match = true;
					var candidateItem = arrayOfItems[i];
					if(candidateItem === null){
						match = false;
					}else{
						for(key in requestArgs.query){
							value = requestArgs.query[key];
							if(!self._containsValue(candidateItem, key, value, regexpList[key])){
								match = false;
							}
						}
					}
					if(match){
						items.push(candidateItem);
					}
				}
				findCallback(items, requestArgs);
			}else{
				// We want a copy to pass back in case the parent wishes to sort the array.
				// We shouldn't allow resort of the internal list, so that multiple callers
				// can get lists and sort without affecting each other.  We also need to
				// filter out any null values that have been left as a result of deleteItem()
				// calls in ItemFileWriteStore.
				for(i = 0; i < arrayOfItems.length; ++i){
					var item = arrayOfItems[i];
					if(item !== null){
						items.push(item);
					}
				}
				findCallback(items, requestArgs);
			}
		};

		if(this._loadFinished){
			filter(keywordArgs, this._getItemsArray(keywordArgs.queryOptions));
		}else{
			//Do a check on the JsonFileUrl and crosscheck it.
			//If it doesn't match the cross-check, it needs to be updated
			//This allows for either url or _jsonFileUrl to he changed to
			//reset the store load location.  Done this way for backwards
			//compatibility.  People use _jsonFileUrl (even though officially
			//private.
			if(this._jsonFileUrl !== this._ccUrl){
				dojo.deprecated("dojo.data.ItemFileReadStore: ",
					"To change the url, set the url property of the store," +
					" not _jsonFileUrl.  _jsonFileUrl support will be removed in 2.0");
				this._ccUrl = this._jsonFileUrl;
				this.url = this._jsonFileUrl;
			}else if(this.url !== this._ccUrl){
				this._jsonFileUrl = this.url;
				this._ccUrl = this.url;
			}

			//See if there was any forced reset of data.
			if(this.data != null){
				this._jsonData = this.data;
				this.data = null;
			}

			if(this._jsonFileUrl){
				//If fetches come in before the loading has finished, but while
				//a load is in progress, we have to defer the fetching to be
				//invoked in the callback.
				if(this._loadInProgress){
					this._queuedFetches.push({args: keywordArgs, filter: filter});
				}else{
					this._loadInProgress = true;
					var getArgs = {
							url: self._jsonFileUrl,
							handleAs: "json-comment-optional",
							preventCache: this.urlPreventCache,
							failOk: this.failOk
						};
					var getHandler = dojo.xhrGet(getArgs);
					getHandler.addCallback(function(data){
						try{
							self._getItemsFromLoadedData(data);
							self._loadFinished = true;
							self._loadInProgress = false;
							
							filter(keywordArgs, self._getItemsArray(keywordArgs.queryOptions));
							self._handleQueuedFetches();
						}catch(e){
							self._loadFinished = true;
							self._loadInProgress = false;
							errorCallback(e, keywordArgs);
						}
					});
					getHandler.addErrback(function(error){
						self._loadInProgress = false;
						errorCallback(error, keywordArgs);
					});

					//Wire up the cancel to abort of the request
					//This call cancel on the deferred if it hasn't been called
					//yet and then will chain to the simple abort of the
					//simpleFetch keywordArgs
					var oldAbort = null;
					if(keywordArgs.abort){
						oldAbort = keywordArgs.abort;
					}
					keywordArgs.abort = function(){
						var df = getHandler;
						if(df && df.fired === -1){
							df.cancel();
							df = null;
						}
						if(oldAbort){
							oldAbort.call(keywordArgs);
						}
					};
				}
			}else if(this._jsonData){
				try{
					this._loadFinished = true;
					this._getItemsFromLoadedData(this._jsonData);
					this._jsonData = null;
					filter(keywordArgs, this._getItemsArray(keywordArgs.queryOptions));
				}catch(e){
					errorCallback(e, keywordArgs);
				}
			}else{
				errorCallback(new Error("dojo.data.ItemFileReadStore: No JSON source data was provided as either URL or a nested Javascript object."), keywordArgs);
			}
		}
	},

	_handleQueuedFetches: function(){
		//	summary:
		//		Internal function to execute delayed request in the store.
		//Execute any deferred fetches now.
		if(this._queuedFetches.length > 0){
			for(var i = 0; i < this._queuedFetches.length; i++){
				var fData = this._queuedFetches[i],
				    delayedQuery = fData.args,
				    delayedFilter = fData.filter;
				if(delayedFilter){
					delayedFilter(delayedQuery, this._getItemsArray(delayedQuery.queryOptions));
				}else{
					this.fetchItemByIdentity(delayedQuery);
				}
			}
			this._queuedFetches = [];
		}
	},

	_getItemsArray: function(/*object?*/queryOptions){
		//	summary:
		//		Internal function to determine which list of items to search over.
		//	queryOptions: The query options parameter, if any.
		if(queryOptions && queryOptions.deep){
			return this._arrayOfAllItems;
		}
		return this._arrayOfTopLevelItems;
	},

	close: function(/*dojo.data.api.Request || keywordArgs || null */ request){
		 //	summary:
		 //		See dojo.data.api.Read.close()
		 if(this.clearOnClose &&
			this._loadFinished &&
			!this._loadInProgress){
			 //Reset all internalsback to default state.  This will force a reload
			 //on next fetch.  This also checks that the data or url param was set
			 //so that the store knows it can get data.  Without one of those being set,
			 //the next fetch will trigger an error.

			 if(((this._jsonFileUrl == "" || this._jsonFileUrl == null) &&
				 (this.url == "" || this.url == null)
				) && this.data == null){
				 console.debug("dojo.data.ItemFileReadStore: WARNING!  Data reload " +
					" information has not been provided." +
					"  Please set 'url' or 'data' to the appropriate value before" +
					" the next fetch");
			 }
			 this._arrayOfAllItems = [];
			 this._arrayOfTopLevelItems = [];
			 this._loadFinished = false;
			 this._itemsByIdentity = null;
			 this._loadInProgress = false;
			 this._queuedFetches = [];
		 }
	},

	_getItemsFromLoadedData: function(/* Object */ dataObject){
		//	summary:
		//		Function to parse the loaded data into item format and build the internal items array.
		//	description:
		//		Function to parse the loaded data into item format and build the internal items array.
		//
		//	dataObject:
		//		The JS data object containing the raw data to convery into item format.
		//
		// 	returns: array
		//		Array of items in store item format.
		
		// First, we define a couple little utility functions...
		var addingArrays = false,
		    self = this;
		
		function valueIsAnItem(/* anything */ aValue){
			// summary:
			//		Given any sort of value that could be in the raw json data,
			//		return true if we should interpret the value as being an
			//		item itself, rather than a literal value or a reference.
			// example:
			// 	|	false == valueIsAnItem("Kermit");
			// 	|	false == valueIsAnItem(42);
			// 	|	false == valueIsAnItem(new Date());
			// 	|	false == valueIsAnItem({_type:'Date', _value:'1802-05-14'});
			// 	|	false == valueIsAnItem({_reference:'Kermit'});
			// 	|	true == valueIsAnItem({name:'Kermit', color:'green'});
			// 	|	true == valueIsAnItem({iggy:'pop'});
			// 	|	true == valueIsAnItem({foo:42});
			var isItem = (
				(aValue !== null) &&
				(typeof aValue === "object") &&
				(!dojo.isArray(aValue) || addingArrays) &&
				(!dojo.isFunction(aValue)) &&
				(aValue.constructor == Object || dojo.isArray(aValue)) &&
				(typeof aValue._reference === "undefined") &&
				(typeof aValue._type === "undefined") &&
				(typeof aValue._value === "undefined") &&
				self.hierarchical
			);
			return isItem;
		}
		
		function addItemAndSubItemsToArrayOfAllItems(/* Item */ anItem){
			self._arrayOfAllItems.push(anItem);
			for(var attribute in anItem){
				var valueForAttribute = anItem[attribute];
				if(valueForAttribute){
					if(dojo.isArray(valueForAttribute)){
						var valueArray = valueForAttribute;
						for(var k = 0; k < valueArray.length; ++k){
							var singleValue = valueArray[k];
							if(valueIsAnItem(singleValue)){
								addItemAndSubItemsToArrayOfAllItems(singleValue);
							}
						}
					}else{
						if(valueIsAnItem(valueForAttribute)){
							addItemAndSubItemsToArrayOfAllItems(valueForAttribute);
						}
					}
				}
			}
		}

		this._labelAttr = dataObject.label;

		// We need to do some transformations to convert the data structure
		// that we read from the file into a format that will be convenient
		// to work with in memory.

		// Step 1: Walk through the object hierarchy and build a list of all items
		var i,
		    item;
		this._arrayOfAllItems = [];
		this._arrayOfTopLevelItems = dataObject.items;

		for(i = 0; i < this._arrayOfTopLevelItems.length; ++i){
			item = this._arrayOfTopLevelItems[i];
			if(dojo.isArray(item)){
				addingArrays = true;
			}
			addItemAndSubItemsToArrayOfAllItems(item);
			item[this._rootItemPropName]=true;
		}

		// Step 2: Walk through all the attribute values of all the items,
		// and replace single values with arrays.  For example, we change this:
		//		{ name:'Miss Piggy', pets:'Foo-Foo'}
		// into this:
		//		{ name:['Miss Piggy'], pets:['Foo-Foo']}
		//
		// We also store the attribute names so we can validate our store
		// reference and item id special properties for the O(1) isItem
		var allAttributeNames = {},
		    key;

		for(i = 0; i < this._arrayOfAllItems.length; ++i){
			item = this._arrayOfAllItems[i];
			for(key in item){
				if(key !== this._rootItemPropName){
					var value = item[key];
					if(value !== null){
						if(!dojo.isArray(value)){
							item[key] = [value];
						}
					}else{
						item[key] = [null];
					}
				}
				allAttributeNames[key]=key;
			}
		}

		// Step 3: Build unique property names to use for the _storeRefPropName and _itemNumPropName
		// This should go really fast, it will generally never even run the loop.
		while(allAttributeNames[this._storeRefPropName]){
			this._storeRefPropName += "_";
		}
		while(allAttributeNames[this._itemNumPropName]){
			this._itemNumPropName += "_";
		}
		while(allAttributeNames[this._reverseRefMap]){
			this._reverseRefMap += "_";
		}

		// Step 4: Some data files specify an optional 'identifier', which is
		// the name of an attribute that holds the identity of each item.
		// If this data file specified an identifier attribute, then build a
		// hash table of items keyed by the identity of the items.
		var arrayOfValues;

		var identifier = dataObject.identifier;
		if(identifier){
			this._itemsByIdentity = {};
			this._features['dojo.data.api.Identity'] = identifier;
			for(i = 0; i < this._arrayOfAllItems.length; ++i){
				item = this._arrayOfAllItems[i];
				arrayOfValues = item[identifier];
				var identity = arrayOfValues[0];
				if(!Object.hasOwnProperty.call(this._itemsByIdentity, identity)){
					this._itemsByIdentity[identity] = item;
				}else{
					if(this._jsonFileUrl){
						throw new Error("dojo.data.ItemFileReadStore:  The json data as specified by: [" + this._jsonFileUrl + "] is malformed.  Items within the list have identifier: [" + identifier + "].  Value collided: [" + identity + "]");
					}else if(this._jsonData){
						throw new Error("dojo.data.ItemFileReadStore:  The json data provided by the creation arguments is malformed.  Items within the list have identifier: [" + identifier + "].  Value collided: [" + identity + "]");
					}
				}
			}
		}else{
			this._features['dojo.data.api.Identity'] = Number;
		}

		// Step 5: Walk through all the items, and set each item's properties
		// for _storeRefPropName and _itemNumPropName, so that store.isItem() will return true.
		for(i = 0; i < this._arrayOfAllItems.length; ++i){
			item = this._arrayOfAllItems[i];
			item[this._storeRefPropName] = this;
			item[this._itemNumPropName] = i;
		}

		// Step 6: We walk through all the attribute values of all the items,
		// looking for type/value literals and item-references.
		//
		// We replace item-references with pointers to items.  For example, we change:
		//		{ name:['Kermit'], friends:[{_reference:{name:'Miss Piggy'}}] }
		// into this:
		//		{ name:['Kermit'], friends:[miss_piggy] }
		// (where miss_piggy is the object representing the 'Miss Piggy' item).
		//
		// We replace type/value pairs with typed-literals.  For example, we change:
		//		{ name:['Nelson Mandela'], born:[{_type:'Date', _value:'1918-07-18'}] }
		// into this:
		//		{ name:['Kermit'], born:(new Date(1918, 6, 18)) }
		//
		// We also generate the associate map for all items for the O(1) isItem function.
		for(i = 0; i < this._arrayOfAllItems.length; ++i){
			item = this._arrayOfAllItems[i]; // example: { name:['Kermit'], friends:[{_reference:{name:'Miss Piggy'}}] }
			for(key in item){
				arrayOfValues = item[key]; // example: [{_reference:{name:'Miss Piggy'}}]
				for(var j = 0; j < arrayOfValues.length; ++j){
					value = arrayOfValues[j]; // example: {_reference:{name:'Miss Piggy'}}
					if(value !== null && typeof value == "object"){
						if(("_type" in value) && ("_value" in value)){
							var type = value._type; // examples: 'Date', 'Color', or 'ComplexNumber'
							var mappingObj = this._datatypeMap[type]; // examples: Date, dojo.Color, foo.math.ComplexNumber, {type: dojo.Color, deserialize(value){ return new dojo.Color(value)}}
							if(!mappingObj){
								throw new Error("dojo.data.ItemFileReadStore: in the typeMap constructor arg, no object class was specified for the datatype '" + type + "'");
							}else if(dojo.isFunction(mappingObj)){
								arrayOfValues[j] = new mappingObj(value._value);
							}else if(dojo.isFunction(mappingObj.deserialize)){
								arrayOfValues[j] = mappingObj.deserialize(value._value);
							}else{
								throw new Error("dojo.data.ItemFileReadStore: Value provided in typeMap was neither a constructor, nor a an object with a deserialize function");
							}
						}
						if(value._reference){
							var referenceDescription = value._reference; // example: {name:'Miss Piggy'}
							if(!dojo.isObject(referenceDescription)){
								// example: 'Miss Piggy'
								// from an item like: { name:['Kermit'], friends:[{_reference:'Miss Piggy'}]}
								arrayOfValues[j] = this._getItemByIdentity(referenceDescription);
							}else{
								// example: {name:'Miss Piggy'}
								// from an item like: { name:['Kermit'], friends:[{_reference:{name:'Miss Piggy'}}] }
								for(var k = 0; k < this._arrayOfAllItems.length; ++k){
									var candidateItem = this._arrayOfAllItems[k],
									    found = true;
									for(var refKey in referenceDescription){
										if(candidateItem[refKey] != referenceDescription[refKey]){
											found = false;
										}
									}
									if(found){
										arrayOfValues[j] = candidateItem;
									}
								}
							}
							if(this.referenceIntegrity){
								var refItem = arrayOfValues[j];
								if(this.isItem(refItem)){
									this._addReferenceToMap(refItem, item, key);
								}
							}
						}else if(this.isItem(value)){
							//It's a child item (not one referenced through _reference).
							//We need to treat this as a referenced item, so it can be cleaned up
							//in a write store easily.
							if(this.referenceIntegrity){
								this._addReferenceToMap(value, item, key);
							}
						}
					}
				}
			}
		}
	},

	_addReferenceToMap: function(/*item*/ refItem, /*item*/ parentItem, /*string*/ attribute){
		 //	summary:
		 //		Method to add an reference map entry for an item and attribute.
		 //	description:
		 //		Method to add an reference map entry for an item and attribute. 		 //
		 //	refItem:
		 //		The item that is referenced.
		 //	parentItem:
		 //		The item that holds the new reference to refItem.
		 //	attribute:
		 //		The attribute on parentItem that contains the new reference.
		 
		 //Stub function, does nothing.  Real processing is in ItemFileWriteStore.
	},

	getIdentity: function(/* item */ item){
		//	summary:
		//		See dojo.data.api.Identity.getIdentity()
		var identifier = this._features['dojo.data.api.Identity'];
		if(identifier === Number){
			return item[this._itemNumPropName]; // Number
		}else{
			var arrayOfValues = item[identifier];
			if(arrayOfValues){
				return arrayOfValues[0]; // Object || String
			}
		}
		return null; // null
	},

	fetchItemByIdentity: function(/* Object */ keywordArgs){
		//	summary:
		//		See dojo.data.api.Identity.fetchItemByIdentity()

		// Hasn't loaded yet, we have to trigger the load.
		var item,
		    scope;
		if(!this._loadFinished){
			var self = this;
			//Do a check on the JsonFileUrl and crosscheck it.
			//If it doesn't match the cross-check, it needs to be updated
			//This allows for either url or _jsonFileUrl to he changed to
			//reset the store load location.  Done this way for backwards
			//compatibility.  People use _jsonFileUrl (even though officially
			//private.
			if(this._jsonFileUrl !== this._ccUrl){
				dojo.deprecated("dojo.data.ItemFileReadStore: ",
					"To change the url, set the url property of the store," +
					" not _jsonFileUrl.  _jsonFileUrl support will be removed in 2.0");
				this._ccUrl = this._jsonFileUrl;
				this.url = this._jsonFileUrl;
			}else if(this.url !== this._ccUrl){
				this._jsonFileUrl = this.url;
				this._ccUrl = this.url;
			}
			
			//See if there was any forced reset of data.
			if(this.data != null && this._jsonData == null){
				this._jsonData = this.data;
				this.data = null;
			}

			if(this._jsonFileUrl){

				if(this._loadInProgress){
					this._queuedFetches.push({args: keywordArgs});
				}else{
					this._loadInProgress = true;
					var getArgs = {
							url: self._jsonFileUrl,
							handleAs: "json-comment-optional",
							preventCache: this.urlPreventCache,
							failOk: this.failOk
					};
					var getHandler = dojo.xhrGet(getArgs);
					getHandler.addCallback(function(data){
						var scope = keywordArgs.scope?keywordArgs.scope:dojo.global;
						try{
							self._getItemsFromLoadedData(data);
							self._loadFinished = true;
							self._loadInProgress = false;
							item = self._getItemByIdentity(keywordArgs.identity);
							if(keywordArgs.onItem){
								keywordArgs.onItem.call(scope, item);
							}
							self._handleQueuedFetches();
						}catch(error){
							self._loadInProgress = false;
							if(keywordArgs.onError){
								keywordArgs.onError.call(scope, error);
							}
						}
					});
					getHandler.addErrback(function(error){
						self._loadInProgress = false;
						if(keywordArgs.onError){
							var scope = keywordArgs.scope?keywordArgs.scope:dojo.global;
							keywordArgs.onError.call(scope, error);
						}
					});
				}

			}else if(this._jsonData){
				// Passed in data, no need to xhr.
				self._getItemsFromLoadedData(self._jsonData);
				self._jsonData = null;
				self._loadFinished = true;
				item = self._getItemByIdentity(keywordArgs.identity);
				if(keywordArgs.onItem){
					scope = keywordArgs.scope?keywordArgs.scope:dojo.global;
					keywordArgs.onItem.call(scope, item);
				}
			}
		}else{
			// Already loaded.  We can just look it up and call back.
			item = this._getItemByIdentity(keywordArgs.identity);
			if(keywordArgs.onItem){
				scope = keywordArgs.scope?keywordArgs.scope:dojo.global;
				keywordArgs.onItem.call(scope, item);
			}
		}
	},

	_getItemByIdentity: function(/* Object */ identity){
		//	summary:
		//		Internal function to look an item up by its identity map.
		var item = null;
		if(this._itemsByIdentity &&
		   Object.hasOwnProperty.call(this._itemsByIdentity, identity)){
			item = this._itemsByIdentity[identity];
		}else if (Object.hasOwnProperty.call(this._arrayOfAllItems, identity)){
			item = this._arrayOfAllItems[identity];
		}
		if(item === undefined){
			item = null;
		}
		return item; // Object
	},

	getIdentityAttributes: function(/* item */ item){
		//	summary:
		//		See dojo.data.api.Identity.getIdentityAttributes()
		 
		var identifier = this._features['dojo.data.api.Identity'];
		if(identifier === Number){
			// If (identifier === Number) it means getIdentity() just returns
			// an integer item-number for each item.  The dojo.data.api.Identity
			// spec says we need to return null if the identity is not composed
			// of attributes
			return null; // null
		}else{
			return [identifier]; // Array
		}
	},
	
	_forceLoad: function(){
		//	summary:
		//		Internal function to force a load of the store if it hasn't occurred yet.  This is required
		//		for specific functions to work properly.
		var self = this;
		//Do a check on the JsonFileUrl and crosscheck it.
		//If it doesn't match the cross-check, it needs to be updated
		//This allows for either url or _jsonFileUrl to he changed to
		//reset the store load location.  Done this way for backwards
		//compatibility.  People use _jsonFileUrl (even though officially
		//private.
		if(this._jsonFileUrl !== this._ccUrl){
			dojo.deprecated("dojo.data.ItemFileReadStore: ",
				"To change the url, set the url property of the store," +
				" not _jsonFileUrl.  _jsonFileUrl support will be removed in 2.0");
			this._ccUrl = this._jsonFileUrl;
			this.url = this._jsonFileUrl;
		}else if(this.url !== this._ccUrl){
			this._jsonFileUrl = this.url;
			this._ccUrl = this.url;
		}

		//See if there was any forced reset of data.
		if(this.data != null){
			this._jsonData = this.data;
			this.data = null;
		}

		if(this._jsonFileUrl){
				var getArgs = {
					url: this._jsonFileUrl,
					handleAs: "json-comment-optional",
					preventCache: this.urlPreventCache,
					failOk: this.failOk,
					sync: true
				};
			var getHandler = dojo.xhrGet(getArgs);
			getHandler.addCallback(function(data){
				try{
					//Check to be sure there wasn't another load going on concurrently
					//So we don't clobber data that comes in on it.  If there is a load going on
					//then do not save this data.  It will potentially clobber current data.
					//We mainly wanted to sync/wait here.
					//TODO:  Revisit the loading scheme of this store to improve multi-initial
					//request handling.
					if(self._loadInProgress !== true && !self._loadFinished){
						self._getItemsFromLoadedData(data);
						self._loadFinished = true;
					}else if(self._loadInProgress){
						//Okay, we hit an error state we can't recover from.  A forced load occurred
						//while an async load was occurring.  Since we cannot block at this point, the best
						//that can be managed is to throw an error.
						throw new Error("dojo.data.ItemFileReadStore:  Unable to perform a synchronous load, an async load is in progress.");
					}
				}catch(e){
					console.log(e);
					throw e;
				}
			});
			getHandler.addErrback(function(error){
				throw error;
			});
		}else if(this._jsonData){
			self._getItemsFromLoadedData(self._jsonData);
			self._jsonData = null;
			self._loadFinished = true;
		}
	}
});
//Mix in the simple fetch implementation to this class.
dojo.extend(dojo.data.ItemFileReadStore,dojo.data.util.simpleFetch);

}

if(!dojo._hasResource["dojo.data.ItemFileWriteStore"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.data.ItemFileWriteStore"] = true;
dojo.provide("dojo.data.ItemFileWriteStore");



dojo.declare("dojo.data.ItemFileWriteStore", dojo.data.ItemFileReadStore, {
	constructor: function(/* object */ keywordParameters){
		//	keywordParameters: {typeMap: object)
		//		The structure of the typeMap object is as follows:
		//		{
		//			type0: function || object,
		//			type1: function || object,
		//			...
		//			typeN: function || object
		//		}
		//		Where if it is a function, it is assumed to be an object constructor that takes the
		//		value of _value as the initialization parameters.  It is serialized assuming object.toString()
		//		serialization.  If it is an object, then it is assumed
		//		to be an object of general form:
		//		{
		//			type: function, //constructor.
		//			deserialize:	function(value) //The function that parses the value and constructs the object defined by type appropriately.
		//			serialize:	function(object) //The function that converts the object back into the proper file format form.
		//		}

		// ItemFileWriteStore extends ItemFileReadStore to implement these additional dojo.data APIs
		this._features['dojo.data.api.Write'] = true;
		this._features['dojo.data.api.Notification'] = true;
		
		// For keeping track of changes so that we can implement isDirty and revert
		this._pending = {
			_newItems:{},
			_modifiedItems:{},
			_deletedItems:{}
		};

		if(!this._datatypeMap['Date'].serialize){
			this._datatypeMap['Date'].serialize = function(obj){
				return dojo.date.stamp.toISOString(obj, {zulu:true});
			};
		}
		//Disable only if explicitly set to false.
		if(keywordParameters && (keywordParameters.referenceIntegrity === false)){
			this.referenceIntegrity = false;
		}

		// this._saveInProgress is set to true, briefly, from when save() is first called to when it completes
		this._saveInProgress = false;
	},

	referenceIntegrity: true, //Flag that defaultly enabled reference integrity tracking.  This way it can also be disabled pogrammatially or declaratively.

	_assert: function(/* boolean */ condition){
		if(!condition){
			throw new Error("assertion failed in ItemFileWriteStore");
		}
	},

	_getIdentifierAttribute: function(){
		var identifierAttribute = this.getFeatures()['dojo.data.api.Identity'];
		// this._assert((identifierAttribute === Number) || (dojo.isString(identifierAttribute)));
		return identifierAttribute;
	},
	
	
/* dojo.data.api.Write */

	newItem: function(/* Object? */ keywordArgs, /* Object? */ parentInfo){
		// summary: See dojo.data.api.Write.newItem()

		this._assert(!this._saveInProgress);

		if(!this._loadFinished){
			// We need to do this here so that we'll be able to find out what
			// identifierAttribute was specified in the data file.
			this._forceLoad();
		}

		if(typeof keywordArgs != "object" && typeof keywordArgs != "undefined"){
			throw new Error("newItem() was passed something other than an object");
		}
		var newIdentity = null;
		var identifierAttribute = this._getIdentifierAttribute();
		if(identifierAttribute === Number){
			newIdentity = this._arrayOfAllItems.length;
		}else{
			newIdentity = keywordArgs[identifierAttribute];
			if(typeof newIdentity === "undefined"){
				throw new Error("newItem() was not passed an identity for the new item");
			}
			if(dojo.isArray(newIdentity)){
				throw new Error("newItem() was not passed an single-valued identity");
			}
		}
		
		// make sure this identity is not already in use by another item, if identifiers were
		// defined in the file.  Otherwise it would be the item count,
		// which should always be unique in this case.
		if(this._itemsByIdentity){
			this._assert(typeof this._itemsByIdentity[newIdentity] === "undefined");
		}
		this._assert(typeof this._pending._newItems[newIdentity] === "undefined");
		this._assert(typeof this._pending._deletedItems[newIdentity] === "undefined");
		
		var newItem = {};
		newItem[this._storeRefPropName] = this;
		newItem[this._itemNumPropName] = this._arrayOfAllItems.length;
		if(this._itemsByIdentity){
			this._itemsByIdentity[newIdentity] = newItem;
			//We have to set the identifier now, otherwise we can't look it
			//up at calls to setValueorValues in parentInfo handling.
			newItem[identifierAttribute] = [newIdentity];
		}
		this._arrayOfAllItems.push(newItem);

		//We need to construct some data for the onNew call too...
		var pInfo = null;
		
		// Now we need to check to see where we want to assign this thingm if any.
		if(parentInfo && parentInfo.parent && parentInfo.attribute){
			pInfo = {
				item: parentInfo.parent,
				attribute: parentInfo.attribute,
				oldValue: undefined
			};

			//See if it is multi-valued or not and handle appropriately
			//Generally, all attributes are multi-valued for this store
			//So, we only need to append if there are already values present.
			var values = this.getValues(parentInfo.parent, parentInfo.attribute);
			if(values && values.length > 0){
				var tempValues = values.slice(0, values.length);
				if(values.length === 1){
					pInfo.oldValue = values[0];
				}else{
					pInfo.oldValue = values.slice(0, values.length);
				}
				tempValues.push(newItem);
				this._setValueOrValues(parentInfo.parent, parentInfo.attribute, tempValues, false);
				pInfo.newValue = this.getValues(parentInfo.parent, parentInfo.attribute);
			}else{
				this._setValueOrValues(parentInfo.parent, parentInfo.attribute, newItem, false);
				pInfo.newValue = newItem;
			}
		}else{
			//Toplevel item, add to both top list as well as all list.
			newItem[this._rootItemPropName]=true;
			this._arrayOfTopLevelItems.push(newItem);
		}
		
		this._pending._newItems[newIdentity] = newItem;
		
		//Clone over the properties to the new item
		for(var key in keywordArgs){
			if(key === this._storeRefPropName || key === this._itemNumPropName){
				// Bummer, the user is trying to do something like
				// newItem({_S:"foo"}).  Unfortunately, our superclass,
				// ItemFileReadStore, is already using _S in each of our items
				// to hold private info.  To avoid a naming collision, we
				// need to move all our private info to some other property
				// of all the items/objects.  So, we need to iterate over all
				// the items and do something like:
				//    item.__S = item._S;
				//    item._S = undefined;
				// But first we have to make sure the new "__S" variable is
				// not in use, which means we have to iterate over all the
				// items checking for that.
				throw new Error("encountered bug in ItemFileWriteStore.newItem");
			}
			var value = keywordArgs[key];
			if(!dojo.isArray(value)){
				value = [value];
			}
			newItem[key] = value;
			if(this.referenceIntegrity){
				for(var i = 0; i < value.length; i++){
					var val = value[i];
					if(this.isItem(val)){
						this._addReferenceToMap(val, newItem, key);
					}
				}
			}
		}
		this.onNew(newItem, pInfo); // dojo.data.api.Notification call
		return newItem; // item
	},
	
	_removeArrayElement: function(/* Array */ array, /* anything */ element){
		var index = dojo.indexOf(array, element);
		if(index != -1){
			array.splice(index, 1);
			return true;
		}
		return false;
	},
	
	deleteItem: function(/* item */ item){
		// summary: See dojo.data.api.Write.deleteItem()
		this._assert(!this._saveInProgress);
		this._assertIsItem(item);

		// Remove this item from the _arrayOfAllItems, but leave a null value in place
		// of the item, so as not to change the length of the array, so that in newItem()
		// we can still safely do: newIdentity = this._arrayOfAllItems.length;
		var indexInArrayOfAllItems = item[this._itemNumPropName];
		var identity = this.getIdentity(item);

		//If we have reference integrity on, we need to do reference cleanup for the deleted item
		if(this.referenceIntegrity){
			//First scan all the attributes of this items for references and clean them up in the map
			//As this item is going away, no need to track its references anymore.

			//Get the attributes list before we generate the backup so it
			//doesn't pollute the attributes list.
			var attributes = this.getAttributes(item);

			//Backup the map, we'll have to restore it potentially, in a revert.
			if(item[this._reverseRefMap]){
				item["backup_" + this._reverseRefMap] = dojo.clone(item[this._reverseRefMap]);
			}
			
			//TODO:  This causes a reversion problem.  This list won't be restored on revert since it is
			//attached to the 'value'. item, not ours.  Need to back tese up somehow too.
			//Maybe build a map of the backup of the entries and attach it to the deleted item to be restored
			//later.  Or just record them and call _addReferenceToMap on them in revert.
			dojo.forEach(attributes, function(attribute){
				dojo.forEach(this.getValues(item, attribute), function(value){
					if(this.isItem(value)){
						//We have to back up all the references we had to others so they can be restored on a revert.
						if(!item["backupRefs_" + this._reverseRefMap]){
							item["backupRefs_" + this._reverseRefMap] = [];
						}
						item["backupRefs_" + this._reverseRefMap].push({id: this.getIdentity(value), attr: attribute});
						this._removeReferenceFromMap(value, item, attribute);
					}
				}, this);
			}, this);

			//Next, see if we have references to this item, if we do, we have to clean them up too.
			var references = item[this._reverseRefMap];
			if(references){
				//Look through all the items noted as references to clean them up.
				for(var itemId in references){
					var containingItem = null;
					if(this._itemsByIdentity){
						containingItem = this._itemsByIdentity[itemId];
					}else{
						containingItem = this._arrayOfAllItems[itemId];
					}
					//We have a reference to a containing item, now we have to process the
					//attributes and clear all references to the item being deleted.
					if(containingItem){
						for(var attribute in references[itemId]){
							var oldValues = this.getValues(containingItem, attribute) || [];
							var newValues = dojo.filter(oldValues, function(possibleItem){
								return !(this.isItem(possibleItem) && this.getIdentity(possibleItem) == identity);
							}, this);
							//Remove the note of the reference to the item and set the values on the modified attribute.
							this._removeReferenceFromMap(item, containingItem, attribute);
							if(newValues.length < oldValues.length){
								this._setValueOrValues(containingItem, attribute, newValues, true);
							}
						}
					}
				}
			}
		}

		this._arrayOfAllItems[indexInArrayOfAllItems] = null;

		item[this._storeRefPropName] = null;
		if(this._itemsByIdentity){
			delete this._itemsByIdentity[identity];
		}
		this._pending._deletedItems[identity] = item;
		
		//Remove from the toplevel items, if necessary...
		if(item[this._rootItemPropName]){
			this._removeArrayElement(this._arrayOfTopLevelItems, item);
		}
		this.onDelete(item); // dojo.data.api.Notification call
		return true;
	},

	setValue: function(/* item */ item, /* attribute-name-string */ attribute, /* almost anything */ value){
		// summary: See dojo.data.api.Write.set()
		return this._setValueOrValues(item, attribute, value, true); // boolean
	},
	
	setValues: function(/* item */ item, /* attribute-name-string */ attribute, /* array */ values){
		// summary: See dojo.data.api.Write.setValues()
		return this._setValueOrValues(item, attribute, values, true); // boolean
	},
	
	unsetAttribute: function(/* item */ item, /* attribute-name-string */ attribute){
		// summary: See dojo.data.api.Write.unsetAttribute()
		return this._setValueOrValues(item, attribute, [], true);
	},
	
	_setValueOrValues: function(/* item */ item, /* attribute-name-string */ attribute, /* anything */ newValueOrValues, /*boolean?*/ callOnSet){
		this._assert(!this._saveInProgress);
		
		// Check for valid arguments
		this._assertIsItem(item);
		this._assert(dojo.isString(attribute));
		this._assert(typeof newValueOrValues !== "undefined");

		// Make sure the user isn't trying to change the item's identity
		var identifierAttribute = this._getIdentifierAttribute();
		if(attribute == identifierAttribute){
			throw new Error("ItemFileWriteStore does not have support for changing the value of an item's identifier.");
		}

		// To implement the Notification API, we need to make a note of what
		// the old attribute value was, so that we can pass that info when
		// we call the onSet method.
		var oldValueOrValues = this._getValueOrValues(item, attribute);

		var identity = this.getIdentity(item);
		if(!this._pending._modifiedItems[identity]){
			// Before we actually change the item, we make a copy of it to
			// record the original state, so that we'll be able to revert if
			// the revert method gets called.  If the item has already been
			// modified then there's no need to do this now, since we already
			// have a record of the original state.
			var copyOfItemState = {};
			for(var key in item){
				if((key === this._storeRefPropName) || (key === this._itemNumPropName) || (key === this._rootItemPropName)){
					copyOfItemState[key] = item[key];
				}else if(key === this._reverseRefMap){
					copyOfItemState[key] = dojo.clone(item[key]);
				}else{
					copyOfItemState[key] = item[key].slice(0, item[key].length);
				}
			}
			// Now mark the item as dirty, and save the copy of the original state
			this._pending._modifiedItems[identity] = copyOfItemState;
		}
		
		// Okay, now we can actually change this attribute on the item
		var success = false;
		
		if(dojo.isArray(newValueOrValues) && newValueOrValues.length === 0){
			
			// If we were passed an empty array as the value, that counts
			// as "unsetting" the attribute, so we need to remove this
			// attribute from the item.
			success = delete item[attribute];
			newValueOrValues = undefined; // used in the onSet Notification call below

			if(this.referenceIntegrity && oldValueOrValues){
				var oldValues = oldValueOrValues;
				if(!dojo.isArray(oldValues)){
					oldValues = [oldValues];
				}
				for(var i = 0; i < oldValues.length; i++){
					var value = oldValues[i];
					if(this.isItem(value)){
						this._removeReferenceFromMap(value, item, attribute);
					}
				}
			}
		}else{
			var newValueArray;
			if(dojo.isArray(newValueOrValues)){
				var newValues = newValueOrValues;
				// Unfortunately, it's not safe to just do this:
				//    newValueArray = newValues;
				// Instead, we need to copy the array, which slice() does very nicely.
				// This is so that our internal data structure won't
				// get corrupted if the user mucks with the values array *after*
				// calling setValues().
				newValueArray = newValueOrValues.slice(0, newValueOrValues.length);
			}else{
				newValueArray = [newValueOrValues];
			}

			//We need to handle reference integrity if this is on.
			//In the case of set, we need to see if references were added or removed
			//and update the reference tracking map accordingly.
			if(this.referenceIntegrity){
				if(oldValueOrValues){
					var oldValues = oldValueOrValues;
					if(!dojo.isArray(oldValues)){
						oldValues = [oldValues];
					}
					//Use an associative map to determine what was added/removed from the list.
					//Should be O(n) performant.  First look at all the old values and make a list of them
					//Then for any item not in the old list, we add it.  If it was already present, we remove it.
					//Then we pass over the map and any references left it it need to be removed (IE, no match in
					//the new values list).
					var map = {};
					dojo.forEach(oldValues, function(possibleItem){
						if(this.isItem(possibleItem)){
							var id = this.getIdentity(possibleItem);
							map[id.toString()] = true;
						}
					}, this);
					dojo.forEach(newValueArray, function(possibleItem){
						if(this.isItem(possibleItem)){
							var id = this.getIdentity(possibleItem);
							if(map[id.toString()]){
								delete map[id.toString()];
							}else{
								this._addReferenceToMap(possibleItem, item, attribute);
							}
						}
					}, this);
					for(var rId in map){
						var removedItem;
						if(this._itemsByIdentity){
							removedItem = this._itemsByIdentity[rId];
						}else{
							removedItem = this._arrayOfAllItems[rId];
						}
						this._removeReferenceFromMap(removedItem, item, attribute);
					}
				}else{
					//Everything is new (no old values) so we have to just
					//insert all the references, if any.
					for(var i = 0; i < newValueArray.length; i++){
						var value = newValueArray[i];
						if(this.isItem(value)){
							this._addReferenceToMap(value, item, attribute);
						}
					}
				}
			}
			item[attribute] = newValueArray;
			success = true;
		}

		// Now we make the dojo.data.api.Notification call
		if(callOnSet){
			this.onSet(item, attribute, oldValueOrValues, newValueOrValues);
		}
		return success; // boolean
	},

	_addReferenceToMap: function(/*item*/ refItem, /*item*/ parentItem, /*string*/ attribute){
		//	summary:
		//		Method to add an reference map entry for an item and attribute.
		//	description:
		//		Method to add an reference map entry for an item and attribute. 		 //
		//	refItem:
		//		The item that is referenced.
		//	parentItem:
		//		The item that holds the new reference to refItem.
		//	attribute:
		//		The attribute on parentItem that contains the new reference.
		 
		var parentId = this.getIdentity(parentItem);
		var references = refItem[this._reverseRefMap];

		if(!references){
			references = refItem[this._reverseRefMap] = {};
		}
		var itemRef = references[parentId];
		if(!itemRef){
			itemRef = references[parentId] = {};
		}
		itemRef[attribute] = true;
	},

	_removeReferenceFromMap: function(/* item */ refItem, /* item */ parentItem, /*strin*/ attribute){
		//	summary:
		//		Method to remove an reference map entry for an item and attribute.
		//	description:
		//		Method to remove an reference map entry for an item and attribute.  This will
		//		also perform cleanup on the map such that if there are no more references at all to
		//		the item, its reference object and entry are removed.
		//
		//	refItem:
		//		The item that is referenced.
		//	parentItem:
		//		The item holding a reference to refItem.
		//	attribute:
		//		The attribute on parentItem that contains the reference.
		var identity = this.getIdentity(parentItem);
		var references = refItem[this._reverseRefMap];
		var itemId;
		if(references){
			for(itemId in references){
				if(itemId == identity){
					delete references[itemId][attribute];
					if(this._isEmpty(references[itemId])){
						delete references[itemId];
					}
				}
			}
			if(this._isEmpty(references)){
				delete refItem[this._reverseRefMap];
			}
		}
	},

	_dumpReferenceMap: function(){
		//	summary:
		//		Function to dump the reverse reference map of all items in the store for debug purposes.
		//	description:
		//		Function to dump the reverse reference map of all items in the store for debug purposes.
		var i;
		for(i = 0; i < this._arrayOfAllItems.length; i++){
			var item = this._arrayOfAllItems[i];
			if(item && item[this._reverseRefMap]){
				console.log("Item: [" + this.getIdentity(item) + "] is referenced by: " + dojo.toJson(item[this._reverseRefMap]));
			}
		}
	},
	
	_getValueOrValues: function(/* item */ item, /* attribute-name-string */ attribute){
		var valueOrValues = undefined;
		if(this.hasAttribute(item, attribute)){
			var valueArray = this.getValues(item, attribute);
			if(valueArray.length == 1){
				valueOrValues = valueArray[0];
			}else{
				valueOrValues = valueArray;
			}
		}
		return valueOrValues;
	},
	
	_flatten: function(/* anything */ value){
		if(this.isItem(value)){
			var item = value;
			// Given an item, return an serializable object that provides a
			// reference to the item.
			// For example, given kermit:
			//    var kermit = store.newItem({id:2, name:"Kermit"});
			// we want to return
			//    {_reference:2}
			var identity = this.getIdentity(item);
			var referenceObject = {_reference: identity};
			return referenceObject;
		}else{
			if(typeof value === "object"){
				for(var type in this._datatypeMap){
					var typeMap = this._datatypeMap[type];
					if(dojo.isObject(typeMap) && !dojo.isFunction(typeMap)){
						if(value instanceof typeMap.type){
							if(!typeMap.serialize){
								throw new Error("ItemFileWriteStore:  No serializer defined for type mapping: [" + type + "]");
							}
							return {_type: type, _value: typeMap.serialize(value)};
						}
					} else if(value instanceof typeMap){
						//SImple mapping, therefore, return as a toString serialization.
						return {_type: type, _value: value.toString()};
					}
				}
			}
			return value;
		}
	},
	
	_getNewFileContentString: function(){
		// summary:
		//		Generate a string that can be saved to a file.
		//		The result should look similar to:
		//		http://trac.dojotoolkit.org/browser/dojo/trunk/tests/data/countries.json
		var serializableStructure = {};
		
		var identifierAttribute = this._getIdentifierAttribute();
		if(identifierAttribute !== Number){
			serializableStructure.identifier = identifierAttribute;
		}
		if(this._labelAttr){
			serializableStructure.label = this._labelAttr;
		}
		serializableStructure.items = [];
		for(var i = 0; i < this._arrayOfAllItems.length; ++i){
			var item = this._arrayOfAllItems[i];
			if(item !== null){
				var serializableItem = {};
				for(var key in item){
					if(key !== this._storeRefPropName && key !== this._itemNumPropName && key !== this._reverseRefMap && key !== this._rootItemPropName){
						var attribute = key;
						var valueArray = this.getValues(item, attribute);
						if(valueArray.length == 1){
							serializableItem[attribute] = this._flatten(valueArray[0]);
						}else{
							var serializableArray = [];
							for(var j = 0; j < valueArray.length; ++j){
								serializableArray.push(this._flatten(valueArray[j]));
								serializableItem[attribute] = serializableArray;
							}
						}
					}
				}
				serializableStructure.items.push(serializableItem);
			}
		}
		var prettyPrint = true;
		return dojo.toJson(serializableStructure, prettyPrint);
	},

	_isEmpty: function(something){
		//	summary:
		//		Function to determine if an array or object has no properties or values.
		//	something:
		//		The array or object to examine.
		var empty = true;
		if(dojo.isObject(something)){
			var i;
			for(i in something){
				empty = false;
				break;
			}
		}else if(dojo.isArray(something)){
			if(something.length > 0){
				empty = false;
			}
		}
		return empty; //boolean
	},
	
	save: function(/* object */ keywordArgs){
		// summary: See dojo.data.api.Write.save()
		this._assert(!this._saveInProgress);
		
		// this._saveInProgress is set to true, briefly, from when save is first called to when it completes
		this._saveInProgress = true;
		
		var self = this;
		var saveCompleteCallback = function(){
			self._pending = {
				_newItems:{},
				_modifiedItems:{},
				_deletedItems:{}
			};

			self._saveInProgress = false; // must come after this._pending is cleared, but before any callbacks
			if(keywordArgs && keywordArgs.onComplete){
				var scope = keywordArgs.scope || dojo.global;
				keywordArgs.onComplete.call(scope);
			}
		};
		var saveFailedCallback = function(err){
			self._saveInProgress = false;
			if(keywordArgs && keywordArgs.onError){
				var scope = keywordArgs.scope || dojo.global;
				keywordArgs.onError.call(scope, err);
			}
		};
		
		if(this._saveEverything){
			var newFileContentString = this._getNewFileContentString();
			this._saveEverything(saveCompleteCallback, saveFailedCallback, newFileContentString);
		}
		if(this._saveCustom){
			this._saveCustom(saveCompleteCallback, saveFailedCallback);
		}
		if(!this._saveEverything && !this._saveCustom){
			// Looks like there is no user-defined save-handler function.
			// That's fine, it just means the datastore is acting as a "mock-write"
			// store -- changes get saved in memory but don't get saved to disk.
			saveCompleteCallback();
		}
	},
	
	revert: function(){
		// summary: See dojo.data.api.Write.revert()
		this._assert(!this._saveInProgress);

		var identity;
		for(identity in this._pending._modifiedItems){
			// find the original item and the modified item that replaced it
			var copyOfItemState = this._pending._modifiedItems[identity];
			var modifiedItem = null;
			if(this._itemsByIdentity){
				modifiedItem = this._itemsByIdentity[identity];
			}else{
				modifiedItem = this._arrayOfAllItems[identity];
			}
	
			// Restore the original item into a full-fledged item again, we want to try to
			// keep the same object instance as if we don't it, causes bugs like #9022.
			copyOfItemState[this._storeRefPropName] = this;
			for(key in modifiedItem){
				delete modifiedItem[key];
			}
			dojo.mixin(modifiedItem, copyOfItemState);
		}
		var deletedItem;
		for(identity in this._pending._deletedItems){
			deletedItem = this._pending._deletedItems[identity];
			deletedItem[this._storeRefPropName] = this;
			var index = deletedItem[this._itemNumPropName];

			//Restore the reverse refererence map, if any.
			if(deletedItem["backup_" + this._reverseRefMap]){
				deletedItem[this._reverseRefMap] = deletedItem["backup_" + this._reverseRefMap];
				delete deletedItem["backup_" + this._reverseRefMap];
			}
			this._arrayOfAllItems[index] = deletedItem;
			if(this._itemsByIdentity){
				this._itemsByIdentity[identity] = deletedItem;
			}
			if(deletedItem[this._rootItemPropName]){
				this._arrayOfTopLevelItems.push(deletedItem);
			}
		}
		//We have to pass through it again and restore the reference maps after all the
		//undeletes have occurred.
		for(identity in this._pending._deletedItems){
			deletedItem = this._pending._deletedItems[identity];
			if(deletedItem["backupRefs_" + this._reverseRefMap]){
				dojo.forEach(deletedItem["backupRefs_" + this._reverseRefMap], function(reference){
					var refItem;
					if(this._itemsByIdentity){
						refItem = this._itemsByIdentity[reference.id];
					}else{
						refItem = this._arrayOfAllItems[reference.id];
					}
					this._addReferenceToMap(refItem, deletedItem, reference.attr);
				}, this);
				delete deletedItem["backupRefs_" + this._reverseRefMap];
			}
		}

		for(identity in this._pending._newItems){
			var newItem = this._pending._newItems[identity];
			newItem[this._storeRefPropName] = null;
			// null out the new item, but don't change the array index so
			// so we can keep using _arrayOfAllItems.length.
			this._arrayOfAllItems[newItem[this._itemNumPropName]] = null;
			if(newItem[this._rootItemPropName]){
				this._removeArrayElement(this._arrayOfTopLevelItems, newItem);
			}
			if(this._itemsByIdentity){
				delete this._itemsByIdentity[identity];
			}
		}

		this._pending = {
			_newItems:{},
			_modifiedItems:{},
			_deletedItems:{}
		};
		return true; // boolean
	},
	
	isDirty: function(/* item? */ item){
		// summary: See dojo.data.api.Write.isDirty()
		if(item){
			// return true if the item is dirty
			var identity = this.getIdentity(item);
			return new Boolean(this._pending._newItems[identity] ||
				this._pending._modifiedItems[identity] ||
				this._pending._deletedItems[identity]).valueOf(); // boolean
		}else{
			// return true if the store is dirty -- which means return true
			// if there are any new items, dirty items, or modified items
			if(!this._isEmpty(this._pending._newItems) ||
				!this._isEmpty(this._pending._modifiedItems) ||
				!this._isEmpty(this._pending._deletedItems)){
				return true;
			}
			return false; // boolean
		}
	},

/* dojo.data.api.Notification */

	onSet: function(/* item */ item,
					/*attribute-name-string*/ attribute,
					/*object | array*/ oldValue,
					/*object | array*/ newValue){
		// summary: See dojo.data.api.Notification.onSet()
		
		// No need to do anything. This method is here just so that the
		// client code can connect observers to it.
	},

	onNew: function(/* item */ newItem, /*object?*/ parentInfo){
		// summary: See dojo.data.api.Notification.onNew()
		
		// No need to do anything. This method is here just so that the
		// client code can connect observers to it.
	},

	onDelete: function(/* item */ deletedItem){
		// summary: See dojo.data.api.Notification.onDelete()
		
		// No need to do anything. This method is here just so that the
		// client code can connect observers to it.
	},

	close: function(/* object? */ request){
		 // summary:
		 //		Over-ride of base close function of ItemFileReadStore to add in check for store state.
		 // description:
		 //		Over-ride of base close function of ItemFileReadStore to add in check for store state.
		 //		If the store is still dirty (unsaved changes), then an error will be thrown instead of
		 //		clearing the internal state for reload from the url.

		 //Clear if not dirty ... or throw an error
		 if(this.clearOnClose){
			 if(!this.isDirty()){
				 this.inherited(arguments);
			 }else{
				 //Only throw an error if the store was dirty and we were loading from a url (cannot reload from url until state is saved).
				 throw new Error("dojo.data.ItemFileWriteStore: There are unsaved changes present in the store.  Please save or revert the changes before invoking close.");
			 }
		 }
	}
});

}

if(!dojo._hasResource["plugins.core.Common.Array"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.core.Common.Array"] = true;
dojo.provide("plugins.core.Common.Array");

/* SUMMARY: THIS CLASS IS INHERITED BY Common.js AND CONTAINS 
	
	ARRAY METHODS  
*/

dojo.declare( "plugins.core.Common.Array",	[  ], {

///////}}}
// HASHARRAY METHODS
_getIndex : function (array, key) {
	//console.log("  Common.Array._getIndex    array: ");
	//console.dir({array:array});
	//console.log("  Common.Array._getIndex    key: " + key);
	
	for ( var i = 0; i < array.length; i++ ) {
		//console.log("  Common.Array._getIndex    array[i]: " + array[i]);
		if ( array[i] == key ) {
			//console.log("  Common.Array._getIndex    RETURNING " + i);
			return i;
		}
	}
	
	return -1;
},
_getObjectByKeyValue : function (hasharray, key, value) {
// RETRIEVE AN OBJECT FROM AN ARRAY, IDENTIFED BY A KEY:VALUE PAIR
	//console.log("  Common.Array._getObjectByKeyValue    plugins.core.Common._getObjectByKeyValue(hasharray, key, value)");
	//console.log("  Common.Array._getObjectByKeyValue    hasharray: ");
	//console.dir({hasharray:hasharray});
	//console.log("  Common.Array._getObjectByKeyValue    key: " + key);
	//console.log("  Common.Array._getObjectByKeyValue    value: " + value);
	if ( hasharray == null )	return;
	for ( var i = 0; i < hasharray.length; i++ )
	{
		//console.log("  Common.Array._getObjectByKeyValue    hasharray[" + i + "]: ");
		//console.dir({hasharray_entry:hasharray[i]});
		//console.log("  Common.Array._getObjectByKeyValue    hasharray[" + i + "][" + key + "]: " + hasharray[i][key]);
		//console.log("  Common.Array._getObjectByKeyValue    BEFORE");
		if ( hasharray[i][key] == value )
			return hasharray[i];
		//console.log("  Common.Array._getObjectByKeyValue    AFTER");
	}
	
	return;
},
_addObjectToArray : function (array, object, requiredKeys) {
// ADD AN OBJECT TO AN ARRAY, CHECK REQUIRED KEY VALUES ARE NOT NULL

	//console.log("  Common.Array._addObjectToArray    plugins.core.Common._addObjectToArray(array, object, requiredKeys)");
	//console.log("  Common.Array._addObjectToArray    array.length: " + array.length);
	//console.log("  Common.Array._addObjectToArray    array: " + dojo.toJson(array));
	//console.log("  Common.Array._addObjectToArray    object: " + dojo.toJson(object, true));
	//console.log("  Common.Array._addObjectToArray    requiredKeys: " + dojo.toJson(requiredKeys));
	
	if ( array == null )
	{
		//console.log("  Common.Array._addObjectToArray    array is null. Creating new Array.");
		array = new Array;
	}
	
	var notDefined = this.notDefined(object, requiredKeys);
	if ( notDefined.length > 0 )
	{
		console.log("  Common.Array._addObjectToArray    notDefined: " + dojo.toJson(notDefined));
		return false;
	}
	
	//console.log("  Common.Array._addObjectToArray    Doing array.push(object)");
	array.push(object);

	return true;
},
_removeObjectFromArray : function (array, object, keys) {
// REMOVE AN OBJECT FROM AN ARRAY, IDENTIFY OBJECT USING SPECIFIED KEY VALUES

	//console.log("  Common.Array._removeObjectFromArray    BEFORE getIndexInArray, array: " + dojo.toJson(array));
	//console.dir({array:array});
	//console.dir({object:object});
	//console.dir({keys:keys});
	
	var index = this._getIndexInArray(array, object, keys);
	//console.log("  Common.Array._removeObjectFromArray    index: " + index);

	if ( index == null )	return false;
	
	//console.log("  Common.Array._removeObjectFromArray    AFTER this._getIndexInArray    array: " + dojo.toJson(array));

	//console.log("  Common.Array._removeObjectFromArray    BEFORE SPLICE array.length: " + array.length);
	array.splice(index, 1);
	//console.log("  Common.Array._removeObjectFromArray    AFTER SPLICE array.length: " + array.length);

	//console.log("  Common.Array._removeObjectFromArray    AFTER array: " + dojo.toJson(array));

	return true;
},
_removeArrayFromArray : function(hasharray, removeThis, uniqueKeys) {
// REMOVE AN ARRAY OF OBJECTS FROM A LARGER ARRAY CONTAINING IT,
// IDENTIFYING OBJECTS USING THE SPECIFIED KEY VALUES

	//console.log("  Common.Array.removeArrayFromArray    hasharray.length: " + hasharray.length);
	//console.log("  Common.Array.removeArrayFromArray    removeThis.length: " + removeThis.length);
	
	var success = true;
	for ( var j = 0; j < removeThis.length; j++ )
	{
		////console.log("  Common.Array.removeArrayFromArray    Removing removeThis[" + j + "]");
		////console.log("  Common.Array.removeArrayFromArray    Removing removeThis[" + j + "]: " + dojo.toJson(removeThis[j]));
		
		var notDefined = this.notDefined (removeThis[j], uniqueKeys);
		if ( notDefined.length > 0 )
		{
			////console.log("  Common.Array.removeArrayFromArray    SKIPPING removeArrayFromArray FOR removeThis[" + j + "] BECAUSE IT HAS notDefined VALUES: " + dojo.toJson(removeThis[j]));
			console.log("  Common.Array.removeArrayFromArray    object has notDefined keys: " + dojo.toJson(notDefined));
			success = false;
			continue;
		}
		////console.log("  Common.Array.removeArrayFromArray    notDefined: " + dojo.toJson(notDefined));
		var thisSuccess = this._removeObjectFromArray(hasharray, removeThis[j], uniqueKeys);
		if ( thisSuccess == false ) success = thisSuccess;
		////console.log("  Common.Array.removeArrayFromArray    removeSuccess: " + dojo.toJson(removeSuccess));
	}
	//console.log("  Common.Array.removeArrayFromArray    FINAL hasharray.length: " + hasharray.length);
	
	return success;
},
_getIndexInArray : function (hasharray, object, keys) {
// GET THE INDEX OF AN OBJECT IN AN ARRAY, IDENTIFY OBJECT USING SPECIFIED KEY VALUES
	//console.dir({hasharray:hasharray});
	//console.dir({object:object});
	//console.dir({keys:keys});
		
	if ( hasharray == null )
	{
		//console.log("  Common.Array._getIndexInArray    hasharray is null. Returning null.");
		return null;
	}
	
	for ( var i = 0; i < hasharray.length; i++ )
	{
		var arrayObject = hasharray[i];
		//console.dir({arrayObject:arrayObject});
		
		var identified = true;
		for ( var j = 0; j < keys.length; j++ )
		{
			//console.log("  Common.Array._getIndexInArray    Checking value for keys[" + j + "]: " + keys[j] + ": " + arrayObject[keys[j]]);
			if ( arrayObject[keys[j]] != object[keys[j]] )
			{
				//console.log("  Common.Array._getIndexInArray    object[" + keys[j] + "] : " + object[keys[j]]);
				//console.log("  Common.Array._getIndexInArray    arrayObject[" + keys[j] + "] : " + arrayObject[keys[j]]);
				//console.log("  Common.Array._getIndexInArray    " + arrayObject[keys[j]] + "** != **" + object[keys[j]] + "**");
				identified = false;
				break;
			}
		}
		//console.log("  Common.Array._getIndexInArray    identified: " + identified);

		if ( identified == true )
		{
			//console.log("  Common.Array._getIndexInArray    Returning index: " + i);
			return i;
		}
	}
	
	return null;
},
_objectInArray : function (array, object, keys) {
// RETURN true IF AN OBJECT ALREADY BELONGS TO A GROUP

	//console.log("  Common.Array._objectInArray    Agua._objectInArray(array, object, keys)");
	
	if ( array == null )	return false;
	if ( object == null )	return false;
	
	var index = this._getIndexInArray(array, object, keys);

	if ( index == null )	return false;

	//console.log("  Common.Array._objectInArray    Returning true");
	return true;
},
_removeObjectsFromArray : function (hasharray, object, keys) {
// REMOVE AN OBJECT FROM AN ARRAY, IDENTIFY OBJECT USING SPECIFIED KEY VALUES
	//console.log("  Common.Array._removeObjectFromArray    plugins.core.Common._removeObjectFromArray(array, object, keys)");
	//console.log("  Common.Array._removeObjectFromArray    hasharray: " + dojo.toJson(hasharray, true));
	//console.log("  Common.Array._removeObjectFromArray    object: " + dojo.toJson(object, true));
	//console.log("  Common.Array._removeObjectFromArray    keys: " + dojo.toJson(keys));
	if ( hasharray == null )	return;	

	var removed = new Array;
	for ( var i = 0; i < hasharray.length; i++ )
	{
		var arrayObject = hasharray[i];
		//console.log("  Common.Array._getIndexInArray    arrayObject: " + dojo.toJson(arrayObject));
		var identified = true;
		for ( var j = 0; j < keys.length; j++ )
		{
			//console.log("  Common.Array._getIndexInArray    Checking value for keys[" + j + "]: " + keys[j] + ": " + arrayObject[keys[j]]);
			if ( arrayObject[keys[j]] != object[keys[j]] )
			{
				//console.log("  Common.Array._getIndexInArray    object[" + keys[j] + "] : " + object[keys[j]]);
				//console.log("  Common.Array._getIndexInArray    arrayObject[" + keys[j] + "] : " + arrayObject[keys[j]]);
				//console.log("  Common.Array._getIndexInArray    " + arrayObject[keys[j]] + "** != **" + object[keys[j]] + "**");
				identified = false;
				break;
			}
		}
		//console.log("  Common.Array._getIndexInArray    identified: " + identified);

		if ( identified == true )
		{
			removed.push(hasharray.splice(i, 1));
			i--;
		}
	}
	
	//console.log("  Common.Array._removeObjectFromArray    BEFORE SPLICE array.length: " + array.length);
	//console.log("  Common.Array._removeObjectFromArray    AFTER SPLICE array.length: " + array.length);

	return removed;
},
_addArrayToArray : function (hasharray, array, keys) {
// REMOVE AN OBJECT FROM AN ARRAY, IDENTIFY OBJECT USING SPECIFIED KEY VALUES
	//console.log("  Common.Array._addArrayToArray    plugins.core.Common._addArrayToArray(array, object, keys)");
	//console.log("  Common.Array._addArrayToArray    hasharray: " + dojo.toJson(hasharray, true));
	//console.log("  Common.Array._addArrayToArray    object: " + dojo.toJson(object, true));
	//console.log("  Common.Array._addArrayToArray    keys: " + dojo.toJson(keys));
	if ( hasharray == null )	return;	

	var success = true;
	for ( var i = 0; i < array.length; i++ )
	{
		if ( ! this._addObjectToArray(hasharray, array[i], keys) )
			success = false;
	}

	return success;
},
_objectsMatchByKey : function (object1, object2, keys) {
	console.log("    Common._objectsMatchByKey object1:");
	console.dir({object1:object1});
	console.log("    Common._objectsMatchByKey object2:");
	console.dir({object2:object2});
	
	if ( ! object1 || ! object2 )	return;

	if ( object1 == null || object1 == null || keys == null )	return false;
	for ( var i = 0; i < keys.length; i++ ){
		if ( object1[keys[i]] != object2[keys[i]] )	return false;
	}
	
	return true;
},
hashArrayKeyToArray : function (hasharray, key) {
// RETURN AN ARRAY CONTAINING ONLY OBJECTS WHICH HAVE
// A DEFINED VALUE FOR THE SPECIFIED key 

	//console.log("  Common.Array.hashArrayKeyToArray    hasharray: ");
	//console.dir({hasharray:hasharray});
	//console.log("  Common.Array.hashArrayKeyToArray    key: " + key);
	//
	var outputArray = new Array;
	dojo.forEach(hasharray, function(entry) {
		//console.log("  Common.Array.hashArrayKeyToArray    entry[" + key + "]: " + entry[key]);
		if ( entry[key] )
			outputArray.push(entry[key]);
	});
	//console.log("  Common.Array.hashArrayKeyToArray    outputArray: ");
	//console.dir({outputArray:outputArray});

	return outputArray;
},
hashkeysToArray : function (hash) {
// RETURN AN ARRAY CONTAINING ONLY THE KEYS OF A HASH

	//console.log("  Common.Array.hashkeysToArray    plugins.core.Common.hashkeysToArray(hash)");
	//console.log("  Common.Array.hashkeysToArray    hash: " + dojo.toJson(hash));
	var array = new Array;
	for ( var key in hash )
	{
		if ( key != null && key != '' )   array.push(key);
	}
	//console.log("  Common.Array.hashkeysToArray    array: " + dojo.toJson(array));

	return array;
},
filterHasharray : function (hasharray, key) {
// RETURN A HASHARRAY CONTAINING THE SPECIFIED key VALUE
// IN EACH HASH IN A HASHARRAY

	var outputHasharray = new Array;
	dojo.forEach(hasharray, function(entry) {
		if ( entry[key] != null )
		{
			outputHasharray.push(entry);
		}
	});
	
	return outputHasharray;
},
filterByKeyValues : function (hasharray, keyarray, valuearray ) {
// RETURN AN ARRAY OF OBJECTS THAT ALL POSSESS GIVEN KEY VALUE
// NB: THIS SPLICES OUT THE ENTRIES FROM THE ACTUAL INPUT ARRAY
// REFERENCE I.E., THE PASSED ARRAY WILL SHRINK IN SIZE

	//console.log("  Common.Array.filterByKeyValues    plugins.core.Common.filterByKeyValues(hasharrray, keyarray, valuearray)");
	//console.log("  Common.Array.filterByKeyValues    hasharray: " + dojo.toJson(hasharray));
	//console.log("  Common.Array.filterByKeyValues    keyarray: " + dojo.toJson(keyarray));
	//console.log("  Common.Array.filterByKeyValues    valuearray: " + dojo.toJson(valuearray));
	if ( hasharray == null )	return;
	if ( keyarray == null )	return;
	if ( valuearray == null )	return;
	
	for ( var i = 0; i < hasharray.length; i++ )
	{
		var isMatched = true;
		for ( var j = 0; j < keyarray.length; j++ )
		{
			//console.log("  Common.Array.filterByKeyValues    hasharray[" + i + "][" + keyarray[j] + "]: " + hasharray[i][keyarray[j]]);
			//console.log("  Common.Array.filterByKeyValues    valuearray[" + j + "]: " + valuearray[j]);
			if ( hasharray[i][keyarray[j]] != valuearray[j] )
			{
				isMatched = false;
				break;
			}
		}
		if ( isMatched == false )	{
			var removed = hasharray[i];
			//console.log("  Common.Array.filterByKeyValues    removed name: " + removed.name + ", paramtype: " + removed.parametype);
			hasharray.splice(i, 1);
			i--;
		}
	}
	
	//console.log("  Common.Array.filterByKeyValues    Returning hasharray: " + dojo.toJson(hasharray));
	return hasharray;
},
// two-D ARRAY
_addArrayToArray : function (twoDArray, array, requiredKeys) {
// ADD AN ARRAY TO A TWO-D ARRAY, CHECK REQUIRED KEY VALUES ARE NOT NULL
	//console.log("  Common.Array._addArrayToArray    twoDArray: " + dojo.toJson(twoDArray));
	//console.log("  Common.Array._addArrayToArray    array: " + dojo.toJson(array, true));
	//console.log("  Common.Array._addArrayToArray    requiredKeys: " + dojo.toJson(requiredKeys));
	
	if ( twoDArray == null )
	{
		//console.log("  Common.Array._addArrayToArray    twoDArray is null. Creating new Array.");
		twoDArray = new Array;
	}
	
	var notDefined = this.notDefined(array, requiredKeys);
	if ( notDefined.length > 0 )
	{
		console.log("  Common.Array._addArrayToArray    notDefined: " + dojo.toJson(notDefined));
		return false;
	}
	console.log("  Common.Array._addArrayToArray    Doing twoDArray.push(array)");
	twoDArray.push(array);
	console.log("  Common.Array._addArrayToArray    AFTER twoDArray.push(array). twoDArray: " + dojo.toJson(twoDArray));

	return true;
},
// DATA METHODS
notDefined : function (hasharray, keys) {
// RETURN AN ARRAY OF THE UNDEFINED FIELDS IN A HASH

	//console.log("  Common.Array.notDefined    plugins.core.Common.notDefined(hasharray, order)");
	if ( hasharray == null )	return;
	var notDefined = new Array;
	for ( var i = 0; i < keys.length; i++ )
	{
		if ( hasharray[keys[i]] == null )	notDefined.push(keys[i]);
	}
	
	return notDefined;
},
getEntry : function (hasharray, keyarray, valuearray ) {
// RETURN AN ENTRY IN A HASH ARRAY IDENTIFIED BY ITS UNIQUE KEYS
	//console.log("  Common.Array.getEntry    plugins.core.Common.getEntry(hasharrray, keyarray, valuearray)");
	//console.log("  Common.Array.getEntry    hasharray: " + dojo.toJson(hasharray));
	//console.log("  Common.Array.getEntry    keyarray: " + dojo.toJson(keyarray));
	//console.log("  Common.Array.getEntry    valuearray: " + dojo.toJson(valuearray));
	if ( hasharray == null )	return;
	if ( keyarray == null )	return;
	if ( valuearray == null )	return;
	
	for ( var i = 0; i < hasharray.length; i++ )
	{
		var isMatched = true;
		for ( var j = 0; j < keyarray.length; j++ )
		{
			//console.log("  Common.Array.getEntry    hasharray[" + i + "][" + keyarray[j] + "]: " + hasharray[i][keyarray[j]]);
			//console.log("  Common.Array.getEntry    valuearray[" + j + "]: " + valuearray[j]);
			if ( hasharray[i][keyarray[j]] != valuearray[j] )
			{
				isMatched = false;
				break;
			}
		}

		//console.log("  Common.Array.getEntry    isMatched: " + isMatched);
		if ( isMatched == true )
		{
			//console.log("  Common.Array.getEntry    isMatched is true. valueArray: " + dojo.toJson(valuearray));
			//console.log("  Common.Array.getEntry    Returning hasharray[" + i + "]: " + dojo.toJson( hasharray[i]));
			return hasharray[i];
		}
	}
	console.log("  Common.Array.getEntry    Returning null");

	return null;
},
uniqueValues : function(array) {
	//console.log("  Common.Array.uniqueValues    plugins.core.Common.uniqueValues(array)");

	if ( array.length == 1 )	return array;

	array = array.sort();		
	for ( var i = 1; i < array.length; i++ )
	{
		if ( array[i-1] == array[i] )
		{
			array.splice(i, 1);
			i--;
			
		}
	}
	//console.log("  Common.Array.uniqueValues    array: " + dojo.toJson(array));
	
	return array;
}

});

}

if(!dojo._hasResource["plugins.core.Common.ComboBox"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.core.Common.ComboBox"] = true;
dojo.provide("plugins.core.Common.ComboBox");

/* SUMMARY: THIS CLASS IS INHERITED BY Common.js AND CONTAINS 
	
	COMBOBOX METHODS  
*/

dojo.declare( "plugins.core.Common.ComboBox",	[  ], {

///////}}}
// COMBOBOX METHODS
setUsernameCombo : function () {
//	POPULATE COMBOBOX AND SET SELECTED ITEM
//	INPUTS: Agua.sharedprojects DATA OBJECT
//	OUTPUTS:	ARRAY OF USERNAMES IN COMBO BOX, ONCLICK CALL TO setSharedProjectCombo
	//console.log("  Common.ComboBox.setUsernameCombo    plugins.core.Common.setUsernameCombo()");
	var usernames = Agua.getSharedUsernames();
	//console.log("  Common.ComboBox.setUsernameCombo    usernames: " + dojo.toJson(usernames));

	// RETURN IF projects NOT DEFINED
	if ( usernames == null || usernames.length == 0 )
	{
		//console.log("  Common.ComboBox.setUsernameCombo    usernames not defined. Returning.");
		return;
	}

	// DO data FOR store
	var data = {identifier: "name", items: []};
	for ( var i in usernames )
	{
		data.items[i] = { name: usernames[i]	};
	}
	//console.log("  Common.ComboBox.setUsernameCombo    store data: " + dojo.toJson(data));

	// CREATE store
	var store = new dojo.data.ItemFileReadStore( {	data: data	} );
	//console.log("   Common.setUsernameCombo    store: " + dojo.toJson(store));

	// ADD STORE TO USERNAMES COMBO
	this.usernameCombo.store = store;	
	
	// START UP AND SET VALUE
	this.usernameCombo.startup();
	this.usernameCombo.set('value', usernames[0]);			
},
setSharedProjectCombo : function (username, projectName, workflowName) {
//	POPULATE COMBOBOX AND SET SELECTED ITEM
//	INPUTS: USERNAME, OPTIONAL PROJECT NAME AND WORKFLOW NAME
//	OUTPUTS: ARRAY OF USERNAMES IN COMBO BOX, ONCLICK CALL TO setSharedWorkflowCombo

	//console.log("  Common.ComboBox.setSharedProjectCombo    plugins.report.Workflow.setSharedProjectCombo(username, project, workflow)");

	var projects = Agua.getSharedProjectsByUsername(username);
	if ( projects == null )
	{
		//console.log("   Common.setSharedProjectCombo    projects is null. Returning");
		return;
	}
	//console.log("  Common.ComboBox.setSharedProjectCombo    projects: " + dojo.toJson(projects));
	
	var projectNames = this.hashArrayKeyToArray(projects, "name");
	projectNames = this.uniqueValues(projectNames);
	//console.log("  Common.ComboBox.setSharedProjectCombo    projectNames: " + dojo.toJson(projectNames));
	
	// RETURN IF projects NOT DEFINED
	if ( projectNames == null || projectNames.length == 0 )
	{
		//console.log("  Common.ComboBox.setSharedProjectCombo    projectNames not defined. Returning.");
		return;
	}

	// DO data FOR store
	var data = {identifier: "name", items: []};
	for ( var i in projectNames )
	{
		data.items[i] = { name: projectNames[i]	};
	}
	//console.log("  Common.ComboBox.setSharedProjectCombo    store data: " + dojo.toJson(data));

	// CREATE store
	var store = new dojo.data.ItemFileReadStore( {	data: data	} );
	//console.log("  Common.ComboBox.setSharedProjectCombo    store: " + dojo.toJson(store));

	// ADD STORE TO USERNAMES COMBO
	this.projectCombo.store = store;	
	
	// START UP AND SET VALUE
	this.projectCombo.startup();
	this.projectCombo.set('value', projectNames[0]);	
},
setSharedWorkflowCombo : function (username, projectName, workflowName) {
//	POPULATE COMBOBOX AND SET SELECTED ITEM
//	INPUTS: USERNAME, OPTIONAL PROJECT NAME AND WORKFLOW NAME
//	OUTPUTS: ARRAY OF USERNAMES IN COMBO BOX, ONCLICK CALL TO setSharedWorkflowCombo

	console.log("  Common.ComboBox.setSharedWorkflowCombo    plugins.report.Workflow.setSharedWorkflowCombo(username, project, workflow)");
	console.log("  Common.ComboBox.setSharedWorkflowCombo    projectName: " + projectName);
				
	if ( projectName == null )	projectName = this.projectCombo.get('value');
	console.log("  Common.ComboBox.setSharedWorkflowCombo    AFTER projectName: " + projectName);

	var workflows = Agua.getSharedWorkflowsByProject(username, projectName);
	if ( workflows == null )
	{
		console.log("  Common.ComboBox.setSharedWorkflowCombo    workflows is null. Returning");
		return;
	}
	console.log("  Common.ComboBox.setSharedWorkflowCombo    workflows: ");
	console.dir({workflows:workflows});
	
	var workflowNames = this.hashArrayKeyToArray(workflows, "name");
	workflowNames = this.uniqueValues(workflowNames);
	console.log("  Common.ComboBox.setSharedWorkflowCombo    workflowNames: " + dojo.toJson(workflowNames));
	
	// RETURN IF workflows NOT DEFINED
	if ( workflowNames == null || workflowNames.length == 0 )
	{
		console.log("  Common.ComboBox.setSharedWorkflowCombo    workflowNames not defined. Returning.");
		return;
	}

	// DO data FOR store
	var data = {identifier: "name", items: []};
	for ( var i in workflowNames )
	{
		data.items[i] = { name: workflowNames[i]	};
	}

	// CREATE store
	var store = new dojo.data.ItemFileReadStore( {	data: data	} );

	// ADD STORE TO USERNAMES COMBO
	this.workflowCombo.store = store;	
	
	// START UP AND SET VALUE
	this.workflowCombo.startup();
	this.workflowCombo.set('value', workflowNames[0]);
},
setProjectCombo : function (project, workflow) {
//	INPUT: (OPTIONAL) project, workflow NAMES
//	OUTPUT:	POPULATE COMBOBOX AND SET SELECTED ITEM

	////console.log("  Common.ComboBox.setProjectCombo    plugins.report.Template.Common.setProjectCombo(project,workflow)");
	////console.log("  Common.ComboBox.setProjectCombo    project: " + project);
	////console.log("  Common.ComboBox.setProjectCombo    workflow: " + workflow);

	var projectNames = Agua.getProjectNames();
	////console.log("  Common.ComboBox.setProjectCombo    projectNames: " + dojo.toJson(projectNames));

	// RETURN IF projects NOT DEFINED
	if ( ! projectNames )
	{
		//console.log("  Common.ComboBox.setProjectCombo    projectNames not defined. Returning.");
		return;
	}
	////console.log("  Common.ComboBox.setProjectCombo    projects: " + dojo.toJson(projects));

	// SET PROJECT IF NOT DEFINED TO FIRST ENTRY IN projects
	if ( project == null || ! project)	project = projectNames[0];
	
	// DO DATA ARRAY
	var data = {identifier: "name", items: []};
	for ( var i in projectNames )
	{
		data.items[i] = { name: projectNames[i]	};
	}
	////console.log("  Common.ComboBox.setProjectCombo    store data: " + dojo.toJson(data));

	// CREATE store
	var store = new dojo.data.ItemFileReadStore( {	data: data	} );

	//// GET PROJECT COMBO WIDGET
	var projectCombo = this.projectCombo;
	if ( projectCombo == null )
	{
		//console.log("  Common.ComboBox.setProjectCombo    projectCombo is null. Returning.");
		return;
	}
			
	projectCombo.store = store;	
	////console.log("  Common.ComboBox.setProjectCombo    project: " + project);
	
	// START UP AND SET VALUE
	//projectCombo.startup();
	//console.log("  Common.ComboBox.setProjectCombo    projectCombo.set('value', " + project + ")");
	projectCombo.set('value', project);			
},
setWorkflowCombo : function (project, workflow) {
// SET THE workflow COMBOBOX

	//console.log("  Common.ComboBox.setWorkflowCombo    plugins.workflow.Common.setWorkflowCombo(project, workflow)");

	if ( project == null || ! project )
	{
		//console.log("  Common.ComboBox.setWorkflowCombo    Project not defined. Returning.");
		return;
	}
	//console.log("  Common.ComboBox.setWorkflowCombo    project: " + project);
	//console.log("  Common.ComboBox.setWorkflowCombo    workflow: " + workflow);

	// CREATE THE DATA FOR A STORE		
	var workflows = Agua.getWorkflowsByProject(project);
	//console.log("  Common.ComboBox.setWorkflowCombo    project '" + project + "' workflows: " + dojo.toJson(workflows));

	console.log("  Common.ComboBox.setWorkflowCombo    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX DOING SORT workflows");
	workflows = this.sortHasharrayByKeys(workflows, ["number"]);
	console.log("  Common.ComboBox.setWorkflowCombo    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX AFTER SORT workflows:");
	console.dir({XXXXXXXXXXXXXXXXXworkflows:workflows});
	
	var workflowNames = this.hashArrayKeyToArray(workflows, "name");
	
	
	// RETURN IF workflows NOT DEFINED
	if ( ! workflowNames )
	{
		console.log("  Common.ComboBox.setWorkflowCombo    workflowNames not defined. Returning.");
		return;
	}		

	// DO data FOR store
	var data = {identifier: "name", items: []};
	for ( var i in workflowNames )
	{
		data.items[i] = { name: workflowNames[i]	};
	}
	console.log("  Common.ComboBox.setWorkflowCombo    data: " + dojo.toJson(data));

	// CREATE store
	var store = new dojo.data.ItemFileReadStore( { data: data } );

	// GET WORKFLOW COMBO
	var workflowCombo = this.workflowCombo;
	if ( workflowCombo == null )
	{
		console.log("  Common.ComboBox.setworkflowCombo    workflowCombo is null. Returning.");
		return;
	}

	//console.log("  Common.ComboBox.setWorkflowCombo    workflowCombo: " + workflowCombo);
	workflowCombo.store = store;

	// START UP COMBO AND SET SELECTED VALUE TO FIRST ENTRY IN workflowNames IF NOT DEFINED 
	if ( workflow == null || ! workflow )	workflow = workflowNames[0];
	//console.log("  Common.ComboBox.setWorkflowCombo    workflow: " + workflow);

	workflowCombo.startup();
	workflowCombo.set('value', workflow);			
},
setReportCombo : function (project, workflow, report) {
// SET THE report COMBOBOX

	//console.log("  Common.ComboBox.setReportCombo    plugins.report.Common.setReportCombo(project, workflow, report)");
	//console.log("  Common.ComboBox.setReportCombo    project: " + project);
	//console.log("  Common.ComboBox.setReportCombo    workflow: " + workflow);
	//console.log("  Common.ComboBox.setReportCombo    report: " + report);

	if ( project == null || ! project )
	{
		console.log("  Common.ComboBox.setReportCombo    project not defined. Returning.");
		return;
	}
	if ( workflow == null || ! workflow )
	{
		console.log("  Common.ComboBox.setReportCombo    workflow not defined. Returning.");
		return;
	}
	//console.log("  Common.ComboBox.setReportCombo    project: " + project);
	//console.log("  Common.ComboBox.setReportCombo    workflow: " + workflow);
	//console.log("  Common.ComboBox.setReportCombo    report: " + report);

	var reports = Agua.getReportsByWorkflow(project, workflow);
	if ( reports == null )	reports = [];
	console.log("  Common.ComboBox.setReportCombo    project " + project + " reports: " + dojo.toJson(reports));

	var reportNames = this.hashArrayKeyToArray(reports, "name");
	console.log("  Common.ComboBox.setReportCombo    reportNames: " + dojo.toJson(reportNames));
	
	// DO data FOR store
	var data = {identifier: "name", items: []};
	for ( var i in reports )
	{
		data.items[i] = { name: reportNames[i]	};
	}
	console.log("  Common.ComboBox.setReportCombo    data: " + dojo.toJson(data));

	// CREATE store
	// http://docs.dojocampus.org/dojo/data/ItemFileWriteStore
	var store = new dojo.data.ItemFileReadStore( { data: data } );

	// GET WORKFLOW COMBO
	var reportCombo = this.reportCombo;
	if ( reportCombo == null )
	{
		console.log("  Common.ComboBox.setreportCombo    reportCombo is null. Returning.");
		return;
	}

	console.log("  Common.ComboBox.setReportCombo    reportCombo: " + reportCombo);
	reportCombo.store = store;

	// GET USER INPUT WORKFLOW
	var snpReport = this;

	// START UP COMBO (?? NEEDED ??)
	reportCombo.startup();
	reportCombo.set('value', report);			
},
setViewCombo : function (projectName, viewName) {
// SET THE view COMBOBOX
	console.log("  Common.ComboBox.setViewCombo    projectName: " + projectName);
	console.log("  Common.ComboBox.setViewCombo    viewName: " + viewName);

	// SANITY CHECK
	if ( ! this.viewCombo )	return;
	if ( ! projectName )	return;

	var views = Agua.getViewNames(projectName);

	console.log("  Common.ComboBox.setViewCombo    BEFORE SORT views: ");
	console.dir({views: views});
	
	views.sort(this.sortNaturally);

	console.log("View.setViewCombo    AFTER SORT views: ");
	console.dir({views:views});

	//console.log("  Common.ComboBox.setViewCombo    projectName '" + projectName + "' views: " + dojo.toJson(views));
	
	// RETURN IF views NOT DEFINED
	if ( ! views || views.length == 0 )	views = [];
	//{
		//console.log("  Common.ComboBox.setViewCombo    views not defined. Returning.");
		//return;
		//Agua.addView({ project: projectName, name: "View1" });
		//views = Agua.getViewNames(projectName);
	//}		
	//console.log("  Common.ComboBox.setViewCombo    views: " + dojo.toJson(views));

	// SET view IF NOT DEFINED TO FIRST ENTRY IN views
	if ( viewName == null || ! viewName)
	{
		viewName = views[0];
	}
	//console.log("  Common.ComboBox.setViewCombo    viewName: " + viewName);
	
	// DO data FOR store
	var data = {identifier: "name", items: []};
	for ( var i in views )
	{
		data.items[i] = { name: views[i]	};
	}
	//console.log("  Common.ComboBox.setViewCombo    data: " + dojo.toJson(data));

	// CREATE store
	// http://docs.dojocampus.org/dojo/data/ItemFileWriteStore
	var store = new dojo.data.ItemFileReadStore( { data: data } );

	//console.log("  Common.ComboBox.setViewCombo    this.viewCombo: " + this.viewCombo);
	this.viewCombo.store = store;

	// START UP COMBO (?? NEEDED ??)
	this.viewCombo.startup();
	this.viewCombo.set('value', viewName);			
},
getSelectedValue : function (element) {
	var index = element.selectedIndex;
	//console.log("  Common.ComboBox.getSelectedValue    index: " + index);
	var value = element.options[index].text;
	//console.log("  Common.ComboBox.getSelectedValue    value: " + value);
	
	return value;
}



});

}

if(!dojo._hasResource["plugins.core.Common.Date"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.core.Common.Date"] = true;
dojo.provide("plugins.core.Common.Date");

/* SUMMARY: THIS CLASS IS INHERITED BY Common.js AND CONTAINS 
	
	DATE METHODS  
*/

dojo.declare( "plugins.core.Common.Date",	[  ], {

///////}}}

// DATES
currentDate : function () {
	var date = new Date;
	var string = date.toString();

	return string;
},
currentMysqlDate : function () {
	var date = new Date;
	date = this.dateToMysql(date);	
	
	return date;
},
dateToMysql : function (date) {

  return date.getFullYear()
	+ '-'
	+ (date.getMonth() < 9 ? '0' : '') + (date.getMonth()+1)
	+ '-'
	+ (date.getDate() < 10 ? '0' : '') + date.getDate()
	+ ' '
	+ (date.getHours() < 10 ? '0' : '' ) + date.getHours()
	+ ':'
	+ (date.getMinutes() < 10 ? '0' : '' ) + date.getMinutes() 
	+ ':'
	+ (date.getSeconds() < 10 ? '0' : '' ) + date.getSeconds();
},
mysqlToDate : function (timestamp) {
	// FORMAT: 2007-06-05 15:26:03
	var regex=/^([0-9]{2,4})-([0-1][0-9])-([0-3][0-9]) (?:([0-2][0-9]):([0-5][0-9]):([0-5][0-9]))?$/;
	var elements = timestamp.replace(regex,"$1 $2 $3 $4 $5 $6").split(' ');

	return new Date(elements[0],elements[1]-1,elements[2],elements[3],elements[4],elements[5]);
}



});

}

if(!dojo._hasResource["plugins.core.Common.Sort"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.core.Common.Sort"] = true;
dojo.provide("plugins.core.Common.Sort");

/* SUMMARY: THIS CLASS IS INHERITED BY Common.js AND CONTAINS 
	
	SORT METHODS  
*/

dojo.declare( "plugins.core.Common.Sort",	[  ], {

///////}}}
sortHasharrayByOrder : function (hasharray, order) {
// SORT A HASHARRAY BY THE GIVEN ORDER OF KEYS, EXCLUDING ENTRIES
// THAT DO NOT HAVE VALUES FOR ANY OF THE GIVEN KEYS

	//console.log("  Common.Sort.sortHasharrayByOrder    hasharray: " + dojo.toJson(hasharray));
	//console.log("  Common.Sort.sortHasharrayByOrder    order: " + dojo.toJson(order));

	var orderedArray = new Array;	
	for ( var i = 0; i < order.length; i++ )
	{
		var orderedType = order[i];
		//console.log("  Common.Sort.sortHasharrayByOrder    orderedType: " + orderedType);
		
		for ( var j = 0; j < hasharray.length; j++ )
		{
			//console.log("  Common.Sort.sortHasharrayByOrder    applicationsList[" + j + "]: " + applicationsList[i]);
			var applicationHash = hasharray[j];
			var applicationType;
			for ( var applicationType in applicationHash )
			{
				if ( applicationType == orderedType ) {
					//console.log("  Common.Sort.sortHasharrayByOrder     applicationType: " + applicationType);
					orderedArray.push(applicationHash);
					break;
				}
			}
		}
	}
	
	return orderedArray;		
},
sortNoCase : function (array) {
// DO A NON-CASE SPECIFIC SORT OF AN ARRAY

	//console.log("  Common.Sort.sortNoCase    plugins.core.Common.sortNoCase(array)");
	//console.log("  Common.Sort.sortNoCase    array: " + dojo.toJson(array));
	
	return array.sort( function (a,b)
		{
			return a.toUpperCase() == b.toUpperCase() ?
			(a < b ? -1 : a > b) : (a.toUpperCase() < b.toUpperCase() ? -1 : a.toUpperCase() > b.toUpperCase());
		}
	);
},
sortHasharrayByKeys : function (hashArray, keys) {

	if ( hashArray == null )	return;
	if ( keys == null )	return;
	if ( ! typeof hashArray == "ARRAY" || hashArray == null ) return;
	if ( ! typeof keys == "ARRAY" || keys == null ) return;

	return hashArray.sort(function (a,b) {
    //console.log("  Common.Sort.sortHasharray    a[" + key + "]: " + a[key]);
    //console.log("  Common.Sort.sortHasharray    b[" + key + "]: " + b[key]);

        var result = 1;
        for ( var i = 0; i < keys.length; i++ )
        {
            var key = keys[i];
            //console.log("Doing key '" + key + "'");
            if ( a[key] == null || b[key] == null )
            {
                //console.log("No value for a['" + key + "']: " + a[key] + " or  b['" + key + "']: " + b[key] + " in hashArray items a: " + dojo.toJson(a) + " or b: " + dojo.toJson(b));
                continue;
            }
    
            if ( a[key].toUpperCase && b[key].toUpperCase )
            {

                var aString = a[key].toUpperCase(); 
                var bString = b[key].toUpperCase(); 
                //console.log("aString: " + aString);
                //console.log("bString: " + bString);
    
                result =  aString == bString ?
                ( a[key] < b[key] ? -1 : (a[key] > b[key] ? 1 : 0) )
                    : ( aString < bString ? -1 : (aString > bString ? 1 : 0) );
    
                //console.log("result for key '" + key + "': " + result);
                if ( result != 0 )    break;
            }
            else
            {
                //console.log("Comparing ints a['" + key + "']: " + a[key] + " and  b['" + key + "']: " + b[key]);
                result = a[key] < b[key] ? -1 :
                         ( a[key] > b[key] ? 1 : 0 );

                //console.log("result for key '" + key + "': " + result);
                if ( result != 0 )    break;
            }  
        }
        
        return result;
    });
},
sortHasharray : function (hashArray, key) {
// SORT AN ARRAY OF HASHES BY A SPECIFIED HASH FIELD
// NB: IF THE FIELD IS NULL OR EMPTY IN AN ARRAY ENTRY
// IT WILL BE DISCARDED.

	//console.log("  Common.Sort.sortHasharray    hashArray: " + dojo.toJson(hashArray));
	//console.log("  Common.Sort.sortHasharray    key: " + key);
	if ( hashArray == null )	return;
	if ( key == null )	return;
	if ( ! typeof hashArray == "ARRAY" ) return;
	
	return hashArray.sort(function (a,b) {
		if ( a[key] == null )
		{
			//console.log("No value for key '" + key + "' in hashArray item: " + dojo.toJson(a));
			return;
		}
		if ( b[key] == null )
		{
			//console.log("No value for key '" + key + "' in hashArray item: " + dojo.toJson(b));
			return;
		}

		return a[key].toUpperCase() == b[key].toUpperCase() ?
			(a[key] < b[key] ? -1
			: a[key] > b[key])
			: (a[key].toUpperCase() < b[key].toUpperCase() ? -1
			: a[key].toUpperCase() > b[key].toUpperCase());
		}
	);
},
sortNumericHasharray : function (hashArray, key) {
// SORT AN ARRAY OF HASHES BY A SPECIFIED *NUMERIC* HASH FIELD
// NB: IF THE FIELD IS NULL OR EMPTY IN AN ARRAY ENTRY
// IT WILL BE DISCARDED.

//        console.log("  Common.Sort.sortNumericHasharray    plugins.core.Common.sortNumericHasharray(hashArray, key)");
//		if ( hashArray == null )	return;
//		if ( key == null )	return;
//        console.log("  Common.Sort.sortNumericHasharray    hashArray: " + dojo.toJson(hashArray));
//		console.log("  Common.Sort.sortNumericHasharray    key: " + key);

	if ( hashArray == null )
	{
		console.log("  Common.Sort.sortNumericHasharray    hashArray is null. Returning");
		return;
	}
	
	if ( key == null )
	{
		console.log("  Common.Sort.sortNumericHasharray    key is null. Returning.");
		return;
	}

	// REMOVE NON-NUMERIC ENTRIES FOR SORT KEY
	for ( var i = 0; i < hashArray.length; i++ )
	{
		if ( parseInt(hashArray[i]) == "NaN" )
		{
			hashArray.splice(i, 1);
			i--;
		}
	}

	return hashArray.sort(function (a,b) {
		//console.log("  Common.Sort.sortNumericHasharray    a[" + key + "]: " + a[key]);
		//console.log("  Common.Sort.sortNumericHasharray    b[" + key + "]: " + b[key]);
		return parseInt(a[key]) == parseInt(b[key]) ?
			(  parseInt(a[key]) < parseInt(b[key]) ? -1
			: parseInt(a[key]) > parseInt(b[key])  )
			: (  parseInt(a[key]) < parseInt(b[key]) ? -1
			: parseInt(a[key]) > parseInt(b[key]) );
		}
	);

},
sortNaturally : function (a, b) {
// SORT BY LEFTMOST STRING THEN RIGHTMOST NUMBER
	//console.log("  Common.Sort.sortNaturally    a: " + a);
	//console.log("  Common.Sort.sortNaturally    b: " + b);

	var stringA = a.match(/^(\d*\D+)/);
	var stringB = b.match(/^(\d*\D+)/);
	
	//console.log("  Common.Sort.sortNaturally    stringA: " + stringA);
	//console.log("  Common.Sort.sortNaturally    stringB: " + stringB);
	
	if ( stringA && stringB ) {
		if ( stringA < stringB ) return -1;
		if ( stringA > stringB ) return 1;
	}
	if ( stringA && ! stringB )	return -1;
	if ( ! stringA && stringB )	return 1;
	
	var numberA = a.match(/(\d+)[^\/^\d]*$/);
	var numberB = b.match(/(\d+)[^\/^\d]*$/);
	
	//console.log("  Common.Sort.sortNaturally    numberA: " + numberA);
	//console.log("  Common.Sort.sortNaturally    numberB: " + numberB);
	
	if ( parseInt(numberA) && parseInt(numberB) ) {
		if ( parseInt(numberA) < parseInt(numberB) ) return -1;
		if ( parseInt(numberA) > parseInt(numberB) ) return 1;
		return 0;
	}
	if ( parseInt(numberA) && ! parseInt(numberB) )	return -1;
	if ( ! parseInt(numberA) && parseInt(numberB) )	return 1;

	return 0;	
},	
sortObjectsNaturally : function (a, b, key) {
// SORT BY LEFTMOST STRING THEN RIGHTMOST NUMBER
	//console.log("  Common.Sort.sortObjectsNaturally    a: " + a);
	//console.log("  Common.Sort.sortObjectsNaturally    b: " + b);
	//console.log("  Common.Sort.sortObjectsNaturally    key: " + key);

	if ( a[key] && ! b[key] )	return -1;
	if ( ! a[key] && b[key] )	return 1;
	if ( ! a[key] && ! b[key] )	return 0;

	var stringA = a[key].match(/^(\d*\D+)/);
	if ( stringA )	stringA = stringA[1];
	var stringB = b[key].match(/^(\d*\D+)/);
	if ( stringB )	stringB = stringB[1];
	
	//console.log("  Common.Sort.sortObjectsNaturally    stringA: " + stringA);
	//console.log("  Common.Sort.sortObjectsNaturally    stringB: " + stringB);
	
	if ( stringA && stringB ) {
		if ( stringA < stringB ) return -1;
		if ( stringA > stringB ) return 1;
	}
	if ( stringA && ! stringB )	return -1;
	if ( ! stringA && stringB )	return 1;
	
	var numberA = a[key].match(/(\d+)[^\/^\d]*$/);
	if ( numberA )	numberA = parseInt(numberA[1]);
	var numberB = b[key].match(/(\d+)[^\/^\d]*$/);
	if ( numberB )	numberB = parseInt(numberB[1]);
	
	//console.log("  Common.Sort.sortObjectsNaturally    numberA: " + numberA);
	//console.log("  Common.Sort.sortObjectsNaturally    numberB: " + numberB);
	
	if ( numberA && numberB ) {
		if ( numberA < numberB ) {
			//console.log("  Common.Sort.sortObjectsNaturally    Returning -1");
			return -1;
		}
		if ( numberA > numberB ) {
			//console.log("  Common.Sort.sortObjectsNaturally    Returning 1");
			return 1;
		}
		//console.log("  Common.Sort.sortObjectsNaturally    Returning 0");
		return 0;
	}
	if ( numberA && ! numberB )	return -1;
	if ( ! numberA && numberB )	return 1;

	return 0;	
},	
sortTwoDArray : function (twoDArray, index) {
// SORT AN ARRAY OF HASHES BY A SPECIFIED HASH FIELD
// NB: IF THE FIELD IS NULL OR EMPTY IN AN ARRAY ENTRY
// IT WILL BE DISCARDED.

	console.log("  Common.Sort.sortTwoDArray    plugins.core.Common.sortTwoDArray(twoDArray, key)");
	if ( twoDArray == null )	return;
	if ( index == null )	return;
	console.log("  Common.Sort.sortTwoDArray    twoDArray: " + dojo.toJson(twoDArray));
	console.log("  Common.Sort.sortTwoDArray    index: " + index);

	return twoDArray.sort(function (a,b) {
		console.log("  Common.Sort.sortTwoDArray    a[" + index + "]: " + a[index]);
		console.log("  Common.Sort.sortTwoDArray    b[" + index + "]: " + b[index]);
		
		if ( a[index] == null )
		{
			console.log("No value for index '" + index + "' in twoDArray item: " + dojo.toJson(a));
			return;
		}
		if ( b[index] == null )
		{
			console.log("No value for index '" + index + "' in twoDArray item: " + dojo.toJson(b));
			return;
		}

		return a[index].toUpperCase() == b[index].toUpperCase() ?
			(a[index] < b[index] ? -1
			: a[index] > b[index])
			: (a[index].toUpperCase() < b[index].toUpperCase() ? -1
			: a[index].toUpperCase() > b[index].toUpperCase());
		}
	);
}



});

}

if(!dojo._hasResource["plugins.core.Common.Text"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.core.Common.Text"] = true;
dojo.provide("plugins.core.Common.Text");

/* SUMMARY: THIS CLASS IS INHERITED BY Common.js AND CONTAINS 
	
	DATE METHODS  
*/

dojo.declare( "plugins.core.Common.Text",	[  ], {

///////}}}

repeatChar : function(character, length) {
    var string = '';
    for ( var i = 0; i < length; i++ ) {
        string += character;
    }
    
    return string;
},
xor : function (option1, option2) {
	//console.log("  Common.Text.xor    plugins.core.Common.xor(option1, option2)");
	//console.log("  Common.Text.xor    option1: " + option1);
	//console.log("  Common.Text.xor    option2: " + option2);
	if ( (option1 && ! option2)
		|| (! option1 && option2) )	return true;
	return false;
},
systemVariables : function (value, object) {
// PARSE THE SYSTEM VARIABLES. I.E., REPLACE %<STRING>% TERMS
	if ( object == null )	object = this;
	if ( value == null || value == true || value == false )	return value;
	if ( value.replace == null )	return value;
	
	//console.log("  Common.Text.systemVariables    plugins.core.Common.systemVariables(value)");
	//console.log("  Common.Text.systemVariables    value: " + dojo.toJson(value));
	
	value = value.replace(/%username%/g, Agua.cookie('username'));
	value = value.replace(/%project%/g, object.project);
	value = value.replace(/%workflow%/g, object.workflow);
	
	return value;
},
insertTextBreaks : function (text, width) {
// INSERT INVISIBLE UNICODE CHARACTER &#8203; AT INTERVALS OF
// LENGTH width IN THE TEXT
	//console.log("  Common.Text.insertTextBreaks    plugins.workflow.Workflow.insertTextBreaks(text, width)");
	//console.log("  Common.Text.insertTextBreaks    text: " + text);	
	//console.log("  Common.Text.insertTextBreaks    text.length: " + text.length);	
	//console.log("  Common.Text.insertTextBreaks    width: " + width);

	if ( this.textBreakWidth != null )	width = this.textBreakWidth;
	if ( width == null )	return;

	// SET INSERT CHARACTERS
	var insert = "\n";

	// FIRST, REMOVE ANY EXISTING INVISIBLE LINE BREAKS IN THE TEXT
	text = this.removeTextBreaks(text);

	// SECOND, INSERT A "&#8203;" CHARACTER AT REGULAR INTERVALS
	var insertedText = '';
	var offset = 0;
	while ( offset < text.length )
	{
		var temp = text.substring(offset, offset + width);
		offset += width;
		
		insertedText += temp;
		//insertedText += "&#8203;"
		insertedText += insert;
	}

	//console.log("  Common.Text.insertTextBreaks    Returning insertedText: " + insertedText);
	return insertedText;
},
removeTextBreaks : function (text) {
// REMOVE ANY LINE BREAK CHARACTERS IN THE TEXT
	//console.log("  Common.removeTextBreaks    plugins.workflow.Common.removeTextBreaks(text)");
	//console.log("  Common.removeTextBreaks    text: " + text);	
	text = text.replace(/\n/g, '');
	return text;
},
jsonSafe : function (string, mode) {
// CONVERT FROM JSON SAFE TO ORDINARY TEXT OR THE REVERSE
	//console.log("ApplicationTemplate.jsonSafe string: " + string);
	//console.log("ApplicationTemplate.jsonSafe mode: " + mode);
	
	// SANITY CHECKS
	if ( string == null || ! string )
	{
		return '';
	}
	if ( string == true || string == false )
	{
		return string;
	}
	
	// CLEAN UP WHITESPACE
	string = String(string).replace(/\s+$/g,'');
	string = String(string).replace(/^\s+/g,'');
	string = String(string).replace(/"/g,"'");

	var specialChars = [
		[ '&quot;',	"'" ],	
		//[ '&quot;',	'"' ],	
		[ '&#35;', '#' ],	
		[ '&#36;', '$' ],	
		[ '&#37;', '%' ],	
		[ '&amp;', '&' ],	
		//[ '&#39;', "'" ],	
		[ '&#40;', '(' ],	
		[ '&#41;', ')' ],	
		[ '&frasl;', '/' ],	
		[ '&#91;', '\[' ],	
		[ '&#92;', '\\' ],	
		[ '&#93;', '\]' ],	
		[ '&#96;', '`' ],	
		[ '&#123;', '\{' ],	
		[ '&#124;', '|' ],	
		[ '&#125;', '\}' ]	
	];
	
	for ( var i = 0; i < specialChars.length; i++)
	{
		if ( mode == 'toJson' )
		{
			var sRegExInput = new RegExp(specialChars[i][1], "g");
			return string.replace(sRegExInput, specialChars[i][0]);
		}
		else if ( mode == 'fromJson' )
		{
			var sRegExInput = new RegExp(specialChars[i][0], "g");
			return string.replace(sRegExInput, specialChars[i][1]);
		}
	}
	
	return string;
},
autoHeight : function(textarea) {
	//console.log("  Common.Text.autoHeight    plugins.workflow.Workflow.autoHeight(event)");
	//console.log("  Common.Text.autoHeight    textarea: " + textarea);

	var rows = parseInt(textarea.rows);
	console.log("  Common.Text.autoHeight    textarea.rows: " + textarea.rows);

	while ( textarea.rows * textarea.cols < textarea.value.length )
	{
		textarea.rows = ++rows;
	}
	
	// REMOVE ONE LINE TO FIT SNUGLY
	//textarea.rows--; 
	
////    // THIS ALSO WORKS OKAY
////    console.log("  Common.Text.autoHeight    event.target.scrollHeight: " + event.target.scrollHeight );
////    
////    var height = event.target.scrollHeight;
////    var rows = parseInt((height / 15) - 2);
////
////    console.log("  Common.Text.autoHeight    height: " + height);
////    console.log("  Common.Text.autoHeight    rows: " + rows);
////
//////<textarea id="value" class="autosize" rows="3" cols="10">    
////    
////    console.log("  Common.Text.autoHeight    BEFORE event.target.setAttribute('rows', " + rows + "): " +  event.target.getAttribute('rows'));
////    
////    event.target.setAttribute('rows', rows);
////    
////
////    console.log("  Common.Text.autoHeight    AFTER event.target.setAttribute('rows', " + rows + "): " + event.target.getAttribute('rows'));}
},
firstLetterUpperCase : function (word) {
	if ( word == null || word == '' ) return word;
	if ( word.substring == null )	return null;
	return word.substring(0,1).toUpperCase() + word.substring(1);
},
cleanEnds : function (words) {
	if ( words == null )	return '';

	words = words.replace(/^[\s\n]+/, '');
	words = words.replace(/[\s\n]+$/, '');
	
	return words;
},
cleanWord : function (word) {
	//console.log("  Common.cleanWord    plugins.core.Common.cleanWord(word)");
	//console.log("  Common.cleanWord    word: " + word);

	if ( word == null )	return '';

	return word.replace(/[\s\n]+/, '');
},
clearValue : function (widget, value) {
	//console.log("  Common.clearValue    plugins.core.Common.clearValue(widget, value)");
	//console.log("  Common.clearValue    widget: " + widget);
	//console.log("  Common.clearValue    value: " + value);
	if ( widget == null )	return;

	if ( widget.get && widget.get('value') == value )
	{
		widget.set('value', '');
	}
	else if ( widget.value && widget.value.match(value) )
	{
		widget.value = '';
	}
},
cleanNumber : function (number) {
	//console.log("  Common.cleanNumber    plugins.core.Common.cleanNumber(number)");
	////console.log("Clusters.cleanNumber    BEFORE number: " + number);
	if ( number == null )	return '';
	number = number.toString().replace(/[\s\n]+/, '');
	////console.log("Clusters.cleanNumber    AFTER number: " + number);

	return number.toString().replace(/[\s\n]+/, '');
},
convertString : function (string, type) {
	if ( string == null )	return '';
	//console.log("  Common.Text.convertString    plugins.form.EditForm.convertString(string)");
	//console.log("  Common.Text.convertString    type: " + type);
	//console.log("  Common.Text.convertString    string: " + dojo.toJson(string));

	if ( string == null ) 	return '';
	if ( string.replace == null )	return string;

	var before = string;
	string = this.convertAngleBrackets(string, type);
	string = this.convertAmpersand(string, type);
	string = this.convertQuote(string, type);

	//console.log("  Common.Text.convertString    converted " + dojo.toJson(before) + " to " + dojo.toJson(string));
	
	return string
},
convertBackslash : function (string, type) {
	//console.log("  Common.Text.convertBackslash    plugins.core.Common.convertBackslash(string, type)");	
//    console.log("  Common.Text.convertBackslash    string:" + dojo.toJson(string));
//	console.log("  Common.Text.convertBackslash    type: " + type);
	if ( string == null ) 	return '';
	if ( string.replace == null )	return string;
	
	try {
		
		var multiplyString = function (string, num) {
			if (!num) return "";
			var newString = string;
			while (--num) newString += string;
			return newString;
		};
	
		var compress = function(match) {
			return multiplyString("\\", (match.length / 2));
		};
		
		var expand = function(match) {
			return multiplyString("\\", (match.length * 2));
		};
	
		if ( type == "compress" ) { 
			string = string.replace(/\\+/g, compress);
		}
		if ( type == "expand" ) { 
			string = string.replace(/\\+/g, expand);
		}
		//console.log("  Common.Text.convertBackslash    returning string:" + dojo.toJson(string));
		
	}
	catch (error) {
		//console.log("  Common.Text.convertBackslash    error:" + error);
		return "";
	}	
	
    return string;
},
convertAmpersand : function (string, type) {
	//console.log("  Common.Text.convertAmpersand    plugins.form.EditForm.convertAmpersand(string)");
	//console.log("  Common.Text.convertAmpersand    string: " + string);
	if ( string == null ) 	return '';
	if ( string.replace == null )	return string;
	if ( type == "textToHtml")
		string = string.replace(/&/g, "&amp;");
	else
		string = string.replace(/&amp;/g, "&");
	return string;
},
convertQuote : function (string, type) {
	//console.log("  Common.Text.convertQuote    plugins.form.EditForm.convertQuote(string)");
	//console.log("  Common.Text.convertQuote    string: " + string);
	if ( string == null ) 	return '';
	if ( string.replace == null )	return string;
	if ( type == "textToHtml")
		string = string.replace(/"/g, "&quot;");
	else
		string = string.replace(/&quot;/g, '"');
	return string;
},
convertAngleBrackets : function (string, type) {
	//console.log("  Common.Text.convertAngleBrackets    plugins.form.EditForm.convertAngleBrackets(string)");
	//console.log("  Common.Text.convertAngleBrackets    string: " + string);

	if ( string == null ) 	return '';
	if ( string.replace == null )	return string;
	
	var specialChars = [
		[ '&lt;',	"<" ],
		[ '&gt;',	'>' ]
	];

	var from = 0;
	var to = 1;
	if ( type == "textToHtml")
	{
		from = 1;
		to = 0;
	}
	
	for ( var i = 0; i < specialChars.length; i++)
	{
		////console.log("  Common.Text.converString    converting from " +specialChars[i][from] + " to " + specialChars[i][to]);
		var sRegExInput = new RegExp(specialChars[i][from], "g");
		string = string.replace(sRegExInput, specialChars[i][to]);
	}

	return string;	
},
printObjectKeys : function (hasharray, key, label) {
	if ( label == null )	label = "key";
	for ( var i = 0; i < hasharray.length; i++ )
	{
		console.log(label + " " + i + ": " + hasharray[i][key]);
	}
},


});

}

if(!dojo._hasResource["dojo.fx.Toggler"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.fx.Toggler"] = true;
dojo.provide("dojo.fx.Toggler");


dojo.declare("dojo.fx.Toggler", null, {
	// summary:
	//		A simple `dojo.Animation` toggler API.
	//
	// description:
	//		class constructor for an animation toggler. It accepts a packed
	//		set of arguments about what type of animation to use in each
	//		direction, duration, etc. All available members are mixed into
	//		these animations from the constructor (for example, `node`,
	//		`showDuration`, `hideDuration`).
	//
	// example:
	//	|	var t = new dojo.fx.Toggler({
	//	|		node: "nodeId",
	//	|		showDuration: 500,
	//	|		// hideDuration will default to "200"
	//	|		showFunc: dojo.fx.wipeIn,
	//	|		// hideFunc will default to "fadeOut"
	//	|	});
	//	|	t.show(100); // delay showing for 100ms
	//	|	// ...time passes...
	//	|	t.hide();

	// node: DomNode
	//		the node to target for the showing and hiding animations
	node: null,

	// showFunc: Function
	//		The function that returns the `dojo.Animation` to show the node
	showFunc: dojo.fadeIn,

	// hideFunc: Function
	//		The function that returns the `dojo.Animation` to hide the node
	hideFunc: dojo.fadeOut,

	// showDuration:
	//		Time in milliseconds to run the show Animation
	showDuration: 200,

	// hideDuration:
	//		Time in milliseconds to run the hide Animation
	hideDuration: 200,

	// FIXME: need a policy for where the toggler should "be" the next
	// time show/hide are called if we're stopped somewhere in the
	// middle.
	// FIXME: also would be nice to specify individual showArgs/hideArgs mixed into
	// each animation individually.
	// FIXME: also would be nice to have events from the animations exposed/bridged

	/*=====
	_showArgs: null,
	_showAnim: null,

	_hideArgs: null,
	_hideAnim: null,

	_isShowing: false,
	_isHiding: false,
	=====*/

	constructor: function(args){
		var _t = this;

		dojo.mixin(_t, args);
		_t.node = args.node;
		_t._showArgs = dojo.mixin({}, args);
		_t._showArgs.node = _t.node;
		_t._showArgs.duration = _t.showDuration;
		_t.showAnim = _t.showFunc(_t._showArgs);

		_t._hideArgs = dojo.mixin({}, args);
		_t._hideArgs.node = _t.node;
		_t._hideArgs.duration = _t.hideDuration;
		_t.hideAnim = _t.hideFunc(_t._hideArgs);

		dojo.connect(_t.showAnim, "beforeBegin", dojo.hitch(_t.hideAnim, "stop", true));
		dojo.connect(_t.hideAnim, "beforeBegin", dojo.hitch(_t.showAnim, "stop", true));
	},

	show: function(delay){
		// summary: Toggle the node to showing
		// delay: Integer?
		//		Ammount of time to stall playing the show animation
		return this.showAnim.play(delay || 0);
	},

	hide: function(delay){
		// summary: Toggle the node to hidden
		// delay: Integer?
		//		Ammount of time to stall playing the hide animation
		return this.hideAnim.play(delay || 0);
	}
});

}

if(!dojo._hasResource["dojo.fx"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.fx"] = true;
dojo.provide("dojo.fx");



/*=====
dojo.fx = {
	// summary: Effects library on top of Base animations
};
=====*/
(function(){
	
	var d = dojo,
		_baseObj = {
			_fire: function(evt, args){
				if(this[evt]){
					this[evt].apply(this, args||[]);
				}
				return this;
			}
		};

	var _chain = function(animations){
		this._index = -1;
		this._animations = animations||[];
		this._current = this._onAnimateCtx = this._onEndCtx = null;

		this.duration = 0;
		d.forEach(this._animations, function(a){
			this.duration += a.duration;
			if(a.delay){ this.duration += a.delay; }
		}, this);
	};
	d.extend(_chain, {
		_onAnimate: function(){
			this._fire("onAnimate", arguments);
		},
		_onEnd: function(){
			d.disconnect(this._onAnimateCtx);
			d.disconnect(this._onEndCtx);
			this._onAnimateCtx = this._onEndCtx = null;
			if(this._index + 1 == this._animations.length){
				this._fire("onEnd");
			}else{
				// switch animations
				this._current = this._animations[++this._index];
				this._onAnimateCtx = d.connect(this._current, "onAnimate", this, "_onAnimate");
				this._onEndCtx = d.connect(this._current, "onEnd", this, "_onEnd");
				this._current.play(0, true);
			}
		},
		play: function(/*int?*/ delay, /*Boolean?*/ gotoStart){
			if(!this._current){ this._current = this._animations[this._index = 0]; }
			if(!gotoStart && this._current.status() == "playing"){ return this; }
			var beforeBegin = d.connect(this._current, "beforeBegin", this, function(){
					this._fire("beforeBegin");
				}),
				onBegin = d.connect(this._current, "onBegin", this, function(arg){
					this._fire("onBegin", arguments);
				}),
				onPlay = d.connect(this._current, "onPlay", this, function(arg){
					this._fire("onPlay", arguments);
					d.disconnect(beforeBegin);
					d.disconnect(onBegin);
					d.disconnect(onPlay);
				});
			if(this._onAnimateCtx){
				d.disconnect(this._onAnimateCtx);
			}
			this._onAnimateCtx = d.connect(this._current, "onAnimate", this, "_onAnimate");
			if(this._onEndCtx){
				d.disconnect(this._onEndCtx);
			}
			this._onEndCtx = d.connect(this._current, "onEnd", this, "_onEnd");
			this._current.play.apply(this._current, arguments);
			return this;
		},
		pause: function(){
			if(this._current){
				var e = d.connect(this._current, "onPause", this, function(arg){
						this._fire("onPause", arguments);
						d.disconnect(e);
					});
				this._current.pause();
			}
			return this;
		},
		gotoPercent: function(/*Decimal*/percent, /*Boolean?*/ andPlay){
			this.pause();
			var offset = this.duration * percent;
			this._current = null;
			d.some(this._animations, function(a){
				if(a.duration <= offset){
					this._current = a;
					return true;
				}
				offset -= a.duration;
				return false;
			});
			if(this._current){
				this._current.gotoPercent(offset / this._current.duration, andPlay);
			}
			return this;
		},
		stop: function(/*boolean?*/ gotoEnd){
			if(this._current){
				if(gotoEnd){
					for(; this._index + 1 < this._animations.length; ++this._index){
						this._animations[this._index].stop(true);
					}
					this._current = this._animations[this._index];
				}
				var e = d.connect(this._current, "onStop", this, function(arg){
						this._fire("onStop", arguments);
						d.disconnect(e);
					});
				this._current.stop();
			}
			return this;
		},
		status: function(){
			return this._current ? this._current.status() : "stopped";
		},
		destroy: function(){
			if(this._onAnimateCtx){ d.disconnect(this._onAnimateCtx); }
			if(this._onEndCtx){ d.disconnect(this._onEndCtx); }
		}
	});
	d.extend(_chain, _baseObj);

	dojo.fx.chain = function(/*dojo.Animation[]*/ animations){
		// summary:
		//		Chain a list of `dojo.Animation`s to run in sequence
		//
		// description:
		//		Return a `dojo.Animation` which will play all passed
		//		`dojo.Animation` instances in sequence, firing its own
		//		synthesized events simulating a single animation. (eg:
		//		onEnd of this animation means the end of the chain,
		//		not the individual animations within)
		//
		// example:
		//	Once `node` is faded out, fade in `otherNode`
		//	|	dojo.fx.chain([
		//	|		dojo.fadeIn({ node:node }),
		//	|		dojo.fadeOut({ node:otherNode })
		//	|	]).play();
		//
		return new _chain(animations) // dojo.Animation
	};

	var _combine = function(animations){
		this._animations = animations||[];
		this._connects = [];
		this._finished = 0;

		this.duration = 0;
		d.forEach(animations, function(a){
			var duration = a.duration;
			if(a.delay){ duration += a.delay; }
			if(this.duration < duration){ this.duration = duration; }
			this._connects.push(d.connect(a, "onEnd", this, "_onEnd"));
		}, this);
		
		this._pseudoAnimation = new d.Animation({curve: [0, 1], duration: this.duration});
		var self = this;
		d.forEach(["beforeBegin", "onBegin", "onPlay", "onAnimate", "onPause", "onStop", "onEnd"],
			function(evt){
				self._connects.push(d.connect(self._pseudoAnimation, evt,
					function(){ self._fire(evt, arguments); }
				));
			}
		);
	};
	d.extend(_combine, {
		_doAction: function(action, args){
			d.forEach(this._animations, function(a){
				a[action].apply(a, args);
			});
			return this;
		},
		_onEnd: function(){
			if(++this._finished > this._animations.length){
				this._fire("onEnd");
			}
		},
		_call: function(action, args){
			var t = this._pseudoAnimation;
			t[action].apply(t, args);
		},
		play: function(/*int?*/ delay, /*Boolean?*/ gotoStart){
			this._finished = 0;
			this._doAction("play", arguments);
			this._call("play", arguments);
			return this;
		},
		pause: function(){
			this._doAction("pause", arguments);
			this._call("pause", arguments);
			return this;
		},
		gotoPercent: function(/*Decimal*/percent, /*Boolean?*/ andPlay){
			var ms = this.duration * percent;
			d.forEach(this._animations, function(a){
				a.gotoPercent(a.duration < ms ? 1 : (ms / a.duration), andPlay);
			});
			this._call("gotoPercent", arguments);
			return this;
		},
		stop: function(/*boolean?*/ gotoEnd){
			this._doAction("stop", arguments);
			this._call("stop", arguments);
			return this;
		},
		status: function(){
			return this._pseudoAnimation.status();
		},
		destroy: function(){
			d.forEach(this._connects, dojo.disconnect);
		}
	});
	d.extend(_combine, _baseObj);

	dojo.fx.combine = function(/*dojo.Animation[]*/ animations){
		// summary:
		//		Combine a list of `dojo.Animation`s to run in parallel
		//
		// description:
		//		Combine an array of `dojo.Animation`s to run in parallel,
		//		providing a new `dojo.Animation` instance encompasing each
		//		animation, firing standard animation events.
		//
		// example:
		//	Fade out `node` while fading in `otherNode` simultaneously
		//	|	dojo.fx.combine([
		//	|		dojo.fadeIn({ node:node }),
		//	|		dojo.fadeOut({ node:otherNode })
		//	|	]).play();
		//
		// example:
		//	When the longest animation ends, execute a function:
		//	|	var anim = dojo.fx.combine([
		//	|		dojo.fadeIn({ node: n, duration:700 }),
		//	|		dojo.fadeOut({ node: otherNode, duration: 300 })
		//	|	]);
		//	|	dojo.connect(anim, "onEnd", function(){
		//	|		// overall animation is done.
		//	|	});
		//	|	anim.play(); // play the animation
		//
		return new _combine(animations); // dojo.Animation
	};

	dojo.fx.wipeIn = function(/*Object*/ args){
		// summary:
		//		Expand a node to it's natural height.
		//
		// description:
		//		Returns an animation that will expand the
		//		node defined in 'args' object from it's current height to
		//		it's natural height (with no scrollbar).
		//		Node must have no margin/border/padding.
		//
		// args: Object
		//		A hash-map of standard `dojo.Animation` constructor properties
		//		(such as easing: node: duration: and so on)
		//
		// example:
		//	|	dojo.fx.wipeIn({
		//	|		node:"someId"
		//	|	}).play()
		var node = args.node = d.byId(args.node), s = node.style, o;

		var anim = d.animateProperty(d.mixin({
			properties: {
				height: {
					// wrapped in functions so we wait till the last second to query (in case value has changed)
					start: function(){
						// start at current [computed] height, but use 1px rather than 0
						// because 0 causes IE to display the whole panel
						o = s.overflow;
						s.overflow = "hidden";
						if(s.visibility == "hidden" || s.display == "none"){
							s.height = "1px";
							s.display = "";
							s.visibility = "";
							return 1;
						}else{
							var height = d.style(node, "height");
							return Math.max(height, 1);
						}
					},
					end: function(){
						return node.scrollHeight;
					}
				}
			}
		}, args));

		d.connect(anim, "onEnd", function(){
			s.height = "auto";
			s.overflow = o;
		});

		return anim; // dojo.Animation
	};

	dojo.fx.wipeOut = function(/*Object*/ args){
		// summary:
		//		Shrink a node to nothing and hide it.
		//
		// description:
		//		Returns an animation that will shrink node defined in "args"
		//		from it's current height to 1px, and then hide it.
		//
		// args: Object
		//		A hash-map of standard `dojo.Animation` constructor properties
		//		(such as easing: node: duration: and so on)
		//
		// example:
		//	|	dojo.fx.wipeOut({ node:"someId" }).play()
		
		var node = args.node = d.byId(args.node), s = node.style, o;
		
		var anim = d.animateProperty(d.mixin({
			properties: {
				height: {
					end: 1 // 0 causes IE to display the whole panel
				}
			}
		}, args));

		d.connect(anim, "beforeBegin", function(){
			o = s.overflow;
			s.overflow = "hidden";
			s.display = "";
		});
		d.connect(anim, "onEnd", function(){
			s.overflow = o;
			s.height = "auto";
			s.display = "none";
		});

		return anim; // dojo.Animation
	};

	dojo.fx.slideTo = function(/*Object*/ args){
		// summary:
		//		Slide a node to a new top/left position
		//
		// description:
		//		Returns an animation that will slide "node"
		//		defined in args Object from its current position to
		//		the position defined by (args.left, args.top).
		//
		// args: Object
		//		A hash-map of standard `dojo.Animation` constructor properties
		//		(such as easing: node: duration: and so on). Special args members
		//		are `top` and `left`, which indicate the new position to slide to.
		//
		// example:
		//	|	dojo.fx.slideTo({ node: node, left:"40", top:"50", units:"px" }).play()

		var node = args.node = d.byId(args.node),
			top = null, left = null;

		var init = (function(n){
			return function(){
				var cs = d.getComputedStyle(n);
				var pos = cs.position;
				top = (pos == 'absolute' ? n.offsetTop : parseInt(cs.top) || 0);
				left = (pos == 'absolute' ? n.offsetLeft : parseInt(cs.left) || 0);
				if(pos != 'absolute' && pos != 'relative'){
					var ret = d.position(n, true);
					top = ret.y;
					left = ret.x;
					n.style.position="absolute";
					n.style.top=top+"px";
					n.style.left=left+"px";
				}
			};
		})(node);
		init();

		var anim = d.animateProperty(d.mixin({
			properties: {
				top: args.top || 0,
				left: args.left || 0
			}
		}, args));
		d.connect(anim, "beforeBegin", anim, init);

		return anim; // dojo.Animation
	};

})();

}

if(!dojo._hasResource["dojox.widget.Toaster"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.widget.Toaster"] = true;
dojo.provide("dojox.widget.Toaster");







dojo.declare("dojox.widget.Toaster", [dijit._Widget, dijit._Templated], {
		// summary:
		//		Message that slides in from the corner of the screen, used for notifications
		//		like "new email".

		templateString: '<div class="dijitToasterClip" dojoAttachPoint="clipNode"><div class="dijitToasterContainer" dojoAttachPoint="containerNode" dojoAttachEvent="onclick:onSelect"><div class="dijitToasterContent" dojoAttachPoint="contentNode"></div></div></div>',

		// messageTopic: String
		//		Name of topic; anything published to this topic will be displayed as a message.
		//		Message format is either String or an object like
		//		{message: "hello word", type: "error", duration: 500}
		messageTopic: "",

		// messageTypes: Enumeration
		//		Possible message types.
		messageTypes: {
			MESSAGE: "message",
			WARNING: "warning",
			ERROR: "error",
			FATAL: "fatal"
		},

		// defaultType: String
		//		If message type isn't specified (see "messageTopic" parameter),
		//		then display message as this type.
		//		Possible values in messageTypes enumeration ("message", "warning", "error", "fatal")
		defaultType: "message",

		// positionDirection: String
		//		Position from which message slides into screen, one of
		//		["br-up", "br-left", "bl-up", "bl-right", "tr-down", "tr-left", "tl-down", "tl-right"]
		positionDirection: "br-up",
		
		// positionDirectionTypes: Array
		//		Possible values for positionDirection parameter
		positionDirectionTypes: ["br-up", "br-left", "bl-up", "bl-right", "tr-down", "tr-left", "tl-down", "tl-right"],

		// duration: Integer
		//		Number of milliseconds to show message
		duration: 2000,

		// slideDuration: Integer
		//		Number of milliseconds for the slide animation, increasing will cause the Toaster
		//    to slide in more slowly.
		slideDuration: 500,

		//separator: String
		//		String used to separate messages if consecutive calls are made to setContent before previous messages go away
		separator: "<hr></hr>",

		postCreate: function(){
			this.inherited(arguments);
			this.hide();
			
			// place node as a child of body for positioning
			dojo.body().appendChild(this.domNode);
			
			if(this.messageTopic){
				dojo.subscribe(this.messageTopic, this, "_handleMessage");
			}
		},

		_handleMessage: function(/*String|Object*/message){
			if(dojo.isString(message)){
				this.setContent(message);
			}else{
				this.setContent(message.message, message.type, message.duration);
			}
		},

		_capitalize: function(/* String */w){
				return w.substring(0,1).toUpperCase() + w.substring(1);
		},

		setContent: function(/*String|Function*/message, /*String*/messageType, /*int?*/duration){
			// summary:
			//		sets and displays the given message and show duration
			// message:
			//		the message. If this is a function, it will be called with this toaster widget as the only argument.
			// messageType:
			//		type of message; possible values in messageTypes enumeration ("message", "warning", "error", "fatal")
			// duration:
			//		duration in milliseconds to display message before removing it. Widget has default value.
			duration = duration||this.duration;
			// sync animations so there are no ghosted fades and such
			if(this.slideAnim){
				if(this.slideAnim.status() != "playing"){
					this.slideAnim.stop();
				}
				if(this.slideAnim.status() == "playing" || (this.fadeAnim && this.fadeAnim.status() == "playing")){
					setTimeout(dojo.hitch(this, function(){
						this.setContent(message, messageType, duration);
					}), 50);
					return;
				}
			}

			// determine type of content and apply appropriately
			for(var type in this.messageTypes){
				dojo.removeClass(this.containerNode, "dijitToaster" + this._capitalize(this.messageTypes[type]));
			}

			dojo.style(this.containerNode, "opacity", 1);

			this._setContent(message);

			dojo.addClass(this.containerNode, "dijitToaster" + this._capitalize(messageType || this.defaultType));

			// now do funky animation of widget appearing from
			// bottom right of page and up
			this.show();
			var nodeSize = dojo.marginBox(this.containerNode);
			this._cancelHideTimer();
			if(this.isVisible){
				this._placeClip();
				//update hide timer if no sticky message in stack
				if(!this._stickyMessage) {
					this._setHideTimer(duration);
				}
			}else{
				var style = this.containerNode.style;
				var pd = this.positionDirection;
				// sets up initial position of container node and slide-out direction
				if(pd.indexOf("-up") >= 0){
					style.left=0+"px";
					style.top=nodeSize.h + 10 + "px";
				}else if(pd.indexOf("-left") >= 0){
					style.left=nodeSize.w + 10 +"px";
					style.top=0+"px";
				}else if(pd.indexOf("-right") >= 0){
					style.left = 0 - nodeSize.w - 10 + "px";
					style.top = 0+"px";
				}else if(pd.indexOf("-down") >= 0){
					style.left = 0+"px";
					style.top = 0 - nodeSize.h - 10 + "px";
				}else{
					throw new Error(this.id + ".positionDirection is invalid: " + pd);
				}
				this.slideAnim = dojo.fx.slideTo({
					node: this.containerNode,
					top: 0, left: 0,
					duration: this.slideDuration});
				this.connect(this.slideAnim, "onEnd", function(nodes, anim){
						//we build the fadeAnim here so we dont have to duplicate it later
						// can't do a fadeHide because we're fading the
						// inner node rather than the clipping node
						this.fadeAnim = dojo.fadeOut({
							node: this.containerNode,
							duration: 1000});
						this.connect(this.fadeAnim, "onEnd", function(evt){
							this.isVisible = false;
							this.hide();
						});
						this._setHideTimer(duration);
						this.connect(this, 'onSelect', function(evt){
							this._cancelHideTimer();
							//force clear sticky message
							this._stickyMessage=false;
							this.fadeAnim.play();
						});

						this.isVisible = true;
					});
				this.slideAnim.play();
			}
		},
		
		_setContent: function(message){
			if(dojo.isFunction(message)){
				message(this);
				return;
			}
			if(message && this.isVisible){
				message = this.contentNode.innerHTML + this.separator + message;
			}
			this.contentNode.innerHTML = message;
		},
		_cancelHideTimer:function(){
			if (this._hideTimer){
				clearTimeout(this._hideTimer);
				this._hideTimer=null;
			}
		},
		
		_setHideTimer:function(duration){
			this._cancelHideTimer();
			//if duration == 0 we keep the message displayed until clicked
			if(duration>0){
				this._cancelHideTimer();
				this._hideTimer=setTimeout(dojo.hitch(this, function(evt){
					// we must hide the iframe in order to fade
					// TODO: figure out how to fade with a BackgroundIframe
					if(this.bgIframe && this.bgIframe.iframe){
						this.bgIframe.iframe.style.display="none";
					}
					this._hideTimer=null;
					//force clear sticky message
					this._stickyMessage=false;
					this.fadeAnim.play();
				}), duration);
			}
			else
				this._stickyMessage=true;
		},
		
		_placeClip: function(){
			var view = dojo.window.getBox();

			var nodeSize = dojo.marginBox(this.containerNode);

			var style = this.clipNode.style;
			// sets up the size of the clipping node
			style.height = nodeSize.h+"px";
			style.width = nodeSize.w+"px";

			// sets up the position of the clipping node
			var pd = this.positionDirection;
			if(pd.match(/^t/)){
				style.top = view.t+"px";
			}else if(pd.match(/^b/)){
				style.top = (view.h - nodeSize.h - 2 + view.t)+"px";
			}
			if(pd.match(/^[tb]r-/)){
				style.left = (view.w - nodeSize.w - 1 - view.l)+"px";
			}else if(pd.match(/^[tb]l-/)){
				style.left = 0 + "px";
			}

			style.clip = "rect(0px, " + nodeSize.w + "px, " + nodeSize.h + "px, 0px)";
			if(dojo.isIE){
				if(!this.bgIframe){
					this.clipNode.id = dijit.getUniqueId("dojox_widget_Toaster_clipNode");
					this.bgIframe = new dijit.BackgroundIframe(this.clipNode);
				}
				var iframe = this.bgIframe.iframe;
				if(iframe){ iframe.style.display="block"; }
			}
		},

		onSelect: function(/*Event*/e){
			// summary: callback for when user clicks the message
		},

		show: function(){
			// summary: show the Toaster
			dojo.style(this.domNode, 'display', 'block');

			this._placeClip();

			if(!this._scrollConnected){
				this._scrollConnected = dojo.connect(window, "onscroll", this, this._placeClip);
			}
		},

		hide: function(){
			// summary: hide the Toaster

			dojo.style(this.domNode, 'display', 'none');

			if(this._scrollConnected){
				dojo.disconnect(this._scrollConnected);
				this._scrollConnected = false;
			}

			dojo.style(this.containerNode, "opacity", 1);
		}
	}
);

}

if(!dojo._hasResource["plugins.dojox.widget.Toaster"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.dojox.widget.Toaster"] = true;
dojo.provide("plugins.dojox.widget.Toaster");



dojo.declare("plugins.dojox.widget.Toaster", [dojox.widget.Toaster], {

// OVERRIDES
setContent: function(/*String|Function*/message, /*String*/messageType, /*int?*/duration){
	// CHANGED CALL TO _setContent - ADDED messageType ARGUMENT

	duration = duration||this.duration;
	// sync animations so there are no ghosted fades and such
	if(this.slideAnim){
		if(this.slideAnim.status() != "playing"){
			this.slideAnim.stop();
		}
		if(this.slideAnim.status() == "playing" || (this.fadeAnim && this.fadeAnim.status() == "playing")){
			setTimeout(dojo.hitch(this, function(){
				this.setContent(message, messageType, duration);
			}), 50);
			return;
		}
	}

	// determine type of content and apply appropriately
	for(var type in this.messageTypes){
		dojo.removeClass(this.containerNode, "dijitToaster" + this._capitalize(this.messageTypes[type]));
	}

	dojo.style(this.containerNode, "opacity", 1);

    // CHANGED HERE - ADDED messageType ARGUMENT
	this._setContent(message, messageType);

	dojo.addClass(this.containerNode, "dijitToaster" + this._capitalize(messageType || this.defaultType));

	// now do funky animation of widget appearing from
	// bottom right of page and up
	this.show();
	var nodeSize = dojo.marginBox(this.containerNode);
	this._cancelHideTimer();
	if(this.isVisible){
		this._placeClip();
		//update hide timer if no sticky message in stack
		if(!this._stickyMessage) {
			this._setHideTimer(duration);
		}
	}else{
		var style = this.containerNode.style;
		var pd = this.positionDirection;
		// sets up initial position of container node and slide-out direction
		if(pd.indexOf("-up") >= 0){
			style.left=0+"px";
			style.top=nodeSize.h + 10 + "px";
		}else if(pd.indexOf("-left") >= 0){
			style.left=nodeSize.w + 10 +"px";
			style.top=0+"px";
		}else if(pd.indexOf("-right") >= 0){
			style.left = 0 - nodeSize.w - 10 + "px";
			style.top = 0+"px";
		}else if(pd.indexOf("-down") >= 0){
			style.left = 0+"px";
			style.top = 0 - nodeSize.h - 10 + "px";
		}else{
			throw new Error(this.id + ".positionDirection is invalid: " + pd);
		}
		this.slideAnim = dojo.fx.slideTo({
			node: this.containerNode,
			top: 0, left: 0,
			duration: this.slideDuration});
		this.connect(this.slideAnim, "onEnd", function(nodes, anim){
				//we build the fadeAnim here so we dont have to duplicate it later
				// can't do a fadeHide because we're fading the
				// inner node rather than the clipping node
				this.fadeAnim = dojo.fadeOut({
					node: this.containerNode,
					duration: 1000});
				this.connect(this.fadeAnim, "onEnd", function(evt){
					this.isVisible = false;
					this.hide();
				});
				this._setHideTimer(duration);
				this.connect(this, 'onSelect', function(evt){
					this._cancelHideTimer();
					//force clear sticky message
					this._stickyMessage=false;
					this.fadeAnim.play();
				});

				this.isVisible = true;
			});
		this.slideAnim.play();
	}
},

_setContent: function(message, messageType){
	console.log("plugins.core.Common.Toaster._setContent    message: " + message);
	console.log("plugins.core.Common.Toaster._setContent    messageType: " + messageType);

	if(dojo.isFunction(message)){
		message(this);
		return;
	}
	if(message && this.isVisible){
		message = this.contentNode.innerHTML + this.separator + "<span class='" + messageType + "'>" + message + "</span>";
	}
    else {
        message = "<span class='" + messageType + "'>" + message + "</span>";
    }
	console.log("plugins.core.Common.Toaster._setContent    FINAL message: " + message);

	this.contentNode.innerHTML = message;
}

});

}

if(!dojo._hasResource["plugins.core.Common.Toast"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.core.Common.Toast"] = true;
dojo.provide("plugins.core.Common.Toast");

/* SUMMARY: THIS CLASS IS INHERITED BY Common.js AND CONTAINS 
	
	TOASTER METHODS  
*/

// DEPENDENCIES


dojo.declare( "plugins.core.Common.Toast",	[  ], {

///////}}}

setToaster : function () {
	console.log("Common.Toast.setToaster    this.toaster: " + this.toaster);
	console.dir({this_toaster:this.toaster});
	
	var cssFiles = [
		dojo.moduleUrl("plugins", "core/css/toaster.css")
	];
	this.loadCSS(cssFiles);
	
	if ( ! this.toaster ) {
		this.toaster = new plugins.dojox.widget.Toaster({
			className: "toaster",
			positionDirection: "bl-right",
			duration: "500",
			messageTopic: "toastTopic"
		});
	}
	
	// SET WIDTH TO 100%
	this.containerNode.style.width = "100%";
	
},
toastMessage : function (args) {
	//console.log("Common.Toast.toastMessage    args:");
	//console.dir({args:args});
	//console.log("Common.Toast.toastMessage    this.toaster: " + this.toaster);
	//console.dir({this_toaster:this.toaster});
	if ( ! args )	return;
	if ( ! this.toaster || ! this.toaster.containerNode ) {
		this.setToaster();
	}
	
	if ( args.doToast == false )	return;
	var message = args.message;
	if ( message == null || message == '' ) {
		
		//console.log("Common.Toast.toastMessage    message is empty or not defined. Returning");
		return;
	}
	//console.log("Common.Toast.toastMessage    args: ");
	//console.dir({args:args});
	////console.log("Common.Toast.toastMessage    caller: " + this.toastMessage.caller.nom);

	// type: 'error' or 'warning'
	var type = args.type;
	////console.log("Common.Toast.toastMessage    type: " + type);

	// duration: time before fade out (milliseconds)
	var duration = args.duration;

	if ( duration == null )	duration = 4000;
	if ( type != null
		&& (type != "warning" && type != "error" && type != "fatal") )
	{
		//console.log("Common.Toast.toastMessage    type not supported (must be warning|error|fatal): " + type);
		return;
	}
	
	var topic = "toastTopic";
	try {
			
		dojo.publish(topic, [ {
			message: message,
			type: type,
			duration: duration
		}]);
	}
	catch (error) {
		//console.log("Common.Toast.toastMessage    error: " + dojo.toJson(error));
	}

},
toast : function (response) {
	//console.log("Common.Toast.toast    response: ");
	//console.dir({response:response});

	if ( response.error ) {
		var args = {
			message: response.error,
			type: "error"
		};
		if ( response.duration != null )
			args.duration = response.duration;
		this.toastMessage(args);
	}
	else {
		var args = {
			message: response.status,
			type: "warning"
		};
		if ( response.duration != null )
			args.duration = response.duration;
		this.toastMessage(args);
	}
},
toastError : function (error) {
	this.toastMessage(
	{
		message: error,
		type: "error"
	});	
},
toastInfo : function (info) {
	this.toastMessage({
		message: info,
		type: "warning"
	});
},
error : function (error) {
	this.toastMessage(
	{
		message: error,
		type: "error"
	});
},
warning : function (warning) {
	this.toastMessage({
		message: warning,
		type: "warning"
	});
}


});

}

if(!dojo._hasResource["plugins.core.Common.Util"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.core.Common.Util"] = true;
dojo.provide("plugins.core.Common.Util");

/* SUMMARY: THIS CLASS IS INHERITED BY Common.js AND CONTAINS 
	
	UTIL METHODS  
*/

dojo.declare( "plugins.core.Common.Util",	[  ], {

///////}}}

setLoadPanels : function (args) {
	if ( ! args.inputs )	return;
	
	this.inputs = args.inputs;
	var array = args.inputs.split(";");
	console.log("Common.Util.setLoadPanels    array: ");
	console.dir({array:array});

	var loadPanels = {};
	for ( i = 0; i < array.length + 1; i++ ) {
		console.log("Common.Util.setLoadPanels    array: ");
		loadPanels[array[i]] = 1;
	}
	console.log("Common.Util.setLoadPanels    loadPanels: ");
	console.dir({loadPanels:loadPanels});
	
	this.loadPanels = loadPanels;
},
doPut : function (inputs) {
	console.log("    Common.Util.doPut    inputs: ");
	console.dir({inputs:inputs});
	var callback = function (){}
	if ( inputs.callback != null )	callback = inputs.callback;
	//console.log("    Common.Util.doPut    inputs.callback: " + inputs.callback);
	var doToast = true;
	if ( inputs.doToast != null )	doToast = inputs.doToast;
	var url = inputs.url;
	url += "?";
	url += Math.floor(Math.random()*100000);
	var query = inputs.query;
	var timeout = inputs.timeout ? inputs.timeout : null;
	var handleAs = inputs.handleAs ? inputs.handleAs : "json";
	var sync = inputs.sync ? inputs.sync : false;
	//console.log("    Common.Util.doPut     doToast: " + doToast);
	
	// SEND TO SERVER
	dojo.xhrPut(
		{
			url: url,
			contentType: "text",
			preventCache : true,
			sync: sync,
			handleAs: handleAs,
			putData: dojo.toJson(query),
			timeout: timeout,
			load: function(response, ioArgs) {
				console.log("    Common.Util.doPut    response: ");
				console.dir({response:response});

				if ( response.error ) {
					if ( doToast ) {
						console.log("    Common.Util.doPut    DOING Agua.toastMessage ERROR");
						Agua.toastMessage({
							message: response.error,
							type: "error",
							duration: 10000
						});
					}
				}
				else {
					if ( response.status ) {
						if ( doToast ) {
						console.log("    Common.Util.doPut    DOING Agua.toastMessage STATUS");
							Agua.toastMessage({
								message: response.status,
								type: "warning",
								duration: 10000
							})
							if ( Agua.loader != null )	Agua.loader._hide();
						}
					}
					
					//console.log("    Common.Util.doPut    callback: " + callback);
					console.log("    Common.Util.doPut    DOING callback(response, inputs)");
					callback(response, inputs);
				}
			},
			error: function(response, ioArgs) {
				console.log("    Common.Util.doPut    Error with put. Response: " + response);
				return response;
			}
		}
	);	
},
getClassName : function (object) {
	//console.log("    Common.Util.getClassName    object: " + object);
	//console.dir({object:object});
	var className = new String(object);
	var name;
	if ( className.match(/^\[Widget\s+(\S+),/) )
		name = className.match(/^\[Widget\s+(\S+),/)[1];
	//console.log("    Common.Util.getClassName    name: " + name);

	return name;
},	
showMessage : function (message, putData) {
	console.log("    Common.Util.showMessage    Polling message: " + message)	
},
downloadFile : function (filepath, username) {
	//console.log("ParameterRow.downloadFile     plugins.workflow.ParameterRow.downloadFile(filepath, shared)");
	//console.log("ParameterRow.downloadFile     filepath: " + filepath);
	var query = "?mode=downloadFile";

	// SET requestor = THIS_USER IF PROVIDED
	if ( username != null )
	{
		query += "&username=" + username;
		query += "&requestor=" + Agua.cookie('username');
	}
	else
	{
		query += "&username=" + Agua.cookie('username');
	}

	query += "&sessionid=" + Agua.cookie('sessionid');
	query += "&filepath=" + filepath;
	//console.log("ParameterRow.downloadFile     query: " + query);
	
	var url = Agua.cgiUrl + "download.cgi";
	//console.log("ParameterRow.downloadFile     url: " + url);
	
	var args = {
		method: "GET",
		url: url + query,
		handleAs: "json",
		timeout: 10000,
		load: this.handleDownload
	};
	console.log("ParameterRow.downloadFile     args: ", args);

	console.log("ParameterRow.downloadFile     Doing dojo.io.iframe.send(args))");
	var value = dojo.io.iframe.send(args);
},
loadCSS : function (cssFiles) {
// LOAD EITHER this.cssFiles OR A SUPPLIED ccsFiles ARRAY OF FILES ARGUMENT

	//console.log("    Common.Util.loadCSS");
	
	if ( cssFiles == null )
	{
		cssFiles = this.cssFiles;
	}
	//console.log("    Common.Util.loadCSS     cssFiles: " +  dojo.toJson(cssFiles, true));
	
	// LOAD CSS
	for ( var i in cssFiles )
	{
		//console.log("    Common.Util.loadCSS     Loading CSS file: " + this.cssFiles[i]);
		
		this.loadCSSFile(cssFiles[i]);
	}
},
loadCSSFile : function (cssFile) {
// LOAD A CSS FILE IF NOT ALREADY LOADED, REGISTER IN this.loadedCssFiles

	//console.log("    Common.Util.loadCSSFile    *******************");
	//console.log("    Common.Util.loadCSSFile    plugins.core.Common.loadCSSFile(cssFile)");
	//console.log("    Common.Util.loadCSSFile    cssFile: " + cssFile);
	//console.log("    Common.Util.loadCSSFile    this.loadedCssFiles: " + dojo.toJson(this.loadedCssFiles));

	if ( Agua.loadedCssFiles == null || ! Agua.loadedCssFiles )
	{
		//console.log("    Common.Util.loadCSSFile    Creating Agua.loadedCssFiles = new Object");
		Agua.loadedCssFiles = new Object;
	}
	
	if ( ! Agua.loadedCssFiles[cssFile] )
	{
		console.log("    Common.Util.loadCSSFile    Loading cssFile: " + cssFile);
		
		var cssNode = document.createElement('link');
		cssNode.type = 'text/css';
		cssNode.rel = 'stylesheet';
		cssNode.href = cssFile;
		document.getElementsByTagName("head")[0].appendChild(cssNode);

		Agua.loadedCssFiles[cssFile] = 1;
	}
	else
	{
		//console.log("    Common.Util.loadCSSFile    No load. cssFile already exists: " + cssFile);
	}

	//console.log("    Common.Util.loadCSSFile    Returning Agua.loadedCssFiles: " + dojo.toJson(Agua.loadedCssFiles));
	
	return Agua.loadedCssFiles;
},
randomiseUrl : function (url) {
	url += "?dojo.preventCache=1266358799763";
	url += Math.floor(Math.random()*1000000000000);
	
	return url;
},
killPopup : function (combo) {
	//console.log("    Common.Util.killPopup    core.Common.killPopup(combo)");
	var popupId = "widget_" + combo.id + "_dropdown";
	var popup = dojo.byId(popupId);
	if ( popup != null )
	{
		var popupWidget = dijit.byNode(popup.childNodes[0]);
		dijit.popup.close(popupWidget);
	}	
},

});

}

if(!dojo._hasResource["plugins.core.Common"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.core.Common"] = true;
dojo.provide("plugins.core.Common");

/* 	CLASS SUMMARY: PROVIDE COMMONLY USED METHODS FOR ALL CLASSES.

	ALSO PROVIDE LOW-LEVEL METHODS THAT ACCOMPLISH GENERIC TASKS WHICH
	
	ARE WRAPPED AROUND BY CONTEXT-SPECIFIC METHODS
*/









dojo.declare( "plugins.core.Common", [
	plugins.core.Common.Array,
	plugins.core.Common.ComboBox,
	plugins.core.Common.Date,
	plugins.core.Common.Sort,
	plugins.core.Common.Text,
	plugins.core.Common.Toast,
	plugins.core.Common.Util
], {

// HASH OF LOADED CSS FILES
loadedCssFiles : null,

});


}

if(!dojo._hasResource["dojo.regexp"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.regexp"] = true;
dojo.provide("dojo.regexp");

dojo.getObject("regexp", true, dojo);

/*=====
dojo.regexp = {
	// summary: Regular expressions and Builder resources
};
=====*/

dojo.regexp.escapeString = function(/*String*/str, /*String?*/except){
	//	summary:
	//		Adds escape sequences for special characters in regular expressions
	// except:
	//		a String with special characters to be left unescaped

	return str.replace(/([\.$?*|{}\(\)\[\]\\\/\+^])/g, function(ch){
		if(except && except.indexOf(ch) != -1){
			return ch;
		}
		return "\\" + ch;
	}); // String
};

dojo.regexp.buildGroupRE = function(/*Object|Array*/arr, /*Function*/re, /*Boolean?*/nonCapture){
	//	summary:
	//		Builds a regular expression that groups subexpressions
	//	description:
	//		A utility function used by some of the RE generators. The
	//		subexpressions are constructed by the function, re, in the second
	//		parameter.  re builds one subexpression for each elem in the array
	//		a, in the first parameter. Returns a string for a regular
	//		expression that groups all the subexpressions.
	// arr:
	//		A single value or an array of values.
	// re:
	//		A function. Takes one parameter and converts it to a regular
	//		expression.
	// nonCapture:
	//		If true, uses non-capturing match, otherwise matches are retained
	//		by regular expression. Defaults to false

	// case 1: a is a single value.
	if(!(arr instanceof Array)){
		return re(arr); // String
	}

	// case 2: a is an array
	var b = [];
	for(var i = 0; i < arr.length; i++){
		// convert each elem to a RE
		b.push(re(arr[i]));
	}

	 // join the REs as alternatives in a RE group.
	return dojo.regexp.group(b.join("|"), nonCapture); // String
};

dojo.regexp.group = function(/*String*/expression, /*Boolean?*/nonCapture){
	// summary:
	//		adds group match to expression
	// nonCapture:
	//		If true, uses non-capturing match, otherwise matches are retained
	//		by regular expression.
	return "(" + (nonCapture ? "?:":"") + expression + ")"; // String
};

}

if(!dojo._hasResource["dijit.Tooltip"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.Tooltip"] = true;
dojo.provide("dijit.Tooltip");




dojo.declare(
	"dijit._MasterTooltip",
	[dijit._Widget, dijit._Templated],
	{
		// summary:
		//		Internal widget that holds the actual tooltip markup,
		//		which occurs once per page.
		//		Called by Tooltip widgets which are just containers to hold
		//		the markup
		// tags:
		//		protected

		// duration: Integer
		//		Milliseconds to fade in/fade out
		duration: dijit.defaultDuration,

		templateString: dojo.cache("dijit", "templates/Tooltip.html", "<div class=\"dijitTooltip dijitTooltipLeft\" id=\"dojoTooltip\"\n\t><div class=\"dijitTooltipContainer dijitTooltipContents\" dojoAttachPoint=\"containerNode\" role='alert'></div\n\t><div class=\"dijitTooltipConnector\" dojoAttachPoint=\"connectorNode\"></div\n></div>\n"),

		postCreate: function(){
			dojo.body().appendChild(this.domNode);

			this.bgIframe = new dijit.BackgroundIframe(this.domNode);

			// Setup fade-in and fade-out functions.
			this.fadeIn = dojo.fadeIn({ node: this.domNode, duration: this.duration, onEnd: dojo.hitch(this, "_onShow") });
			this.fadeOut = dojo.fadeOut({ node: this.domNode, duration: this.duration, onEnd: dojo.hitch(this, "_onHide") });
		},

		show: function(/*String*/ innerHTML, /*DomNode*/ aroundNode, /*String[]?*/ position, /*Boolean*/ rtl){
			// summary:
			//		Display tooltip w/specified contents to right of specified node
			//		(To left if there's no space on the right, or if rtl == true)

			if(this.aroundNode && this.aroundNode === aroundNode){
				return;
			}

			// reset width; it may have been set by orient() on a previous tooltip show()
			this.domNode.width = "auto";

			if(this.fadeOut.status() == "playing"){
				// previous tooltip is being hidden; wait until the hide completes then show new one
				this._onDeck=arguments;
				return;
			}
			this.containerNode.innerHTML=innerHTML;

			var pos = dijit.placeOnScreenAroundElement(this.domNode, aroundNode, dijit.getPopupAroundAlignment((position && position.length) ? position : dijit.Tooltip.defaultPosition, !rtl), dojo.hitch(this, "orient"));

			// show it
			dojo.style(this.domNode, "opacity", 0);
			this.fadeIn.play();
			this.isShowingNow = true;
			this.aroundNode = aroundNode;
		},

		orient: function(/*DomNode*/ node, /*String*/ aroundCorner, /*String*/ tooltipCorner, /*Object*/ spaceAvailable, /*Object*/ aroundNodeCoords){
			// summary:
			//		Private function to set CSS for tooltip node based on which position it's in.
			//		This is called by the dijit popup code.   It will also reduce the tooltip's
			//		width to whatever width is available
			// tags:
			//		protected
			this.connectorNode.style.top = ""; //reset to default
			
			//Adjust the spaceAvailable width, without changing the spaceAvailable object
			var tooltipSpaceAvaliableWidth = spaceAvailable.w - this.connectorNode.offsetWidth;

			node.className = "dijitTooltip " +
				{
					"BL-TL": "dijitTooltipBelow dijitTooltipABLeft",
					"TL-BL": "dijitTooltipAbove dijitTooltipABLeft",
					"BR-TR": "dijitTooltipBelow dijitTooltipABRight",
					"TR-BR": "dijitTooltipAbove dijitTooltipABRight",
					"BR-BL": "dijitTooltipRight",
					"BL-BR": "dijitTooltipLeft"
				}[aroundCorner + "-" + tooltipCorner];
				
			// reduce tooltip's width to the amount of width available, so that it doesn't overflow screen
			this.domNode.style.width = "auto";
			var size = dojo.contentBox(this.domNode);
			
			var width = Math.min((Math.max(tooltipSpaceAvaliableWidth,1)), size.w);
			var widthWasReduced = width < size.w;
			
			this.domNode.style.width = width+"px";
						
			//Adjust width for tooltips that have a really long word or a nowrap setting
			if(widthWasReduced){
				this.containerNode.style.overflow = "auto"; //temp change to overflow to detect if our tooltip needs to be wider to support the content
				var scrollWidth = this.containerNode.scrollWidth;
				this.containerNode.style.overflow = "visible"; //change it back
				if(scrollWidth > width){
					scrollWidth = scrollWidth + dojo.style(this.domNode,"paddingLeft") + dojo.style(this.domNode,"paddingRight");
					this.domNode.style.width = scrollWidth + "px";
				}
			}
			
			// Reposition the tooltip connector.
			if(tooltipCorner.charAt(0) == 'B' && aroundCorner.charAt(0) == 'B'){
				var mb = dojo.marginBox(node);
				var tooltipConnectorHeight = this.connectorNode.offsetHeight;
				if(mb.h > spaceAvailable.h){
					// The tooltip starts at the top of the page and will extend past the aroundNode
					var aroundNodePlacement = spaceAvailable.h - (aroundNodeCoords.h / 2) - (tooltipConnectorHeight / 2);
					this.connectorNode.style.top = aroundNodePlacement + "px";
					this.connectorNode.style.bottom = "";
				}else{
					// Align center of connector with center of aroundNode, except don't let bottom
					// of connector extend below bottom of tooltip content, or top of connector
					// extend past top of tooltip content
					this.connectorNode.style.bottom = Math.min(
						Math.max(aroundNodeCoords.h/2 - tooltipConnectorHeight/2, 0),
						mb.h - tooltipConnectorHeight) + "px";
					this.connectorNode.style.top = "";
				}
			}else{
				// reset the tooltip back to the defaults
				this.connectorNode.style.top = "";
				this.connectorNode.style.bottom = "";
			}
			
			return Math.max(0, size.w - tooltipSpaceAvaliableWidth);
		},

		_onShow: function(){
			// summary:
			//		Called at end of fade-in operation
			// tags:
			//		protected
			if(dojo.isIE){
				// the arrow won't show up on a node w/an opacity filter
				this.domNode.style.filter="";
			}
		},

		hide: function(aroundNode){
			// summary:
			//		Hide the tooltip

			if(this._onDeck && this._onDeck[1] == aroundNode){
				// this hide request is for a show() that hasn't even started yet;
				// just cancel the pending show()
				this._onDeck=null;
			}else if(this.aroundNode === aroundNode){
				// this hide request is for the currently displayed tooltip
				this.fadeIn.stop();
				this.isShowingNow = false;
				this.aroundNode = null;
				this.fadeOut.play();
			}else{
				// just ignore the call, it's for a tooltip that has already been erased
			}
		},

		_onHide: function(){
			// summary:
			//		Called at end of fade-out operation
			// tags:
			//		protected

			this.domNode.style.cssText="";	// to position offscreen again
			this.containerNode.innerHTML="";
			if(this._onDeck){
				// a show request has been queued up; do it now
				this.show.apply(this, this._onDeck);
				this._onDeck=null;
			}
		}

	}
);

dijit.showTooltip = function(/*String*/ innerHTML, /*DomNode*/ aroundNode, /*String[]?*/ position, /*Boolean*/ rtl){
	// summary:
	//		Display tooltip w/specified contents in specified position.
	//		See description of dijit.Tooltip.defaultPosition for details on position parameter.
	//		If position is not specified then dijit.Tooltip.defaultPosition is used.
	if(!dijit._masterTT){ dijit._masterTT = new dijit._MasterTooltip(); }
	return dijit._masterTT.show(innerHTML, aroundNode, position, rtl);
};

dijit.hideTooltip = function(aroundNode){
	// summary:
	//		Hide the tooltip
	if(!dijit._masterTT){ dijit._masterTT = new dijit._MasterTooltip(); }
	return dijit._masterTT.hide(aroundNode);
};

dojo.declare(
	"dijit.Tooltip",
	dijit._Widget,
	{
		// summary:
		//		Pops up a tooltip (a help message) when you hover over a node.

		// label: String
		//		Text to display in the tooltip.
		//		Specified as innerHTML when creating the widget from markup.
		label: "",

		// showDelay: Integer
		//		Number of milliseconds to wait after hovering over/focusing on the object, before
		//		the tooltip is displayed.
		showDelay: 400,

		// connectId: String|String[]
		//		Id of domNode(s) to attach the tooltip to.
		//		When user hovers over specified dom node, the tooltip will appear.
		connectId: [],

		// position: String[]
		//		See description of `dijit.Tooltip.defaultPosition` for details on position parameter.
		position: [],

		_setConnectIdAttr: function(/*String*/ newId){
			// summary:
			//		Connect to node(s) (specified by id)

			// Remove connections to old nodes (if there are any)
			dojo.forEach(this._connections || [], function(nested){
				dojo.forEach(nested, dojo.hitch(this, "disconnect"));
			}, this);

			// Make connections to nodes in newIds.
			var ary = dojo.isArrayLike(newId) ? newId : (newId ? [newId] : []);
			this._connections = dojo.map(ary, function(id){
				var node = dojo.byId(id);
				return node ? [
					this.connect(node, "onmouseenter", "_onTargetMouseEnter"),
					this.connect(node, "onmouseleave", "_onTargetMouseLeave"),
					this.connect(node, "onfocus", "_onTargetFocus"),
					this.connect(node, "onblur", "_onTargetBlur")
				] : [];
			}, this);
	
			this._set("connectId", newId);

			this._connectIds = ary;	// save as array
		},

		addTarget: function(/*DOMNODE || String*/ node){
			// summary:
			//		Attach tooltip to specified node if it's not already connected

			// TODO: remove in 2.0 and just use set("connectId", ...) interface

			var id = node.id || node;
			if(dojo.indexOf(this._connectIds, id) == -1){
				this.set("connectId", this._connectIds.concat(id));
			}
		},

		removeTarget: function(/*DOMNODE || String*/ node){
			// summary:
			//		Detach tooltip from specified node

			// TODO: remove in 2.0 and just use set("connectId", ...) interface
			
			var id = node.id || node,	// map from DOMNode back to plain id string
				idx = dojo.indexOf(this._connectIds, id);
			if(idx >= 0){
				// remove id (modifies original this._connectIds but that's OK in this case)
				this._connectIds.splice(idx, 1);
				this.set("connectId", this._connectIds);
			}
		},

		buildRendering: function(){
			this.inherited(arguments);
			dojo.addClass(this.domNode,"dijitTooltipData");
		},

		startup: function(){
			this.inherited(arguments);

			// If this tooltip was created in a template, or for some other reason the specified connectId[s]
			// didn't exist during the widget's initialization, then connect now.
			var ids = this.connectId;
			dojo.forEach(dojo.isArrayLike(ids) ? ids : [ids], this.addTarget, this);
		},

		_onTargetMouseEnter: function(/*Event*/ e){
			// summary:
			//		Handler for mouseenter event on the target node
			// tags:
			//		private
			this._onHover(e);
		},

		_onTargetMouseLeave: function(/*Event*/ e){
			// summary:
			//		Handler for mouseleave event on the target node
			// tags:
			//		private
			this._onUnHover(e);
		},

		_onTargetFocus: function(/*Event*/ e){
			// summary:
			//		Handler for focus event on the target node
			// tags:
			//		private

			this._focus = true;
			this._onHover(e);
		},

		_onTargetBlur: function(/*Event*/ e){
			// summary:
			//		Handler for blur event on the target node
			// tags:
			//		private

			this._focus = false;
			this._onUnHover(e);
		},

		_onHover: function(/*Event*/ e){
			// summary:
			//		Despite the name of this method, it actually handles both hover and focus
			//		events on the target node, setting a timer to show the tooltip.
			// tags:
			//		private
			if(!this._showTimer){
				var target = e.target;
				this._showTimer = setTimeout(dojo.hitch(this, function(){this.open(target)}), this.showDelay);
			}
		},

		_onUnHover: function(/*Event*/ e){
			// summary:
			//		Despite the name of this method, it actually handles both mouseleave and blur
			//		events on the target node, hiding the tooltip.
			// tags:
			//		private

			// keep a tooltip open if the associated element still has focus (even though the
			// mouse moved away)
			if(this._focus){ return; }

			if(this._showTimer){
				clearTimeout(this._showTimer);
				delete this._showTimer;
			}
			this.close();
		},

		open: function(/*DomNode*/ target){
 			// summary:
			//		Display the tooltip; usually not called directly.
			// tags:
			//		private

			if(this._showTimer){
				clearTimeout(this._showTimer);
				delete this._showTimer;
			}
			dijit.showTooltip(this.label || this.domNode.innerHTML, target, this.position, !this.isLeftToRight());

			this._connectNode = target;
			this.onShow(target, this.position);
		},

		close: function(){
			// summary:
			//		Hide the tooltip or cancel timer for show of tooltip
			// tags:
			//		private

			if(this._connectNode){
				// if tooltip is currently shown
				dijit.hideTooltip(this._connectNode);
				delete this._connectNode;
				this.onHide();
			}
			if(this._showTimer){
				// if tooltip is scheduled to be shown (after a brief delay)
				clearTimeout(this._showTimer);
				delete this._showTimer;
			}
		},

		onShow: function(target, position){
			// summary:
			//		Called when the tooltip is shown
			// tags:
			//		callback
		},

		onHide: function(){
			// summary:
			//		Called when the tooltip is hidden
			// tags:
			//		callback
		},

		uninitialize: function(){
			this.close();
			this.inherited(arguments);
		}
	}
);

// dijit.Tooltip.defaultPosition: String[]
//		This variable controls the position of tooltips, if the position is not specified to
//		the Tooltip widget or *TextBox widget itself.  It's an array of strings with the following values:
//
//			* before: places tooltip to the left of the target node/widget, or to the right in
//			  the case of RTL scripts like Hebrew and Arabic
//			* after: places tooltip to the right of the target node/widget, or to the left in
//			  the case of RTL scripts like Hebrew and Arabic
//			* above: tooltip goes above target node
//			* below: tooltip goes below target node
//
//		The list is positions is tried, in order, until a position is found where the tooltip fits
//		within the viewport.
//
//		Be careful setting this parameter.  A value of "above" may work fine until the user scrolls
//		the screen so that there's no room above the target node.   Nodes with drop downs, like
//		DropDownButton or FilteringSelect, are especially problematic, in that you need to be sure
//		that the drop down and tooltip don't overlap, even when the viewport is scrolled so that there
//		is only room below (or above) the target node, but not both.
dijit.Tooltip.defaultPosition = ["after", "before"];

}

if(!dojo._hasResource["dijit.form.ValidationTextBox"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.ValidationTextBox"] = true;
dojo.provide("dijit.form.ValidationTextBox");






/*=====
	dijit.form.ValidationTextBox.__Constraints = function(){
		// locale: String
		//		locale used for validation, picks up value from this widget's lang attribute
		// _flags_: anything
		//		various flags passed to regExpGen function
		this.locale = "";
		this._flags_ = "";
	}
=====*/

dojo.declare(
	"dijit.form.ValidationTextBox",
	dijit.form.TextBox,
	{
		// summary:
		//		Base class for textbox widgets with the ability to validate content of various types and provide user feedback.
		// tags:
		//		protected

		templateString: dojo.cache("dijit.form", "templates/ValidationTextBox.html", "<div class=\"dijit dijitReset dijitInlineTable dijitLeft\"\n\tid=\"widget_${id}\" role=\"presentation\"\n\t><div class='dijitReset dijitValidationContainer'\n\t\t><input class=\"dijitReset dijitInputField dijitValidationIcon dijitValidationInner\" value=\"&#935; \" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"presentation\"\n\t/></div\n\t><div class=\"dijitReset dijitInputField dijitInputContainer\"\n\t\t><input class=\"dijitReset dijitInputInner\" dojoAttachPoint='textbox,focusNode' autocomplete=\"off\"\n\t\t\t${!nameAttrSetting} type='${type}'\n\t/></div\n></div>\n"),
		baseClass: "dijitTextBox dijitValidationTextBox",

		// required: Boolean
		//		User is required to enter data into this field.
		required: false,

		// promptMessage: String
		//		If defined, display this hint string immediately on focus to the textbox, if empty.
		//		Also displays if the textbox value is Incomplete (not yet valid but will be with additional input).
		//		Think of this like a tooltip that tells the user what to do, not an error message
		//		that tells the user what they've done wrong.
		//
		//		Message disappears when user starts typing.
		promptMessage: "",

		// invalidMessage: String
		// 		The message to display if value is invalid.
		//		The translated string value is read from the message file by default.
		// 		Set to "" to use the promptMessage instead.
		invalidMessage: "$_unset_$",

		// missingMessage: String
		// 		The message to display if value is empty and the field is required.
		//		The translated string value is read from the message file by default.
		// 		Set to "" to use the invalidMessage instead.
		missingMessage: "$_unset_$",

		// message: String
		//		Currently error/prompt message.
		//		When using the default tooltip implementation, this will only be
		//		displayed when the field is focused.
		message: "",

		// constraints: dijit.form.ValidationTextBox.__Constraints
		//		user-defined object needed to pass parameters to the validator functions
		constraints: {},

		// regExp: [extension protected] String
		//		regular expression string used to validate the input
		//		Do not specify both regExp and regExpGen
		regExp: ".*",

		regExpGen: function(/*dijit.form.ValidationTextBox.__Constraints*/ constraints){
			// summary:
			//		Overridable function used to generate regExp when dependent on constraints.
			//		Do not specify both regExp and regExpGen.
			// tags:
			//		extension protected
			return this.regExp; // String
		},

		// state: [readonly] String
		//		Shows current state (ie, validation result) of input (""=Normal, Incomplete, or Error)
		state: "",

		// tooltipPosition: String[]
		//		See description of `dijit.Tooltip.defaultPosition` for details on this parameter.
		tooltipPosition: [],

		_setValueAttr: function(){
			// summary:
			//		Hook so set('value', ...) works.
			this.inherited(arguments);
			this.validate(this._focused);
		},

		validator: function(/*anything*/ value, /*dijit.form.ValidationTextBox.__Constraints*/ constraints){
			// summary:
			//		Overridable function used to validate the text input against the regular expression.
			// tags:
			//		protected
			
			//console.log("dijit.form.ValidationTextBox.validator    value: " + value);
			//console.log("dijit.form.ValidationTextBox.validator    this._required: " + this.required);

			return (new RegExp("^(?:" + this.regExpGen(constraints) + ")"+(this.required?"":"?")+"$")).test(value) &&
				(!this.required || !this._isEmpty(value)) &&
				(this._isEmpty(value) || this.parse(value, constraints) !== undefined); // Boolean
		},

		_isValidSubset: function(){
			// summary:
			//		Returns true if the value is either already valid or could be made valid by appending characters.
			//		This is used for validation while the user [may be] still typing.
			return this.textbox.value.search(this._partialre) == 0;
		},

		isValid: function(/*Boolean*/ isFocused){
			// summary:
			//		Tests if value is valid.
			//		Can override with your own routine in a subclass.
			// tags:
			//		protected
			
			//console.log("dijit.form.ValidationTextBox.isValid    OOOOOOOOOOOOOOOOOOOOOOOOO this.textbox.value: " + this.textbox.value);
			
			var result = this.validator(this.textbox.value, this.constraints);
			//console.log("dijit.form.ValidationTextBox.isValid    OOOOOOOOOOOOOOOOOOOOOOOOO result: " + result);
			return result;
		},

		_isEmpty: function(value){
			// summary:
			//		Checks for whitespace
			//console.log("dijit.form.ValidationTextBox._isEmpty    value: " + value);
			var returnValue = (this.trim ? /^\s*$/ : /^$/).test(value);
			//console.log("dijit.form.ValidationTextBox._isEmpty    Returning: " + returnValue);

			return (this.trim ? /^\s*$/ : /^$/).test(value); // Boolean
		},

		getErrorMessage: function(/*Boolean*/ isFocused){
			// summary:
			//		Return an error message to show if appropriate
			// tags:
			//		protected
			return (this.required && this._isEmpty(this.textbox.value)) ? this.missingMessage : this.invalidMessage; // String
		},

		getPromptMessage: function(/*Boolean*/ isFocused){
			// summary:
			//		Return a hint message to show when widget is first focused
			// tags:
			//		protected
			return this.promptMessage; // String
		},

		_maskValidSubsetError: true,
		
		validate: function(/*Boolean*/ isFocused){
			//console.log("dijit.form.ValidationTextBox.validate    XXXXXXXXXXXXXXXXXXXXXXXXX");
			//console.log("dijit.form.ValidationTextBox.validate    isFocused: " + isFocused);
			//console.log("dijit.form.ValidationTextBox.validate    this.disabled: " + this.disabled);

			// summary:
			//		Called by oninit, onblur, and onkeypress.
			// description:
			//		Show missing or invalid messages if appropriate, and highlight textbox field.
			// tags:
			//		protected
			var message = "";
			var isValid = this.disabled || this.isValid(isFocused);
			//console.log("dijit.form.ValidationTextBox.validate    isValid: " + isValid);

			if(isValid){ this._maskValidSubsetError = true; }
			var isEmpty = this._isEmpty(this.textbox.value);
			//console.log("dijit.form.ValidationTextBox.validate    isEmpty: " + isEmpty);

			var isValidSubset = !isValid && isFocused && this._isValidSubset();
			//console.log("dijit.form.ValidationTextBox.validate    isValidSubset: " + isValidSubset);

			this._set("state", isValid ? "" : (((((!this._hasBeenBlurred || isFocused) && isEmpty) || isValidSubset) && this._maskValidSubsetError) ? "Incomplete" : "Error"));
			dijit.setWaiState(this.focusNode, "invalid", isValid ? "false" : "true");

			if(this.state == "Error"){
				this._maskValidSubsetError = isFocused && isValidSubset; // we want the error to show up after a blur and refocus
				message = this.getErrorMessage(isFocused);
			}else if(this.state == "Incomplete"){
				message = this.getPromptMessage(isFocused); // show the prompt whenever the value is not yet complete
				this._maskValidSubsetError = !this._hasBeenBlurred || isFocused; // no Incomplete warnings while focused
			}else if(isEmpty){
				message = this.getPromptMessage(isFocused); // show the prompt whenever there's no error and no text
			}
			this.set("message", message);

			return isValid;
		},

		displayMessage: function(/*String*/ message){
			// summary:
			//		Overridable method to display validation errors/hints.
			//		By default uses a tooltip.
			// tags:
			//		extension
			dijit.hideTooltip(this.domNode);
			if(message && this._focused){
				dijit.showTooltip(message, this.domNode, this.tooltipPosition, !this.isLeftToRight());
			}
		},

		_refreshState: function(){
			// Overrides TextBox._refreshState()
			this.validate(this._focused);
			this.inherited(arguments);
		},

		//////////// INITIALIZATION METHODS ///////////////////////////////////////

		constructor: function(){
			this.constraints = {};
		},

		_setConstraintsAttr: function(/*Object*/ constraints){
			if(!constraints.locale && this.lang){
				constraints.locale = this.lang;
			}
			this._set("constraints", constraints);
			this._computePartialRE();
		},

		_computePartialRE: function(){
			var p = this.regExpGen(this.constraints);
			this.regExp = p;
			var partialre = "";
			// parse the regexp and produce a new regexp that matches valid subsets
			// if the regexp is .* then there's no use in matching subsets since everything is valid
			if(p != ".*"){ this.regExp.replace(/\\.|\[\]|\[.*?[^\\]{1}\]|\{.*?\}|\(\?[=:!]|./g,
				function (re){
					switch(re.charAt(0)){
						case '{':
						case '+':
						case '?':
						case '*':
						case '^':
						case '$':
						case '|':
						case '(':
							partialre += re;
							break;
						case ")":
							partialre += "|$)";
							break;
						 default:
							partialre += "(?:"+re+"|$)";
							break;
					}
				}
			);}
			try{ // this is needed for now since the above regexp parsing needs more test verification
				"".search(partialre);
			}catch(e){ // should never be here unless the original RE is bad or the parsing is bad
				partialre = this.regExp;
				console.warn('RegExp error in ' + this.declaredClass + ': ' + this.regExp);
			} // should never be here unless the original RE is bad or the parsing is bad
			this._partialre = "^(?:" + partialre + ")$";
		},

		postMixInProperties: function(){
			this.inherited(arguments);
			this.messages = dojo.i18n.getLocalization("dijit.form", "validate", this.lang);
			if(this.invalidMessage == "$_unset_$"){ this.invalidMessage = this.messages.invalidMessage; }
			if(!this.invalidMessage){ this.invalidMessage = this.promptMessage; }
			if(this.missingMessage == "$_unset_$"){ this.missingMessage = this.messages.missingMessage; }
			if(!this.missingMessage){ this.missingMessage = this.invalidMessage; }
			this._setConstraintsAttr(this.constraints); // this needs to happen now (and later) due to codependency on _set*Attr calls attachPoints
		},

		_setDisabledAttr: function(/*Boolean*/ value){
			this.inherited(arguments);	// call FormValueWidget._setDisabledAttr()
			this._refreshState();
		},

		_setRequiredAttr: function(/*Boolean*/ value){
			this._set("required", value);
			dijit.setWaiState(this.focusNode, "required", value);
			this._refreshState();
		},

		_setMessageAttr: function(/*String*/ message){
			this._set("message", message);
			this.displayMessage(message);
		},

		reset:function(){
			// Overrides dijit.form.TextBox.reset() by also
			// hiding errors about partial matches
			this._maskValidSubsetError = true;
			this.inherited(arguments);
		},

		_onBlur: function(){
			// the message still exists but for back-compat, and to erase the tooltip
			// (if the message is being displayed as a tooltip), call displayMessage('')
			this.displayMessage('');

			this.inherited(arguments);
		}
	}
);

dojo.declare(
	"dijit.form.MappedTextBox",
	dijit.form.ValidationTextBox,
	{
		// summary:
		//		A dijit.form.ValidationTextBox subclass which provides a base class for widgets that have
		//		a visible formatted display value, and a serializable
		//		value in a hidden input field which is actually sent to the server.
		// description:
		//		The visible display may
		//		be locale-dependent and interactive.  The value sent to the server is stored in a hidden
		//		input field which uses the `name` attribute declared by the original widget.  That value sent
		//		to the server is defined by the dijit.form.MappedTextBox.serialize method and is typically
		//		locale-neutral.
		// tags:
		//		protected

		postMixInProperties: function(){
			this.inherited(arguments);

			// we want the name attribute to go to the hidden <input>, not the displayed <input>,
			// so override _FormWidget.postMixInProperties() setting of nameAttrSetting
			this.nameAttrSetting = "";
		},

		serialize: function(/*anything*/ val, /*Object?*/ options){
			// summary:
			//		Overridable function used to convert the get('value') result to a canonical
			//		(non-localized) string.  For example, will print dates in ISO format, and
			//		numbers the same way as they are represented in javascript.
			// tags:
			//		protected extension
			return val.toString ? val.toString() : ""; // String
		},

		toString: function(){
			// summary:
			//		Returns widget as a printable string using the widget's value
			// tags:
			//		protected
			var val = this.filter(this.get('value')); // call filter in case value is nonstring and filter has been customized
			return val != null ? (typeof val == "string" ? val : this.serialize(val, this.constraints)) : ""; // String
		},

		validate: function(){
			// Overrides `dijit.form.TextBox.validate`
			this.valueNode.value = this.toString();
			return this.inherited(arguments);
		},

		buildRendering: function(){
			// Overrides `dijit._Templated.buildRendering`

			this.inherited(arguments);

			// Create a hidden <input> node with the serialized value used for submit
			// (as opposed to the displayed value).
			// Passing in name as markup rather than calling dojo.create() with an attrs argument
			// to make dojo.query(input[name=...]) work on IE. (see #8660)
			this.valueNode = dojo.place("<input type='hidden'" + (this.name ? " name='" + this.name.replace(/'/g, "&quot;") + "'" : "") + "/>", this.textbox, "after");
		},

		reset: function(){
			// Overrides `dijit.form.ValidationTextBox.reset` to
			// reset the hidden textbox value to ''
			this.valueNode.value = '';
			this.inherited(arguments);
		}
	}
);

/*=====
	dijit.form.RangeBoundTextBox.__Constraints = function(){
		// min: Number
		//		Minimum signed value.  Default is -Infinity
		// max: Number
		//		Maximum signed value.  Default is +Infinity
		this.min = min;
		this.max = max;
	}
=====*/

dojo.declare(
	"dijit.form.RangeBoundTextBox",
	dijit.form.MappedTextBox,
	{
		// summary:
		//		Base class for textbox form widgets which defines a range of valid values.

		// rangeMessage: String
		//		The message to display if value is out-of-range
		rangeMessage: "",

		/*=====
		// constraints: dijit.form.RangeBoundTextBox.__Constraints
		constraints: {},
		======*/

		rangeCheck: function(/*Number*/ primitive, /*dijit.form.RangeBoundTextBox.__Constraints*/ constraints){
			// summary:
			//		Overridable function used to validate the range of the numeric input value.
			// tags:
			//		protected
			return	("min" in constraints? (this.compare(primitive,constraints.min) >= 0) : true) &&
				("max" in constraints? (this.compare(primitive,constraints.max) <= 0) : true); // Boolean
		},

		isInRange: function(/*Boolean*/ isFocused){
			// summary:
			//		Tests if the value is in the min/max range specified in constraints
			// tags:
			//		protected
			return this.rangeCheck(this.get('value'), this.constraints);
		},

		_isDefinitelyOutOfRange: function(){
			// summary:
			//		Returns true if the value is out of range and will remain
			//		out of range even if the user types more characters
			var val = this.get('value');
			var isTooLittle = false;
			var isTooMuch = false;
			if("min" in this.constraints){
				var min = this.constraints.min;
				min = this.compare(val, ((typeof min == "number") && min >= 0 && val !=0) ? 0 : min);
				isTooLittle = (typeof min == "number") && min < 0;
			}
			if("max" in this.constraints){
				var max = this.constraints.max;
				max = this.compare(val, ((typeof max != "number") || max > 0) ? max : 0);
				isTooMuch = (typeof max == "number") && max > 0;
			}
			return isTooLittle || isTooMuch;
		},

		_isValidSubset: function(){
			// summary:
			//		Overrides `dijit.form.ValidationTextBox._isValidSubset`.
			//		Returns true if the input is syntactically valid, and either within
			//		range or could be made in range by more typing.
			return this.inherited(arguments) && !this._isDefinitelyOutOfRange();
		},

		isValid: function(/*Boolean*/ isFocused){
			// Overrides dijit.form.ValidationTextBox.isValid to check that the value is also in range.
			
			
			return this.inherited(arguments) &&
				((this._isEmpty(this.textbox.value) && !this.required) || this.isInRange(isFocused)); // Boolean
		},

		getErrorMessage: function(/*Boolean*/ isFocused){
			// Overrides dijit.form.ValidationTextBox.getErrorMessage to print "out of range" message if appropriate
			var v = this.get('value');
			if(v !== null && v !== '' && v !== undefined && (typeof v != "number" || !isNaN(v)) && !this.isInRange(isFocused)){ // don't check isInRange w/o a real value
				return this.rangeMessage; // String
			}
			return this.inherited(arguments);
		},

		postMixInProperties: function(){
			this.inherited(arguments);
			if(!this.rangeMessage){
				this.messages = dojo.i18n.getLocalization("dijit.form", "validate", this.lang);
				this.rangeMessage = this.messages.rangeMessage;
			}
		},

		_setConstraintsAttr: function(/*Object*/ constraints){
			this.inherited(arguments);
			if(this.focusNode){ // not set when called from postMixInProperties
				if(this.constraints.min !== undefined){
					dijit.setWaiState(this.focusNode, "valuemin", this.constraints.min);
				}else{
					dijit.removeWaiState(this.focusNode, "valuemin");
				}
				if(this.constraints.max !== undefined){
					dijit.setWaiState(this.focusNode, "valuemax", this.constraints.max);
				}else{
					dijit.removeWaiState(this.focusNode, "valuemax");
				}
			}
		},

		_setValueAttr: function(/*Number*/ value, /*Boolean?*/ priorityChange){
			// summary:
			//		Hook so set('value', ...) works.

			dijit.setWaiState(this.focusNode, "valuenow", value);
			this.inherited(arguments);
		}
	}
);

}

if(!dojo._hasResource["dijit.form.ComboBox"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.ComboBox"] = true;
dojo.provide("dijit.form.ComboBox");











dojo.declare(
	"dijit.form.ComboBoxMixin",
	dijit._HasDropDown,
	{
		// summary:
		//		Implements the base functionality for `dijit.form.ComboBox`/`dijit.form.FilteringSelect`
		// description:
		//		All widgets that mix in dijit.form.ComboBoxMixin must extend `dijit.form._FormValueWidget`.
		// tags:
		//		protected

		// item: Object
		//		This is the item returned by the dojo.data.store implementation that
		//		provides the data for this ComboBox, it's the currently selected item.
		item: null,

		// pageSize: Integer
		//		Argument to data provider.
		//		Specifies number of search results per page (before hitting "next" button)
		pageSize: Infinity,

		// store: [const] Object
		//		Reference to data provider object used by this ComboBox
		store: null,

		// fetchProperties: Object
		//		Mixin to the dojo.data store's fetch.
		//		For example, to set the sort order of the ComboBox menu, pass:
		//	|	{ sort: [{attribute:"name",descending: true}] }
		//		To override the default queryOptions so that deep=false, do:
		//	|	{ queryOptions: {ignoreCase: true, deep: false} }
		fetchProperties:{},

		// query: Object
		//		A query that can be passed to 'store' to initially filter the items,
		//		before doing further filtering based on `searchAttr` and the key.
		//		Any reference to the `searchAttr` is ignored.
		query: {},

		// autoComplete: Boolean
		//		If user types in a partial string, and then tab out of the `<input>` box,
		//		automatically copy the first entry displayed in the drop down list to
		//		the `<input>` field
		autoComplete: true,

		// highlightMatch: String
		// 		One of: "first", "all" or "none".
		//
		//		If the ComboBox/FilteringSelect opens with the search results and the searched
		//		string can be found, it will be highlighted.  If set to "all"
		//		then will probably want to change `queryExpr` parameter to '*${0}*'
		//
		//		Highlighting is only performed when `labelType` is "text", so as to not
		//		interfere with any HTML markup an HTML label might contain.
		highlightMatch: "first",

		// searchDelay: Integer
		//		Delay in milliseconds between when user types something and we start
		//		searching based on that value
		searchDelay: 100,

		// searchAttr: String
		//		Search for items in the data store where this attribute (in the item)
		//		matches what the user typed
		searchAttr: "name",

		// labelAttr: String?
		//		The entries in the drop down list come from this attribute in the
		//		dojo.data items.
		//		If not specified, the searchAttr attribute is used instead.
		labelAttr: "",

		// labelType: String
		//		Specifies how to interpret the labelAttr in the data store items.
		//		Can be "html" or "text".
		labelType: "text",

		// queryExpr: String
		//		This specifies what query ComboBox/FilteringSelect sends to the data store,
		//		based on what the user has typed.  Changing this expression will modify
		//		whether the drop down shows only exact matches, a "starting with" match,
		//		etc.  Use it in conjunction with highlightMatch.
		//		dojo.data query expression pattern.
		//		`${0}` will be substituted for the user text.
		//		`*` is used for wildcards.
		//		`${0}*` means "starts with", `*${0}*` means "contains", `${0}` means "is"
		queryExpr: "${0}*",

		// ignoreCase: Boolean
		//		Set true if the ComboBox/FilteringSelect should ignore case when matching possible items
		ignoreCase: true,

		// hasDownArrow: Boolean
		//		Set this textbox to have a down arrow button, to display the drop down list.
		//		Defaults to true.
		hasDownArrow: true,

		templateString: dojo.cache("dijit.form", "templates/DropDownBox.html", "<div class=\"dijit dijitReset dijitInlineTable dijitLeft\"\n\tid=\"widget_${id}\"\n\trole=\"combobox\"\n\t><div class='dijitReset dijitRight dijitButtonNode dijitArrowButton dijitDownArrowButton dijitArrowButtonContainer'\n\t\tdojoAttachPoint=\"_buttonNode, _popupStateNode\" role=\"presentation\"\n\t\t><input class=\"dijitReset dijitInputField dijitArrowButtonInner\" value=\"&#9660; \" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"presentation\"\n\t\t\t${_buttonInputDisabled}\n\t/></div\n\t><div class='dijitReset dijitValidationContainer'\n\t\t><input class=\"dijitReset dijitInputField dijitValidationIcon dijitValidationInner\" value=\"&#935; \" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"presentation\"\n\t/></div\n\t><div class=\"dijitReset dijitInputField dijitInputContainer\"\n\t\t><input class='dijitReset dijitInputInner' ${!nameAttrSetting} type=\"text\" autocomplete=\"off\"\n\t\t\tdojoAttachPoint=\"textbox,focusNode\" role=\"textbox\" aria-haspopup=\"true\"\n\t/></div\n></div>\n"),

		baseClass: "dijitTextBox dijitComboBox",

		// dropDownClass: [protected extension] String
		//		Name of the dropdown widget class used to select a date/time.
		//		Subclasses should specify this.
		dropDownClass: "dijit.form._ComboBoxMenu",

		// Set classes like dijitDownArrowButtonHover depending on
		// mouse action over button node
		cssStateNodes: {
			"_buttonNode": "dijitDownArrowButton"
		},

		// Flags to _HasDropDown to limit height of drop down to make it fit in viewport
		maxHeight: -1,

		// For backwards compatibility let onClick events propagate, even clicks on the down arrow button
		_stopClickEvents: false,

		_getCaretPos: function(/*DomNode*/ element){
			// khtml 3.5.2 has selection* methods as does webkit nightlies from 2005-06-22
			var pos = 0;
			if(typeof(element.selectionStart) == "number"){
				// FIXME: this is totally borked on Moz < 1.3. Any recourse?
				pos = element.selectionStart;
			}else if(dojo.isIE){
				// in the case of a mouse click in a popup being handled,
				// then the dojo.doc.selection is not the textarea, but the popup
				// var r = dojo.doc.selection.createRange();
				// hack to get IE 6 to play nice. What a POS browser.
				var tr = dojo.doc.selection.createRange().duplicate();
				var ntr = element.createTextRange();
				tr.move("character",0);
				ntr.move("character",0);
				try{
					// If control doesn't have focus, you get an exception.
					// Seems to happen on reverse-tab, but can also happen on tab (seems to be a race condition - only happens sometimes).
					// There appears to be no workaround for this - googled for quite a while.
					ntr.setEndPoint("EndToEnd", tr);
					pos = String(ntr.text).replace(/\r/g,"").length;
				}catch(e){
					// If focus has shifted, 0 is fine for caret pos.
				}
			}
			return pos;
		},

		_setCaretPos: function(/*DomNode*/ element, /*Number*/ location){
			location = parseInt(location);
			dijit.selectInputText(element, location, location);
		},

		_setDisabledAttr: function(/*Boolean*/ value){
			// Additional code to set disabled state of ComboBox node.
			// Overrides _FormValueWidget._setDisabledAttr() or ValidationTextBox._setDisabledAttr().
			this.inherited(arguments);
			dijit.setWaiState(this.domNode, "disabled", value);
		},

		_abortQuery: function(){
			// stop in-progress query
			if(this.searchTimer){
				clearTimeout(this.searchTimer);
				this.searchTimer = null;
			}
			if(this._fetchHandle){
				if(this._fetchHandle.abort){ this._fetchHandle.abort(); }
				this._fetchHandle = null;
			}
		},

		_onInput: function(/*Event*/ evt){
			// summary:
			//		Handles paste events
			if(!this.searchTimer && (evt.type == 'paste'/*IE|WebKit*/ || evt.type == 'input'/*Firefox*/) && this._lastInput != this.textbox.value){
				this.searchTimer = setTimeout(dojo.hitch(this, function(){
					this._onKey({charOrCode: 229}); // fake IME key to cause a search
				}), 100); // long delay that will probably be preempted by keyboard input
			}
			this.inherited(arguments);
		},

		_onKey: function(/*Event*/ evt){
			// summary:
			//		Handles keyboard events

			var key = evt.charOrCode;

			// except for cutting/pasting case - ctrl + x/v
			if(evt.altKey || ((evt.ctrlKey || evt.metaKey) && (key != 'x' && key != 'v')) || key == dojo.keys.SHIFT){
				return; // throw out weird key combinations and spurious events
			}
			
			var doSearch = false;
			var pw = this.dropDown;
			var dk = dojo.keys;
			var highlighted = null;
			this._prev_key_backspace = false;
			this._abortQuery();

			// _HasDropDown will do some of the work:
			//		1. when drop down is not yet shown:
			//			- if user presses the down arrow key, call loadDropDown()
			//		2. when drop down is already displayed:
			//			- on ESC key, call closeDropDown()
			//			- otherwise, call dropDown.handleKey() to process the keystroke
			this.inherited(arguments);

			if(this._opened){
				highlighted = pw.getHighlightedOption();
			}
			switch(key){
				case dk.PAGE_DOWN:
				case dk.DOWN_ARROW:
				case dk.PAGE_UP:
				case dk.UP_ARROW:
					// Keystroke caused ComboBox_menu to move to a different item.
					// Copy new item to <input> box.
					if(this._opened){
						this._announceOption(highlighted);
					}
					dojo.stopEvent(evt);
					break;

				case dk.ENTER:
					// prevent submitting form if user presses enter. Also
					// prevent accepting the value if either Next or Previous
					// are selected
					if(highlighted){
						// only stop event on prev/next
						if(highlighted == pw.nextButton){
							this._nextSearch(1);
							dojo.stopEvent(evt);
							break;
						}else if(highlighted == pw.previousButton){
							this._nextSearch(-1);
							dojo.stopEvent(evt);
							break;
						}
					}else{
						// Update 'value' (ex: KY) according to currently displayed text
						this._setBlurValue(); // set value if needed
						this._setCaretPos(this.focusNode, this.focusNode.value.length); // move cursor to end and cancel highlighting
					}
					// default case:
					// if enter pressed while drop down is open, or for FilteringSelect,
					// if we are in the middle of a query to convert a directly typed in value to an item,
					// prevent submit, but allow event to bubble
					if(this._opened || this._fetchHandle){
					evt.preventDefault();
					}
					// fall through

				case dk.TAB:
					var newvalue = this.get('displayedValue');
					//	if the user had More Choices selected fall into the
					//	_onBlur handler
					if(pw && (
						newvalue == pw._messages["previousMessage"] ||
						newvalue == pw._messages["nextMessage"])
					){
						break;
					}
					if(highlighted){
						this._selectOption();
					}
					if(this._opened){
						this._lastQuery = null; // in case results come back later
						this.closeDropDown();
					}
					break;

				case ' ':
					if(highlighted){
						// user is effectively clicking a choice in the drop down menu
						dojo.stopEvent(evt);
						this._selectOption();
						this.closeDropDown();
					}else{
						// user typed a space into the input box, treat as normal character
						doSearch = true;
					}
					break;

				case dk.DELETE:
				case dk.BACKSPACE:
					this._prev_key_backspace = true;
					doSearch = true;
					break;

				default:
					// Non char keys (F1-F12 etc..)  shouldn't open list.
					// Ascii characters and IME input (Chinese, Japanese etc.) should.
					//IME input produces keycode == 229.
					doSearch = typeof key == 'string' || key == 229;
			}
			if(doSearch){
				// need to wait a tad before start search so that the event
				// bubbles through DOM and we have value visible
				this.item = undefined; // undefined means item needs to be set
				this.searchTimer = setTimeout(dojo.hitch(this, "_startSearchFromInput"),1);
			}
		},

		_autoCompleteText: function(/*String*/ text){
			// summary:
			// 		Fill in the textbox with the first item from the drop down
			// 		list, and highlight the characters that were
			// 		auto-completed. For example, if user typed "CA" and the
			// 		drop down list appeared, the textbox would be changed to
			// 		"California" and "ifornia" would be highlighted.

			var fn = this.focusNode;

			// IE7: clear selection so next highlight works all the time
			dijit.selectInputText(fn, fn.value.length);
			// does text autoComplete the value in the textbox?
			var caseFilter = this.ignoreCase? 'toLowerCase' : 'substr';
			if(text[caseFilter](0).indexOf(this.focusNode.value[caseFilter](0)) == 0){
				var cpos = this._getCaretPos(fn);
				// only try to extend if we added the last character at the end of the input
				if((cpos+1) > fn.value.length){
					// only add to input node as we would overwrite Capitalisation of chars
					// actually, that is ok
					fn.value = text;//.substr(cpos);
					// visually highlight the autocompleted characters
					dijit.selectInputText(fn, cpos);
				}
			}else{
				// text does not autoComplete; replace the whole value and highlight
				fn.value = text;
				dijit.selectInputText(fn);
			}
		},

		_openResultList: function(/*Object*/ results, /*Object*/ dataObject){
			// summary:
			//		Callback when a search completes.
			// description:
			//		1. generates drop-down list and calls _showResultList() to display it
			//		2. if this result list is from user pressing "more choices"/"previous choices"
			//			then tell screen reader to announce new option
			this._fetchHandle = null;
			if(	this.disabled ||
				this.readOnly ||
				(dataObject.query[this.searchAttr] != this._lastQuery)
			){
				return;
			}
			var wasSelected = this.dropDown._highlighted_option && dojo.hasClass(this.dropDown._highlighted_option, "dijitMenuItemSelected");
			this.dropDown.clearResultList();
			if(!results.length && !this._maxOptions){ // if no results and not just the previous choices button
				this.closeDropDown();
				return;
			}

			// Fill in the textbox with the first item from the drop down list,
			// and highlight the characters that were auto-completed. For
			// example, if user typed "CA" and the drop down list appeared, the
			// textbox would be changed to "California" and "ifornia" would be
			// highlighted.

			dataObject._maxOptions = this._maxOptions;
			var nodes = this.dropDown.createOptions(
				results,
				dataObject,
				dojo.hitch(this, "_getMenuLabelFromItem")
			);

			// show our list (only if we have content, else nothing)
			this._showResultList();

			// #4091:
			//		tell the screen reader that the paging callback finished by
			//		shouting the next choice
			if(dataObject.direction){
				if(1 == dataObject.direction){
					this.dropDown.highlightFirstOption();
				}else if(-1 == dataObject.direction){
					this.dropDown.highlightLastOption();
				}
				if(wasSelected){
					this._announceOption(this.dropDown.getHighlightedOption());
				}
			}else if(this.autoComplete && !this._prev_key_backspace
				// when the user clicks the arrow button to show the full list,
				// startSearch looks for "*".
				// it does not make sense to autocomplete
				// if they are just previewing the options available.
				&& !/^[*]+$/.test(dataObject.query[this.searchAttr])){
					this._announceOption(nodes[1]); // 1st real item
			}
		},

		_showResultList: function(){
			// summary:
			//		Display the drop down if not already displayed, or if it is displayed, then
			//		reposition it if necessary (reposition may be necessary if drop down's height changed).

			this.closeDropDown(true);

			// hide the tooltip
			this.displayMessage("");

			this.openDropDown();

			dijit.setWaiState(this.domNode, "expanded", "true");
		},

		loadDropDown: function(/*Function*/ callback){
			// Overrides _HasDropDown.loadDropDown().
			// This is called when user has pressed button icon or pressed the down arrow key
			// to open the drop down.
			
			this._startSearchAll();
		},

		isLoaded: function(){
			// signal to _HasDropDown that it needs to call loadDropDown() to load the
			// drop down asynchronously before displaying it
			return false;
		},

		closeDropDown: function(){
			// Overrides _HasDropDown.closeDropDown().  Closes the drop down (assuming that it's open).
			// This method is the callback when the user types ESC or clicking
			// the button icon while the drop down is open.  It's also called by other code.
			this._abortQuery();
			if(this._opened){
				this.inherited(arguments);
				dijit.setWaiState(this.domNode, "expanded", "false");
				dijit.removeWaiState(this.focusNode,"activedescendant");
			}
		},

		_setBlurValue: function(){
			// if the user clicks away from the textbox OR tabs away, set the
			// value to the textbox value
			// #4617:
			//		if value is now more choices or previous choices, revert
			//		the value
			var newvalue = this.get('displayedValue');
			var pw = this.dropDown;
			if(pw && (
				newvalue == pw._messages["previousMessage"] ||
				newvalue == pw._messages["nextMessage"]
				)
			){
				this._setValueAttr(this._lastValueReported, true);
			}else if(typeof this.item == "undefined"){
				// Update 'value' (ex: KY) according to currently displayed text
				this.item = null;
				this.set('displayedValue', newvalue);
			}else{
				if(this.value != this._lastValueReported){
					dijit.form._FormValueWidget.prototype._setValueAttr.call(this, this.value, true);
				}
				this._refreshState();
			}
		},

		_onBlur: function(){
			// summary:
			//		Called magically when focus has shifted away from this widget and it's drop down
			this.closeDropDown();
			this.inherited(arguments);
		},

		_setItemAttr: function(/*item*/ item, /*Boolean?*/ priorityChange, /*String?*/ displayedValue){
			// summary:
			//		Set the displayed valued in the input box, and the hidden value
			//		that gets submitted, based on a dojo.data store item.
			// description:
			//		Users shouldn't call this function; they should be calling
			//		set('item', value)
			// tags:
			//		private
			if(!displayedValue){
				displayedValue = this.store.getValue(item, this.searchAttr);
			}
			var value = this._getValueField() != this.searchAttr? this.store.getIdentity(item) : displayedValue;
			this._set("item", item);
			dijit.form.ComboBox.superclass._setValueAttr.call(this, value, priorityChange, displayedValue);
		},

		_announceOption: function(/*Node*/ node){
			// summary:
			//		a11y code that puts the highlighted option in the textbox.
			//		This way screen readers will know what is happening in the
			//		menu.

			if(!node){
				return;
			}
			// pull the text value from the item attached to the DOM node
			var newValue;
			if(node == this.dropDown.nextButton ||
				node == this.dropDown.previousButton){
				newValue = node.innerHTML;
				this.item = undefined;
				this.value = '';
			}else{
				newValue = this.store.getValue(node.item, this.searchAttr).toString();
				this.set('item', node.item, false, newValue);
			}
			// get the text that the user manually entered (cut off autocompleted text)
			this.focusNode.value = this.focusNode.value.substring(0, this._lastInput.length);
			// set up ARIA activedescendant
			dijit.setWaiState(this.focusNode, "activedescendant", dojo.attr(node, "id"));
			// autocomplete the rest of the option to announce change
			this._autoCompleteText(newValue);
		},

		_selectOption: function(/*Event*/ evt){
			// summary:
			//		Menu callback function, called when an item in the menu is selected.
			if(evt){
				this._announceOption(evt.target);
			}
			this.closeDropDown();
			this._setCaretPos(this.focusNode, this.focusNode.value.length);
			dijit.form._FormValueWidget.prototype._setValueAttr.call(this, this.value, true); // set this.value and fire onChange
		},

		_startSearchAll: function(){
			this._startSearch('');
		},

		_startSearchFromInput: function(){
			this._startSearch(this.focusNode.value.replace(/([\\\*\?])/g, "\\$1"));
		},

		_getQueryString: function(/*String*/ text){
			return dojo.string.substitute(this.queryExpr, [text]);
		},

		_startSearch: function(/*String*/ key){
			// summary:
			//		Starts a search for elements matching key (key=="" means to return all items),
			//		and calls _openResultList() when the search completes, to display the results.
			if(!this.dropDown){
				var popupId = this.id + "_popup",
				dropDownConstructor = dojo.getObject(this.dropDownClass, false);
				this.dropDown = new dropDownConstructor({
					onChange: dojo.hitch(this, this._selectOption),
					id: popupId,
					dir: this.dir
				});
				dijit.removeWaiState(this.focusNode,"activedescendant");
				dijit.setWaiState(this.textbox,"owns",popupId); // associate popup with textbox
			}
			// create a new query to prevent accidentally querying for a hidden
			// value from FilteringSelect's keyField
			var query = dojo.clone(this.query); // #5970
			this._lastInput = key; // Store exactly what was entered by the user.
			this._lastQuery = query[this.searchAttr] = this._getQueryString(key);
			// #5970: set _lastQuery, *then* start the timeout
			// otherwise, if the user types and the last query returns before the timeout,
			// _lastQuery won't be set and their input gets rewritten
			this.searchTimer=setTimeout(dojo.hitch(this, function(query, _this){
				this.searchTimer = null;
				var fetch = {
					queryOptions: {
						ignoreCase: this.ignoreCase,
						deep: true
					},
					query: query,
					onBegin: dojo.hitch(this, "_setMaxOptions"),
					onComplete: dojo.hitch(this, "_openResultList"),
					onError: function(errText){
						_this._fetchHandle = null;
						console.error('dijit.form.ComboBox: ' + errText);
						_this.closeDropDown();
					},
					start: 0,
					count: this.pageSize
				};
				dojo.mixin(fetch, _this.fetchProperties);
				this._fetchHandle = _this.store.fetch(fetch);

				var nextSearch = function(dataObject, direction){
					dataObject.start += dataObject.count*direction;
					// #4091:
					//		tell callback the direction of the paging so the screen
					//		reader knows which menu option to shout
					dataObject.direction = direction;
					this._fetchHandle = this.store.fetch(dataObject);
					this.focus();
				};
				this._nextSearch = this.dropDown.onPage = dojo.hitch(this, nextSearch, this._fetchHandle);
			}, query, this), this.searchDelay);
		},

		_setMaxOptions: function(size, request){
			 this._maxOptions = size;
		},

		_getValueField: function(){
			// summary:
			//		Helper for postMixInProperties() to set this.value based on data inlined into the markup.
			//		Returns the attribute name in the item (in dijit.form._ComboBoxDataStore) to use as the value.
			return this.searchAttr;
		},

		//////////// INITIALIZATION METHODS ///////////////////////////////////////

		constructor: function(){
			this.query={};
			this.fetchProperties={};
		},

		postMixInProperties: function(){
			if(!this.store){
				var srcNodeRef = this.srcNodeRef;

				// if user didn't specify store, then assume there are option tags
				this.store = new dijit.form._ComboBoxDataStore(srcNodeRef);

				// if there is no value set and there is an option list, set
				// the value to the first value to be consistent with native
				// Select

				// Firefox and Safari set value
				// IE6 and Opera set selectedIndex, which is automatically set
				// by the selected attribute of an option tag
				// IE6 does not set value, Opera sets value = selectedIndex
				if(!("value" in this.params)){
					var item = (this.item = this.store.fetchSelectedItem());
					if(item){
						var valueField = this._getValueField();
						this.value = this.store.getValue(item, valueField);
					}
				}
			}

			this.inherited(arguments);
		},

		postCreate: function(){
			// summary:
			//		Subclasses must call this method from their postCreate() methods
			// tags:
			//		protected

			// find any associated label element and add to ComboBox node.
			var label=dojo.query('label[for="'+this.id+'"]');
			if(label.length){
				label[0].id = (this.id+"_label");
				dijit.setWaiState(this.domNode, "labelledby", label[0].id);

			}
			this.inherited(arguments);
		},

		_setHasDownArrowAttr: function(val){
			this.hasDownArrow = val;
			this._buttonNode.style.display = val ? "" : "none";
		},

		_getMenuLabelFromItem: function(/*Item*/ item){
			var label = this.labelFunc(item, this.store),
				labelType = this.labelType;
			// If labelType is not "text" we don't want to screw any markup ot whatever.
			if(this.highlightMatch != "none" && this.labelType == "text" && this._lastInput){
				label = this.doHighlight(label, this._escapeHtml(this._lastInput));
				labelType = "html";
			}
			return {html: labelType == "html", label: label};
		},

		doHighlight: function(/*String*/ label, /*String*/ find){
			// summary:
			//		Highlights the string entered by the user in the menu.  By default this
			//		highlights the first occurrence found. Override this method
			//		to implement your custom highlighting.
			// tags:
			//		protected

			var
				// Add (g)lobal modifier when this.highlightMatch == "all" and (i)gnorecase when this.ignoreCase == true
				modifiers = (this.ignoreCase ? "i" : "") + (this.highlightMatch == "all" ? "g" : ""),
				i = this.queryExpr.indexOf("${0}");
			find = dojo.regexp.escapeString(find); // escape regexp special chars
			return this._escapeHtml(label).replace(
				// prepend ^ when this.queryExpr == "${0}*" and append $ when this.queryExpr == "*${0}"
				new RegExp((i == 0 ? "^" : "") + "("+ find +")" + (i == (this.queryExpr.length - 4) ? "$" : ""), modifiers),
				'<span class="dijitComboBoxHighlightMatch">$1</span>'
			); // returns String, (almost) valid HTML (entities encoded)
		},

		_escapeHtml: function(/*String*/ str){
			// TODO Should become dojo.html.entities(), when exists use instead
			// summary:
			//		Adds escape sequences for special characters in XML: &<>"'
			str = String(str).replace(/&/gm, "&amp;").replace(/</gm, "&lt;")
				.replace(/>/gm, "&gt;").replace(/"/gm, "&quot;");
			return str; // string
		},

		reset: function(){
			// Overrides the _FormWidget.reset().
			// Additionally reset the .item (to clean up).
			this.item = null;
			this.inherited(arguments);
		},

		labelFunc: function(/*item*/ item, /*dojo.data.store*/ store){
			// summary:
			//		Computes the label to display based on the dojo.data store item.
			// returns:
			//		The label that the ComboBox should display
			// tags:
			//		private

			// Use toString() because XMLStore returns an XMLItem whereas this
			// method is expected to return a String (#9354)
			return store.getValue(item, this.labelAttr || this.searchAttr).toString(); // String
		}
	}
);

dojo.declare(
	"dijit.form._ComboBoxMenu",
	[dijit._Widget, dijit._Templated, dijit._CssStateMixin],
	{
		// summary:
		//		Focus-less menu for internal use in `dijit.form.ComboBox`
		// tags:
		//		private

		templateString: "<ul class='dijitReset dijitMenu' dojoAttachEvent='onmousedown:_onMouseDown,onmouseup:_onMouseUp,onmouseover:_onMouseOver,onmouseout:_onMouseOut' style='overflow: \"auto\"; overflow-x: \"hidden\";'>"
				+"<li class='dijitMenuItem dijitMenuPreviousButton' dojoAttachPoint='previousButton' role='option'></li>"
				+"<li class='dijitMenuItem dijitMenuNextButton' dojoAttachPoint='nextButton' role='option'></li>"
			+"</ul>",

		// _messages: Object
		//		Holds "next" and "previous" text for paging buttons on drop down
		_messages: null,
		
		baseClass: "dijitComboBoxMenu",

		postMixInProperties: function(){
			this.inherited(arguments);
			this._messages = dojo.i18n.getLocalization("dijit.form", "ComboBox", this.lang);
		},

		buildRendering: function(){
			this.inherited(arguments);

			// fill in template with i18n messages
			this.previousButton.innerHTML = this._messages["previousMessage"];
			this.nextButton.innerHTML = this._messages["nextMessage"];
		},

		_setValueAttr: function(/*Object*/ value){
			this.value = value;
			this.onChange(value);
		},

		// stubs
		onChange: function(/*Object*/ value){
			// summary:
			//		Notifies ComboBox/FilteringSelect that user clicked an option in the drop down menu.
			//		Probably should be called onSelect.
			// tags:
			//		callback
		},
		onPage: function(/*Number*/ direction){
			// summary:
			//		Notifies ComboBox/FilteringSelect that user clicked to advance to next/previous page.
			// tags:
			//		callback
		},

		onClose: function(){
			// summary:
			//		Callback from dijit.popup code to this widget, notifying it that it closed
			// tags:
			//		private
			this._blurOptionNode();
		},

		_createOption: function(/*Object*/ item, labelFunc){
			// summary:
			//		Creates an option to appear on the popup menu subclassed by
			//		`dijit.form.FilteringSelect`.

			var menuitem = dojo.create("li", {
				"class": "dijitReset dijitMenuItem" +(this.isLeftToRight() ? "" : " dijitMenuItemRtl"),
				role: "option"
			});
			var labelObject = labelFunc(item);
			if(labelObject.html){
				menuitem.innerHTML = labelObject.label;
			}else{
				menuitem.appendChild(
					dojo.doc.createTextNode(labelObject.label)
				);
			}
			// #3250: in blank options, assign a normal height
			if(menuitem.innerHTML == ""){
				menuitem.innerHTML = "&nbsp;";
			}
			menuitem.item=item;
			return menuitem;
		},

		createOptions: function(results, dataObject, labelFunc){
			// summary:
			//		Fills in the items in the drop down list
			// results:
			//		Array of dojo.data items
			// dataObject:
			//		dojo.data store
			// labelFunc:
			//		Function to produce a label in the drop down list from a dojo.data item

			//this._dataObject=dataObject;
			//this._dataObject.onComplete=dojo.hitch(comboBox, comboBox._openResultList);
			// display "Previous . . ." button
			this.previousButton.style.display = (dataObject.start == 0) ? "none" : "";
			dojo.attr(this.previousButton, "id", this.id + "_prev");
			// create options using _createOption function defined by parent
			// ComboBox (or FilteringSelect) class
			// #2309:
			//		iterate over cache nondestructively
			dojo.forEach(results, function(item, i){
				var menuitem = this._createOption(item, labelFunc);
				dojo.attr(menuitem, "id", this.id + i);
				this.domNode.insertBefore(menuitem, this.nextButton);
			}, this);
			// display "Next . . ." button
			var displayMore = false;
			//Try to determine if we should show 'more'...
			if(dataObject._maxOptions && dataObject._maxOptions != -1){
				if((dataObject.start + dataObject.count) < dataObject._maxOptions){
					displayMore = true;
				}else if((dataObject.start + dataObject.count) > dataObject._maxOptions && dataObject.count == results.length){
					//Weird return from a datastore, where a start + count > maxOptions
					// implies maxOptions isn't really valid and we have to go into faking it.
					//And more or less assume more if count == results.length
					displayMore = true;
				}
			}else if(dataObject.count == results.length){
				//Don't know the size, so we do the best we can based off count alone.
				//So, if we have an exact match to count, assume more.
				displayMore = true;
			}

			this.nextButton.style.display = displayMore ? "" : "none";
			dojo.attr(this.nextButton,"id", this.id + "_next");
			return this.domNode.childNodes;
		},

		clearResultList: function(){
			// summary:
			//		Clears the entries in the drop down list, but of course keeps the previous and next buttons.
			while(this.domNode.childNodes.length>2){
				this.domNode.removeChild(this.domNode.childNodes[this.domNode.childNodes.length-2]);
			}
			this._blurOptionNode();
		},

		_onMouseDown: function(/*Event*/ evt){
			dojo.stopEvent(evt);
		},

		_onMouseUp: function(/*Event*/ evt){
			if(evt.target === this.domNode || !this._highlighted_option){
				// !this._highlighted_option check to prevent immediate selection when menu appears on top
				// of <input>, see #9898.  Note that _HasDropDown also has code to prevent this.
				return;
			}else if(evt.target == this.previousButton){
				this._blurOptionNode();
				this.onPage(-1);
			}else if(evt.target == this.nextButton){
				this._blurOptionNode();
				this.onPage(1);
			}else{
				var tgt = evt.target;
				// while the clicked node is inside the div
				while(!tgt.item){
					// recurse to the top
					tgt = tgt.parentNode;
				}
				this._setValueAttr({ target: tgt }, true);
			}
		},

		_onMouseOver: function(/*Event*/ evt){
			if(evt.target === this.domNode){ return; }
			var tgt = evt.target;
			if(!(tgt == this.previousButton || tgt == this.nextButton)){
				// while the clicked node is inside the div
				while(!tgt.item){
					// recurse to the top
					tgt = tgt.parentNode;
				}
			}
			this._focusOptionNode(tgt);
		},

		_onMouseOut: function(/*Event*/ evt){
			if(evt.target === this.domNode){ return; }
			this._blurOptionNode();
		},

		_focusOptionNode: function(/*DomNode*/ node){
			// summary:
			//		Does the actual highlight.
			if(this._highlighted_option != node){
				this._blurOptionNode();
				this._highlighted_option = node;
				dojo.addClass(this._highlighted_option, "dijitMenuItemSelected");
			}
		},

		_blurOptionNode: function(){
			// summary:
			//		Removes highlight on highlighted option.
			if(this._highlighted_option){
				dojo.removeClass(this._highlighted_option, "dijitMenuItemSelected");
				this._highlighted_option = null;
			}
		},

		_highlightNextOption: function(){
			// summary:
			// 		Highlight the item just below the current selection.
			// 		If nothing selected, highlight first option.

			// because each press of a button clears the menu,
			// the highlighted option sometimes becomes detached from the menu!
			// test to see if the option has a parent to see if this is the case.
			if(!this.getHighlightedOption()){
				var fc = this.domNode.firstChild;
				this._focusOptionNode(fc.style.display == "none" ? fc.nextSibling : fc);
			}else{
				var ns = this._highlighted_option.nextSibling;
				if(ns && ns.style.display != "none"){
					this._focusOptionNode(ns);
				}else{
					this.highlightFirstOption();
				}
			}
			// scrollIntoView is called outside of _focusOptionNode because in IE putting it inside causes the menu to scroll up on mouseover
			dojo.window.scrollIntoView(this._highlighted_option);
		},

		highlightFirstOption: function(){
			// summary:
			// 		Highlight the first real item in the list (not Previous Choices).
			var first = this.domNode.firstChild;
			var second = first.nextSibling;
			this._focusOptionNode(second.style.display == "none" ? first : second); // remotely possible that Previous Choices is the only thing in the list
			dojo.window.scrollIntoView(this._highlighted_option);
		},

		highlightLastOption: function(){
			// summary:
			// 		Highlight the last real item in the list (not More Choices).
			this._focusOptionNode(this.domNode.lastChild.previousSibling);
			dojo.window.scrollIntoView(this._highlighted_option);
		},

		_highlightPrevOption: function(){
			// summary:
			// 		Highlight the item just above the current selection.
			// 		If nothing selected, highlight last option (if
			// 		you select Previous and try to keep scrolling up the list).
			if(!this.getHighlightedOption()){
				var lc = this.domNode.lastChild;
				this._focusOptionNode(lc.style.display == "none" ? lc.previousSibling : lc);
			}else{
				var ps = this._highlighted_option.previousSibling;
				if(ps && ps.style.display != "none"){
					this._focusOptionNode(ps);
				}else{
					this.highlightLastOption();
				}
			}
			dojo.window.scrollIntoView(this._highlighted_option);
		},

		_page: function(/*Boolean*/ up){
			// summary:
			//		Handles page-up and page-down keypresses

			var scrollamount = 0;
			var oldscroll = this.domNode.scrollTop;
			var height = dojo.style(this.domNode, "height");
			// if no item is highlighted, highlight the first option
			if(!this.getHighlightedOption()){
				this._highlightNextOption();
			}
			while(scrollamount<height){
				if(up){
					// stop at option 1
					if(!this.getHighlightedOption().previousSibling ||
						this._highlighted_option.previousSibling.style.display == "none"){
						break;
					}
					this._highlightPrevOption();
				}else{
					// stop at last option
					if(!this.getHighlightedOption().nextSibling ||
						this._highlighted_option.nextSibling.style.display == "none"){
						break;
					}
					this._highlightNextOption();
				}
				// going backwards
				var newscroll=this.domNode.scrollTop;
				scrollamount+=(newscroll-oldscroll)*(up ? -1:1);
				oldscroll=newscroll;
			}
		},

		pageUp: function(){
			// summary:
			//		Handles pageup keypress.
			//		TODO: just call _page directly from handleKey().
			// tags:
			//		private
			this._page(true);
		},

		pageDown: function(){
			// summary:
			//		Handles pagedown keypress.
			//		TODO: just call _page directly from handleKey().
			// tags:
			//		private
			this._page(false);
		},

		getHighlightedOption: function(){
			// summary:
			//		Returns the highlighted option.
			var ho = this._highlighted_option;
			return (ho && ho.parentNode) ? ho : null;
		},

		handleKey: function(evt){
			// summary:
			//		Handle keystroke event forwarded from ComboBox, returning false if it's
			//		a keystroke I recognize and process, true otherwise.
			switch(evt.charOrCode){
				case dojo.keys.DOWN_ARROW:
					this._highlightNextOption();
					return false;
				case dojo.keys.PAGE_DOWN:
					this.pageDown();
					return false;
				case dojo.keys.UP_ARROW:
					this._highlightPrevOption();
					return false;
				case dojo.keys.PAGE_UP:
					this.pageUp();
					return false;
				default:
					return true;
			}
		}
	}
);

dojo.declare(
	"dijit.form.ComboBox",
	[dijit.form.ValidationTextBox, dijit.form.ComboBoxMixin],
	{
		// summary:
		//		Auto-completing text box, and base class for dijit.form.FilteringSelect.
		//
		// description:
		//		The drop down box's values are populated from an class called
		//		a data provider, which returns a list of values based on the characters
		//		that the user has typed into the input box.
		//		If OPTION tags are used as the data provider via markup,
		//		then the OPTION tag's child text node is used as the widget value
		//		when selected.  The OPTION tag's value attribute is ignored.
		//		To set the default value when using OPTION tags, specify the selected
		//		attribute on 1 of the child OPTION tags.
		//
		//		Some of the options to the ComboBox are actually arguments to the data
		//		provider.

		_setValueAttr: function(/*String*/ value, /*Boolean?*/ priorityChange, /*String?*/ displayedValue){
			// summary:
			//		Hook so set('value', value) works.
			// description:
			//		Sets the value of the select.
			this._set("item", null); // value not looked up in store
			if(!value){ value = ''; } // null translates to blank
			dijit.form.ValidationTextBox.prototype._setValueAttr.call(this, value, priorityChange, displayedValue);
		}
	}
);

dojo.declare("dijit.form._ComboBoxDataStore", null, {
	// summary:
	//		Inefficient but small data store specialized for inlined `dijit.form.ComboBox` data
	//
	// description:
	//		Provides a store for inlined data like:
	//
	//	|	<select>
	//	|		<option value="AL">Alabama</option>
	//	|		...
	//
	//		Actually. just implements the subset of dojo.data.Read/Notification
	//		needed for ComboBox and FilteringSelect to work.
	//
	//		Note that an item is just a pointer to the <option> DomNode.

	constructor: function( /*DomNode*/ root){
		this.root = root;
		if(root.tagName != "SELECT" && root.firstChild){
			root = dojo.query("select", root);
			if(root.length > 0){ // SELECT is a child of srcNodeRef
				root = root[0];
			}else{ // no select, so create 1 to parent the option tags to define selectedIndex
				this.root.innerHTML = "<SELECT>"+this.root.innerHTML+"</SELECT>";
				root = this.root.firstChild;
			}
			this.root = root;
		}
		dojo.query("> option", root).forEach(function(node){
			//	TODO: this was added in #3858 but unclear why/if it's needed;  doesn't seem to be.
			//	If it is needed then can we just hide the select itself instead?
			//node.style.display="none";
			node.innerHTML = dojo.trim(node.innerHTML);
		});

	},

	getValue: function(	/*item*/ item,
						/*attribute-name-string*/ attribute,
						/*value?*/ defaultValue){
		return (attribute == "value") ? item.value : (item.innerText || item.textContent || '');
	},

	isItemLoaded: function(/*anything*/ something){
		return true;
	},

	getFeatures: function(){
		return {"dojo.data.api.Read": true, "dojo.data.api.Identity": true};
	},

	_fetchItems: function(	/*Object*/ args,
							/*Function*/ findCallback,
							/*Function*/ errorCallback){
		// summary:
		//		See dojo.data.util.simpleFetch.fetch()
		if(!args.query){ args.query = {}; }
		if(!args.query.name){ args.query.name = ""; }
		if(!args.queryOptions){ args.queryOptions = {}; }
		var matcher = dojo.data.util.filter.patternToRegExp(args.query.name, args.queryOptions.ignoreCase),
			items = dojo.query("> option", this.root).filter(function(option){
				return (option.innerText || option.textContent || '').match(matcher);
			} );
		if(args.sort){
			items.sort(dojo.data.util.sorter.createSortFunction(args.sort, this));
		}
		findCallback(items, args);
	},

	close: function(/*dojo.data.api.Request || args || null*/ request){
		return;
	},

	getLabel: function(/*item*/ item){
		return item.innerHTML;
	},

	getIdentity: function(/*item*/ item){
		return dojo.attr(item, "value");
	},

	fetchItemByIdentity: function(/*Object*/ args){
		// summary:
		//		Given the identity of an item, this method returns the item that has
		//		that identity through the onItem callback.
		//		Refer to dojo.data.api.Identity.fetchItemByIdentity() for more details.
		//
		// description:
		//		Given arguments like:
		//
		//	|		{identity: "CA", onItem: function(item){...}
		//
		//		Call `onItem()` with the DOM node `<option value="CA">California</option>`
		var item = dojo.query("> option[value='" + args.identity + "']", this.root)[0];
		args.onItem(item);
	},

	fetchSelectedItem: function(){
		// summary:
		//		Get the option marked as selected, like `<option selected>`.
		//		Not part of dojo.data API.
		var root = this.root,
			si = root.selectedIndex;
		return typeof si == "number"
			? dojo.query("> option:nth-child(" + (si != -1 ? si+1 : 1) + ")", root)[0]
			: null;	// dojo.data.Item
	}
});
//Mix in the simple fetch implementation to this class.
dojo.extend(dijit.form._ComboBoxDataStore,dojo.data.util.simpleFetch);

}

if(!dojo._hasResource["plugins.dnd.Avatar"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.dnd.Avatar"] = true;
dojo.provide("plugins.dnd.Avatar");



dojo.declare("plugins.dnd.Avatar", [dojo.dnd.Avatar], {
	// summary:
	//		Object that represents transferred DnD items visually
	// manager: Object
	//		a DnD manager object

	// methods
	
	construct: function(){

		//console.log("plugins.dnd.Avatar.construct    this.manager.copy: " + this.manager.copy);
		//console.log("plugins.dnd.Avatar.construct    this.manager.nodes[0].data: " + dojo.toJson(this.manager.nodes[0].data));


		// summary:
		//		constructor function;
		//		it is separate so it can be (dynamically) overwritten in case of need

		var avatarType = '';
		if ( this.manager.nodes[0].data != null
			&& this.manager.nodes[0].data.avatarType != null )
			avatarType = this.manager.nodes[0].data.avatarType;

		this.isA11y = dojo.hasClass(dojo.body(),"dijit_a11y");
		var a = dojo.create("table", {
				"class": "dojoDndAvatar " + avatarType,
				style: {
					position: "absolute",
					zIndex:   "1999",
					margin:   "0px"
				}
			}),
			source = this.manager.source, node,
			b = dojo.create("tbody", null, a),

			// DISABLE HEADER AND NUMBER SINCE ONLY ONE ITEM DRAGGED AT A TIME
			//
			//tr = dojo.create("tr", null, b),
			//td = dojo.create("td", null, tr),

			//
			//icon = this.isA11y ? dojo.create("span", {
			//			id : "a11yIcon",
			//			innerHTML : this.manager.copy ? '+' : "<"
			//		}, td) : null,
			//span = dojo.create("span", {
			//	innerHTML: source.generateText ? this._generateText() : ""
			//}, td),

			k = Math.min(5, this.manager.nodes.length), i = 0;
		//
		//// we have to set the opacity on IE only after the node is live
		//dojo.attr(tr, {
		//	"class": "dojoDndAvatarHeader",
		//	style: {opacity: 0.9}
		//});
		
		
		for(; i < k; ++i){
			
			if(source.creator){

				// create an avatar representation of the node
				//try {
					node = source._normalizedCreator(source.getItem(this.manager.nodes[i].id).data, "avatar").node;
				//}
				//catch (err) {
					////console.log("dojo.dnd.Avatar    error with getItem(this.manager.nodes[" + i + "].id)");
					//// or just clone the node and hope it works
					//node = this.manager.nodes[i].cloneNode(true);
					//if(node.tagName.toLowerCase() == "tr"){
					//	// insert extra table nodes
					//	var table = dojo.create("table"),
					//		tbody = dojo.create("tbody", null, table);
					//	tbody.appendChild(node);
					//	node = table;
					//}
				//}
			}
			else
			{
				// or just clone the node and hope it works
				node = this.manager.nodes[i].cloneNode(true);
				if(node.tagName.toLowerCase() == "tr"){
					// insert extra table nodes
					var table = dojo.create("table"),
						tbody = dojo.create("tbody", null, table);
					tbody.appendChild(node);
					node = table;
				}
			}
			node.id = "";
			tr = dojo.create("tr", null, b);
			td = dojo.create("td", null, tr);
			td.appendChild(node);
			dojo.attr(tr, {
				"class": "dojoDndAvatarItem",
				style: {opacity: (9 - i) / 10}
			});
		}
		this.node = a;
	}
	
	//,
	//destroy : function ()
	//{
	//	//console.log("plugins.dnd.Avatar.destroy    DEBUG DO NOTHING");
	//}
	
	
});

}

if(!dojo._hasResource["plugins.dnd.Manager"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.dnd.Manager"] = true;
dojo.provide("plugins.dnd.Manager");






/////}}}



//dojo.provide("plugins.dnd.Manager");
//
// **** NB: MUST KEEP THESE FOR BUILD!!! ****
//
//
//
//
//
//
//dojo.declare("plugins.dnd.Manager", [ plugins.dnd.Avatar, plugins.core.Common ], {

/////}}}

	// summary:
	//		the manager of DnD operations (usually a singleton)
	

dojo.declare("plugins.dnd.Manager", null, {

/////}}}

	// summary:
	//		the manager of DnD operations (usually a singleton)
	
	cssFiles : [
		dojo.moduleUrl("plugins", "dnd/css/dnd.css")
	],
	
	constructor : function(){

		Agua.loadCSSFile(this.cssFiles[0]);

		this.avatar  = null;
		this.source = null;
		this.nodes = [];
		this.copy  = true;
		this.target = null;
		this.canDropFlag = false;
		this.events = [];
	},

	// avatar's offset from the mouse
	OFFSET_X: 16,
	OFFSET_Y: 16,
	
	// methods
	overSource: function(source){
		// summary:
		//		called when a source detected a mouse-over condition
		// source: Object
		//		the reporter
		if(this.avatar){
			
			//console.log("plugins.dnd.Manager.oversource");
			
			this.target = (source && source.targetState != "Disabled") ? source : null;
			this.canDropFlag = Boolean(this.target);
			this.avatar.update();
		}
		dojo.publish("/dnd/source/over", [source]);
	},
	outSource: function(source){
		// summary:
		//		called when a source detected a mouse-out condition
		// source: Object
		//		the reporter
		if(this.avatar){
			if(this.target == source){
				this.target = null;
				this.canDropFlag = false;
				this.avatar.update();
				dojo.publish("/dnd/source/over", [null]);
			}
		}else{
			dojo.publish("/dnd/source/over", [null]);
		}
	},
	startDrag: function(source, nodes, copy){
		// summary:
		//		called to initiate the DnD operation
		// source: Object
		//		the source which provides items
		// nodes: Array
		//		the list of transferred items
		// copy: Boolean
		//		copy items, if true, move items otherwise
		this.source = source;
		this.nodes  = nodes;
		this.copy   = Boolean(copy); // normalizing to true boolean
		this.avatar = this.makeAvatar();
		dojo.body().appendChild(this.avatar.node);
		dojo.publish("/dnd/start", [source, nodes, this.copy]);
		this.events = [
			dojo.connect(dojo.doc, "onmousemove", this, "onMouseMove"),
			dojo.connect(dojo.doc, "onmouseup",   this, "onMouseUp"),
			dojo.connect(dojo.doc, "onkeydown",   this, "onKeyDown"),
			dojo.connect(dojo.doc, "onkeyup",     this, "onKeyUp"),
			// cancel text selection and text dragging
			dojo.connect(dojo.doc, "ondragstart",   dojo.stopEvent),
			dojo.connect(dojo.body(), "onselectstart", dojo.stopEvent)
		];
		var c = "dojoDnd" + (copy ? "Copy" : "Move");
		dojo.addClass(dojo.body(), c);
	},
	canDrop: function(flag){
		// summary:
		//		called to notify if the current target can accept items
		var canDropFlag = Boolean(this.target && flag);
		if(this.canDropFlag != canDropFlag){
			this.canDropFlag = canDropFlag;
			this.avatar.update();
		}
	},
	stopDrag: function(){
		// summary:
		//		stop the DnD in progress
		dojo.removeClass(dojo.body(), ["dojoDndCopy", "dojoDndMove"]);
		dojo.forEach(this.events, dojo.disconnect);
		this.events = [];
		this.avatar.destroy();
		this.avatar = null;
		this.source = this.target = null;
		this.nodes = [];
	},
	makeAvatar: function(){
		// summary:
		//		makes the avatar; it is separate to be overwritten dynamically, if needed

		//console.log("plugins.dnd.Manager.makeAvatar()");
		//console.log("plugins.dnd.Manager.makeAvatar this:");
		//console.dir(this);
		
		return new plugins.dnd.Avatar(this);
	},
	updateAvatar: function(){
		// summary:
		//		updates the avatar; it is separate to be overwritten dynamically, if needed
		this.avatar.update();
	},
	
	// mouse event processors
	onMouseMove: function(e){
		// summary:
		//		event processor for onmousemove
		// e: Event
		//		mouse event
		var a = this.avatar;
		if(a){
			dojo.dnd.autoScrollNodes(e);
			//dojo.dnd.autoScroll(e);
			var s = a.node.style;
			s.left = (e.pageX + this.OFFSET_X) + "px";
			s.top  = (e.pageY + this.OFFSET_Y) + "px";
			var copy = Boolean(this.source.copyState(dojo.isCopyKey(e)));
			if(this.copy != copy){
				this._setCopyStatus(copy);
			}
		}
	},
	onMouseUp: function(e){
		// summary:
		//		event processor for onmouseup
		// e: Event
		//		mouse event
		if(this.avatar){
			if(this.target && this.canDropFlag){
				var copy = Boolean(this.source.copyState(dojo.isCopyKey(e))),
				params = [this.source, this.nodes, copy, this.target, e];
				dojo.publish("/dnd/drop/before", params);
				dojo.publish("/dnd/drop", params);
			}else{
				dojo.publish("/dnd/cancel");
			}
			this.stopDrag();
		}
	},
	
	// keyboard event processors
	onKeyDown: function(e){
		// summary:
		//		event processor for onkeydown:
		//		watching for CTRL for copy/move status, watching for ESCAPE to cancel the drag
		// e: Event
		//		keyboard event
		if(this.avatar){
			switch(e.keyCode){
				case dojo.keys.CTRL:
					var copy = Boolean(this.source.copyState(true));
					if(this.copy != copy){
						this._setCopyStatus(copy);
					}
					break;
				case dojo.keys.ESCAPE:
					dojo.publish("/dnd/cancel");
					this.stopDrag();
					break;
			}
		}
	},
	onKeyUp: function(e){
		// summary:
		//		event processor for onkeyup, watching for CTRL for copy/move status
		// e: Event
		//		keyboard event
		if(this.avatar && e.keyCode == dojo.keys.CTRL){
			var copy = Boolean(this.source.copyState(false));
			if(this.copy != copy){
				this._setCopyStatus(copy);
			}
		}
	},
	
	// utilities
	_setCopyStatus: function(copy){
		// summary:
		//		changes the copy status
		// copy: Boolean
		//		the copy status
		this.copy = copy;
		this.source._markDndStatus(this.copy);
		this.updateAvatar();
		dojo.replaceClass(dojo.body(),
			"dojoDnd" + (this.copy ? "Copy" : "Move"),
			"dojoDnd" + (this.copy ? "Move" : "Copy"));
	}
});

// dojo.dnd._manager:
//		The manager singleton variable. Can be overwritten if needed.
dojo.dnd._manager = null;

dojo.dnd.manager = function(){
	// summary:
	//		Returns the current DnD manager.  Creates one if it is not created yet.
	if(!dojo.dnd._manager){
		dojo.dnd._manager = new plugins.dnd.Manager();
	}
	return dojo.dnd._manager;	// Object
};

}

if(!dojo._hasResource["plugins.dnd.Source"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.dnd.Source"] = true;
dojo.provide("plugins.dnd.Source");




dojo.declare("plugins.dnd.Source", [dojo.dnd.Selector, plugins.dnd.Manager], {

/////}}}
	// summary:
	//		a Source object, which can be used as a DnD source, or a DnD target
	
	// object attributes (for markup)
	isSource: true,
	horizontal: false,
	copyOnly: false,
	selfCopy: false,
	selfAccept: true,
	skipForm: false,
	withHandles: false,
	autoSync: false,
	delay: 0, // pixels
	accept: ["text"],
	generateText: true,

	creator : function (item, hint) {
		//console.log("DndSource.setDragSourceCreator     plugins.dnd.Source");
		////console.log("DndSource.setDragSourceCreator     this.dragSourceWidget.creator    item: " + dojo.toJson(item, true));
		////console.log("DndSource.setDragSourceCreator     this.dragSourceWidget.creator    thisObject.formInputs: " + dojo.toJson(thisObject.formInputs));
		////console.log("DndSource.setDragSourceCreator     this.dragSourceWidget.creator    thisObject.avatarItems: " + dojo.toJson(thisObject.avatarItems));

		var data = item.data;

		var node = dojo.doc.createElement("div");
		node.id = dojo.dnd.getUniqueId();
		node.className = "dojoDndItem";
		node.data = new Object;
		for ( name in thisObject.formInputs )
		{
			node.data[name] = item[name];
		}

		// SET FANCY FORMAT IN NODE INNERHTML
		var avatarHtml = "<table>";
		var title = true;
		for ( var i = 0; i < thisObject.avatarItems.length; i++ )
		{
		//dojo.forEach(thisObject.avatarItems, function (name) {
			var name = thisObject.avatarItems[i];
			////console.log("DndSource.setDragSourceCreator     this.dragSourceWidget.creator    name: " + name);
			if ( title == true )
			{
				avatarHtml += "<tr><td><strong style='color: darkred'>";
				avatarHtml += data[name] + "</strong></td></tr>";
			}
			else
			{
				avatarHtml += "<tr><td>";
				avatarHtml += data[name] + "</td></tr>";
			}
		}
		//});
		avatarHtml += "</table>";
		////console.log("DndSource.setDragSourceCreator     this.dragSourceWidget.creator    avatarHtml: " + avatarHtml);
		node.innerHTML = avatarHtml;

		return {node: node, data: item, type: ["draggableItem"]};
	},
	
	startup: function(){
		// summary:
		//		collects valid child items and populate the map
		
		// set up the real parent node
		if(!this.parent){
			// use the standard algorithm, if not assigned
			this.parent = this.node;
			
			console.log("plugins.dnd.Source.startup    plugins.dnd.Source.startup()");
			console.log("plugins.dnd.Source.startup    console.dir(this.parent):");
			console.dir({parent: this.parent});

			if ( this.parent.tagName != null ) {
				if(this.parent.tagName.toLowerCase() == "table"){
					var c = this.parent.getElementsByTagName("tbody");
					if(c && c.length){ this.parent = c[0]; }
				}
			}
		}
		this.defaultCreator = dojo.dnd._defaultCreator(this.parent);

		// process specially marked children
		this.sync();
	}
	
});


}

if(!dojo._hasResource["plugins.form.DndSource"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.form.DndSource"] = true;
dojo.provide("plugins.form.DndSource");

// PROVIDES FORM INPUT AND ROW EDITING WITH VALIDATION
// INHERITING CLASSES MUST IMPLEMENT saveInputs AND deleteItem METHODS
// THE dnd DRAG SOURCE MUST BE this.dragSourceWidget IF PRESENT

// EXTERNAL MODULES
//

// INTERNAL MODULES




dojo.declare("plugins.form.DndSource",
	[ ],
{
// NB: INHERITING CLASS MUST PROVIDE THE FOLLOWING 

// ROW CLASS
rowClass : null,

// AVATAR DISPLAYED DATA ITEMS
avatarItems : [],

// FORM INPUTS (DATA ITEMS TO BE ADDED TO ROWS)
formInputs : {},

// LOADED DND WIDGETS
childWidgets : [],

////}}}

constructor : function(args) {
	//console.log("DndSource.constructor     plugins.form.DndSource.constructor");	
},

postCreate : function() {
	//console.log("DndSource.postCreate    plugins.form.DndSource.postCreate()");
	this.startup();
},

startup : function () {
	//console.log("DndSource.startup    plugins.form.DndSource.startup()");
	this.initialiseDragSource();
	this.setDragSourceCreator();
},

initialiseDragSource : function (node) {
	//console.log("DndSource.initialiseDragSource    plugins.form.DndSource.initialiseDragSource()");
	//console.log("DndSource.initialiseDragSource    this.dragSourceNode: " + this.dragSourceNode);
	
	if ( node == null )
		node = this.dragSourceNode; 

	this.dragSource = new dojo.dnd.Source(
		node,
		{
			copyOnly: true,
			selfAccept: false,
			accept : [ "none" ]
		}
	);
	//console.log("DndSource.initialiseDragSource    AFTER this.dragSource = new dojo.dnd.Source");

},

setDragSourceCreator : function () {
// AVATAR CREATOR

	var thisObject = this;
	this.dragSource.creator = dojo.hitch(this.dragSource, function (item, hint)
	{
		//console.log("DndSource.setDragSourceCreator     this: " + this);
		//console.log("DndSource.setDragSourceCreator     this.dragSourceWidget.creator    item: " + dojo.toJson(item, true));
		//console.log("DndSource.setDragSourceCreator     this.dragSourceWidget.creator    thisObject.formInputs: " + dojo.toJson(thisObject.formInputs));
		//console.log("DndSource.setDragSourceCreator     this.dragSourceWidget.creator    thisObject.avatarItems: " + dojo.toJson(thisObject.avatarItems));

		var data = item.data;

		var node = dojo.doc.createElement("div");
		node.id = dojo.dnd.getUniqueId();
		node.className = "dojoDndItem";
		node.data = new Object;
		for ( name in thisObject.formInputs )
		{
			node.data[name] = item[name];
		}
		
		// SET FANCY FORMAT IN NODE INNERHTML
		var avatarHtml = "<table>";
		//var title = true;
		for ( var i = 0; i < thisObject.avatarItems.length; i++ )
		{
		//dojo.forEach(thisObject.avatarItems, function (name) {
			var name = thisObject.avatarItems[i];
			//console.log("DndSource.setDragSourceCreator     this.dragSourceWidget.creator    name: " + name);
			if ( i == 0 )
			{
				avatarHtml += "<tr><td class='dojoDndAvatarHeader'><strong style='color: darkred'>";
				avatarHtml += data[name] + "</strong></td></tr>";
			}
			else
			{
				avatarHtml += "<tr><td>";
				avatarHtml += data[name] + "</td></tr>";
			}
		}
		//});
		avatarHtml += "</table>";
		//console.log("DndSource.setDragSourceCreator     this.dragSourceWidget.creator    avatarHtml: " + avatarHtml);
		node.innerHTML = avatarHtml;

		return {node: node, data: item, type: ["draggableItem"]};
	});	
},

// DATA ITEMS FOR ROWS - INHERITING CLASS MUST OVERRIDE
getItemArray : function () {
	// GET A LIST OF DATA ITEMS - ONE FOR EACH ROW
},

clearDragSource : function () {
// DELETE EXISTING TABLE CONTENT

	//console.log("DndSource.clearDragSource     DndSource.clearDragSource()");
	//console.log("DndSource.clearDragSource     this.dragSource: " + this.dragSource);
	var nodes = this.dragSource.getAllNodes();
	//console.log("DndSource.clearDragSource     TO DELETE nodes: " + nodes);
	if ( nodes != null )
	{
		//console.log("DndSource.clearDragSource     TO DELETE nodes.length: " + nodes.length);
		for ( var i = 0; i < nodes.length; i++ )
		{
			var node = nodes[i];
			//console.log("DndSource.clearDragSource     DELETING node.id: " + node.id);
			var item = this.dragSource.getItem(node.id);
			//console.log("DndSource.clearDragSource     DELETING node.id: " + node.id);
			this.dragSource.delItem(item);
			dojo.destroy(node);
		}

	}

	if ( this.childWidgets.length != 0 )
	for ( var i = 0; i < this.childWidgets.length; i++ )
	{
		dojo.destroy(this.childWidgets[i]);
	}

	this.childWidgets = [];
},

// NB: INHERITING CLASS MUST HAVE this.dragSource
setDragSource : function () {
	//console.log("DndSource.setDragSource     plugins.form.DndSource.setDragSource()");

	// GENERATE DND GROUP
	if ( this.dragSource == null ) {
		this.initialiseDragSource();
		this.setDragSourceCreator();
	}

	// DELETE EXISTING CONTENT
	this.clearDragSource();
	
	nodes = this.dragSource.getAllNodes();
	//console.log("DndSource.setDragSource     AFTER DELETE nodes.length: " + nodes.length);
	//console.log("DndSource.setDragSource     this.dragSource: " + this.dragSource);
	//console.log("DndSource.setDragSource     this.dragSource.map: ");
	for ( var id in this.dragSource.map )
	{
		//console.log("DndSource.setDragSource     this.dragSource.map    id: " + id);
	}

	var itemArray = this.getItemArray();
	//console.log("DndSource.setDragSource     itemArray.length: " + dojo.toJson(itemArray.length));
	//console.log("DndSource.setDragSource     itemArray: " + dojo.toJson(itemArray));
	
	this.loadDragItems(itemArray);
},

loadDragItems : function (itemArray, dragSourceNode) {
	//console.log("DndSource.loadDragItems     itemArray: ");
	//console.dir({itemArray:itemArray});
	//console.log("DndSource.loadDragItems     itemArray.length: " + itemArray.length);

	// SET FLAG TO ABSORB EXTRANEOUS ONCHANGE FIRE
	this.dragSourceOnchange = false;

	// CHECK itemArray IS NOT NULL OR EMPTY
	if ( itemArray == null || itemArray.length == 0 )	return;

	// GENERATE dataArray TO INSERT INTO DND GROUP TABLE
	var dataArray = new Array;
	for ( var j = 0; j < itemArray.length; j++ )
	{
		var data = itemArray[j];				
		dataArray.push( { data: data, type: ["draggableItem"] } );
	}
	//console.log("DndSource.loadDragItems     dataArray.length: " + dataArray.length);	

	// INSERT NODES
	this.dragSource.insertNodes(false, dataArray);
	//console.log("DndSource.setDragSource     this.dragSource: ");
	//console.dir({this_dragSource: this.dragSource});
	
	// SET TABLE ROW STYLE IN dojDndItems
	var allNodes = this.dragSource.getAllNodes();
	//console.log("DndSource.loadDragItems     allNodes.length: " + allNodes.length);
	for ( var k = 0; k < allNodes.length; k++ )
	{
		// SET NODE DATA
		var node = allNodes[k];
		node.data = dataArray[k].data;
		//console.log("DndSource.loadDragItems     dataArray[" + k + "].data: " + dojo.toJson( dataArray[k].data));
	
		// SET AVATAR TYPE
		if ( this.avatarType !== null ) {
			node.data.avatarType = this.avatarType;
		}
		// SET ITEM OBJECT
		var itemObject = new Object;
		for ( name in this.formInputs )
		{
			//console.log("DndSource.loadDragItems     itemObject[" + name + "] = " + dataArray[k].data[name]);
			////itemObject[name] = node[name];
			itemObject[name] = dataArray[k].data[name];
		}
		//console.log("DndSource.loadDragItems     itemObject: ");
		//console.dir({itemObject:itemObject});
		itemObject.parentWidget = this;

	
		// CREATE ROW
		var rowClass = this.rowClass;
		var module = dojo.getObject(rowClass);
		
		var itemObjectRow = new module(itemObject);
		this.childWidgets.push(itemObjectRow);
		node.innerHTML = '';
		node.appendChild(itemObjectRow.domNode);
	
		// ADD CONTEXT MENU
		if ( this.contextMenu != null ) this.contextMenu.bind(node);
	}

}

}); // plugins.form.DndSource


}

if(!dojo._hasResource["plugins.form.EditRow"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.form.EditRow"] = true;
dojo.provide("plugins.form.EditRow");

// PROVIDES FORM INPUT AND ROW EDITING WITH VALIDATION
// INHERITING CLASSES MUST IMPLEMENT saveInputs AND deleteItem METHODS
// THE dnd DRAG SOURCE MUST BE this.dragSourceWidget IF PRESENT
/*
	EDIT ROW FUNCTIONALITY:
	
		1. SAVE IF 'RETURN' PRESSED,
	
		2. EXIT WITHOUT CHANGES IF 'ESCAPE' PRESSED
	
	CONVERSION OF BACKSLASHES:
		
		1. EVERY '\' VISIBLE IN HTML IS ACTUALLY '\\'
		
		2. THIS '\\' DISPLAYS AS A '\' WHEN INSERTED INTO THE TEXTAREA

		3. CONVERT INTO A '\\\\' IN THE MYSQL INSERT COMMAND

*/


// EXTERNAL MODULES


// INTERNAL MODULES


dojo.declare("plugins.form.EditRow",
	[ plugins.core.Common ],
{

// ROW EDITING STATE
editingRow : false,

// WIDGET OWNING EDITED NODE
rowWidget : null,

// EDITED NODE
node : null,

////}}}

constructor : function(args) {
	////console.log("EditRow.constructor     plugins.form.EditRow.constructor");	

	this.setTextarea();
	this.setEventHandlers();
},

postCreate : function() {
	////console.log("EditRow.postCreate    ");
	this.startup();
},

startup : function () {
	////console.log("EditRow.startup    plugins.form.EditRow.startup()");
},

setTextarea : function () {
	////console.log("EditRow.setTextarea    plugins.form.EditRow.setTextarea()");
	this.textarea = document.createElement('textarea');
	dojo.addClass(this.textarea, 'editRow');
	dojo.attr(this.textarea, 'style', 'visibility: hidden');	
},

setEventHandlers : function () {
// SET onkeypress AND onblur LISTENERS
	////console.log("EditRow.setEventHandlers    plugins.form.EditRow.setEventHandlers()");
	dojo.connect(this.textarea, "onblur", dojo.hitch(this, "handleOnBlur"));
	////console.log("EditRow.setEventHandlers    plugins.form.EditRow.setEventHandlers()");
	dojo.connect(this.textarea, "onkeypress", dojo.hitch(this, "handleOnKeyPress"));
},

editRow : function (rowWidget, node) {
	////console.log("EditRow.editRow    plugins.form.EditRow.editRow(rowWidget, node)");
	////console.log("EditRow.editRow    rowWidget: " + rowWidget);	
	////console.log("EditRow.editRow    this.editingRow: " + this.editingRow);

	// RETURN IF ALREADY EDITING PARAMETER ROW (I.E., MULTIPLE CLICKS)
	if ( this.editingRow == true ) return;

	// RETURN IF THIS IS A DOUBLE-CLICK
	this.originalText = node.innerHTML;
	if ( this.originalText == null || ! this.originalText ) this.originalText = '';
	if ( this.originalText.match(/^<i/) ||
		this.originalText.match(/^<br/) ||
		this.originalText.match(/^<fieldset/) ||
		this.originalText.match(/^<textarea/) )		return;

	// SET this VARIABLES
	this.rowWidget= rowWidget;
	this.node = node;
	
	this.editingRow = true;
	this.disableDrag();
	
	node.innerHTML = '';
	this.originalText = this.convertString(this.originalText, "htmlToText");
	this.textarea.value = this.originalText;
	////console.log("EditRow.editRow    Inserted into this.textarea this.originalText: " + dojo.toJson(this.originalText));
	////console.log("EditRow.editRow    New this.textarea.value: " + dojo.toJson(this.textarea.value));
	node.appendChild(this.textarea);
	dojo.attr(this.textarea, 'style', 'visibility: visible');
	this.textarea.focus();
},

handleOnKeyPress: function (event) {
	//////console.log("EditRow.handleOnKeyPress    plugins.form.EditRow.handleOnKeyPress(event)");
	//////console.log("EditRow.handleOnKeyPress    event: " + event);
	
	// summary: handles keyboard events
	var key = event.charOrCode;
	if ( key == null )	return;
	
	event.stopPropagation();
	//////console.log("EditRow.handleOnKeyPress    this.textarea.onkeypress	key: " + key);
	
	if ( key == dojo.keys.ESCAPE )	this.handleEscape();
	if ( key != 13 )	return;

	try {

		// GET NEW VALUE OF INPUT
		this.freshValue = this.convertAngleBrackets(this.textarea.value, "htmlToText");
		//this.freshValue = this.convertBackslash(this.freshValue, "textToHtml");
		////console.log("EditRow.handleOnKeyPress    this.freshValue: " + dojo.toJson(this.freshValue));

		// REMOVE TEXTAREA
		////console.log("EditRow.handleOnKeyPress    REMOVING TEXTAREA NODE");
		this.node.removeChild(this.textarea);
		this.node.focus();

		// SET NEW VALUE OF INPUT
		this.node.innerHTML = this.freshValue;
		////console.log("EditRow.handleOnKeyPress    Set this.node.innerHTML = this.freshValue: " + dojo.toJson(this.freshValue));

		// NOT EDITING ROW ANY MORE
		this.editingRow = false;

		// IF NEW INPUT VALUE IS INVALID, ADD 'invalid' CSS CLASS 
		// AND RESTORE ORIGINAL VALUE OF INPUT
		var key = this.node.getAttribute('class').match(/^(\S+)/)[1];
		var value = this.convertString(this.freshValue, "htmlToText");
		value = this.convertBackslash(value, "expand");
		if ( (this.isValidInput(key, value) == false
				&& this.requiredInputs[key] != null) )
		{
			////console.log("EditRow.handleOnKeyPress    invalid input '" + key + "': " + dojo.toJson(value));
			dojo.addClass(this.node, 'invalid');
			this.node.innerHTML = this.freshValue;
			this.enableDrag();
			this.textarea.blur();
		}

		// IF THERE'S NO CHANGE, RESTORE ORIGINAL VALUE OF INPUT
		else if ( this.originalText == this.freshValue ) {
			////console.log("EditRow.handleOnKeyPress    this.originalText == this.freshValue: " + dojo.toJson(this.originalText) + "==" + dojo.toJson(this.freshValue));
			this.node.innerHTML = this.freshValue;
			////console.log("EditRow.handleOnKeyPress    this.node.innerHTML: " + dojo.toJson(this.node.innerHTML));
			this.enableDrag();
			this.textarea.blur();
		}

		// OTHERWISE, SAVE THE PARAMETER AND RELOAD THE DRAG SOURCE
		else
		{
			////console.log("EditRow.handleOnKeyPress    VALID input '" + key + "': " + dojo.toJson(value));
			dojo.removeClass(this.node, 'invalid');
			this.enableDrag();

			// SAVE PARAMETER
			////console.log("EditRow.handleOnKeyPress    Doing this.saveInputs(inputs, {reload: false, originator: this})");				
			var inputs = this.getFormInputs(this.rowWidget);
			if ( inputs == null ){
				this.textarea.blur();
				return;
			}
			this.saveInputs(inputs, {reload: false, originator: this});
			this.textarea.blur();
		}
	
	
	}
	catch (error) {
		////console.log("EditRow.handleOnKeyPress    ERROR: " + error);
		this.editingRow = false;
	}

	this.enableDrag();
},

handleEscape : function () {
	
	////console.log("EditRow.handleOnKeyPress    Doing ESCAPE");
	this.editingRow = false;
	this.enableDrag();

	// REMOVE TEXTAREA
	this.textarea.blur();
	this.node.removeChild(this.textarea);

	// RESTORE ORIGINAL VALUE
	this.node.innerHTML = this.originalText;
},

handleOnBlur: function (event) {
// QUIT EDIT IF FOCUS IS LOST
	////console.log("EditRow.handleOnBlur    rowWidget.onBlur(event)");
	////console.log("EditRow.handleOnBlur    //console.dir(event)");
	//console.dir({event: event});
	////console.log("EditRow.handleOnBlur    this.editingRow: " + this.editingRow);

	if ( this.editingRow == false )	return;		

	// REMOVE TEXTAREA
	////console.log("EditRow.handleOnBlur    this.textarea: " + this.textarea);
	var parentNode;
	if ( this.textarea != null )
		parentNode = this.textarea.parentNode;
	////console.log("EditRow.handleOnBlur    parentNode: " + parentNode);

	try {
		if ( parentNode != null && this.textarea != null )
		{
			this.textarea.blur();
			parentNode.removeChild(this.textarea);
		}
		// RESTORE ORIGINAL VALUE
		////console.log("EditRow.handleOnBlur    rowWidget.onBlur    Doing node.innerHTML = " + this.originalText);
		parentNode.innerHTML = this.originalText;
	}
	catch (error) {
		//console.warn("EditRow.handleOnBlur    rowWidget.onBlur    onBlur ERROR");
	}

	this.editingRow = false;
	this.enableDrag();
},


disableDrag : function () {
////console.log("EditRow.disableDrag    form.EditRow.disableDrag()");
	if ( this.dragSourceWidget == null )	return;
		this.dragSourceWidget.isSource = false;
},

enableDrag : function () {
////console.log("EditRow.enableDrag    form.EditRow.enableDrag()");
	if ( this.dragSourceWidget == null )	return;
		this.dragSourceWidget.isSource = true;
}




}); // plugins.form.EditRow


}

if(!dojo._hasResource["plugins.form.DndTrash"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.form.DndTrash"] = true;
dojo.provide("plugins.form.DndTrash");

// PROVIDES FORM INPUT AND ROW EDITING WITH VALIDATION
// INHERITING CLASSES MUST IMPLEMENT saveInputs AND deleteItem METHODS
// THE dnd DRAG SOURCE MUST BE this.dragSourceWidget IF PRESENT

// EXTERNAL MODULES


// INTERNAL MODULES



dojo.declare("plugins.form.DndTrash",
	[ ],
{

// DATA FIELDS TO BE RETRIEVED FROM DELETED ITEM
dataFields : ["name"],

////}}}

constructor : function(args) {
	console.log("Dnd.constructor     plugins.form.DndTrash.constructor");			
},

postCreate : function() {
	console.log("Dnd.postCreate    ");
	this.startup();
},

startup : function () {
	console.log("Dnd.startup    plugins.form.DndTrash.startup()");

	//this.setSubscriptions();
	this.setTrash(this.dataFields);	
},

//setSubscriptions : function () {
//	dojo.subscribe("/dnd/source/over", null,  function(arg) {
//		console.log("/dnd/source/over");
//	});
//
//	dojo.subscribe("/dnd/start",  null,  function(arg) {
//		console.log("/dnd/start");
//	});
//	
//	dojo.subscribe("/dnd/drop",   null,  function(arg) {
//		console.log("/dnd/drop");
//	});
//	
//	dojo.subscribe("/dnd/cancel", null,  function(arg) {
//		console.log("/dnd/cancel");
//	});
//},

setTrash : function (dataFields) {
//	DELETE NODE IF DROPPED INTO TRASH. ACTUAL REMOVAL FROM THE
//	DATA IS ACCOMPLISHED IN THE onDndDrop LISTENER OF THE SOURCE
	//console.log("Dnd.setTrash     plugins.form.DndTrash.setTrash(dataFields)");
	//console.log("Dnd.setTrash     dataFields: " + dojo.toJson(dataFields));

	this.trash = new dojo.dnd.Source(
		this.trashContainer,
		{
			accept : [ "draggableItem" ]
		}
	);
	////console.log("Dnd.setTrash     trash: " + trash);

	// REMOVE DUPLICATE NODES
	var thisObject = this;
	dojo.connect(this.trash, "onDndDrop", dojo.hitch(this, function(source, nodes, copy, target){
		//console.log("Dnd.setTrash    dojo.connect(onDndDrop)    checking if target == this.");
		//console.log("Dnd.setTrash    dojo.connect(onDndDrop)    target: " + target);
		//console.dir({target:target});
		//console.log("Dnd.setTrash    dojo.connect(onDndDrop)    nodes.length: " + nodes.length);
		//console.log("Dnd.setTrash    dojo.connect(onDndDrop)    nodes[0].name: " + nodes[0].name);

		// NODE DROPPED ON SELF --> DELETE THE NODE
		if ( target == thisObject.trash )
		{
			//console.log("Dnd.setTrash    dojo.connect(onDndDrop)    target == this. Removing dropped nodes");

			// TRY TO AVOID THIS ERROR: node.parentNode is null
			try {
				var node = nodes[0];
				var itemObject = new Object;
				for ( var i = 0; i < dataFields.length; i++ )
				{
					itemObject[dataFields[i]] = node.data[dataFields[i]];
					//console.log("Dnd.setTrash    dojo.connect(onDndDrop)    Deleting dataFields[i] " + dataFields[i] + ": " + node.data[dataFields[i]]);
				}			
				//console.log("Dnd.setTrash    dojo.connect(onDndDrop)    Deleting itemObject: " + dojo.toJson(itemObject));
				
				node.parentNode.removeChild(node);
				thisObject.deleteItem(itemObject);
			}
			catch (error) {
				//console.log("Dnd.setTrash    error: " + dojo.toJson(error));
			}
			
			// EMPTY TRASH CONTAINER
			while ( thisObject.trashContainer.childNodes.length > 2 )
			{
				//console.log("Dnd.setTrash    dojo.connect(onDndDrop)    Removing thisObject.trashContainer.childNodes[1]: " + thisObject.trashContainer.childNodes[2]);
			
				thisObject.trashContainer.removeChild(thisObject.trashContainer.childNodes[2]);
			}
		}
	}));
}


}); // plugins.form.DndTrash


}

if(!dojo._hasResource["plugins.form.Inputs"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.form.Inputs"] = true;
dojo.provide("plugins.form.Inputs");

// PROVIDES FORM INPUT AND ROW EDITING WITH VALIDATION
// INHERITING CLASSES MUST IMPLEMENT saveInputs AND deleteItem METHODS
// THE dnd DRAG SOURCE MUST BE this.dragSourceWidget IF PRESENT

/* USE CASE 1: USER CREATES NEW PARAMETER USING 'New Param' BUTTON
  
  saveInputs

	-->	getFormInputs (return: inputs)

		--> processWidgetValue

			--> getWidgetValue

				--> setWidgetValue

	--> checkInputs (set: this.allValid, return inputs,
					return null if this.allValid == false )
		
		--> isValidInput (return true|false: non-empty if required & not invalid)
		
	--> addItem
	
*/
  
// INTERNAL MODULES


dojo.declare("plugins.form.Inputs",
	[ plugins.core.Common ], {

// FORM INPUT-S AND TYPES (word|phrase)
formInputs : {},

// DEFAULT INPUTS (e.g., name : "Name" )
defaultInputs : {},

// REQUIRED INPUTS CANNOT BE ''
requiredInputs : {},

// INVALID INPUTS (e.g., DEFAULT INPUTS:	name : "Name")
invalidInputs : {},

////}}}

constructor : function(args) {
	////console.log("Inputs.constructor     plugins.form.Inputs.constructor");	
},
postCreate : function() {
	////console.log("Inputs.postCreate    ");
	this.startup();
},
startup : function () {
	////console.log("Inputs.startup    plugins.form.Inputs.startup()");
},
setClearValues : function () {	
// SET ONCLICK TO CANCEL INVALID TEXT

////console.log("Inputs.setClearValues    this:");
//console.dir({this: this});

	for ( var name in this.invalidInputs )
	{
		dojo.connect(this[name], "onclick", dojo.hitch(this, "clearValue", this[name], this.invalidInputs[name]));
		dojo.connect(this[name], "onfocus", dojo.hitch(this, "clearValue", this[name], this.invalidInputs[name]));
	}
},
chainInputs : function (inputs) {
// CHAIN TOGETHER INPUTS ON 'RETURN' KEYPRESS
	////////console.log("Inputs.chainInputs    form.EditForm.chainInputs(inputs)");
	////////console.log("Inputs.chainInputs    inputs: " + dojo.toJson(inputs));
	for ( var i = 0; i < inputs.length - 1; i++ ) {
		var name = inputs[i];
		var nextName = inputs[i+1];
	////////console.log("Inputs.chainInputs    Doing dojo.connect for name " + i + ": " + name + " and " + nextName);
		this.chainOnkey(name, nextName);
	}
},
chainOnkey : function (current, next) {
// SHIFT FOCUS TO NEXT INPUT ON KEYPRESS
	////////console.log("Inputs.chainOnkey    form.EditForm.chainOnkey(current, next)");
	////////console.log("Inputs.chainOnkey    current: " + current);
	////////console.log("Inputs.chainOnkey    next: " + next);
	
	var thisObject = this;
	dojo.connect(this[current], "onkeypress", this, function(event){
		if ( event.charOrCode == 13 )
		{				
			////////console.log("Inputs.chainOnkey    current " + current + " to next " + next);
			thisObject[next].focus();
			setTimeout(function() {
				thisObject[current].scrollTop = 0;
			}, 50);
		}
	});
},
saveInputs : function (inputs, updateArgs) {
	////console.log("Inputs.saveInputs    plugins.form.Inputs.saveInputs(inputs, updateArgs)");
	////console.log("Inputs.saveInputs    inputs: " + dojo.toJson(inputs));
	////console.log("Inputs.saveInputs    updateArgs: ");
	//console.dir(updateArgs);
	
	if ( this.saving == true )	return;
	this.saving = true;
	
	var formAdd = false;
	if ( inputs == null )
	{
		formAdd = true;
		inputs = this.getFormInputs(this);
		////console.log("Inputs.saveInputs    AFTER this.getFormInputs(this)    inputs: ");
		//console.dir(inputs);
		
		// RETURN IF INPUTS ARE NULL OR INVALID
		
		if ( inputs == null )
		{
			this.saving = false;
			return;
		}
	}

	var itemObject = new Object;
	itemObject.username = Agua.cookie('username');	
	itemObject.sessionid = Agua.cookie('sessionid');	
	for ( var input in inputs )
	{
		itemObject[input] = inputs[input];
	}
	this.saving = false;

	this.addItem(itemObject, formAdd);
},
getFormInputs : function (widget) {
// GET INPUTS FROM THE EDITED ITEM
	////console.log("Inputs.getFormInputs    plugins.form.Inputs.getFormInputs(widget)");
	////console.log("Inputs.getFormInputs    widget: " + widget);
	//console.dir({parameterRow: widget});

	var inputs = new Object;
	for ( var name in this.formInputs )
	{
		inputs[name] = this.processWidgetValue(widget, name);	
		inputs[name] = this.convertBackslash(inputs[name], "expand");
		inputs[name] = this.convertAngleBrackets(inputs[name], "htmlToText");
		inputs[name] = this.convertAmpersand(inputs[name], "htmlToText");
	}
	////console.log("Inputs.getFormInputs    inputs: " + dojo.toJson(inputs));
	inputs = this.checkInputs(widget, inputs);

	return inputs;
},
processWidgetValue : function (widget, name) {
	console.log("Inputs.processWidgetValue    (widget: " + widget + ", name: " + name + ")");
	console.dir({widget:widget});
	var value = this.getWidgetValue(widget[name]);
	console.log("Inputs.processWidgetValue    (name: " + name + ", value: " + value + ")");
	if ( value == null )	return value;
	if ( value.replace == null )	return value;
	
	if ( value == null )	return null;
	if ( widget.formInputs[name] == "word" )
		value = this.cleanWord(value);
	else if ( widget.formInputs[name] == "phrase" )
		value = this.cleanEnds(value);
	if ( value != null )	this.setWidgetValue(widget[name], value);
	console.log("Inputs.processWidgetValue    widget: " + widget + ", name: " + name + ". Returning value: " + value);

	return value;
},
getWidgetValue : function (widget) {
	var value;
	////////console.log("Inputs.getWidgetValue    (widget: " + widget);
	////////console.log("Inputs.getWidgetValue    widget: ");
	//////console.dir({widget:widget});

	// NUMBER TEXT BOX
	if ( widget.id != null && widget.id.match(/^dijit_form_NumberTextBox/) )
	{
		////////console.log("Inputs.getWidgetValue    DOING NumberTextBox widget");
		value = String(widget);
		//value = String(widget.getValue());
	}
	// WIDGET COMBO BOX
	else if ( widget.get && widget.get('value') )
	{
		////////console.log("Inputs.getWidgetValue    DOING widget.get('value')");
		value = widget.get('value');
	}
	else if ( widget.getValue )
	{
		value = widget.getValue();
	}
	// HTML TEXT INPUT OR HTML COMBO BOX
	else if ( widget.value )
	{
		////////console.log("Inputs.getWidgetValue    DOING widget.value");
		value = String(widget.value.toString());
	}
	// HTML DIV	
	else if ( widget.innerHTML )
	{
	    ////////console.log("Inputs.getWidgetValue    DOING widget.innerHTML");

	    // CHECKBOX
		if ( widget.innerHTML == "<input type=\"checkbox\">" )
	    {
			////////console.log("Inputs.getWidgetValue    CHECKBOX - GETTING VALUE");
			value = widget.childNodes[0].checked;
			////////console.log("Inputs.getWidgetValue    value: " + value);
	    }
		else {
			value = widget.innerHTML;
		}
	}
	////////console.log("Inputs.getWidgetValue    XXXX value: " + dojo.toJson(value));
	if ( value == null )    value = '';
	return value;
},
setWidgetValue : function (widget, value) {
	////////console.log("Inputs.setWidgetValue    form.EditForm.setWidgetValue(widget, name, value)");
	////////console.log("Inputs.setWidgetValue    widget: " + widget);
	////////console.log("Inputs.setWidgetValue    value: " + value);
		
	//////////console.log("Clusters.getEditedInputs    NumberTextBox widget[" + name + "].value name: " + name);
	// NUMBER TEXT BOX
	if ( widget.id != null && widget.id.match(/^dijit_form_NumberTextBox/) )
	{
		////////console.log("Clusters.setEditedInputs    NumberTextBox widget.setValue(value)");
		widget.set('value', value);
	}
	// WIDGET COMBO BOX
	else if ( widget.set )
	{
		////////console.log("Inputs.setWidgetValue    widget.set('value', value)");
		widget.set('value', value);
	}
	// LEGACY: ALL NON-get/set WIDGETS
	else if ( widget.setValue )
	{
		////////console.log("Inputs.setWidgetValue    widget.set('value', value)");
		widget.setValue(value);
	}
	// HTML TEXT INPUT OR HTML COMBO BOX
	else if ( widget.value )
	{
		////////console.log("Inputs.setWidgetValue    widget.value");
		widget.value = value;
	}
	// HTML DIV	
	else if ( widget.innerHTML )
	{
		////////console.log("Inputs.setWidgetValue    widget.innerHTML name: " + name);
		widget.innerHTML = value;
	}
},
clearValue : function (widget, value) {
	////console.log("Inputs.clearValue    plugins.form.Inputs.clearValue(widget, value)");
	////console.log("Inputs.clearValue    widget: " + widget);
	////console.log("Inputs.clearValue    value: " + value);
	if ( widget == null )	return;

	if ( this.getWidgetValue(widget) == value )
		this.setWidgetValue(widget, '')
},
checkInputs : function (widget, inputs) {
// CHECK INPUTS ARE VALID, IF NOT RETURN NULL
	console.log("Inputs.checkInputs    plugins.form.Inputs.checkInputs(inputs)");
	console.log("Inputs.checkInputs    inputs: " + dojo.toJson(inputs));
	
	this.allValid = true;	
	for ( var key in this.formInputs )
	{
		var value = inputs[key];
		console.log("Inputs.checkInputs    Checking " + key + ": " + value);
		
		if ( this.isValidInput(key, value) )
		{
			console.log("Inputs.checkInputs    removing 'invalid' class for " + key + ": " + value);
			this.setValid(widget[key]);
		}
		else{
			console.log("Inputs.checkInputs    adding 'invalid' class for name " + key + ", value " + value);
			
			this.setInvalid(widget[key]);
			this.allValid = false;
		}
	}
	console.log("Inputs.checkInputs    this.allValid: " + this.allValid);
	if ( this.allValid == false )	return null;

	for ( var key in this.formInputs )
	{
		console.log("Inputs.checkInputs    BEFORE convert, inputs[key]: " + dojo.toJson(inputs[key]));
		inputs[key] = this.convertAngleBrackets(inputs[key], "htmlToText");
		//inputs[key] = this.convertBackslash(inputs[key], "textToHtml");
		console.log("Inputs.checkInputs    AFTER convert, inputs[key]: " + dojo.toJson(inputs[key]));
	}

	return inputs;
},
setValid : function (widget) {
	this.removeClass(widget, 'invalid');
},
setInvalid : function (widget) {
	this.addClass(widget, 'invalid');
},
removeClass : function (widget, className) {
	if ( widget.id != null && widget.id.match(/^dijit_form_/) )
	{
		//////console.log("Inputs.removeClass    removing class from domNode.firstChild: " + className);
		
		dojo.removeClass(widget.domNode, className);
	}
	else if ( widget.domNode )
	{
		//////console.log("Inputs.removeClass    removing class from domNode: " + className);
		
		dojo.removeClass(widget.domNode, className);
	}
	else	{
		//////console.log("Inputs.removeClass    removing class for widget: " + className);
		
		dojo.removeClass(widget, className);
	}
},
addClass : function (widget, className) {
	if ( widget.id != null && widget.id.match(/^dijit_form_/) )
	{
		//////console.log("Inputs.addClass    adding class to domNode.firstChild : " + className);
		
		dojo.addClass(widget.domNode, className);
	}
	else if ( widget.domNode )
	{
		//////console.log("Inputs.addClass    adding class to domNode: " + className);
		
		dojo.addClass(widget.domNode, className);
	}
	else	{
		//////console.log("Inputs.addClass    adding class: " + className);
		
		dojo.addClass(widget, className);
	}
},
isValidInput : function (name, value) {
	//////////console.log(">>>> EditForm.isValidInput    plugins.form.Inputs.isValidInput(name, value)");
	//////console.log("Inputs.isValidInput    name: " + name);
	//////console.log("Inputs.isValidInput    value: " + value);
	//////console.log("Inputs.isValidInput    this.invalidInputs[name]: " + this.invalidInputs[name]);
	//////console.log("Inputs.isValidInput    this.requiredInputs[name]: " + this.requiredInputs[name]);

	////console.log("Inputs.isValidInput    '" + name + "' value: " + value +" [ invalid: " + name + "]: '" + this.invalidInputs[name] + "', required: " + this.requiredInputs[name] + " ]");
	
	//////console.log("Inputs.isValidInput    this.invalidInputs[name]: " + this.invalidInputs[name]);
	//////console.log("Inputs.isValidInput    this.requiredInputs[name]: " + this.requiredInputs[name]);

	if ( this.invalidInputs[name] == null )	return true;
	else if ( this.requiredInputs[name] == null )	return true;
	else if ( value == null )	return false;
	else if ( value == '' )	return false;
	else if ( this.invalidInputs[name] == value ) return false;

	////console.log("Inputs.isValidInput    Returning true");
	return true;
}


}); // plugins.form.Inputs


}

if(!dojo._hasResource["plugins.form.EditForm"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.form.EditForm"] = true;
dojo.provide("plugins.form.EditForm");

// PROVIDES FORM INPUT AND ROW EDITING WITH VALIDATION
// INHERITING CLASSES MUST IMPLEMENT saveInputs AND deleteItem METHODS
// THE dnd DRAG SOURCE MUST BE this.dragSourceWidget IF PRESENT

// EXTERNAL MODULES


// INTERNAL MODULES






dojo.declare("plugins.form.EditForm",
	[ plugins.form.EditRow, plugins.form.Inputs, plugins.form.DndTrash, plugins.form.DndSource ],
{

////}}}

constructor : function(args) {
	////console.log("EditForm.constructor     plugins.form.EditForm.constructor");			
},

postCreate : function() {
	////console.log("EditForm.postCreate    ");
	this.startup();
},

startup : function () {
	////console.log("EditForm.startup    plugins.form.EditForm.startup()");
	this.inherited(arguments);	
}

}); // plugins.form.EditForm


}

if(!dojo._hasResource["dojo.dnd.Mover"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.Mover"] = true;
dojo.provide("dojo.dnd.Mover");




dojo.declare("dojo.dnd.Mover", null, {
	constructor: function(node, e, host){
		// summary:
		//		an object which makes a node follow the mouse, or touch-drag on touch devices.
		//		Used as a default mover, and as a base class for custom movers.
		// node: Node
		//		a node (or node's id) to be moved
		// e: Event
		//		a mouse event, which started the move;
		//		only pageX and pageY properties are used
		// host: Object?
		//		object which implements the functionality of the move,
		//	 	and defines proper events (onMoveStart and onMoveStop)
		this.node = dojo.byId(node);
		var pos = e.touches ? e.touches[0] : e;
		this.marginBox = {l: pos.pageX, t: pos.pageY};
		this.mouseButton = e.button;
		var h = (this.host = host), d = node.ownerDocument;
		this.events = [
			// At the start of a drag, onFirstMove is called, and then the following two
			// connects are disconnected
			dojo.connect(d, "onmousemove", this, "onFirstMove"),
			dojo.connect(d, "ontouchmove", this, "onFirstMove"),

			// These are called continually during the drag
			dojo.connect(d, "onmousemove", this, "onMouseMove"),
			dojo.connect(d, "ontouchmove", this, "onMouseMove"),

			// And these are called at the end of the drag
			dojo.connect(d, "onmouseup",   this, "onMouseUp"),
			dojo.connect(d, "ontouchend", this, "onMouseUp"),

			// cancel text selection and text dragging
			dojo.connect(d, "ondragstart",   dojo.stopEvent),
			dojo.connect(d.body, "onselectstart", dojo.stopEvent)
		];
		// notify that the move has started
		if(h && h.onMoveStart){
			h.onMoveStart(this);
		}
	},
	// mouse event processors
	onMouseMove: function(e){
		// summary:
		//		event processor for onmousemove/ontouchmove
		// e: Event
		//		mouse/touch event
		dojo.dnd.autoScroll(e);
		var m = this.marginBox,
			pos = e.touches ? e.touches[0] : e;
		this.host.onMove(this, {l: m.l + pos.pageX, t: m.t + pos.pageY}, e);
		dojo.stopEvent(e);
	},
	onMouseUp: function(e){
		if(dojo.isWebKit && dojo.isMac && this.mouseButton == 2 ?
				e.button == 0 : this.mouseButton == e.button){ // TODO Should condition be met for touch devices, too?
			this.destroy();
		}
		dojo.stopEvent(e);
	},
	// utilities
	onFirstMove: function(e){
		// summary:
		//		makes the node absolute; it is meant to be called only once.
		// 		relative and absolutely positioned nodes are assumed to use pixel units
		var s = this.node.style, l, t, h = this.host;
		switch(s.position){
			case "relative":
			case "absolute":
				// assume that left and top values are in pixels already
				l = Math.round(parseFloat(s.left)) || 0;
				t = Math.round(parseFloat(s.top)) || 0;
				break;
			default:
				s.position = "absolute";	// enforcing the absolute mode
				var m = dojo.marginBox(this.node);
				// event.pageX/pageY (which we used to generate the initial
				// margin box) includes padding and margin set on the body.
				// However, setting the node's position to absolute and then
				// doing dojo.marginBox on it *doesn't* take that additional
				// space into account - so we need to subtract the combined
				// padding and margin.  We use getComputedStyle and
				// _getMarginBox/_getContentBox to avoid the extra lookup of
				// the computed style.
				var b = dojo.doc.body;
				var bs = dojo.getComputedStyle(b);
				var bm = dojo._getMarginBox(b, bs);
				var bc = dojo._getContentBox(b, bs);
				l = m.l - (bc.l - bm.l);
				t = m.t - (bc.t - bm.t);
				break;
		}
		this.marginBox.l = l - this.marginBox.l;
		this.marginBox.t = t - this.marginBox.t;
		if(h && h.onFirstMove){
			h.onFirstMove(this, e);
		}
		
		// Disconnect onmousemove and ontouchmove events that call this function
		dojo.disconnect(this.events.shift());
		dojo.disconnect(this.events.shift());
	},
	destroy: function(){
		// summary:
		//		stops the move, deletes all references, so the object can be garbage-collected
		dojo.forEach(this.events, dojo.disconnect);
		// undo global settings
		var h = this.host;
		if(h && h.onMoveStop){
			h.onMoveStop(this);
		}
		// destroy objects
		this.events = this.node = this.host = null;
	}
});

}

if(!dojo._hasResource["dojo.dnd.Moveable"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.Moveable"] = true;
dojo.provide("dojo.dnd.Moveable");



/*=====
dojo.declare("dojo.dnd.__MoveableArgs", [], {
	// handle: Node||String
	//		A node (or node's id), which is used as a mouse handle.
	//		If omitted, the node itself is used as a handle.
	handle: null,

	// delay: Number
	//		delay move by this number of pixels
	delay: 0,

	// skip: Boolean
	//		skip move of form elements
	skip: false,

	// mover: Object
	//		a constructor of custom Mover
	mover: dojo.dnd.Mover
});
=====*/

dojo.declare("dojo.dnd.Moveable", null, {
	// object attributes (for markup)
	handle: "",
	delay: 0,
	skip: false,
	
	constructor: function(node, params){
		// summary:
		//		an object, which makes a node moveable
		// node: Node
		//		a node (or node's id) to be moved
		// params: dojo.dnd.__MoveableArgs?
		//		optional parameters
		this.node = dojo.byId(node);
		if(!params){ params = {}; }
		this.handle = params.handle ? dojo.byId(params.handle) : null;
		if(!this.handle){ this.handle = this.node; }
		this.delay = params.delay > 0 ? params.delay : 0;
		this.skip  = params.skip;
		this.mover = params.mover ? params.mover : dojo.dnd.Mover;
		this.events = [
			dojo.connect(this.handle, "onmousedown", this, "onMouseDown"),
			dojo.connect(this.handle, "ontouchstart", this, "onMouseDown"),
			// cancel text selection and text dragging
			dojo.connect(this.handle, "ondragstart",   this, "onSelectStart"),
			dojo.connect(this.handle, "onselectstart", this, "onSelectStart")
		];
	},

	// markup methods
	markupFactory: function(params, node){
		return new dojo.dnd.Moveable(node, params);
	},

	// methods
	destroy: function(){
		// summary:
		//		stops watching for possible move, deletes all references, so the object can be garbage-collected
		dojo.forEach(this.events, dojo.disconnect);
		this.events = this.node = this.handle = null;
	},
	
	// mouse event processors
	onMouseDown: function(e){
		// summary:
		//		event processor for onmousedown/ontouchstart, creates a Mover for the node
		// e: Event
		//		mouse/touch event
		if(this.skip && dojo.dnd.isFormElement(e)){ return; }
		if(this.delay){
			this.events.push(
				dojo.connect(this.handle, "onmousemove", this, "onMouseMove"),
				dojo.connect(this.handle, "ontouchmove", this, "onMouseMove"),
				dojo.connect(this.handle, "onmouseup", this, "onMouseUp"),
				dojo.connect(this.handle, "ontouchend", this, "onMouseUp")
			);
			var pos = e.touches ? e.touches[0] : e;
			this._lastX = pos.pageX;
			this._lastY = pos.pageY;
		}else{
			this.onDragDetected(e);
		}
		dojo.stopEvent(e);
	},
	onMouseMove: function(e){
		// summary:
		//		event processor for onmousemove/ontouchmove, used only for delayed drags
		// e: Event
		//		mouse/touch event
		var pos = e.touches ? e.touches[0] : e;
		if(Math.abs(pos.pageX - this._lastX) > this.delay || Math.abs(pos.pageY - this._lastY) > this.delay){
			this.onMouseUp(e);
			this.onDragDetected(e);
		}
		dojo.stopEvent(e);
	},
	onMouseUp: function(e){
		// summary:
		//		event processor for onmouseup, used only for delayed drags
		// e: Event
		//		mouse event
		for(var i = 0; i < 2; ++i){
			dojo.disconnect(this.events.pop());
		}
		dojo.stopEvent(e);
	},
	onSelectStart: function(e){
		// summary:
		//		event processor for onselectevent and ondragevent
		// e: Event
		//		mouse event
		if(!this.skip || !dojo.dnd.isFormElement(e)){
			dojo.stopEvent(e);
		}
	},
	
	// local events
	onDragDetected: function(/* Event */ e){
		// summary:
		//		called when the drag is detected;
		//		responsible for creation of the mover
		new this.mover(this.node, e, this);
	},
	onMoveStart: function(/* dojo.dnd.Mover */ mover){
		// summary:
		//		called before every move operation
		dojo.publish("/dnd/move/start", [mover]);
		dojo.addClass(dojo.body(), "dojoMove");
		dojo.addClass(this.node, "dojoMoveItem");
	},
	onMoveStop: function(/* dojo.dnd.Mover */ mover){
		// summary:
		//		called after every move operation
		dojo.publish("/dnd/move/stop", [mover]);
		dojo.removeClass(dojo.body(), "dojoMove");
		dojo.removeClass(this.node, "dojoMoveItem");
	},
	onFirstMove: function(/* dojo.dnd.Mover */ mover, /* Event */ e){
		// summary:
		//		called during the very first move notification;
		//		can be used to initialize coordinates, can be overwritten.
		
		// default implementation does nothing
	},
	onMove: function(/* dojo.dnd.Mover */ mover, /* Object */ leftTop, /* Event */ e){
		// summary:
		//		called during every move notification;
		//		should actually move the node; can be overwritten.
		this.onMoving(mover, leftTop);
		var s = mover.node.style;
		s.left = leftTop.l + "px";
		s.top  = leftTop.t + "px";
		this.onMoved(mover, leftTop);
	},
	onMoving: function(/* dojo.dnd.Mover */ mover, /* Object */ leftTop){
		// summary:
		//		called before every incremental move; can be overwritten.
		
		// default implementation does nothing
	},
	onMoved: function(/* dojo.dnd.Mover */ mover, /* Object */ leftTop){
		// summary:
		//		called after every incremental move; can be overwritten.
		
		// default implementation does nothing
	}
});

}

if(!dojo._hasResource["dojo.dnd.move"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.move"] = true;
dojo.provide("dojo.dnd.move");




/*=====
dojo.declare("dojo.dnd.move.__constrainedMoveableArgs", [dojo.dnd.__MoveableArgs], {
	// constraints: Function
	//		Calculates a constraint box.
	//		It is called in a context of the moveable object.
	constraints: function(){},

	// within: Boolean
	//		restrict move within boundaries.
	within: false
});
=====*/

dojo.declare("dojo.dnd.move.constrainedMoveable", dojo.dnd.Moveable, {
	// object attributes (for markup)
	constraints: function(){},
	within: false,
	
	// markup methods
	markupFactory: function(params, node){
		return new dojo.dnd.move.constrainedMoveable(node, params);
	},

	constructor: function(node, params){
		// summary:
		//		an object that makes a node moveable
		// node: Node
		//		a node (or node's id) to be moved
		// params: dojo.dnd.move.__constrainedMoveableArgs?
		//		an optional object with additional parameters;
		//		the rest is passed to the base class
		if(!params){ params = {}; }
		this.constraints = params.constraints;
		this.within = params.within;
	},
	onFirstMove: function(/* dojo.dnd.Mover */ mover){
		// summary:
		//		called during the very first move notification;
		//		can be used to initialize coordinates, can be overwritten.
		var c = this.constraintBox = this.constraints.call(this, mover);
		c.r = c.l + c.w;
		c.b = c.t + c.h;
		if(this.within){
			var mb = dojo._getMarginSize(mover.node);
			c.r -= mb.w;
			c.b -= mb.h;
		}
	},
	onMove: function(/* dojo.dnd.Mover */ mover, /* Object */ leftTop){
		// summary:
		//		called during every move notification;
		//		should actually move the node; can be overwritten.
		var c = this.constraintBox, s = mover.node.style;
		this.onMoving(mover, leftTop);
		leftTop.l = leftTop.l < c.l ? c.l : c.r < leftTop.l ? c.r : leftTop.l;
		leftTop.t = leftTop.t < c.t ? c.t : c.b < leftTop.t ? c.b : leftTop.t;
		s.left = leftTop.l + "px";
		s.top  = leftTop.t + "px";
		this.onMoved(mover, leftTop);
	}
});

/*=====
dojo.declare("dojo.dnd.move.__boxConstrainedMoveableArgs", [dojo.dnd.move.__constrainedMoveableArgs], {
	// box: Object
	//		a constraint box
	box: {}
});
=====*/

dojo.declare("dojo.dnd.move.boxConstrainedMoveable", dojo.dnd.move.constrainedMoveable, {
	// box:
	//		object attributes (for markup)
	box: {},
	
	// markup methods
	markupFactory: function(params, node){
		return new dojo.dnd.move.boxConstrainedMoveable(node, params);
	},

	constructor: function(node, params){
		// summary:
		//		an object, which makes a node moveable
		// node: Node
		//		a node (or node's id) to be moved
		// params: dojo.dnd.move.__boxConstrainedMoveableArgs?
		//		an optional object with parameters
		var box = params && params.box;
		this.constraints = function(){ return box; };
	}
});

/*=====
dojo.declare("dojo.dnd.move.__parentConstrainedMoveableArgs", [dojo.dnd.move.__constrainedMoveableArgs], {
	// area: String
	//		A parent's area to restrict the move.
	//		Can be "margin", "border", "padding", or "content".
	area: ""
});
=====*/

dojo.declare("dojo.dnd.move.parentConstrainedMoveable", dojo.dnd.move.constrainedMoveable, {
	// area:
	//		object attributes (for markup)
	area: "content",

	// markup methods
	markupFactory: function(params, node){
		return new dojo.dnd.move.parentConstrainedMoveable(node, params);
	},

	constructor: function(node, params){
		// summary:
		//		an object, which makes a node moveable
		// node: Node
		//		a node (or node's id) to be moved
		// params: dojo.dnd.move.__parentConstrainedMoveableArgs?
		//		an optional object with parameters
		var area = params && params.area;
		this.constraints = function(){
			var n = this.node.parentNode,
				s = dojo.getComputedStyle(n),
				mb = dojo._getMarginBox(n, s);
			if(area == "margin"){
				return mb;	// Object
			}
			var t = dojo._getMarginExtents(n, s);
			mb.l += t.l, mb.t += t.t, mb.w -= t.w, mb.h -= t.h;
			if(area == "border"){
				return mb;	// Object
			}
			t = dojo._getBorderExtents(n, s);
			mb.l += t.l, mb.t += t.t, mb.w -= t.w, mb.h -= t.h;
			if(area == "padding"){
				return mb;	// Object
			}
			t = dojo._getPadExtents(n, s);
			mb.l += t.l, mb.t += t.t, mb.w -= t.w, mb.h -= t.h;
			return mb;	// Object
		};
	}
});

// patching functions one level up for compatibility

dojo.dnd.constrainedMover = dojo.dnd.move.constrainedMover;
dojo.dnd.boxConstrainedMover = dojo.dnd.move.boxConstrainedMover;
dojo.dnd.parentConstrainedMover = dojo.dnd.move.parentConstrainedMover;

}

if(!dojo._hasResource["dojo.dnd.TimedMoveable"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.TimedMoveable"] = true;
dojo.provide("dojo.dnd.TimedMoveable");



/*=====
dojo.declare("dojo.dnd.__TimedMoveableArgs", [dojo.dnd.__MoveableArgs], {
	// timeout: Number
	//		delay move by this number of ms,
	//		accumulating position changes during the timeout
	timeout: 0
});
=====*/

(function(){
	// precalculate long expressions
	var oldOnMove = dojo.dnd.Moveable.prototype.onMove;
		
	dojo.declare("dojo.dnd.TimedMoveable", dojo.dnd.Moveable, {
		// summary:
		//		A specialized version of Moveable to support an FPS throttling.
		//		This class puts an upper restriction on FPS, which may reduce
		//		the CPU load. The additional parameter "timeout" regulates
		//		the delay before actually moving the moveable object.
		
		// object attributes (for markup)
		timeout: 40,	// in ms, 40ms corresponds to 25 fps
	
		constructor: function(node, params){
			// summary:
			//		an object that makes a node moveable with a timer
			// node: Node||String
			//		a node (or node's id) to be moved
			// params: dojo.dnd.__TimedMoveableArgs
			//		object with additional parameters.
			
			// sanitize parameters
			if(!params){ params = {}; }
			if(params.timeout && typeof params.timeout == "number" && params.timeout >= 0){
				this.timeout = params.timeout;
			}
		},
	
		// markup methods
		markupFactory: function(params, node){
			return new dojo.dnd.TimedMoveable(node, params);
		},
	
		onMoveStop: function(/* dojo.dnd.Mover */ mover){
			if(mover._timer){
				// stop timer
				clearTimeout(mover._timer)
				// reflect the last received position
				oldOnMove.call(this, mover, mover._leftTop)
			}
			dojo.dnd.Moveable.prototype.onMoveStop.apply(this, arguments);
		},
		onMove: function(/* dojo.dnd.Mover */ mover, /* Object */ leftTop){
			mover._leftTop = leftTop;
			if(!mover._timer){
				var _t = this;	// to avoid using dojo.hitch()
				mover._timer = setTimeout(function(){
					// we don't have any pending requests
					mover._timer = null;
					// reflect the last received position
					oldOnMove.call(_t, mover, mover._leftTop);
				}, this.timeout);
			}
		}
	});
})();

}

if(!dojo._hasResource["dijit.form._FormMixin"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form._FormMixin"] = true;
dojo.provide("dijit.form._FormMixin");



dojo.declare("dijit.form._FormMixin", null, {
	// summary:
	//		Mixin for containers of form widgets (i.e. widgets that represent a single value
	//		and can be children of a <form> node or dijit.form.Form widget)
	// description:
	//		Can extract all the form widgets
	//		values and combine them into a single javascript object, or alternately
	//		take such an object and set the values for all the contained
	//		form widgets

/*=====
	// value: Object
	//		Name/value hash for each child widget with a name and value.
	//		Child widgets without names are not part of the hash.
	//
	//		If there are multiple child widgets w/the same name, value is an array,
	//		unless they are radio buttons in which case value is a scalar (since only
	//		one radio button can be checked at a time).
	//
	//		If a child widget's name is a dot separated list (like a.b.c.d), it's a nested structure.
	//
	//		Example:
	//	|	{ name: "John Smith", interests: ["sports", "movies"] }
=====*/

	// state: [readonly] String
	//		Will be "Error" if one or more of the child widgets has an invalid value,
	//		"Incomplete" if not all of the required child widgets are filled in.  Otherwise, "",
	//		which indicates that the form is ready to be submitted.
	state: "",

	//	TODO:
	//	* Repeater
	//	* better handling for arrays.  Often form elements have names with [] like
	//	* people[3].sex (for a list of people [{name: Bill, sex: M}, ...])
	//
	//

		reset: function(){
			dojo.forEach(this.getDescendants(), function(widget){
				if(widget.reset){
					widget.reset();
				}
			});
		},

		validate: function(){
			// summary:
			//		returns if the form is valid - same as isValid - but
			//		provides a few additional (ui-specific) features.
			//		1 - it will highlight any sub-widgets that are not
			//			valid
			//		2 - it will call focus() on the first invalid
			//			sub-widget
			var didFocus = false;
			return dojo.every(dojo.map(this.getDescendants(), function(widget){
				// Need to set this so that "required" widgets get their
				// state set.
				widget._hasBeenBlurred = true;
				var valid = widget.disabled || !widget.validate || widget.validate();
				if(!valid && !didFocus){
					// Set focus of the first non-valid widget
					dojo.window.scrollIntoView(widget.containerNode || widget.domNode);
					widget.focus();
					didFocus = true;
				}
	 			return valid;
	 		}), function(item){ return item; });
		},

		setValues: function(val){
			dojo.deprecated(this.declaredClass+"::setValues() is deprecated. Use set('value', val) instead.", "", "2.0");
			return this.set('value', val);
		},
		_setValueAttr: function(/*Object*/ obj){
			// summary:
			//		Fill in form values from according to an Object (in the format returned by get('value'))

			// generate map from name --> [list of widgets with that name]
			var map = { };
			dojo.forEach(this.getDescendants(), function(widget){
				if(!widget.name){ return; }
				var entry = map[widget.name] || (map[widget.name] = [] );
				entry.push(widget);
			});

			for(var name in map){
				if(!map.hasOwnProperty(name)){
					continue;
				}
				var widgets = map[name],						// array of widgets w/this name
					values = dojo.getObject(name, false, obj);	// list of values for those widgets

				if(values === undefined){
					continue;
				}
				if(!dojo.isArray(values)){
					values = [ values ];
				}
				if(typeof widgets[0].checked == 'boolean'){
					// for checkbox/radio, values is a list of which widgets should be checked
					dojo.forEach(widgets, function(w, i){
						w.set('value', dojo.indexOf(values, w.value) != -1);
					});
				}else if(widgets[0].multiple){
					// it takes an array (e.g. multi-select)
					widgets[0].set('value', values);
				}else{
					// otherwise, values is a list of values to be assigned sequentially to each widget
					dojo.forEach(widgets, function(w, i){
						w.set('value', values[i]);
					});
				}
			}

			/***
			 * 	TODO: code for plain input boxes (this shouldn't run for inputs that are part of widgets)

			dojo.forEach(this.containerNode.elements, function(element){
				if(element.name == ''){return};	// like "continue"
				var namePath = element.name.split(".");
				var myObj=obj;
				var name=namePath[namePath.length-1];
				for(var j=1,len2=namePath.length;j<len2;++j){
					var p=namePath[j - 1];
					// repeater support block
					var nameA=p.split("[");
					if(nameA.length > 1){
						if(typeof(myObj[nameA[0]]) == "undefined"){
							myObj[nameA[0]]=[ ];
						} // if

						nameIndex=parseInt(nameA[1]);
						if(typeof(myObj[nameA[0]][nameIndex]) == "undefined"){
							myObj[nameA[0]][nameIndex] = { };
						}
						myObj=myObj[nameA[0]][nameIndex];
						continue;
					} // repeater support ends

					if(typeof(myObj[p]) == "undefined"){
						myObj=undefined;
						break;
					};
					myObj=myObj[p];
				}

				if(typeof(myObj) == "undefined"){
					return;		// like "continue"
				}
				if(typeof(myObj[name]) == "undefined" && this.ignoreNullValues){
					return;		// like "continue"
				}

				// TODO: widget values (just call set('value', ...) on the widget)

				// TODO: maybe should call dojo.getNodeProp() instead
				switch(element.type){
					case "checkbox":
						element.checked = (name in myObj) &&
							dojo.some(myObj[name], function(val){ return val == element.value; });
						break;
					case "radio":
						element.checked = (name in myObj) && myObj[name] == element.value;
						break;
					case "select-multiple":
						element.selectedIndex=-1;
						dojo.forEach(element.options, function(option){
							option.selected = dojo.some(myObj[name], function(val){ return option.value == val; });
						});
						break;
					case "select-one":
						element.selectedIndex="0";
						dojo.forEach(element.options, function(option){
							option.selected = option.value == myObj[name];
						});
						break;
					case "hidden":
					case "text":
					case "textarea":
					case "password":
						element.value = myObj[name] || "";
						break;
				}
	  		});
	  		*/
			
			// Note: no need to call this._set("value", ...) as the child updates will trigger onChange events
			// which I am monitoring.
		},

		getValues: function(){
			dojo.deprecated(this.declaredClass+"::getValues() is deprecated. Use get('value') instead.", "", "2.0");
			return this.get('value');
		},
		_getValueAttr: function(){
			// summary:
			// 		Returns Object representing form values.   See description of `value` for details.
			// description:

			// The value is updated into this.value every time a child has an onChange event,
			// so in the common case this function could just return this.value.   However,
			// that wouldn't work when:
			//
			// 1. User presses return key to submit a form.  That doesn't fire an onchange event,
			// and even if it did it would come too late due to the setTimout(..., 0) in _handleOnChange()
			//
			// 2. app for some reason calls this.get("value") while the user is typing into a
			// form field.   Not sure if that case needs to be supported or not.

			// get widget values
			var obj = { };
			dojo.forEach(this.getDescendants(), function(widget){
				var name = widget.name;
				if(!name || widget.disabled){ return; }

				// Single value widget (checkbox, radio, or plain <input> type widget)
				var value = widget.get('value');

				// Store widget's value(s) as a scalar, except for checkboxes which are automatically arrays
				if(typeof widget.checked == 'boolean'){
					if(/Radio/.test(widget.declaredClass)){
						// radio button
						if(value !== false){
							dojo.setObject(name, value, obj);
						}else{
							// give radio widgets a default of null
							value = dojo.getObject(name, false, obj);
							if(value === undefined){
								dojo.setObject(name, null, obj);
							}
						}
					}else{
						// checkbox/toggle button
						var ary=dojo.getObject(name, false, obj);
						if(!ary){
							ary=[];
							dojo.setObject(name, ary, obj);
						}
						if(value !== false){
							ary.push(value);
						}
					}
				}else{
					var prev=dojo.getObject(name, false, obj);
					if(typeof prev != "undefined"){
						if(dojo.isArray(prev)){
							prev.push(value);
						}else{
							dojo.setObject(name, [prev, value], obj);
						}
					}else{
						// unique name
						dojo.setObject(name, value, obj);
					}
				}
			});

			/***
			 * code for plain input boxes (see also dojo.formToObject, can we use that instead of this code?
			 * but it doesn't understand [] notation, presumably)
			var obj = { };
			dojo.forEach(this.containerNode.elements, function(elm){
				if(!elm.name)	{
					return;		// like "continue"
				}
				var namePath = elm.name.split(".");
				var myObj=obj;
				var name=namePath[namePath.length-1];
				for(var j=1,len2=namePath.length;j<len2;++j){
					var nameIndex = null;
					var p=namePath[j - 1];
					var nameA=p.split("[");
					if(nameA.length > 1){
						if(typeof(myObj[nameA[0]]) == "undefined"){
							myObj[nameA[0]]=[ ];
						} // if
						nameIndex=parseInt(nameA[1]);
						if(typeof(myObj[nameA[0]][nameIndex]) == "undefined"){
							myObj[nameA[0]][nameIndex] = { };
						}
					} else if(typeof(myObj[nameA[0]]) == "undefined"){
						myObj[nameA[0]] = { }
					} // if

					if(nameA.length == 1){
						myObj=myObj[nameA[0]];
					} else{
						myObj=myObj[nameA[0]][nameIndex];
					} // if
				} // for

				if((elm.type != "select-multiple" && elm.type != "checkbox" && elm.type != "radio") || (elm.type == "radio" && elm.checked)){
					if(name == name.split("[")[0]){
						myObj[name]=elm.value;
					} else{
						// can not set value when there is no name
					}
				} else if(elm.type == "checkbox" && elm.checked){
					if(typeof(myObj[name]) == 'undefined'){
						myObj[name]=[ ];
					}
					myObj[name].push(elm.value);
				} else if(elm.type == "select-multiple"){
					if(typeof(myObj[name]) == 'undefined'){
						myObj[name]=[ ];
					}
					for(var jdx=0,len3=elm.options.length; jdx<len3; ++jdx){
						if(elm.options[jdx].selected){
							myObj[name].push(elm.options[jdx].value);
						}
					}
				} // if
				name=undefined;
			}); // forEach
			***/
			return obj;
		},

	 	isValid: function(){
	 		// summary:
	 		//		Returns true if all of the widgets are valid.
			//		Deprecated, will be removed in 2.0.  Use get("state") instead.

			return this.state == "";
		},

		onValidStateChange: function(isValid){
			// summary:
			//		Stub function to connect to if you want to do something
			//		(like disable/enable a submit button) when the valid
			//		state changes on the form as a whole.
			//
			//		Deprecated.  Will be removed in 2.0.  Use watch("state", ...) instead.
		},

		_getState: function(){
			// summary:
			//		Compute what this.state should be based on state of children
			var states = dojo.map(this._descendants, function(w){
				return w.get("state") || "";
			});

			return dojo.indexOf(states, "Error") >= 0 ? "Error" :
				dojo.indexOf(states, "Incomplete") >= 0 ? "Incomplete" : "";
		},

		disconnectChildren: function(){
			// summary:
			//		Remove connections to monitor changes to children's value, error state, and disabled state,
			//		in order to update Form.value and Form.state.
			dojo.forEach(this._childConnections || [], dojo.hitch(this, "disconnect"));
			dojo.forEach(this._childWatches || [], function(w){ w.unwatch(); });
		},

		connectChildren: function(/*Boolean*/ inStartup){
			// summary:
			//		Setup connections to monitor changes to children's value, error state, and disabled state,
			//		in order to update Form.value and Form.state.
			//
			//		You can call this function directly, ex. in the event that you
			//		programmatically add a widget to the form *after* the form has been
			//		initialized.

			var _this = this;

			// Remove old connections, if any
			this.disconnectChildren();

			this._descendants = this.getDescendants();

			// (Re)set this.value and this.state.   Send watch() notifications but not on startup.
			var set = inStartup ? function(name, val){ _this[name] = val; } : dojo.hitch(this, "_set");
			set("value", this.get("value"));
			set("state", this._getState());

			// Monitor changes to error state and disabled state in order to update
			// Form.state
			var conns = (this._childConnections = []),
				watches = (this._childWatches = []);
			dojo.forEach(dojo.filter(this._descendants,
				function(item){ return item.validate; }
			),
			function(widget){
				// We are interested in whenever the widget changes validity state - or
				// whenever the disabled attribute on that widget is changed.
				dojo.forEach(["state", "disabled"], function(attr){
					watches.push(widget.watch(attr, function(attr, oldVal, newVal){
						_this.set("state", _this._getState());
					}));
				});
			});

			// And monitor calls to child.onChange so we can update this.value
			var onChange = function(){
				// summary:
				//		Called when child's value or disabled state changes
				
				// Use setTimeout() to collapse value changes in multiple children into a single
				// update to my value.   Multiple updates will occur on:
				//	1. Form.set()
				//	2. Form.reset()
				//	3. user selecting a radio button (which will de-select another radio button,
				//		 causing two onChange events)
				if(_this._onChangeDelayTimer){
					clearTimeout(_this._onChangeDelayTimer);
				}
				_this._onChangeDelayTimer = setTimeout(function(){
					delete _this._onChangeDelayTimer;
					_this._set("value", _this.get("value"));
				}, 10);
			};
			dojo.forEach(
				dojo.filter(this._descendants, function(item){ return item.onChange; } ),
				function(widget){
					// When a child widget's value changes,
					// the efficient thing to do is to just update that one attribute in this.value,
					// but that gets a little complicated when a checkbox is checked/unchecked
					// since this.value["checkboxName"] contains an array of all the checkboxes w/the same name.
					// Doing simple thing for now.
					conns.push(_this.connect(widget, "onChange", onChange));

					// Disabling/enabling a child widget should remove it's value from this.value.
					// Again, this code could be more efficient, doing simple thing for now.
					watches.push(widget.watch("disabled", onChange));
				}
			);
		},

		startup: function(){
			this.inherited(arguments);

			// Initialize value and valid/invalid state tracking.  Needs to be done in startup()
			// so that children are initialized.
			this.connectChildren(true);

			// Make state change call onValidStateChange(), will be removed in 2.0
			this.watch("state", function(attr, oldVal, newVal){ this.onValidStateChange(newVal == ""); });
		},

		destroy: function(){
			this.disconnectChildren();
			this.inherited(arguments);
		}

	});

}

if(!dojo._hasResource["dijit._DialogMixin"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._DialogMixin"] = true;
dojo.provide("dijit._DialogMixin");



dojo.declare("dijit._DialogMixin", null,
	{
		// summary:
		//		This provides functions useful to Dialog and TooltipDialog

		attributeMap: dijit._Widget.prototype.attributeMap,

		execute: function(/*Object*/ formContents){
			// summary:
			//		Callback when the user hits the submit button.
			//		Override this method to handle Dialog execution.
			// description:
			//		After the user has pressed the submit button, the Dialog
			//		first calls onExecute() to notify the container to hide the
			//		dialog and restore focus to wherever it used to be.
			//
			//		*Then* this method is called.
			// type:
			//		callback
		},

		onCancel: function(){
			// summary:
			//	    Called when user has pressed the Dialog's cancel button, to notify container.
			// description:
			//	    Developer shouldn't override or connect to this method;
			//		it's a private communication device between the TooltipDialog
			//		and the thing that opened it (ex: `dijit.form.DropDownButton`)
			// type:
			//		protected
		},

		onExecute: function(){
			// summary:
			//	    Called when user has pressed the dialog's OK button, to notify container.
			// description:
			//	    Developer shouldn't override or connect to this method;
			//		it's a private communication device between the TooltipDialog
			//		and the thing that opened it (ex: `dijit.form.DropDownButton`)
			// type:
			//		protected
		},

		_onSubmit: function(){
			// summary:
			//		Callback when user hits submit button
			// type:
			//		protected
			this.onExecute();	// notify container that we are about to execute
			this.execute(this.get('value'));
		},

		_getFocusItems: function(){
			// summary:
			//		Finds focusable items in dialog,
			//		and sets this._firstFocusItem and this._lastFocusItem
			// tags:
			//		protected

			var elems = dijit._getTabNavigable(this.containerNode);
			this._firstFocusItem = elems.lowest || elems.first || this.closeButtonNode || this.domNode;
			this._lastFocusItem = elems.last || elems.highest || this._firstFocusItem;
		}
	}
);

}

if(!dojo._hasResource["dijit.DialogUnderlay"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.DialogUnderlay"] = true;
dojo.provide("dijit.DialogUnderlay");





dojo.declare(
	"dijit.DialogUnderlay",
	[dijit._Widget, dijit._Templated],
	{
		// summary:
		//		The component that blocks the screen behind a `dijit.Dialog`
		//
		// description:
		// 		A component used to block input behind a `dijit.Dialog`. Only a single
		//		instance of this widget is created by `dijit.Dialog`, and saved as
		//		a reference to be shared between all Dialogs as `dijit._underlay`
		//
		//		The underlay itself can be styled based on and id:
		//	|	#myDialog_underlay { background-color:red; }
		//
		//		In the case of `dijit.Dialog`, this id is based on the id of the Dialog,
		//		suffixed with _underlay.

		// Template has two divs; outer div is used for fade-in/fade-out, and also to hold background iframe.
		// Inner div has opacity specified in CSS file.
		templateString: "<div class='dijitDialogUnderlayWrapper'><div class='dijitDialogUnderlay' dojoAttachPoint='node'></div></div>",

		// Parameters on creation or updatable later

		// dialogId: String
		//		Id of the dialog.... DialogUnderlay's id is based on this id
		dialogId: "",

		// class: String
		//		This class name is used on the DialogUnderlay node, in addition to dijitDialogUnderlay
		"class": "",

		attributeMap: { id: "domNode" },

		_setDialogIdAttr: function(id){
			dojo.attr(this.node, "id", id + "_underlay");
			this._set("dialogId", id);
		},

		_setClassAttr: function(clazz){
			this.node.className = "dijitDialogUnderlay " + clazz;
			this._set("class", clazz);
		},

		postCreate: function(){
			// summary:
			//		Append the underlay to the body
			dojo.body().appendChild(this.domNode);
		},

		layout: function(){
			// summary:
			//		Sets the background to the size of the viewport
			//
			// description:
			//		Sets the background to the size of the viewport (rather than the size
			//		of the document) since we need to cover the whole browser window, even
			//		if the document is only a few lines long.
			// tags:
			//		private

			var is = this.node.style,
				os = this.domNode.style;

			// hide the background temporarily, so that the background itself isn't
			// causing scrollbars to appear (might happen when user shrinks browser
			// window and then we are called to resize)
			os.display = "none";

			// then resize and show
			var viewport = dojo.window.getBox();
			os.top = viewport.t + "px";
			os.left = viewport.l + "px";
			is.width = viewport.w + "px";
			is.height = viewport.h + "px";
			os.display = "block";
		},

		show: function(){
			// summary:
			//		Show the dialog underlay
			this.domNode.style.display = "block";
			this.layout();
			this.bgIframe = new dijit.BackgroundIframe(this.domNode);
		},

		hide: function(){
			// summary:
			//		Hides the dialog underlay
			this.bgIframe.destroy();
			delete this.bgIframe;
			this.domNode.style.display = "none";
		}
	}
);

}

if(!dojo._hasResource["dijit.TooltipDialog"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.TooltipDialog"] = true;
dojo.provide("dijit.TooltipDialog");






dojo.declare(
		"dijit.TooltipDialog",
		[dijit.layout.ContentPane, dijit._Templated, dijit.form._FormMixin, dijit._DialogMixin],
		{
			// summary:
			//		Pops up a dialog that appears like a Tooltip

			// title: String
			// 		Description of tooltip dialog (required for a11y)
			title: "",

			// doLayout: [protected] Boolean
			//		Don't change this parameter from the default value.
			//		This ContentPane parameter doesn't make sense for TooltipDialog, since TooltipDialog
			//		is never a child of a layout container, nor can you specify the size of
			//		TooltipDialog in order to control the size of an inner widget.
			doLayout: false,

			// autofocus: Boolean
			// 		A Toggle to modify the default focus behavior of a Dialog, which
			// 		is to focus on the first dialog element after opening the dialog.
			//		False will disable autofocusing. Default: true
			autofocus: true,

			// baseClass: [protected] String
			//		The root className to use for the various states of this widget
			baseClass: "dijitTooltipDialog",

			// _firstFocusItem: [private] [readonly] DomNode
			//		The pointer to the first focusable node in the dialog.
			//		Set by `dijit._DialogMixin._getFocusItems`.
			_firstFocusItem: null,

			// _lastFocusItem: [private] [readonly] DomNode
			//		The pointer to which node has focus prior to our dialog.
			//		Set by `dijit._DialogMixin._getFocusItems`.
			_lastFocusItem: null,

			templateString: dojo.cache("dijit", "templates/TooltipDialog.html", "<div role=\"presentation\" tabIndex=\"-1\">\n\t<div class=\"dijitTooltipContainer\" role=\"presentation\">\n\t\t<div class =\"dijitTooltipContents dijitTooltipFocusNode\" dojoAttachPoint=\"containerNode\" role=\"dialog\"></div>\n\t</div>\n\t<div class=\"dijitTooltipConnector\" role=\"presentation\"></div>\n</div>\n"),

			_setTitleAttr: function(/*String*/ title){
				this.containerNode.title = title;
				this._set("title", title)
			},

			postCreate: function(){
				this.inherited(arguments);
				this.connect(this.containerNode, "onkeypress", "_onKey");
			},

			orient: function(/*DomNode*/ node, /*String*/ aroundCorner, /*String*/ corner){
				// summary:
				//		Configure widget to be displayed in given position relative to the button.
				//		This is called from the dijit.popup code, and should not be called
				//		directly.
				// tags:
				//		protected
				var newC = "dijitTooltipAB" + (corner.charAt(1) == 'L' ? "Left" : "Right")
						+ " dijitTooltip"
						+ (corner.charAt(0) == 'T' ? "Below" : "Above");
				
				dojo.replaceClass(this.domNode, newC, this._currentOrientClass || "");
				this._currentOrientClass = newC;
			},

			focus: function(){
				// summary:
				//		Focus on first field
				this._getFocusItems(this.containerNode);
				dijit.focus(this._firstFocusItem);
			},

			onOpen: function(/*Object*/ pos){
				// summary:
				//		Called when dialog is displayed.
				//		This is called from the dijit.popup code, and should not be called directly.
				// tags:
				//		protected

				this.orient(this.domNode,pos.aroundCorner, pos.corner);
				this._onShow(); // lazy load trigger
			},

			onClose: function(){
				// summary:
				//		Called when dialog is hidden.
				//		This is called from the dijit.popup code, and should not be called directly.
				// tags:
				//		protected
				this.onHide();
			},

			_onKey: function(/*Event*/ evt){
				// summary:
				//		Handler for keyboard events
				// description:
				//		Keep keyboard focus in dialog; close dialog on escape key
				// tags:
				//		private

				var node = evt.target;
				var dk = dojo.keys;
				if(evt.charOrCode === dk.TAB){
					this._getFocusItems(this.containerNode);
				}
				var singleFocusItem = (this._firstFocusItem == this._lastFocusItem);
				if(evt.charOrCode == dk.ESCAPE){
					// Use setTimeout to avoid crash on IE, see #10396.
					setTimeout(dojo.hitch(this, "onCancel"), 0);
					dojo.stopEvent(evt);
				}else if(node == this._firstFocusItem && evt.shiftKey && evt.charOrCode === dk.TAB){
					if(!singleFocusItem){
						dijit.focus(this._lastFocusItem); // send focus to last item in dialog
					}
					dojo.stopEvent(evt);
				}else if(node == this._lastFocusItem && evt.charOrCode === dk.TAB && !evt.shiftKey){
					if(!singleFocusItem){
						dijit.focus(this._firstFocusItem); // send focus to first item in dialog
					}
					dojo.stopEvent(evt);
				}else if(evt.charOrCode === dk.TAB){
					// we want the browser's default tab handling to move focus
					// but we don't want the tab to propagate upwards
					evt.stopPropagation();
				}
			}
		}
	);

}

if(!dojo._hasResource["dijit.Dialog"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.Dialog"] = true;
dojo.provide("dijit.Dialog");















// dijit/TooltipDialog required for back-compat.  TODO: remove in 2.0

/*=====
dijit._underlay = function(kwArgs){
	// summary:
	//		A shared instance of a `dijit.DialogUnderlay`
	//
	// description:
	//		A shared instance of a `dijit.DialogUnderlay` created and
	//		used by `dijit.Dialog`, though never created until some Dialog
	//		or subclass thereof is shown.
};
=====*/
dojo.declare(
	"dijit._DialogBase",
	[dijit._Templated, dijit.form._FormMixin, dijit._DialogMixin, dijit._CssStateMixin],
	{
		// summary:
		//		A modal dialog Widget
		//
		// description:
		//		Pops up a modal dialog window, blocking access to the screen
		//		and also graying out the screen Dialog is extended from
		//		ContentPane so it supports all the same parameters (href, etc.)
		//
		// example:
		// |	<div dojoType="dijit.Dialog" href="test.html"></div>
		//
		// example:
		// |	var foo = new dijit.Dialog({ title: "test dialog", content: "test content" };
		// |	dojo.body().appendChild(foo.domNode);
		// |	foo.startup();

		templateString: dojo.cache("dijit", "templates/Dialog.html", "<div class=\"dijitDialog\" role=\"dialog\" aria-labelledby=\"${id}_title\">\n\t<div dojoAttachPoint=\"titleBar\" class=\"dijitDialogTitleBar\">\n\t<span dojoAttachPoint=\"titleNode\" class=\"dijitDialogTitle\" id=\"${id}_title\"></span>\n\t<span dojoAttachPoint=\"closeButtonNode\" class=\"dijitDialogCloseIcon\" dojoAttachEvent=\"ondijitclick: onCancel\" title=\"${buttonCancel}\" role=\"button\" tabIndex=\"-1\">\n\t\t<span dojoAttachPoint=\"closeText\" class=\"closeText\" title=\"${buttonCancel}\">x</span>\n\t</span>\n\t</div>\n\t\t<div dojoAttachPoint=\"containerNode\" class=\"dijitDialogPaneContent\"></div>\n</div>\n"),
		
		baseClass: "dijitDialog",
		
		cssStateNodes: {
			closeButtonNode: "dijitDialogCloseIcon"
		},

		attributeMap: dojo.delegate(dijit._Widget.prototype.attributeMap, {
			title: [
				{ node: "titleNode", type: "innerHTML" },
				{ node: "titleBar", type: "attribute" }
			],
			"aria-describedby":""
		}),

		// open: [readonly] Boolean
		//		True if Dialog is currently displayed on screen.
		open: false,

		// duration: Integer
		//		The time in milliseconds it takes the dialog to fade in and out
		duration: dijit.defaultDuration,

		// refocus: Boolean
		// 		A Toggle to modify the default focus behavior of a Dialog, which
		// 		is to re-focus the element which had focus before being opened.
		//		False will disable refocusing. Default: true
		refocus: true,

		// autofocus: Boolean
		// 		A Toggle to modify the default focus behavior of a Dialog, which
		// 		is to focus on the first dialog element after opening the dialog.
		//		False will disable autofocusing. Default: true
		autofocus: true,

		// _firstFocusItem: [private readonly] DomNode
		//		The pointer to the first focusable node in the dialog.
		//		Set by `dijit._DialogMixin._getFocusItems`.
		_firstFocusItem: null,

		// _lastFocusItem: [private readonly] DomNode
		//		The pointer to which node has focus prior to our dialog.
		//		Set by `dijit._DialogMixin._getFocusItems`.
		_lastFocusItem: null,

		// doLayout: [protected] Boolean
		//		Don't change this parameter from the default value.
		//		This ContentPane parameter doesn't make sense for Dialog, since Dialog
		//		is never a child of a layout container, nor can you specify the size of
		//		Dialog in order to control the size of an inner widget.
		doLayout: false,

		// draggable: Boolean
		//		Toggles the moveable aspect of the Dialog. If true, Dialog
		//		can be dragged by it's title. If false it will remain centered
		//		in the viewport.
		draggable: true,

		//aria-describedby: String
		//		Allows the user to add an aria-describedby attribute onto the dialog.   The value should
		//		be the id of the container element of text that describes the dialog purpose (usually
		//		the first text in the dialog).
		//		<div dojoType="dijit.Dialog" aria-describedby="intro" .....>
		//			<div id="intro">Introductory text</div>
		//			<div>rest of dialog contents</div>
		//		</div>
		"aria-describedby":"",

		postMixInProperties: function(){
			var _nlsResources = dojo.i18n.getLocalization("dijit", "common");
			dojo.mixin(this, _nlsResources);
			this.inherited(arguments);
		},

		postCreate: function(){
			dojo.style(this.domNode, {
				display: "none",
				position:"absolute"
			});
			dojo.body().appendChild(this.domNode);

			this.inherited(arguments);

			this.connect(this, "onExecute", "hide");
			this.connect(this, "onCancel", "hide");
			this._modalconnects = [];
		},

		onLoad: function(){
			// summary:
			//		Called when data has been loaded from an href.
			//		Unlike most other callbacks, this function can be connected to (via `dojo.connect`)
			//		but should *not* be overridden.
			// tags:
			//		callback

			// when href is specified we need to reposition the dialog after the data is loaded
			// and find the focusable elements
			this._position();
			if(this.autofocus && dijit._DialogLevelManager.isTop(this)){
				this._getFocusItems(this.domNode);
				dijit.focus(this._firstFocusItem);
			}
			this.inherited(arguments);
		},

		_endDrag: function(e){
			// summary:
			//		Called after dragging the Dialog. Saves the position of the dialog in the viewport.
			// tags:
			//		private
			if(e && e.node && e.node === this.domNode){
				this._relativePosition = dojo.position(e.node);
			}
		},

		_setup: function(){
			// summary:
			//		Stuff we need to do before showing the Dialog for the first
			//		time (but we defer it until right beforehand, for
			//		performance reasons).
			// tags:
			//		private

			var node = this.domNode;

			if(this.titleBar && this.draggable){
				this._moveable = (dojo.isIE == 6) ?
					new dojo.dnd.TimedMoveable(node, { handle: this.titleBar }) :	// prevent overload, see #5285
					new dojo.dnd.Moveable(node, { handle: this.titleBar, timeout: 0 });
				this._dndListener = dojo.subscribe("/dnd/move/stop",this,"_endDrag");
			}else{
				dojo.addClass(node,"dijitDialogFixed");
			}

			this.underlayAttrs = {
				dialogId: this.id,
				"class": dojo.map(this["class"].split(/\s/), function(s){ return s+"_underlay"; }).join(" ")
			};
		},

		_size: function(){
			// summary:
			// 		If necessary, shrink dialog contents so dialog fits in viewport
			// tags:
			//		private

			this._checkIfSingleChild();

			// If we resized the dialog contents earlier, reset them back to original size, so
			// that if the user later increases the viewport size, the dialog can display w/out a scrollbar.
			// Need to do this before the dojo.marginBox(this.domNode) call below.
			if(this._singleChild){
				if(this._singleChildOriginalStyle){
					this._singleChild.domNode.style.cssText = this._singleChildOriginalStyle;
				}
				delete this._singleChildOriginalStyle;
			}else{
				dojo.style(this.containerNode, {
					width:"auto",
					height:"auto"
				});
			}

			var mb = dojo._getMarginSize(this.domNode);
			var viewport = dojo.window.getBox();
			if(mb.w >= viewport.w || mb.h >= viewport.h){
				// Reduce size of dialog contents so that dialog fits in viewport

				var w = Math.min(mb.w, Math.floor(viewport.w * 0.75)),
					h = Math.min(mb.h, Math.floor(viewport.h * 0.75));

				if(this._singleChild && this._singleChild.resize){
					this._singleChildOriginalStyle = this._singleChild.domNode.style.cssText;
					this._singleChild.resize({w: w, h: h});
				}else{
					dojo.style(this.containerNode, {
						width: w + "px",
						height: h + "px",
						overflow: "auto",
						position: "relative"	// workaround IE bug moving scrollbar or dragging dialog
					});
				}
			}else{
				if(this._singleChild && this._singleChild.resize){
					this._singleChild.resize();
				}
			}
		},

		_position: function(){
			// summary:
			//		Position modal dialog in the viewport. If no relative offset
			//		in the viewport has been determined (by dragging, for instance),
			//		center the node. Otherwise, use the Dialog's stored relative offset,
			//		and position the node to top: left: values based on the viewport.
			// tags:
			//		private
			if(!dojo.hasClass(dojo.body(),"dojoMove")){
				var node = this.domNode,
					viewport = dojo.window.getBox(),
					p = this._relativePosition,
					bb = p ? null : dojo._getBorderBox(node),
					l = Math.floor(viewport.l + (p ? p.x : (viewport.w - bb.w) / 2)),
					t = Math.floor(viewport.t + (p ? p.y : (viewport.h - bb.h) / 2))
				;
				dojo.style(node,{
					left: l + "px",
					top: t + "px"
				});
			}
		},

		_onKey: function(/*Event*/ evt){
			// summary:
			//		Handles the keyboard events for accessibility reasons
			// tags:
			//		private

			if(evt.charOrCode){
				var dk = dojo.keys;
				var node = evt.target;
				if(evt.charOrCode === dk.TAB){
					this._getFocusItems(this.domNode);
				}
				var singleFocusItem = (this._firstFocusItem == this._lastFocusItem);
				// see if we are shift-tabbing from first focusable item on dialog
				if(node == this._firstFocusItem && evt.shiftKey && evt.charOrCode === dk.TAB){
					if(!singleFocusItem){
						dijit.focus(this._lastFocusItem); // send focus to last item in dialog
					}
					dojo.stopEvent(evt);
				}else if(node == this._lastFocusItem && evt.charOrCode === dk.TAB && !evt.shiftKey){
					if(!singleFocusItem){
						dijit.focus(this._firstFocusItem); // send focus to first item in dialog
					}
					dojo.stopEvent(evt);
				}else{
					// see if the key is for the dialog
					while(node){
						if(node == this.domNode || dojo.hasClass(node, "dijitPopup")){
							if(evt.charOrCode == dk.ESCAPE){
								this.onCancel();
							}else{
								return; // just let it go
							}
						}
						node = node.parentNode;
					}
					// this key is for the disabled document window
					if(evt.charOrCode !== dk.TAB){ // allow tabbing into the dialog for a11y
						dojo.stopEvent(evt);
					// opera won't tab to a div
					}else if(!dojo.isOpera){
						try{
							this._firstFocusItem.focus();
						}catch(e){ /*squelch*/ }
					}
				}
			}
		},

		show: function(){
			// summary:
			//		Display the dialog
			// returns: dojo.Deferred
			//		Deferred object that resolves when the display animation is complete

			if(this.open){ return; }

			if(!this._started){
				this.startup();
			}

			// first time we show the dialog, there's some initialization stuff to do
			if(!this._alreadyInitialized){
				this._setup();
				this._alreadyInitialized=true;
			}

			if(this._fadeOutDeferred){
				this._fadeOutDeferred.cancel();
			}

			this._modalconnects.push(dojo.connect(window, "onscroll", this, "layout"));
			this._modalconnects.push(dojo.connect(window, "onresize", this, function(){
				// IE gives spurious resize events and can actually get stuck
				// in an infinite loop if we don't ignore them
				var viewport = dojo.window.getBox();
				if(!this._oldViewport ||
						viewport.h != this._oldViewport.h ||
						viewport.w != this._oldViewport.w){
					this.layout();
					this._oldViewport = viewport;
				}
			}));
			this._modalconnects.push(dojo.connect(this.domNode, "onkeypress", this, "_onKey"));

			dojo.style(this.domNode, {
				opacity:0,
				display:""
			});

			this._set("open", true);
			this._onShow(); // lazy load trigger

			this._size();
			this._position();

			// fade-in Animation object, setup below
			var fadeIn;

			this._fadeInDeferred = new dojo.Deferred(dojo.hitch(this, function(){
				fadeIn.stop();
				delete this._fadeInDeferred;
			}));

			fadeIn = dojo.fadeIn({
				node: this.domNode,
				duration: this.duration,
				beforeBegin: dojo.hitch(this, function(){
					dijit._DialogLevelManager.show(this, this.underlayAttrs);
				}),
				onEnd: dojo.hitch(this, function(){
					if(this.autofocus && dijit._DialogLevelManager.isTop(this)){
						// find focusable items each time dialog is shown since if dialog contains a widget the
						// first focusable items can change
						this._getFocusItems(this.domNode);
						dijit.focus(this._firstFocusItem);
					}
					this._fadeInDeferred.callback(true);
					delete this._fadeInDeferred;
				})
			}).play();
			
			return this._fadeInDeferred;
		},

		hide: function(){
			// summary:
			//		Hide the dialog
			// returns: dojo.Deferred
			//		Deferred object that resolves when the hide animation is complete

			// if we haven't been initialized yet then we aren't showing and we can just return
			if(!this._alreadyInitialized){
				return;
			}
			if(this._fadeInDeferred){
				this._fadeInDeferred.cancel();
			}

			// fade-in Animation object, setup below
			var fadeOut;

			this._fadeOutDeferred = new dojo.Deferred(dojo.hitch(this, function(){
				fadeOut.stop();
				delete this._fadeOutDeferred;
			}));

			fadeOut = dojo.fadeOut({
				node: this.domNode,
				duration: this.duration,
				onEnd: dojo.hitch(this, function(){
					this.domNode.style.display = "none";
					dijit._DialogLevelManager.hide(this);
					this.onHide();
					this._fadeOutDeferred.callback(true);
					delete this._fadeOutDeferred;
				})
			 }).play();

			if(this._scrollConnected){
				this._scrollConnected = false;
			}
			dojo.forEach(this._modalconnects, dojo.disconnect);
			this._modalconnects = [];

			if(this._relativePosition){
				delete this._relativePosition;
			}
			this._set("open", false);

			return this._fadeOutDeferred;
		},

		layout: function(){
			// summary:
			//		Position the Dialog and the underlay
			// tags:
			//		private
			if(this.domNode.style.display != "none"){
				if(dijit._underlay){	// avoid race condition during show()
					dijit._underlay.layout();
				}
				this._position();
			}
		},

		destroy: function(){
			if(this._fadeInDeferred){
				this._fadeInDeferred.cancel();
			}
			if(this._fadeOutDeferred){
				this._fadeOutDeferred.cancel();
			}
			if(this._moveable){
				this._moveable.destroy();
			}
			if(this._dndListener){
				dojo.unsubscribe(this._dndListener);
			}
			dojo.forEach(this._modalconnects, dojo.disconnect);

			dijit._DialogLevelManager.hide(this);

			this.inherited(arguments);
		}
	}
);

dojo.declare(
	"dijit.Dialog",
	[dijit.layout.ContentPane, dijit._DialogBase],
	{}
);

dijit._DialogLevelManager = {
	// summary:
	//		Controls the various active "levels" on the page, starting with the
	//		stuff initially visible on the page (at z-index 0), and then having an entry for
	//		each Dialog shown.

	show: function(/*dijit._Widget*/ dialog, /*Object*/ underlayAttrs){
		// summary:
		//		Call right before fade-in animation for new dialog.
		//		Saves current focus, displays/adjusts underlay for new dialog,
		//		and sets the z-index of the dialog itself.
		//
		//		New dialog will be displayed on top of all currently displayed dialogs.
		//
		//		Caller is responsible for setting focus in new dialog after the fade-in
		//		animation completes.

		var ds = dijit._dialogStack;

		// Save current focus
		ds[ds.length-1].focus = dijit.getFocus(dialog);

		// Display the underlay, or if already displayed then adjust for this new dialog
		var underlay = dijit._underlay;
		if(!underlay || underlay._destroyed){
			underlay = dijit._underlay = new dijit.DialogUnderlay(underlayAttrs);
		}else{
			underlay.set(dialog.underlayAttrs);
		}

		// Set z-index a bit above previous dialog
		var zIndex = ds[ds.length-1].dialog ? ds[ds.length-1].zIndex + 2 : 950;
		if(ds.length == 1){	// first dialog
			underlay.show();
		}
		dojo.style(dijit._underlay.domNode, 'zIndex', zIndex - 1);

		// Dialog
		dojo.style(dialog.domNode, 'zIndex', zIndex);

		ds.push({dialog: dialog, underlayAttrs: underlayAttrs, zIndex: zIndex});
	},

	hide: function(/*dijit._Widget*/ dialog){
		// summary:
		//		Called when the specified dialog is hidden/destroyed, after the fade-out
		//		animation ends, in order to reset page focus, fix the underlay, etc.
		//		If the specified dialog isn't open then does nothing.
		//
		//		Caller is responsible for either setting display:none on the dialog domNode,
		//		or calling dijit.popup.hide(), or removing it from the page DOM.

		var ds = dijit._dialogStack;

		if(ds[ds.length-1].dialog == dialog){
			// Removing the top (or only) dialog in the stack, return focus
			// to previous dialog

			ds.pop();

			var pd = ds[ds.length-1];	// the new active dialog (or the base page itself)

			// Adjust underlay
			if(ds.length == 1){
				// Returning to original page.
				// Hide the underlay, unless the underlay widget has already been destroyed
				// because we are being called during page unload (when all widgets are destroyed)
				if(!dijit._underlay._destroyed){
					dijit._underlay.hide();
				}
			}else{
				// Popping back to previous dialog, adjust underlay
				dojo.style(dijit._underlay.domNode, 'zIndex', pd.zIndex - 1);
				dijit._underlay.set(pd.underlayAttrs);
			}

			// Adjust focus
			if(dialog.refocus){
				// If we are returning control to a previous dialog but for some reason
				// that dialog didn't have a focused field, set focus to first focusable item.
				// This situation could happen if two dialogs appeared at nearly the same time,
				// since a dialog doesn't set it's focus until the fade-in is finished.
				var focus = pd.focus;
				if(!focus || (pd.dialog && !dojo.isDescendant(focus.node, pd.dialog.domNode))){
					pd.dialog._getFocusItems(pd.dialog.domNode);
					focus = pd.dialog._firstFocusItem;
				}
	
				try{
					dijit.focus(focus);
				}catch(e){
					/* focus() will fail if user opened the dialog by clicking a non-focusable element */
				}
			}
		}else{
			// Removing a dialog out of order (#9944, #10705).
			// Don't need to mess with underlay or z-index or anything.
			var idx = dojo.indexOf(dojo.map(ds, function(elem){return elem.dialog}), dialog);
			if(idx != -1){
				ds.splice(idx, 1);
			}
		}
	},

	isTop: function(/*dijit._Widget*/ dialog){
		// summary:
		//		Returns true if specified Dialog is the top in the task
		var ds = dijit._dialogStack;
		return ds[ds.length-1].dialog == dialog;
	}
};

// Stack representing the various active "levels" on the page, starting with the
// stuff initially visible on the page (at z-index 0), and then having an entry for
// each Dialog shown.
// Each element in stack has form {
//		dialog: dialogWidget,
//		focus: returnFromGetFocus(),
//		underlayAttrs: attributes to set on underlay (when this widget is active)
// }
dijit._dialogStack = [
	{dialog: null, focus: null, underlayAttrs: null}	// entry for stuff at z-index: 0
];

}

if(!dojo._hasResource["plugins.dijit.SyncDialog"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.dijit.SyncDialog"] = true;
dojo.provide("plugins.dijit.SyncDialog");

// HAS A




// INHERITS


dojo.declare( "plugins.dijit.SyncDialog",
	[ dijit._Widget, dijit._Templated, plugins.core.Common ], {
	
//Path to the template of this widget. 
templateString:"<div dojoAttachPoint=\"containerNode\">\n\n    <table\n        cellspacing=\"0px\"\n        height=\"300px\" width=\"100%\" style=\"padding: 0; margin: 0;\"\n        class=\"syncDialog\">\n        <tr>\n            <td align=\"center\">\n                \n                <div\n                    dojoAttachPoint=\"dialog\"\n                    dojoType=\"dijit.Dialog\"\n                    closeText=\"false\"\n                    title=\"Sync\"\n                    style=\"margin-right: auto; margin-left: auto; text-align: center;\"\n                    >\n                    \n                    <table\n                        cellpadding=\"0\"\n                        cellspacing=\"0\"\n                        class=\"syncDialog\"\n                        width=\"100%\"\n                        >\n\n                        <tr class=\"header\" align=\"center\">\n                            <td\n                                align=\"center\"\n                                dojoAttachPoint=\"headerNode\"\n                                colspan=\"2\">${header}</td>\n                        </tr>\n\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td align=center\n                                class=\"sublabel\">Commit Message</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td colspan=\"2\">\n\t\t\t\t\t\t\t\t<input\n\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"message\"\n\t\t\t\t\t\t\t\t\tclass=\"message\"\n\t\t\t\t\t\t\t\t\tdojoType=\"dijit.form.ValidationTextBox\"\n\t\t\t\t\t\t\t\t\ttype=\"text\"\n\t\t\t\t\t\t\t\t\tmaxlength=\"52\"\n\t\t\t\t\t\t\t\t\tregExpGen=\"return '[^;^`]{1,52}'\"\n\t\t\t\t\t\t\t\t\tinvalidMessage=\"Max 52 characters, no ';' or '`'\"\n\t\t\t\t\t\t\t\t\tpromptMessage=\"Max 52 characters, no ';' or '`'\"\n\t\t\t\t\t\t\t\t\tvalue=\"\"\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t</tr>\n\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td align=center\n                                class=\"sublabel\">Details</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td colspan=\"2\">\n\t\t\t\t\t\t\t\t<textarea\n\t\t\t\t\t\t\t\t\tspellcheck=\"false\"\n\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"details\"\n\t\t\t\t\t\t\t\t\tclass=\"details\"\n\t\t\t\t\t\t\t\t\tstyle=\"width:100%;\";\n\t\t\t\t\t\t\t\t\tcols=\"40\"\n\t\t\t\t\t\t\t\t\trows=\"10\"></textarea>\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t</tr>\n\n                        \n                        <tr>\n                            <td colspan=\"2\"\n                                align=\"center\"\n                                class=\"enterButton\">\n                                <button\n                                    dojoType=\"dijit.form.Button\"\n                                    type=\"button\"\n                                    label=\"Enter\"\n                                    dojoAttachEvent=\"onClick:doEnter\"\n                                    >\n                                </button>\n                            </td>\n                        </tr>\n                        \n                        \n                    </table>\n\n                </div>\n            \n            </td>\n        </tr>\n    </table>\n</div>\n",

// OR USE @import IN HTML TEMPLATE
cssFiles : [
	dojo.moduleUrl("plugins", "dijit/css/syncdialog.css")
],

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

// PARENT plugins.workflow.Apps WIDGET
parentWidget : null,

// DISPLAYED MESSAGE 
message : null,

//////}}
constructor : function(args) {
	console.log("SyncDialog.constructor    args:");
	console.dir({args:args});

	// LOAD CSS
	this.loadCSS();
},
postCreate : function() {
	//////console.log("SyncDialog.postCreate    plugins.dijit.SyncDialog.postCreate()");

	this.startup();
},
startup : function () {
	////console.log("SyncDialog.startup    plugins.dijit.SyncDialog.startup()");
	////console.log("SyncDialog.startup    this.parentWidget: " + this.parentWidget);

	this.inherited(arguments);

	// SET UP DIALOG
	this.setDialogue();

	// SET KEY LISTENER		
	this.setKeyListener();
	
	// ADD CSS NAMESPACE CLASS FOR TITLE CSS STYLING
	this.setNamespaceClass("syncDialog");
},
setKeyListener : function () {
	dojo.connect(this.dialog, "onkeypress", dojo.hitch(this, "handleOnKeyPress"));
},
handleOnKeyPress: function (event) {
	var key = event.charOrCode;
	console.log("SyncDialog.handleOnKeyPress    key: " + key);
	if ( key == null )	return;
	event.stopPropagation();
	
	if ( key == dojo.keys.ESCAPE )	this.hide();
},
setNamespaceClass : function (ccsClass) {
// ADD CSS NAMESPACE CLASS
	dojo.addClass(this.dialog.domNode, ccsClass);
	dojo.addClass(this.dialog.titleNode, ccsClass);
	dojo.addClass(this.dialog.closeButtonNode, ccsClass);	
},
show: function () {
// SHOW THE DIALOGUE
	this.dialog.show();
	this.message.focus();
},
hide: function () {
// HIDE THE DIALOGUE
	this.dialog.hide();
},
doEnter : function(type) {
// RUN ENTER CALLBACK IF 'ENTER' CLICKED
	console.log("SyncDialog.doEnter    plugins.dijit.SyncDialog.doEnter()");

	var inputs = this.validateInputs(["message", "details"]);
	console.log("SyncDialog.doEnter    inputs:");
	console.dir({inputs:inputs});
	if ( ! inputs ) {
		console.log("SyncDialog.doEnter    inputs is null. Returning");
		return;
	}

	// RESET
	this.message.set('value', "");
	this.details.value = "";

    // HIDE
    this.hide();
	
	// DO CALLBACK
	this.dialog.enterCallback(inputs);	
},
validateInputs : function (keys) {
	console.log("Hub.validateInputs    keys: ");
	console.dir({keys:keys});

	var inputs = new Object;
	this.isValid = true;
	for ( var i = 0; i < keys.length; i++ ) {
		console.log("Hub.validateInputs    Doing keys[" + i + "]: " + keys[i]);
		inputs[keys[i]] = this.verifyInput(keys[i]);
	}
	console.log("Hub.validateInputs    inputs: ");
	console.dir({inputs:inputs});

	if ( ! this.isValid ) 	return null;	
	return inputs;
},
verifyInput : function (input) {
	console.log("Aws.verifyInput    input: ");
	console.dir({this_input:this[input]});
	var value = this[input].value;
	console.log("Aws.verifyInput    value: " + value);

	var className = this.getClassName(this[input]);
	console.log("Aws.verifyInput    className: " + className);
	if ( className ) {
		console.log("Aws.verifyInput    this[input].isValid(): " + this[input].isValid());
		if ( ! value || ! this[input].isValid() ) {
			console.log("Aws.verifyInput    input " + input + " value is empty. Adding class 'invalid'");
			dojo.addClass(this[input].domNode, 'invalid');
			this.isValid = false;
		}
		else {
			console.log("SyncDialog.verifyInput    value is NOT empty. Removing class 'invalid'");
			dojo.removeClass(this[input].domNode, 'invalid');
			return value;
		}
	}
	else {
		if ( input.match(/;/) || input.match(/`/) ) {
			console.log("SyncDialog.verifyInput    value is INVALID. Adding class 'invalid'");
			dojo.addClass(this[input], 'invalid');
			this.isValid = false;
			return null;
		}
		else {
			console.log("SyncDialog.verifyInput    value is VALID. Removing class 'invalid'");
			dojo.removeClass(this[input], 'invalid');
			return value;
		}
	}
	
	return null;
},
doCancel : function() {
// RUN CANCEL CALLBACK IF 'CANCEL' CLICKED
	////console.log("SyncDialog.doCancel    plugins.dijit.SyncDialog.doCancel()");
	this.dialog.cancelCallback();
	this.dialog.hide();
},
setDialogue : function () {
	// APPEND DIALOG TO DOCUMENT
	document.body.appendChild(this.dialog.domNode);
	
	this.dialog.parentWidget = this;
	
	// AVOID this._fadeOutDeferred NOT DEFINED ERROR
	this._fadeOutDeferred = function () {};
},
load : function (args) {
	console.log("SyncDialog.load    args:");
	console.dir({args:args});

    if ( args.title ) {
        console.log("SyncDialog.load    SETTING TITLE: " + args.title);
    	this.dialog.set('title', args.title);
    }
    
	this.headerNode.innerHTML		=	args.header;
	if (args.message)	this.message.set('value', args.message);
	if (args.details) 	this.details.value = args.details;
	//if (args.details) 	this.details.innerHTML(args.details);
	this.dialog.enterCallback		=	args.enterCallback;

	this.show();
}


});
	

}

if(!dojo._hasResource["plugins.apps.AppRow"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.apps.AppRow"] = true;
dojo.provide("plugins.apps.AppRow");

dojo.declare( "plugins.apps.AppRow",
	[ dijit._Widget, dijit._Templated ], {
//Path to the template of this widget. 
templateString:"<div dojoAttachPoint=\"containerNode\">\n    <table width=\"100%\" cellspacing=\"2\">\n        <tr>\n            <td\n                colspan=\"2\"\n                dojoAttachPoint=\"name\"\n                class=\"name\"\n\t\t\t\ttitle=\"name: Name of application\"\n                >${name}</td>\n            <td\n                colspan=\"1\"\n                dojoAttachPoint=\"type\"\n                class=\"type\"\n\t\t\t\ttitle=\"type: Type of application (e.g., 'pipeline', 'converter', 'utility')\"\n                >${type}</td>\n        </tr>\n\n<!-- TOGGLED PORTION STARTS HERE -->\n<!-- TOGGLED PORTION STARTS HERE -->\n<!-- TOGGLED PORTION STARTS HERE -->\n\n\t\t\n        <tr>\n            <td\n                colspan=\"1\"\n                dojoAttachPoint=\"executor\"\n                class=\"executor\"\n\t\t\t\ttitle=\"executor: Additional executable used to run application (e.g., '/usr/bin/perl')\"\n            >${executor}</td>\n\n            <td \n                colspan=\"1\"\n                dojoAttachPoint=\"packageCombo\"\n                class=\"package\"\n\t\t\t\ttitle=\"package: Package to which the application belongs\"\n            >${package}</td>\n            \n            <td colspan=\"1\"\n                class=\"localonly\"\n                title=\"localonly: Select to make application only executable locally (e.g., a herder that manages cluster jobs)\"\n                dojoAttachPoint=\"localonlyContainer\"\n            >\n                <span>\n                    Local Only\n                </span>\n                \n                <span\n                    dojoAttachPoint=\"localonly\"\n                    dojoType=\"dijit.form.CheckBox\"\n                    dojoAttachEvent=\"onClick:submitChange\"\n                    checked=\"false\"\n                    class=\"newLocalOnlyCheckbox\"\n                ></span>\n            </td>\n\n        </tr>\n        <tr>\n\n            <td colspan=\"3\"\n                dojoAttachPoint=\"location\"\n                class='location'\n\t\t\t\ttitle=\"location: Absolute path (e.g., '/home/myname/myapp.pl') or path relative to Agua base folder (e.g., 'bin/apps/myScript.pl')\"\n            >${location}</td>\n\t\t\t\t\t\t\t\n\n        </tr>\n        <tr>\n            <td colspan=\"3\"\n                dojoAttachPoint=\"description\"\n                class='description'\n\t\t\t\ttitle=\"description: A brief description of the application\"\n            >${description}</td>\n        </tr>\n        <tr>\n            <td colspan=\"3\"\n                dojoAttachPoint=\"notes\"\n                class='notes'\n\t\t\t\ttitle=\"notes: Notes on the application (e.g., release notes, constraints)\"\n            >${notes}</td>\n        </tr>\n        <tr>\n            <td colspan=\"3\"\n                dojoAttachPoint=\"url\"\n                class='url'\n\t\t\t\ttitle=\"url: Web address of website providing further details (e.g., http://mysite.com/applications)\"\n\t\t\t>${url}</td>\n        </tr>\n    </table>\n</div>\n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

// PARENT plugins.apps.Apps WIDGET
parentWidget : null,

/////}}}

constructor : function(args) {
	////console.log("AppRow.constructor    plugins.workflow.AppRow.constructor()");
	////console.log("AppRow.constructor    args.submit: " + args.submit);
	this.checkboxOn = args.submit;
	this.parentWidget = args.parentWidget;
	this.formInputs = this.parentWidget.formInputs;
},


postCreate : function() {
	////////console.log("AppRow.postCreate    plugins.workflow.AppRow.postCreate()");

	this.startup();
},

startup : function () {
	//////console.log("AppRow.startup    plugins.workflow.AppRow.startup()");
	//////console.log("AppRow.startup    this.parentWidget: " + this.parentWidget);

	this.inherited(arguments);
	
	// CONNECT TOGGLE EVENT
	var thisObject = this;
	dojo.connect( this.name, "onclick", function(event) {
		thisObject.toggle();
	});

	// ADD 'EDIT' ONCLICKS
	var thisObject = this;
	var array = [ "executor", "location", "description", "notes", "url" ];
	for ( var i in array )
	{
		dojo.connect(this[array[i]], "onclick", function(event)
			{
				//////console.log("AppRow.startup    " + array[i] + " clicked");
				thisObject.parentWidget.editRow(thisObject, event.target);
				event.stopPropagation(); //Stop Event Bubbling
			}
		);
	}
	
	// USE this.checkboxOn TO DECIDE IF CHECKBOX IS SELECTED
	////console.log("AppRow.startup    this.checkboxOn: " + this.checkboxOn);
	if ( this.checkboxOn != null && this.checkboxOn == 1 )
	{
		////console.log("AppRow.startup    this.checkboxOn = " + this.checkboxOn + ". Setting this.submit to On");
		this.localonly.setValue("on");
	}
},

submitChange : function (event) {
// REGISTER CHECKBOX CHANGE
	//console.log("AppRow.submitChange    plugins.apps.AppRow.submitChange(event)");		
	//console.log("AppRow.submitChange    event: " + event);		

	event.stopPropagation(); //Stop Event Bubbling
	//console.log("AppRow.submitChange    Doing inputs = this.parentWidget.getFormInputs(this)");		

	// GET INPUTS
	var inputs = this.parentWidget.getFormInputs(this);
	if ( inputs == null ) return;
	this.parentWidget.saveInputs(inputs, {reload: false});
},

// TOGGLE HIDDEN DETAILS	
toggle : function () {
	////console.log("AppRow.toggle    plugins.workflow.AppRow.toggle()");
	//////console.log("AppRow.toggle    this.description: " + this.description);

	var array = [ "executor", "packageCombo", "location", "localonlyContainer", "description", "notes", "url" ];
	for ( var i in array )
	{
		console.log("AppRow.toggle    this[" + array[i] + "]: " + this[array[i]]);

		if ( this[array[i]].style.display == 'inline-block' )	
			this[array[i]].style.display='none';
		else
			this[array[i]].style.display = 'inline-block';
	}
}

});
	

}

if(!dojo._hasResource["plugins.apps.App"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.apps.App"] = true;
dojo.provide("plugins.apps.App");

// ALLOW THE USER TO ADD, REMOVE AND MODIFY APPS

// EXTERNAL MODULES









// INTERNAL MODULES




// SYNC DIALOG


// HAS A


dojo.declare("plugins.apps.App",
	[ dijit._Widget, dijit._Templated, plugins.core.Common, plugins.form.EditForm ],
{
		
//Path to the template of this widget. 
templateString:"<div dojoattachpoint=\"containerNode\">\n\n\t<!-- APPS TAB -->\n\t<div\n\t\tdojoAttachPoint=\"mainTab\"\n\t\tdojoType=\"dijit.layout.ContentPane\"\n\t\ttitle=\"Apps\"\n\t\tstyle=\"height: 100% !important; max-height: auto !important; width: 390px !important; padding: 0 !important;\"\n\t>\n\n<table width=\"100%\" class=\"app\">\n\t<tr valign=\"top\" width=\"100%\">\n\t\t<td colspan=\"2\" class=\"tabTitle\" align=\"center\">\n\t\t\tApps\n\t\t</td>\n\t</tr>\n\n\t<tr valign=\"top\" width=\"95%\">\n\t\t<td width=\"100%\">\n\t\t\t<table width=\"100%\">\n\t\t\t\t<tr>\n\t\t\t\t\t<td\n\t\t\t\t\t\tcolspan=\"3\"\n\t\t\t\t\t\tdojoAttachPoint=\"syncAppsButton\"\n\t\t\t\t\t\tclass=\"syncAppsButton\"\n\t\t\t\t\t\ttitle=\"Click to sync apps to biorepository\"\n\t\t\t\t\t\tdojoAttachEvent=\"onclick:showSyncDialog\"\n\t\t\t\t\t>\n\t\t\t\t\t\tSync\n\t\t\t\t\t</td>\n\t\t\t\t</tr>\n\n\t\t\t\t<tr width=\"100%\">\n\n\t\t\t\t\t<td colspan=\"3\" height=\"32px\">\n\t\t\t\t\t\t\n\t\t\t\t\t\t<table cellspacing=\"0\" cellpadding=\"0\" border=\"0\" style=\"padding: 0; margin: 0;\">\n\n\t\t\t\t\t\t\t<tr>\n\n\t\t\t\t\t\t\t\t<td \n\t\t\t\t\t\t\t\t\tstyle=\"padding-right: 10px;\" >\n\t\t\t\t\t\t\t\t\t<textarea\n\t\t\t\t\t\t\t\t\t\tspellcheck=\"false\"\n\t\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"name\"\n\t\t\t\t\t\t\t\t\t\tclass=\"name\"\n\t\t\t\t\t\t\t\t\t\tcols=\"30\"\n\t\t\t\t\t\t\t\t\t\trows=\"1\"\n\t\t\t\t\t\t\t\t\t\ttitle=\"name: Name of application\"\n\t\t\t\t\t\t\t\t\t\t>Name</textarea>\n\t\t\t\t\t\t\t\t</td>\n\t\n\t\t\t\t\t\t\t\t<td height=\"20px\"\n\t\t\t\t\t\t\t\t\twidth=\"120px\"\n\t\t\t\t\t\t\t\t\talign=\"right\">\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"addAppButton\"\n\t\t\t\t\t\t\t\t\t\tclass=\"addAppButton\"\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\tNew App\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t</table>\n\t\t\t\t\t</td>\n\n\t\t\t\t</tr>\n\n\t\t\t\t<tr class=\"headerRow\" width=\"100%\" height=\"8px\">\n\t\t\t\t\t<td width=\"33%\">Type</td>\n\t\t\t\t\t<td width=\"33%\">Executor</td>\n\t\t\t\t\t<td width=\"33%\">Package</td>\n\t\t\t\t</tr>\n\n\t\t\t\t<tr width=\"100%\">\n\t\t\t\t\t<td width=\"33%\">\n\t\t\t\t\t\t<textarea\n\t\t\t\t\t\t\tspellcheck=\"false\"\n\t\t\t\t\t\t\tdojoAttachPoint=\"type\"\n\t\t\t\t\t\t\tclass=\"type\"\n\t\t\t\t\t\t\tstyle=\"width: 100%; font-weight: bolder; font-family: Verdana;\";\n\t\t\t\t\t\t\tcols=\"40\"\n\t\t\t\t\t\t\trows=\"1\"\n\t\t\t\t\t\t\ttitle=\"type: Type of application (e.g., 'pipeline', 'converter', 'utility')\"\n\t\t\t\t\t\t\t>Type</textarea>\n\t\t\t\t\t</td>\n\n\t\t\t\t\t<td width=\"34%\"\n\t\t\t\t\t\tstyle=\"padding-left: 4px; padding-right: 4px;\" >\n\t\t\t\t\t\t<textarea\n\t\t\t\t\t\t\tspellcheck=\"false\"\n\t\t\t\t\t\t\tdojoAttachPoint=\"executor\"\n\t\t\t\t\t\t\tclass=\"executor\"\n\t\t\t\t\t\t\tstyle=\"width: 100%; font-weight: bolder; font-family: Verdana;\";\n\t\t\t\t\t\t\tcols=\"40\"\n\t\t\t\t\t\t\trows=\"1\"\n\t\t\t\t\t\t\ttitle=\"executor: Additional executable used to run application (e.g., '/usr/bin/perl')\"\n\t\t\t\t\t\t\t>Executor</textarea>\n\t\t\t\t\t</td>\n\n\t\t\t\t\t<td width=\"33%\">\n\t\t\t\t\t\t<div\n\t\t\t\t\t\t\tdojoAttachPoint=\"packageCombo\"\n\t\t\t\t\t\t\tdojoType=\"dijit.form.ComboBox\"\n\t\t\t\t\t\t\tclass=\"packageCombo\"\n\t\t\t\t\t\t\tautocomplete=\"true\"\n\t\t\t\t\t\t\thasDownArrow=\"true\"\n\t\t\t\t\t\t\tdisabled=\"false\"\n\t\t\t\t\t\t\tstyle=\"width: 150px;\"\n\t\t\t\t\t\t\ttitle=\"Select the order of the displayed applications\"\n\t\t\t\t\t\t>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</td>\n\t\t\t\t</tr>\n\n\t\t\t\t<tr class=\"headerRow\" width=\"100%\" height=\"8px\">\n\t\t\t\t\t<td width=\"67%\" colspan=\"2\">Location</td>\n\t\t\t\t\t<td width=\"33%\">&nbsp;</td>\n\t\t\t\t</tr>\n\n\t\t\t\t<tr width=\"100%\">\n\t\t\t\t\t<td colspan=\"2\">\n\t\t\t\t\t\t<textarea\n\t\t\t\t\t\t\tspellcheck=\"false\"\n\t\t\t\t\t\t\tdojoAttachPoint=\"location\"\n\t\t\t\t\t\t\tclass=\"location\"\n\t\t\t\t\t\t\tstyle=\"width: 100%; font-weight: bolder; font-family: Verdana;\";\n\t\t\t\t\t\t\tcols=\"40\"\n\t\t\t\t\t\t\trows=\"1\"\n\t\t\t\t\t\t\ttitle=\"location: Absolute path (e.g., '/home/myname/myapp.pl') or path relative to Agua base folder (e.g., 'bin/apps/myScript.pl')\"\n\t\t\t\t\t\t\t>Location</textarea>\n\t\t\t\t\t</td>\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t<td colspan=\"1\"\n\t\t\t\t\t\ttitle=\"localonly: Select so that application will only run locally (e.g., a herder that submits jobs to the cluster))\"\n\t\t\t\t\t>\n\t\t\t\t\t\t<span\n\t\t\t\t\t\t\tdojoAttachPoint=\"localonly\"\n\t\t\t\t\t\t\tclass=\"localonly\">\n\t\t\t\t\t\t\tLocal Only\n\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\n\t\t\t\t\t\t<span\n\t\t\t\t\t\t\tdojoAttachPoint=\"localonly\"\n\t\t\t\t\t\t\tdojoType=\"dijit.form.CheckBox\"\n\t\t\t\t\t\t\tchecked=\"false\"\n\t\t\t\t\t\t\tclass=\"localonlyCheckbox\"\n\t\t\t\t\t\t></span>\n\t\t\t\t\t</td>\n\t\t\t\t</tr>\n\n\n\t\t\t\t<tr class=\"headerRow\">\n\t\t\t\t\t<td width=\"100%\"\n\t\t\t\t\t\tcolspan=\"3\"\n\t\t\t\t\t\tclass=\"toggleTitle\"\n\t\t\t\t\t\tdojoAttachEvent=\"onclick:toggle\"\n\t\t\t\t\t> Details (Click to toggle)</td>\n\t\t\t\t</tr>\n\t\t\t</table>\n\t\t</td>\n\n\t</tr>\n\t<tr class=\"inputs\" >\n\t\t<td>\n\n\t\t\t<table\n\t\t\t\tstyle=\"display: none\"\n\t\t\t\tdojoAttachPoint=\"togglePoint\"\n\t\t\t\twidth=\"100%\"\n\t\t\t\tstyle=\"padding: 0px;\"\n\t\t\t>\n\t\t\t\t\n\t\t\t\t<tr class=\"headerRow\">\n\t\t\t\t\t<td colspan=\"3\">Description</td>\n\t\t\t\t</tr>\n\n\t\t\t\t<tr>\n\t\t\t\t\t<td colspan=\"3\">\n\t\t\t\t\t\t<textarea\n\t\t\t\t\t\t\tspellcheck=\"false\"\n\t\t\t\t\t\t\tdojoAttachPoint=\"description\"\n\t\t\t\t\t\t\tclass=\"description\"\n\t\t\t\t\t\t\tstyle=\"width:100%; font-weight: bolder; font-family: Verdana;\";\n\t\t\t\t\t\t\tcols=\"40\"\n\t\t\t\t\t\t\trows=\"1\"\n\t\t\t\t\t\t\ttitle=\"description: A brief description of the application\"\n\t\t\t\t\t\t>Description</textarea>\n\t\t\t\t\t</td>\n\t\t\t\t</tr>\n\n\t\t\t\t<tr class=\"headerRow\" width=\"100%\">\n\t\t\t\t\t<td colspan=\"3\">Notes</td>\n\t\t\t\t</tr>\n\n\t\t\t\t<tr>\n\t\t\t\t\t<td colspan=\"3\">\n\t\t\t\t\t\t<textarea\n\t\t\t\t\t\t\tspellcheck=\"false\"\n\t\t\t\t\t\t\tdojoAttachPoint=\"notes\"\n\t\t\t\t\t\t\tclass=\"notes\"\n\t\t\t\t\t\t\tvalue=\"Notes\"\n\t\t\t\t\t\t\tstyle=\"width: 100%; font-weight: bolder; font-family: Verdana;\";\n\t\t\t\t\t\t\tcols=\"40\"\n\t\t\t\t\t\t\trows=\"1\"\n\t\t\t\t\t\t\ttitle=\"notes: Notes on the application/build/etc. (e.g., release notes, constraints)\"\n\t\t\t\t\t\t>Notes</textarea>\n\t\t\t\t\t</td>\n\t\t\t\t</tr>\n\n\t\t\t\t<tr class=\"headerRow\" width=\"100%\">\n\t\t\t\t\t<td\n\t\t\t\t\t\tcolspan=\"3\"\n\t\t\t\t\t\ttitle=\"url: Web address of website providing further details (e.g., http://mysite.com/applications)\"\n\t\t\t\t\t\t>URL</td>\n\t\t\t\t</tr>\n\n\t\t\t\t<tr>\n\t\t\t\t\t<td colspan=\"3\">\n\t\t\t\t\t\t<textarea\n\t\t\t\t\t\t\tspellcheck=\"false\"\n\t\t\t\t\t\t\tdojoAttachPoint=\"url\"\n\t\t\t\t\t\t\tclass=\"url\"\n\t\t\t\t\t\t\tvalue=\"URL\"\n\t\t\t\t\t\t\tstyle=\"width: 100%; font-weight: bolder; font-family: Verdana;\";\n\t\t\t\t\t\t\tcols=\"40\"\n\t\t\t\t\t\t\trows=\"1\"\n\t\t\t\t\t\t\ttitle=\"url: Web address of website providing further details (e.g., http://mysite.com/applications)\"\n\t\t\t\t\t\t>URL</textarea>\n\t\t\t\t\t</td>\n\t\t\t\t</tr>\n\n\t\t\t</table>\n\t\t</td>\n\t</tr>\n\t\n\t<tr valign=\"top\" width=\"95%\">\n\t\t<td width=\"95%\">\n\t\t\t<div class=\"label\"> Application List Order </div>\n\t\t</td>\n\t</tr>\n\n\t<tr>\n\t\t<td align=\"center\">\n\t\t\t<div\n\t\t\t\tdojoAttachPoint=\"appsCombo\"\n\t\t\t\tdojoAttachEvent=\"onChange:changeDragSource\"\n\t\t\t\tdojoType=\"dijit.form.ComboBox\"\n\t\t\t\tclass=\"appsCombo\"\n\t\t\t\tpopupClass=\"sources appsCombo dijitReset dijitMenu\"\n\t\t\t\tautocomplete=\"true\"\n\t\t\t\thasDownArrow=\"true\"\n\t\t\t\tdisabled=\"false\"\n\t\t\t\tstyle=\"width: 250px;\"\n\t\t\t>\n\t\t\t</div>\n\t\t</td>\n\t</tr>\n\t\n\t<tr>\n\t\t<td>\n\t\t\t<div\n\t\t\t\tdojoAttachPoint=\"dragSourceNode\"\n\t\t\t\tclass=\"dragSource\"\n\t\t\t\tstyle=\"height: 395px; width: 96%;\"\n\t\t\t>\n\t\t\t</div>\n\t\t</td>\n\t</tr>\n\n\t<tr align=\"center\">\n\t\t<td align=\"center\">\n\n\t\t\t<!-- TRASH CONTAINER -->\n\t\t\t<div\n\t\t\t\tdojoAttachPoint=\"trashContainer\"\n\t\t\t\tclass=\"trash\"\n\t\t\t\tstyle=\"height: 60px; width: 150px; align: center;\" \n\t\t\t\t>\n\t\t\t\t<div\n\t\t\t\t\tdojoAttachPoint=\"trashIcon\"\n\t\t\t\t\tclass=\"trashIcon\"\n\t\t\t\t\tstyle=\"height: 60px; width: 60px;\"\n\t\t\t\t\t>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</td>\n\t</tr>\n</table>\n\n\n\n\t</div>\n\t<!-- END SOURCES TAB -->\n\t\n</div> \n\n\n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

//addingApp STATE
addingApp : false,

// OR USE @import IN HTML TEMPLATE
cssFiles : [ dojo.moduleUrl("plugins", "apps/css/app.css") ],

// PARENT WIDGET
parentWidget : null,

formInputs : {
	"name"		: "word",
	"type"		: "word",
	"executor"	: "word",
	"package"	: "word",
	"location"	: "word",
	"localonly"	: "word",
	"description": "phrase",
	"notes": "phrase",
	"url": "word"
},

requiredInputs : {
// REQUIRED INPUTS CANNOT BE ''
	name : 1,
	type : 1, 
	location: 1
},

invalidInputs : {
// THESE INPUTS ARE INVALID
	name 		: 	"Name",
	type 		: 	"Type", 
	executor	: 	"Executor", 
	packageCombo: 	"Package",
	location	: 	"Location",
	description	: 	"Description",
	notes		: 	"Notes",
	url			: 	"URL"
},

defaultInputs : {
// THESE INPUTS ARE default
	name 		: 	"Name",
	type 		: 	"Type", 
	executor	: 	"Executor", 
	packageCombo: 	"Package",
	location	: 	"Location",
	description	: 	"Description",
	notes		: 	"Notes",
	url			: 	"URL"
},

dataFields : ["name", "type", "location"],

avatarItems : [ "name", "description" ],

rowClass : "plugins.apps.AppRow",

// dragType: array
// List of permitted dragged items allowed to be dropped
dragTypes : ["app"],

/////}}}
constructor : function(args) {
	//////////console.log("App.constructor     plugins.apps.App.constructor");			
	// GET INFO FROM ARGS
	this.parentWidget = args.parentWidget;
	this.apps = args.parentWidget.apps;

},
postCreate : function() {
	//////////console.log("Controller.postCreate    plugins.apps.Controller.postCreate()");
	// LOAD CSS
	this.loadCSS();		

	this.startup();
},
startup : function () {
	//////////console.log("App.startup    plugins.apps.App.startup()");

	console.group("App-" + this.id + "    startup");

	// COMPLETE CONSTRUCTION OF OBJECT
	this.inherited(arguments);	 

	// ADD TO TAB CONTAINER		
	this.tabContainer.addChild(this.mainTab);
	this.tabContainer.selectChild(this.mainTab);

	// SET APPS COMBO - WILL CASCADE TO setDragSource
	this.setPackageCombo();

	// SET NEW APP FORM
	this.setForm();

	// SET TRASH
	this.setTrash(this.dataFields);	

	// SET SYNC APPS BUTTON
	this.setSyncApps();
	
	// SET SYNC DIALOG
	this.setSyncDialog();

	// SUBSCRIBE TO UPDATES
	Agua.updater.subscribe(this, "updateApps");
	
	// SUBSCRIBE TO UPDATES
	Agua.updater.subscribe(this, "updateSyncApps");
	
	console.groupEnd("App-" + this.id + "    startup");
},
updateApps : function (args) {
// RELOAD GROUP COMBO AND DRAG SOURCE AFTER CHANGES
// TO SOURCES OR GROUPS DATA IN OTHER TABS
	console.log("App.updateApps    Apps.updateApps(args)");
	console.log("App.updateApps    args:");
	console.dir(args);

	// SET DRAG SOURCE
	if ( args != null && args.reload == false )	return;
	console.log("App.updateApps    Calling setDragSource()");
	this.setAppTypesCombo();
},
updateSyncApps : function (args) {
	console.warn("App.updateSyncApps    args:");
	console.dir({args:args});

	this.setSyncApps();
},
// DISABLE SYNC APPS BUTTON IF NO HUB LOGIN
setSyncApps : function () {
	var hub = Agua.getHub();
	console.log("App.setSyncApps    hub:")
	console.dir({hub:hub});

	if ( ! hub.login || ! hub.token ) {
		this.disableSyncApps();
	}
	else {
		this.enableSyncApps();
	}
},
setSyncDialog : function () {
	console.log("App.loadSyncDialog    plugins.apps.App.setSyncDialog()");
	
	var enterCallback = function (){};
	var cancelCallback = function (){};
	var title = "Sync";
	var header = "Sync Apps";
	
	this.syncDialog = new plugins.dijit.SyncDialog(
		{
			title 				:	title,
			header 				:	header,
			parentWidget 		:	this,
			enterCallback 		:	enterCallback
		}			
	);

	console.log("App.loadSyncDialog    this.syncDialog:");
	console.dir({this_syncDialog:this.syncDialog});

},
showSyncDialog : function () {
	var disabled = dojo.hasClass(this.syncAppsButton, "disabled");
	console.log("App.loadSyncDialog    disabled: " + disabled);
	
	if ( disabled ) {
		console.log("App.loadSyncDialog    SyncApps is disabled. Returning");
		return;
	}
	
	var title = "Sync Apps";
	var header = "";
	var message = "";
	var details = "";
	var enterCallback = dojo.hitch(this, "syncApps");
	this.loadSyncDialog(title, header, message, details, enterCallback)
},
loadSyncDialog : function (title, header, message, details, enterCallback) {
	console.log("App.loadSyncDialog    title: " + title);
	console.log("App.loadSyncDialog    header: " + header);
	console.log("App.loadSyncDialog    message: " + message);
	console.log("App.loadSyncDialog    details: " + details);
	console.log("App.loadSyncDialog    enterCallback: " + enterCallback);

	this.syncDialog.load(
		{
			title 			:	title,
			header 			:	header,
			message 		:	message,
			details 		:	details,
			enterCallback 	:	enterCallback
		}			
	);
},
disableSyncApps : function () {
	dojo.addClass(this.syncAppsButton, "disabled");
	dojo.attr(this.syncAppsButton, "title", "Input AWS private key and public certificate to enable Sync");
},
enableSyncApps : function () {
	dojo.removeClass(this.syncAppsButton, "disabled");
	dojo.attr(this.syncAppsButton, "title", "Click to sync apps to biorepository");
},
// SYNC APPS
syncApps : function (inputs) {
	console.log("Hub.syncApps    inputs: ");
	console.dir({inputs:inputs});
	
	if ( this.syncingApps == true ) {
		console.log("Hub.syncApps    this.syncingApps: " + this.syncingApps + ". Returning.");
		return;
	}
	this.syncingApps = true;
	
	var query = new Object;
	query.username 			= Agua.cookie('username');
	query.sessionid 		= Agua.cookie('sessionid');
	query.message			= inputs.message;
	query.details			= inputs.details;
	query.hubtype			= "github";
	query.mode 				= "syncApps";
	console.log("Hub.syncApps    query: ");
	console.dir({query:query});
	
	// SEND TO SERVER
	var url = Agua.cgiUrl + "workflow.cgi?";
	var thisObj = this;
	dojo.xhrPut(
		{
			url: url,
			contentType: "json",
			putData: dojo.toJson(query),
			load: function(response, ioArgs) {
				thisObj.syncingApps = false;

				console.log("App.syncApps    OK. response:")
				console.dir({response:response});

				Agua.toast(response);
			},
			error: function(response, ioArgs) {
				thisObj.syncingApps = false;

				console.log("App.syncApps    ERROR. response:")
				console.dir({response:response});
				Agua.toast(response);
			}
		}
	);
},
toggle : function () {
// TOGGLE HIDDEN DETAILS
	//console.log("Packages.toggle    plugins.workflow.Packages.toggle()");
	////console.log("Packages.toggle    this.description: " + this.description);

	if ( this.togglePoint.style.display == 'inline-block' )	
		this.togglePoint.style.display='none';
	else
		this.togglePoint.style.display = 'inline-block';
},
setPackageCombo : function (type) {
// SET PARAMETERS COMBO BOX
	//console.log("Parameters.setPackageCombo     plugins.apps.Parameters.setPackageCombo()");

	// GET PARAMETERS NAMES		
	var apps = Agua.getApps();
	console.log("Parameters.setPackageCombo     apps:");
	console.dir({apps:apps});

	var packageArray = this.hashArrayKeyToArray(apps, "package");
	packageArray = this.uniqueValues(packageArray);
	console.log("Parameters.setPackageCombo     packageArray:");
	console.dir({packageArray:packageArray});

	// SET STORE
	var data = {identifier: "name", items: []};
	for ( var i = 0; i < packageArray.length; i++ )
	{
		data.items[i] = { name: packageArray[i]	};
	}
	//////console.log("Parameters.setPackageCombo     data: " + dojo.toJson(data));
	var store = new dojo.data.ItemFileWriteStore(	{	data: data	}	);
	//////console.log("Parameters.setPackageCombo     store: " + store);

	// SET COMBO
	this.packageCombo.store = store;
	this.packageCombo.startup();
	////console.log("Parameters.setPackageCombo::setCombo     AFTER this.packageCombo.startup()");th

	// SET COMBO VALUE
	var firstValue = packageArray[0];
	this.packageCombo.set('value', firstValue);
	////console.log("Parameters.setPackageCombo::setCombo     AFTER this.packageCombo.setValue(firstValue)");

	// SET PARAMETER NAMES COMBO
	this.setAppTypesCombo();
},
setAppTypesCombo : function () {
	// SET APPS COMBO BOX WITH APPLICATION NAME VALUES
	console.log("App.setAppTypesCombo     plugins.apps.App.setAppTypesCombo()");

	// GET APPS NAMES
	var apps = Agua.getApps();
	console.log("App.setAppTypesCombo     this: ");
	;
	
	var packageName = this.packageCombo.get('value');
	console.log("App.setAppTypesCombo     packageName: " + packageName);
	
	var keys = ['package'];
	var values = [ packageName ];
	apps = this.filterByKeyValues(apps, keys, values);

	var typesArray = this.hashArrayKeyToArray(apps, "type");
	typesArray = this.uniqueValues(typesArray);
	console.log("App.setAppTypesCombo     typesArray.length: " + typesArray.length);

	typesArray = this.sortNoCase(typesArray);
	typesArray.splice(0,0, 'Order by Type (A-Z)');
	typesArray.splice(0,0, 'Order by Name (A-Z)');
	
	// SET STORE
	var data = {identifier: "name", items: []};
	for ( var i = 0; i < typesArray.length; i++ )
	{
		data.items[i] = { name: typesArray[i]	};
	}
	var store = new dojo.data.ItemFileWriteStore(	{	data: data	}	);
	
	// SET COMBO
	this.appsCombo.store = store;
	this.appsCombo.startup();

	// SET COMBO VALUE
	var firstValue = typesArray[0];
	this.appsCombo.set('value', firstValue);
	////console.log("App.setAppTypesCombo::setCombo     AFTER this.appsCombo.set('value',firstValue)");

	this.setDragSource();
},
setForm : function () {
	// SET ADD ONCLICK
	dojo.connect(this.addAppButton, "onclick", dojo.hitch(this, "saveInputs", null, { reload: true }));

	// SET ONCLICK TO CANCEL INVALID TEXT
	this.setClearValues();

	// CHAIN TOGETHER INPUTS ON 'RETURN' KEYPRESS
	this.chainInputs(["name", "type", "executor", "package", "location", "description", "notes", "url", "addAppButton"]);	
},
getItemArray : function () {
	//console.log("App.getItemArray     plugins.apps.App.getItemArray()");

	var itemArray = Agua.getApps();
	//console.log("App.getItemArray     itemArray: " + dojo.toJson(itemArray));
	console.log("App.getItemArray    itemArray.length: " + itemArray.length);
	
	var type = this.appsCombo.get('value');
	//console.log("App.getItemArray     type: " + type);
	if ( type == "Order by Name (A-Z)" )
	{
		itemArray = this.sortHasharray(itemArray, 'name');
		//console.log("App.getItemArray     Name A-Z itemArray: " + dojo.toJson(itemArray));
	}
	else if ( type == "Order by Type (A-Z)" )
	{
		itemArray = this.sortHasharray(itemArray, 'type');
		//console.log("App.getItemArray     Type A-Z itemArray: " + dojo.toJson(itemArray));
	}
	else
	{
		for ( var i = 0; i < itemArray.length; i++ )
		{
			if ( itemArray[i].type != type )
			{
				itemArray.splice(i, 1);
				i--;
			}
		}
		//console.log("App.getItemArray     Type " + type + " itemArray: " + dojo.toJson(itemArray));
	
	}	
	//console.log("App.getItemArray    Type " + type + " itemArray.length: " + itemArray.length);
	console.log("App.setAppTypesCombo     RETURNING itemArray.length: " + itemArray.length);
	
	return itemArray;
},
changeDragSource : function () {
	console.log("App.changeDragSource     plugins.apps.App.changeDragSource()");
	console.log("App.changeDragSource     this.dragSourceOnchange: " + this.dragSourceOnchange);
	
	//if ( this.dragSourceOnchange == false )
	//{
	//	console.log("App.changeDragSource     this.dragSourceOnchange is false. Returning");
	//	this.dragSourceOnchange = true;
	//	return;
	//}
	
	console.log("App.changeDragSource     Doing this.setDragSource");
	this.setDragSource();
},
deleteItem : function (appObject) {
// DELETE APPLICATION FROM Agua.apps OBJECT AND IN REMOTE DATABASE
	//console.log("App.deleteItem    plugins.apps.App.deleteItem(name)");
	//console.log("App.deleteItem    name: " + name);

	// CLEAN UP WHITESPACE
	appObject.name = appObject.name.replace(/\s+$/,'');
	appObject.name = appObject.name.replace(/^\s+/,'');

	// REMOVING APP FROM Agua.apps
	Agua.removeApp(appObject, "custom");
	
	var url = Agua.cgiUrl + "admin.cgi?";
	//console.log("App.deleteStore     url: " + url);		

	// CREATE JSON QUERY
	var query = new Object;
	query.username = Agua.cookie('username');
	query.sessionid = Agua.cookie('sessionid');
	query.mode = "deleteApp";
	query.data = appObject;
	//console.log("App.deleteItem    query: " + dojo.toJson(query));
	
	// SEND TO SERVER
	dojo.xhrPut(
		{
			url: url,
			contentType: "text",
			putData: dojo.toJson(query),
			load: function(response, ioArgs) {
				//console.log("App.deleteItem    JSON Post worked.");
				return response;
			},
			error: function(response, ioArgs) {
				//console.log("App.deleteItem    Error with JSON Post, response: " + response + ", ioArgs: " + ioArgs);
				return response;
			}
		}
	);

	// RELOAD RELEVANT DISPLAYS
	Agua.updater.update("updateApps");

}, // Apps.deleteItem
saveInputs : function (inputs, updateArgs) {
//	SAVE AN APPLICATION TO Agua.apps AND TO REMOTE DATABASE
	console.log("App.saveInputs    plugins.apps.App.saveInputs(inputs)");
	console.log("App.saveInputs    BEFORE inputs: ");
	console.dir({inputs:inputs});

	if ( this.savingApp == true )	return;
	this.savingApp = true;

	if ( inputs == null )
	{
		inputs = this.getFormInputs(this);

		// RETURN IF INPUTS ARE NULL
		if ( inputs == null )
		{
			this.savingApp = false;
			return;
		}
	}
	console.log("App.saveInputs    AFTER inputs: ");
	console.dir({inputs:inputs});

	// REMOVE ORIGINAL APPLICATION OBJECT FROM Agua.apps 
	// THEN ADD NEW APPLICATION OBJECT TO Agua.apps
	Agua.removeApp({ name: inputs.name });
	Agua.addApp(inputs);

	// CREATE JSON QUERY
	var query = new Object;
	query.username = Agua.cookie('username');
	query.sessionid = Agua.cookie('sessionid');
	query.mode = "saveApp";
	query.data = inputs;
	var url = Agua.cgiUrl + "admin.cgi?";
	//////////console.log("App.saveInputs    query: " + dojo.toJson(query));
	
	// SEND TO SERVER
	dojo.xhrPut(
		{
			url: url,
			contentType: "text",
			putData: dojo.toJson(query),
			timeout: 15000,
			load: function(response, ioArgs) {
				//////////console.log("App.saveInputs    JSON Post worked.");
				return response;
			},
			error: function(response, ioArgs) {
				//////////console.log("App.saveInputs    Error with JSON Post, response: " + response + ", ioArgs: " + ioArgs);
				return response;
			}
		}
	);

	this.savingApp = false;

	// SUBSCRIBE TO UPDATES
	// NB: updateArgs.reload = true
	Agua.updater.update("updateApps", updateArgs);

}, // Apps.saveInputs
getFormInputs : function (widget) {
// GET INPUTS FROM THE EDITED ITEM
	console.log("App.getFormInputs    plugins.apps.App.getFormInputs(textarea)");
	console.log("App.getFormInputs    widget: " + widget);
	console.dir({widget:widget});

	var inputs = new Object;
	console.log("App.getFormInputs    inputs: " + inputs);
	console.dir({inputs:inputs});

	for ( var name in this.formInputs )
	{
		console.log("App.getFormInputs    DOING inputs[" + name + "]");
		var value;
		if ( name == "localonly" )
		{
			value = 0;
			if ( widget[name].getValue() == "on" )
			{
				value = 1;
			}
		}
		else if ( name == "package" ) {
			value = this.processWidgetValue(widget, "packageCombo");
		}
		else
		{
			console.log("App.getFormInputs    DOING processWidgetValue. widget: ");
			console.dir({widget:widget});
			
			value = this.processWidgetValue(widget, name);
		}
		inputs[name] = value;
		console.log("App.getFormInputs    inputs[" + name + "]: " + inputs[name]);
	}

	inputs = this.checkInputs(widget, inputs);
	console.log("App.getFormInputs    FINAL inputs: ");
	console.dir({inputs:inputs});

	return inputs;
},
checkInputs : function (widget, inputs) {
// CHECK INPUTS ARE VALID, IF NOT RETURN NULL
	console.log("App.checkInputs    inputs: ");
	console.dir({inputs:inputs});
	
	this.allValid = true;	
	for ( var key in this.formInputs )
	{
		var value = inputs[key];
		console.log("App.checkInputs    Checking " + key + ": " + value);
		
		if ( key == "package" ) {
			if ( this.isValidInput("packageCombo", value) ) {
				this.setValid(widget["packageCombo"]);
			}
			else {
				this.setInvalid(widget["packageCombo"]);
				this.allValid = false;
				continuev;
			}
		}
		else if ( this.isValidInput(key, value) ) {
			console.log("App.checkInputs    removing 'invalid' class for " + key + ": " + value);
			this.setValid(widget[key]);
		}
		else {
			console.log("App.checkInputs    adding 'invalid' class for name " + key + ", value " + value);
			
			this.setInvalid(widget[key]);
			this.allValid = false;
		}
	}
	console.log("App.checkInputs    this.allValid: " + this.allValid);
	if ( this.allValid == false )	return null;

	for ( var key in this.formInputs )
	{
		console.log("App.checkInputs    BEFORE convert, inputs[key]: " + dojo.toJson(inputs[key]));
		inputs[key] = this.convertAngleBrackets(inputs[key], "htmlToText");
		//inputs[key] = this.convertBackslash(inputs[key], "textToHtml");
		console.log("App.checkInputs    AFTER convert, inputs[key]: " + dojo.toJson(inputs[key]));
	}

	return inputs;
}



}); // plugins.apps.App


}

if(!dojo._hasResource["plugins.apps.Apps"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.apps.Apps"] = true;
dojo.provide("plugins.apps.Apps");



// DISPLAY DIFFERENT PAGES TO ALLOW THE apps AND ORDINARY
// USERS TO MODIFY THEIR SETTINGS

// DnD
 // Source & Target




// comboBox data store




// rightPane buttons


dojo.declare( "plugins.apps.Apps", 
	[ dijit._Widget, dijit._Templated, plugins.core.Common ], {
//Path to the template of this widget. 
templateString:"<div dojoAttachPoint=\"containerNode\">\n\n\t<!-- ADMIN TAB -->\n\t<div\n        dojoAttachPoint=\"mainTab\"\n        class=\"applications\"\n\t\ticonClass=\"appsIcon\"\n        style=\"min-width: 1140px !important; width: 100% !important; height:100% !important; max-height: auto !important; padding: 0px; background: #FFF;\"\n        dojoType=\"dijit.layout.BorderContainer\"\n\t\tclosable=\"true\"\t\t\n        title=\"Apps\"\n        >\n        \n        <!-- LEFT PANE -->\n        <div\n            dojoAttachPoint=\"leftPane\"\n            class=\"leftPane\"\n\t\t\tlayoutAlign=\"left\" \n            dojoType=\"dijit.layout.ContentPane\" \n            style=\"position: absolute !important; width: 390px; height: 100% !important; max-height: auto !important; min-width: 25px; background: #FFF; padding: 0; border: none !important;\"\n            >\n\n            <!-- LEFT TAB CONTAINER-->\n            <div dojoAttachPoint=\"leftTabContainer\"\n                dojoType=\"dijit.layout.TabContainer\"\n                style=\"height: 100%; overflow: visible;\"\n                class=\"infoPane\">\n\n            </div>\n            <!-- END OF LEFT TAB CONTAINER-->\n\t\t\t\n        </div>\n        <!-- END OF LEFT PANE -->\n\n        <!-- MIDDLE PANE -->\n        <div\n            dojoAttachPoint=\"middlePane\"\n\t\t\tlayoutAlign=\"middle\" \n\t\t\tclass=\"middlePane\"\n            dojoType=\"dijit.layout.ContentPane\" \n            style=\"position: absolute !important; left: 390px !important; height: 100% !important; max-height: auto !important; width: 390px; min-width: 25px; background: #FFF; padding: 0; border: none !important;\"\n            >\n\n            <!-- MIDDLE TAB CONTAINER-->\n            <div\n                dojoAttachPoint=\"middleTabContainer\"\n                dojoType=\"dijit.layout.TabContainer\"\n                style=\"height: 100%; overflow: visible;\"\n                class=\"infoPane\">\n\n            </div>\n\n        </div>\n        <!-- END OF MIDDLE PANE -->\n\n\n        <!-- RIGHT PANE -->\n        <div\n            dojoAttachPoint=\"rightPane\" \n            class=\"rightPane\"\n\t\t\tlayoutAlign=\"right\"\n            dojoType=\"dijit.layout.ContentPane\" \n            style=\"position: absolute !important; left: 780px !important; height: 100% !important; max-height: auto !important; width: 390px !important; min-width: 25px; background: #FFF; padding: 0; border: none !important;\"\n            >\n\n            <!-- RIGHT TAB CONTAINER-->\n            <div dojoAttachPoint=\"rightTabContainer\"\n                dojoType=\"dijit.layout.TabContainer\"\n                style=\"height: 100%; overflow: visible; width: 390px !important; \"\n                class=\"infoPane\">\n\n            </div>\n            <!-- END OF RIGHT TAB CONTAINER-->\n\n        </div>\n        <!-- END OF RIGHT PANE -->\n\n\t</div>\n\t<!-- END OF ADMIN TAB -->\n\n</div>\n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

// PANE WIDGETS
paneWidgets : null,

// CORE WORKFLOW OBJECTS
core : new Object,

cssFiles : [
	dojo.moduleUrl("plugins", "apps/css/apps.css")
],

// DEBUG: LIST OF PANELS TO LOAD
// paneList: ';'-separated String
panelList: null,

// INPUTS PASSED FROM CONTROLLER
// inputs: ';'-separated String
inputs : null,

// LOAD PANELS
// loadPanels: array of names of panels to be loaded
loadPanels : null,

/////}}
constructor : function(args) {
	console.log("apps.Apps.constructor    args:");
	console.dir({args:args});

	// SET LOAD PANELS
	this.setLoadPanels(args);
	
	// LOAD CSS
	this.loadCSS();		
},

postCreate : function() {
	////console.log("Apps.postCreate    plugins.apps.Controller.postCreate()");

	this.startup();
},
startup : function () {
	//console.log("Apps.startup    plugins.apps.Controller.startup()");

    // ADD THIS WIDGET TO Agua.widgets
    Agua.addWidget("apps", this);

	// ADD ADMIN TAB TO TAB CONTAINER		
	Agua.tabs.addChild(this.mainTab);
	Agua.tabs.selectChild(this.mainTab);

	// CREATE HASH TO HOLD INSTANTIATED PANE WIDGETS
	this.paneWidgets = new Object;

	// LOAD HEADINGS FOR THIS USER
	this.headings = Agua.getAppHeadings();
	console.log("Apps.startup    this.headings:");
	console.dir({this_headings:this.headings});
	
	// LOAD PANES
	this.loadPanes();
},
reload : function (target) {
// RELOAD A WIDGET, WIDGETS IN A PANE OR ALL WIDGETS
	////console.log("Apps.reload     plugins.apps.Apps.reload(target)");
	////console.log("Apps.reload     target: " + target);

	if ( target == "all" )
	{
		for ( var mainPane in this.headings )
		{
			for ( var i in this.headings[mainPane] )
			{
				this.reloadWidget(this.headings[mainPane][i]);
			}
		}
	}
	else if ( target == "leftPane"
			|| target == "middlePane"
			|| target == "rightPane" )
	{
		for ( var i in this.headings[target] )
		{
			this.reloadWidget(this.headings[target][i]);
		}
	}
	
	// OTHERWISE, THE target MUST BE A PANE NAME
	else
	{
		try {
			this.reloadWidget(target);
		}
		catch (e) {}
	}		
},
reloadWidget : function (paneName) {
// REINSTANTIATE A PANE WIDGET
	////console.log("Apps.reloadWidget     Reloading pane: " + paneName);

	delete this.paneWidgets[paneName];

	var thisObject = this;
	this.paneWidgets[paneName] = new plugins.apps[paneName](
		{
			parentWidget: thisObject,
			tabContainer : thisObject.leftTabContainer
		}
	);
},
loadPanes : function () {
	var panes = ["left", "middle", "right"];
	for ( var i = 0; i < panes.length; i++ )
	{
		this.loadPane(panes[i]);
	}
},
loadPane : function(side) {
	console.log("Apps.loadPane     side: " + side);
	console.log("Apps.loadPane     this.loadPanels: ");
	console.dir({this_loadPanels:this.loadPanels});
	
	//console.log("Apps.loadPane     side: " + dojo.toJson(side));
	var pane = side + "Pane";
	var tabContainer = side + "TabContainer";
	if ( this.headings == null || this.headings[pane] == null )	return;
	for ( var i = 0; i < this.headings[pane].length; i++ )
	{
		//console.log("Apps.loadLeftPane     LOADING PANE this.headings[pane][" + i + "]: " + this.headings[pane][i]);

		var tabPaneName = this.headings[pane][i];
		console.log("Apps.loadPane    dojo.require tabPaneName: " + tabPaneName);

		if ( this.loadPanels && ! this.loadPanels[tabPaneName.toLowerCase()] ) {
			console.log("Apps.loadPane    Skipping panel: " + tabPaneName);
			continue;
		}

		var moduleName = "plugins.apps." + tabPaneName;
		console.log("Apps.loadPane    BEFORE dojo.require moduleName: " + moduleName);
		
		dojo["require"](moduleName);
		console.log("Apps.loadPane    AFTER dojo.require moduleName: " + moduleName);
		
		var thisObject = this;
		var tabPane = new plugins["apps"][tabPaneName](
			{
				parentWidget: thisObject,
				tabContainer : thisObject[tabContainer]
			}
		);
		
		// REGISTER THE NEW TAB PANE IN this.paneWidgets 
		if( this.paneWidgets[moduleName] == null )
			this.paneWidgets[moduleName] = new Array;
		this.paneWidgets[moduleName].push(tabPane);
	}
},
destroyRecursive : function () {
	console.log("Apps.destroyRecursive    this.mainTab: ");
	console.dir({this_mainTab:this.mainTab});

	if ( Agua && Agua.tabs )
		Agua.tabs.removeChild(this.mainTab);
	
	this.inherited(arguments);
}

}); // end of plugins.apps.Apps


}

if(!dojo._hasResource["dojo.cookie"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.cookie"] = true;
dojo.provide("dojo.cookie");



/*=====
dojo.__cookieProps = function(){
	//	expires: Date|String|Number?
	//		If a number, the number of days from today at which the cookie
	//		will expire. If a date, the date past which the cookie will expire.
	//		If expires is in the past, the cookie will be deleted.
	//		If expires is omitted or is 0, the cookie will expire when the browser closes. << FIXME: 0 seems to disappear right away? FF3.
	//	path: String?
	//		The path to use for the cookie.
	//	domain: String?
	//		The domain to use for the cookie.
	//	secure: Boolean?
	//		Whether to only send the cookie on secure connections
	this.expires = expires;
	this.path = path;
	this.domain = domain;
	this.secure = secure;
}
=====*/


dojo.cookie = function(/*String*/name, /*String?*/value, /*dojo.__cookieProps?*/props){
	//	summary:
	//		Get or set a cookie.
	//	description:
	// 		If one argument is passed, returns the value of the cookie
	// 		For two or more arguments, acts as a setter.
	//	name:
	//		Name of the cookie
	//	value:
	//		Value for the cookie
	//	props:
	//		Properties for the cookie
	//	example:
	//		set a cookie with the JSON-serialized contents of an object which
	//		will expire 5 days from now:
	//	|	dojo.cookie("configObj", dojo.toJson(config), { expires: 5 });
	//
	//	example:
	//		de-serialize a cookie back into a JavaScript object:
	//	|	var config = dojo.fromJson(dojo.cookie("configObj"));
	//
	//	example:
	//		delete a cookie:
	//	|	dojo.cookie("configObj", null, {expires: -1});
	var c = document.cookie;
	if(arguments.length == 1){
		var matches = c.match(new RegExp("(?:^|; )" + dojo.regexp.escapeString(name) + "=([^;]*)"));
		return matches ? decodeURIComponent(matches[1]) : undefined; // String or undefined
	}else{
		props = props || {};
// FIXME: expires=0 seems to disappear right away, not on close? (FF3)  Change docs?
		var exp = props.expires;
		if(typeof exp == "number"){
			var d = new Date();
			d.setTime(d.getTime() + exp*24*60*60*1000);
			exp = props.expires = d;
		}
		if(exp && exp.toUTCString){ props.expires = exp.toUTCString(); }

		value = encodeURIComponent(value);
		var updatedCookie = name + "=" + value, propName;
		for(propName in props){
			updatedCookie += "; " + propName;
			var propValue = props[propName];
			if(propValue !== true){ updatedCookie += "=" + propValue; }
		}
		document.cookie = updatedCookie;
	}
};

dojo.cookie.isSupported = function(){
	//	summary:
	//		Use to determine if the current browser supports cookies or not.
	//
	//		Returns true if user allows cookies.
	//		Returns false if user doesn't allow cookies.

	if(!("cookieEnabled" in navigator)){
		this("__djCookieTest__", "CookiesAllowed");
		navigator.cookieEnabled = this("__djCookieTest__") == "CookiesAllowed";
		if(navigator.cookieEnabled){
			this("__djCookieTest__", "", {expires: -1});
		}
	}
	return navigator.cookieEnabled;
};

}

if(!dojo._hasResource["dijit.layout.BorderContainer"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.layout.BorderContainer"] = true;
dojo.provide("dijit.layout.BorderContainer");





dojo.declare(
	"dijit.layout.BorderContainer",
	dijit.layout._LayoutWidget,
{
	// summary:
	//		Provides layout in up to 5 regions, a mandatory center with optional borders along its 4 sides.
	//
	// description:
	//		A BorderContainer is a box with a specified size, such as style="width: 500px; height: 500px;",
	//		that contains a child widget marked region="center" and optionally children widgets marked
	//		region equal to "top", "bottom", "leading", "trailing", "left" or "right".
	//		Children along the edges will be laid out according to width or height dimensions and may
	//		include optional splitters (splitter="true") to make them resizable by the user.  The remaining
	//		space is designated for the center region.
	//
	//		The outer size must be specified on the BorderContainer node.  Width must be specified for the sides
	//		and height for the top and bottom, respectively.  No dimensions should be specified on the center;
	//		it will fill the remaining space.  Regions named "leading" and "trailing" may be used just like
	//		"left" and "right" except that they will be reversed in right-to-left environments.
	//
	//		For complex layouts, multiple children can be specified for a single region.   In this case, the
	//		layoutPriority flag on the children determines which child is closer to the edge (low layoutPriority)
	//		and which child is closer to the center (high layoutPriority).   layoutPriority can also be used
	//		instead of the design attribute to conrol layout precedence of horizontal vs. vertical panes.
	// example:
	// |	<div dojoType="dijit.layout.BorderContainer" design="sidebar" gutters="false"
	// |            style="width: 400px; height: 300px;">
	// |		<div dojoType="dijit.layout.ContentPane" region="top">header text</div>
	// |		<div dojoType="dijit.layout.ContentPane" region="right" splitter="true" style="width: 200px;">table of contents</div>
	// |		<div dojoType="dijit.layout.ContentPane" region="center">client area</div>
	// |	</div>

	// design: String
	//		Which design is used for the layout:
	//			- "headline" (default) where the top and bottom extend
	//				the full width of the container
	//			- "sidebar" where the left and right sides extend from top to bottom.
	design: "headline",

	// gutters: [const] Boolean
	//		Give each pane a border and margin.
	//		Margin determined by domNode.paddingLeft.
	//		When false, only resizable panes have a gutter (i.e. draggable splitter) for resizing.
	gutters: true,

	// liveSplitters: [const] Boolean
	//		Specifies whether splitters resize as you drag (true) or only upon mouseup (false)
	liveSplitters: true,

	// persist: Boolean
	//		Save splitter positions in a cookie.
	persist: false,

	baseClass: "dijitBorderContainer",

	// _splitterClass: String
	// 		Optional hook to override the default Splitter widget used by BorderContainer
	_splitterClass: "dijit.layout._Splitter",

	postMixInProperties: function(){
		// change class name to indicate that BorderContainer is being used purely for
		// layout (like LayoutContainer) rather than for pretty formatting.
		if(!this.gutters){
			this.baseClass += "NoGutter";
		}
		this.inherited(arguments);
	},

	startup: function(){
		if(this._started){ return; }
		dojo.forEach(this.getChildren(), this._setupChild, this);
		this.inherited(arguments);
	},

	_setupChild: function(/*dijit._Widget*/ child){
		// Override _LayoutWidget._setupChild().

		var region = child.region;
		if(region){
			this.inherited(arguments);

			dojo.addClass(child.domNode, this.baseClass+"Pane");

			var ltr = this.isLeftToRight();
			if(region == "leading"){ region = ltr ? "left" : "right"; }
			if(region == "trailing"){ region = ltr ? "right" : "left"; }

			// Create draggable splitter for resizing pane,
			// or alternately if splitter=false but BorderContainer.gutters=true then
			// insert dummy div just for spacing
			if(region != "center" && (child.splitter || this.gutters) && !child._splitterWidget){
				var _Splitter = dojo.getObject(child.splitter ? this._splitterClass : "dijit.layout._Gutter");
				var splitter = new _Splitter({
					id: child.id + "_splitter",
					container: this,
					child: child,
					region: region,
					live: this.liveSplitters
				});
				splitter.isSplitter = true;
				child._splitterWidget = splitter;

				dojo.place(splitter.domNode, child.domNode, "after");

				// Splitters aren't added as Contained children, so we need to call startup explicitly
				splitter.startup();
			}
			child.region = region;	// TODO: technically wrong since it overwrites "trailing" with "left" etc.
		}
	},

	layout: function(){
		// Implement _LayoutWidget.layout() virtual method.
		this._layoutChildren();
	},

	addChild: function(/*dijit._Widget*/ child, /*Integer?*/ insertIndex){
		// Override _LayoutWidget.addChild().
		this.inherited(arguments);
		if(this._started){
			this.layout(); //OPT
		}
	},

	removeChild: function(/*dijit._Widget*/ child){
		// Override _LayoutWidget.removeChild().

		var region = child.region;
		var splitter = child._splitterWidget
		if(splitter){
			splitter.destroy();
			delete child._splitterWidget;
		}
		this.inherited(arguments);
		
		if(this._started){
			this._layoutChildren();
		}
		// Clean up whatever style changes we made to the child pane.
		// Unclear how height and width should be handled.
		dojo.removeClass(child.domNode, this.baseClass+"Pane");
		dojo.style(child.domNode, {
			top: "auto",
			bottom: "auto",
			left: "auto",
			right: "auto",
			position: "static"
		});
		dojo.style(child.domNode, region == "top" || region == "bottom" ? "width" : "height", "auto");
	},

	getChildren: function(){
		// Override _LayoutWidget.getChildren() to only return real children, not the splitters.
		return dojo.filter(this.inherited(arguments), function(widget){
			return !widget.isSplitter;
		});
	},

	// TODO: remove in 2.0
	getSplitter: function(/*String*/region){
		// summary:
		//		Returns the widget responsible for rendering the splitter associated with region
		// tags:
		//		deprecated
		return dojo.filter(this.getChildren(), function(child){
			return child.region == region;
		})[0]._splitterWidget;
	},

	resize: function(newSize, currentSize){
		// Overrides _LayoutWidget.resize().

		// resetting potential padding to 0px to provide support for 100% width/height + padding
		// TODO: this hack doesn't respect the box model and is a temporary fix
		if(!this.cs || !this.pe){
			var node = this.domNode;
			this.cs = dojo.getComputedStyle(node);
			this.pe = dojo._getPadExtents(node, this.cs);
			this.pe.r = dojo._toPixelValue(node, this.cs.paddingRight);
			this.pe.b = dojo._toPixelValue(node, this.cs.paddingBottom);

			dojo.style(node, "padding", "0px");
		}

		this.inherited(arguments);
	},

	_layoutChildren: function(/*String?*/ changedChildId, /*Number?*/ changedChildSize){
		// summary:
		//		This is the main routine for setting size/position of each child.
		// description:
		//		With no arguments, measures the height of top/bottom panes, the width
		//		of left/right panes, and then sizes all panes accordingly.
		//
		//		With changedRegion specified (as "left", "top", "bottom", or "right"),
		//		it changes that region's width/height to changedRegionSize and
		//		then resizes other regions that were affected.
		// changedChildId:
		//		Id of the child which should be resized because splitter was dragged.
		// changedChildSize:
		//		The new width/height (in pixels) to make specified child

		if(!this._borderBox || !this._borderBox.h){
			// We are currently hidden, or we haven't been sized by our parent yet.
			// Abort.   Someone will resize us later.
			return;
		}

		// Generate list of wrappers of my children in the order that I want layoutChildren()
		// to process them (i.e. from the outside to the inside)
		var wrappers = dojo.map(this.getChildren(), function(child, idx){
			return {
				pane: child,
				weight: [
					child.region == "center" ? Infinity : 0,
					child.layoutPriority,
					(this.design == "sidebar" ? 1 : -1) * (/top|bottom/.test(child.region) ? 1 : -1),
					idx
				]
			};
		}, this);
		wrappers.sort(function(a, b){
			var aw = a.weight, bw = b.weight;
			for(var i=0; i<aw.length; i++){
				if(aw[i] != bw[i]){
					return aw[i] - bw[i];
				}
			}
			return 0;
		});

		// Make new list, combining the externally specified children with splitters and gutters
		var childrenAndSplitters = [];
		dojo.forEach(wrappers, function(wrapper){
			var pane = wrapper.pane;
			childrenAndSplitters.push(pane);
			if(pane._splitterWidget){
				childrenAndSplitters.push(pane._splitterWidget);
			}
		});

		// Compute the box in which to lay out my children
		var dim = {
			l: this.pe.l,
			t: this.pe.t,
			w: this._borderBox.w - this.pe.w,
			h: this._borderBox.h - this.pe.h
		};

		// Layout the children, possibly changing size due to a splitter drag
		dijit.layout.layoutChildren(this.domNode, dim, childrenAndSplitters,
			changedChildId, changedChildSize);
	},

	destroyRecursive: function(){
		// Destroy splitters first, while getChildren() still works
		dojo.forEach(this.getChildren(), function(child){
			var splitter = child._splitterWidget;
			if(splitter){
				splitter.destroy();
			}
			delete child._splitterWidget;
		});

		// Then destroy the real children, and myself
		this.inherited(arguments);
	}
});

// This argument can be specified for the children of a BorderContainer.
// Since any widget can be specified as a LayoutContainer child, mix it
// into the base widget class.  (This is a hack, but it's effective.)
dojo.extend(dijit._Widget, {
	// region: [const] String
	//		Parameter for children of `dijit.layout.BorderContainer`.
	//		Values: "top", "bottom", "leading", "trailing", "left", "right", "center".
	//		See the `dijit.layout.BorderContainer` description for details.
	region: '',

	// layoutPriority: [const] Number
	//		Parameter for children of `dijit.layout.BorderContainer`.
	//		Children with a higher layoutPriority will be placed closer to the BorderContainer center,
	//		between children with a lower layoutPriority.
	layoutPriority: 0,

	// splitter: [const] Boolean
	//		Parameter for child of `dijit.layout.BorderContainer` where region != "center".
	//		If true, enables user to resize the widget by putting a draggable splitter between
	//		this widget and the region=center widget.
	splitter: false,

	// minSize: [const] Number
	//		Parameter for children of `dijit.layout.BorderContainer`.
	//		Specifies a minimum size (in pixels) for this widget when resized by a splitter.
	minSize: 0,

	// maxSize: [const] Number
	//		Parameter for children of `dijit.layout.BorderContainer`.
	//		Specifies a maximum size (in pixels) for this widget when resized by a splitter.
	maxSize: Infinity
});

dojo.declare("dijit.layout._Splitter", [ dijit._Widget, dijit._Templated ],
{
	// summary:
	//		A draggable spacer between two items in a `dijit.layout.BorderContainer`.
	// description:
	//		This is instantiated by `dijit.layout.BorderContainer`.  Users should not
	//		create it directly.
	// tags:
	//		private

/*=====
 	// container: [const] dijit.layout.BorderContainer
 	//		Pointer to the parent BorderContainer
	container: null,

	// child: [const] dijit.layout._LayoutWidget
	//		Pointer to the pane associated with this splitter
	child: null,

	// region: [const] String
	//		Region of pane associated with this splitter.
	//		"top", "bottom", "left", "right".
	region: null,
=====*/

	// live: [const] Boolean
	//		If true, the child's size changes and the child widget is redrawn as you drag the splitter;
	//		otherwise, the size doesn't change until you drop the splitter (by mouse-up)
	live: true,

	templateString: '<div class="dijitSplitter" dojoAttachEvent="onkeypress:_onKeyPress,onmousedown:_startDrag,onmouseenter:_onMouse,onmouseleave:_onMouse" tabIndex="0" role="separator"><div class="dijitSplitterThumb"></div></div>',

	postMixInProperties: function(){
		this.inherited(arguments);

		this.horizontal = /top|bottom/.test(this.region);
		this._factor = /top|left/.test(this.region) ? 1 : -1;
		this._cookieName = this.container.id + "_" + this.region;
	},

	buildRendering: function(){
		this.inherited(arguments);

		dojo.addClass(this.domNode, "dijitSplitter" + (this.horizontal ? "H" : "V"));

		if(this.container.persist){
			// restore old size
			var persistSize = dojo.cookie(this._cookieName);
			if(persistSize){
				this.child.domNode.style[this.horizontal ? "height" : "width"] = persistSize;
			}
		}
	},

	_computeMaxSize: function(){
		// summary:
		//		Return the maximum size that my corresponding pane can be set to

		var dim = this.horizontal ? 'h' : 'w',
			childSize = dojo.marginBox(this.child.domNode)[dim],
			center = dojo.filter(this.container.getChildren(), function(child){ return child.region == "center";})[0],
			spaceAvailable = dojo.marginBox(center.domNode)[dim];	// can expand until center is crushed to 0

		return Math.min(this.child.maxSize, childSize + spaceAvailable);
	},

	_startDrag: function(e){
		if(!this.cover){
			this.cover = dojo.doc.createElement('div');
			dojo.addClass(this.cover, "dijitSplitterCover");
			dojo.place(this.cover, this.child.domNode, "after");
		}
		dojo.addClass(this.cover, "dijitSplitterCoverActive");

		// Safeguard in case the stop event was missed.  Shouldn't be necessary if we always get the mouse up.
		if(this.fake){ dojo.destroy(this.fake); }
		if(!(this._resize = this.live)){ //TODO: disable live for IE6?
			// create fake splitter to display at old position while we drag
			(this.fake = this.domNode.cloneNode(true)).removeAttribute("id");
			dojo.addClass(this.domNode, "dijitSplitterShadow");
			dojo.place(this.fake, this.domNode, "after");
		}
		dojo.addClass(this.domNode, "dijitSplitterActive dijitSplitter" + (this.horizontal ? "H" : "V") + "Active");
		if(this.fake){
			dojo.removeClass(this.fake, "dijitSplitterHover dijitSplitter" + (this.horizontal ? "H" : "V") + "Hover");
		}

		//Performance: load data info local vars for onmousevent function closure
		var factor = this._factor,
			isHorizontal = this.horizontal,
			axis = isHorizontal ? "pageY" : "pageX",
			pageStart = e[axis],
			splitterStyle = this.domNode.style,
			dim = isHorizontal ? 'h' : 'w',
			childStart = dojo.marginBox(this.child.domNode)[dim],
			max = this._computeMaxSize(),
			min = this.child.minSize || 20,
			region = this.region,
			splitterAttr = region == "top" || region == "bottom" ? "top" : "left",	// style attribute of splitter to adjust
			splitterStart = parseInt(splitterStyle[splitterAttr], 10),
			resize = this._resize,
			layoutFunc = dojo.hitch(this.container, "_layoutChildren", this.child.id),
			de = dojo.doc;

		this._handlers = (this._handlers || []).concat([
			dojo.connect(de, "onmousemove", this._drag = function(e, forceResize){
				var delta = e[axis] - pageStart,
					childSize = factor * delta + childStart,
					boundChildSize = Math.max(Math.min(childSize, max), min);

				if(resize || forceResize){
					layoutFunc(boundChildSize);
				}
				// TODO: setting style directly (usually) sets content box size, need to set margin box size
				splitterStyle[splitterAttr] = delta + splitterStart + factor*(boundChildSize - childSize) + "px";
			}),
			dojo.connect(de, "ondragstart", dojo.stopEvent),
			dojo.connect(dojo.body(), "onselectstart", dojo.stopEvent),
			dojo.connect(de, "onmouseup", this, "_stopDrag")
		]);
		dojo.stopEvent(e);
	},

	_onMouse: function(e){
		var o = (e.type == "mouseover" || e.type == "mouseenter");
		dojo.toggleClass(this.domNode, "dijitSplitterHover", o);
		dojo.toggleClass(this.domNode, "dijitSplitter" + (this.horizontal ? "H" : "V") + "Hover", o);
	},

	_stopDrag: function(e){
		try{
			if(this.cover){
				dojo.removeClass(this.cover, "dijitSplitterCoverActive");
			}
			if(this.fake){ dojo.destroy(this.fake); }
			dojo.removeClass(this.domNode, "dijitSplitterActive dijitSplitter"
				+ (this.horizontal ? "H" : "V") + "Active dijitSplitterShadow");
			this._drag(e); //TODO: redundant with onmousemove?
			this._drag(e, true);
		}finally{
			this._cleanupHandlers();
			delete this._drag;
		}

		if(this.container.persist){
			dojo.cookie(this._cookieName, this.child.domNode.style[this.horizontal ? "height" : "width"], {expires:365});
		}
	},

	_cleanupHandlers: function(){
		dojo.forEach(this._handlers, dojo.disconnect);
		delete this._handlers;
	},

	_onKeyPress: function(/*Event*/ e){
		// should we apply typematic to this?
		this._resize = true;
		var horizontal = this.horizontal;
		var tick = 1;
		var dk = dojo.keys;
		switch(e.charOrCode){
			case horizontal ? dk.UP_ARROW : dk.LEFT_ARROW:
				tick *= -1;
//				break;
			case horizontal ? dk.DOWN_ARROW : dk.RIGHT_ARROW:
				break;
			default:
//				this.inherited(arguments);
				return;
		}
		var childSize = dojo._getMarginSize(this.child.domNode)[ horizontal ? 'h' : 'w' ] + this._factor * tick;
		this.container._layoutChildren(this.child.id, Math.max(Math.min(childSize, this._computeMaxSize()), this.child.minSize));
		dojo.stopEvent(e);
	},

	destroy: function(){
		this._cleanupHandlers();
		delete this.child;
		delete this.container;
		delete this.cover;
		delete this.fake;
		this.inherited(arguments);
	}
});

dojo.declare("dijit.layout._Gutter", [dijit._Widget, dijit._Templated],
{
	// summary:
	// 		Just a spacer div to separate side pane from center pane.
	//		Basically a trick to lookup the gutter/splitter width from the theme.
	// description:
	//		Instantiated by `dijit.layout.BorderContainer`.  Users should not
	//		create directly.
	// tags:
	//		private

	templateString: '<div class="dijitGutter" role="presentation"></div>',

	postMixInProperties: function(){
		this.inherited(arguments);
		this.horizontal = /top|bottom/.test(this.region);
	},

	buildRendering: function(){
		this.inherited(arguments);
		dojo.addClass(this.domNode, "dijitGutter" + (this.horizontal ? "H" : "V"));
	}
});

}

if(!dojo._hasResource["plugins.apps.Controller"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.apps.Controller"] = true;
dojo.provide("plugins.apps.Controller");

// OBJECT:  plugins.apps.Controller
// PURPOSE: GENERATE AND MANAGE Apps PANES

// CONTAINER


// GLOBAL ADMIN CONTROLLER VARIABLE
var adminController;

// HAS


dojo.declare( "plugins.apps.Controller",
	[ dijit._Widget, dijit._Templated ],
{
// PANE ID 
paneId : null,

//Path to the template of this widget. 
templateString:"<div dojoAttachPoint=\"containerNode\" class=\"apps\">\n    <button\n        dojoType=\"dijit.form.Button\"\n        dojoAttachPoint=\"menuButton\"\n        class=\"menuButton\"\n        iconClass=\"appsIcon\"\n        type=\"button\"\n        label=\"Apps\"\n        ></button>\n</div>\n        \n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

// TAB PANES
tabPanes : [],

// INPUTS TO PASS TO TAB INSTANCES ON INSTANTIATION
inputs : null,

////}}}

// CONSTRUCTOR	
constructor : function(args) {

	console.log("admin.Controller.constructor    args:");
	console.dir({args:args});

	// SET INPUTS IF PRESENT
	if ( args.inputs )
		this.inputs = args.inputs;
	
	// LOAD CSS FOR BUTTON
	this.loadCSS();		
},
postCreate : function() {
	this.startup();
},
startup : function () {
	////console.log("admin.Controller.startup    plugins.apps.Controller.startup()");

	this.inherited(arguments);

	// ADD MENU BUTTON TO TOOLBAR
	Agua.toolbar.addChild(this.menuButton);
	
	// SET BUTTON PARENT WIDGET
	this.menuButton.parentWidget = this;
	
	// SET ADMIN BUTTON LISTENER
	var listener = dojo.connect(this.menuButton, "onClick", this, "createTab");
},
createTab : function () {
	
	// GET INPUTS
	var inputs = this.inputs;
	
	// CREATE WIDGET	
	var widget;
	if ( ! inputs )
		widget = new plugins.apps.Apps({});
	else
		widget = new plugins.apps.Apps({inputs:inputs});
	
	console.log("admin.Controller.createTab    Doing this.tabPanes.push(widget)");
	this.tabPanes.push(widget);

	// ADD TO _supportingWidgets FOR INCLUSION IN DESTROY	
	this._supportingWidgets.push(widget);
},
createMenu : function () {
// ADD PROGRAMMATIC CONTEXT MENU
	var dynamicMenu = new dijit.Menu( { id: "admin" + this.paneId + 'dynamicMenuPopup'} );

	// ADD MENU TITLE
	dynamicMenu.addChild(new dijit.MenuItem( { label:"Application Menu", disabled:false} ));
	dynamicMenu.addChild(new dijit.MenuSeparator());

	//// ONE OF FOUR WAYS TO DO MENU CALLBACK WITH ACCESS TO THE MENU ITEM AND THE CURRENT TARGET 	
	// 4. dojo.connect CALL
	//	REQUIRES:
	//		ADDED menu.currentTarget SLOT TO dijit.menu
	var mItem1 = new dijit.MenuItem(
		{
			id: "admin" + this.paneId + "remove",
			label: "Remove",
			disabled: false
		}
	);
	dynamicMenu.addChild(mItem1);
	dojo.connect(mItem1, "onClick", function()
		{
			//////////console.log("admin.Controller.++++ dojo.connect mItem1, onClick");	
			var parentNode = dynamicMenu.currentTarget.parentNode;
			parentNode.removeChild(dynamicMenu.currentTarget);	
		}
	);

	// SEPARATOR
	dynamicMenu.addChild(new dijit.MenuSeparator());

	//	ADD run MENU ITEM
	var mItem2 = new dijit.MenuItem(
		{
			id: "admin" + this.paneId + "run",
			label: "Run",
			disabled: false
		}
	);
	dynamicMenu.addChild(mItem2);	

	dojo.connect(mItem2, "onClick", function()
		{
			////////console.log("admin.Controller.++++ 'Run' menu item onClick");
			var currentTarget = dynamicMenu.currentTarget; 
			var adminList = currentTarget.parentNode;
		}
	);
		
	return dynamicMenu;
},
loadCSS : function() {
	// LOAD CSS
	var cssFiles = [ "plugins/apps/css/controller.css" ];
	for ( var i in cssFiles )
	{
		var cssFile = cssFiles[i];
		var cssNode = document.createElement('link');
		cssNode.type = 'text/css';
		cssNode.rel = 'stylesheet';
		cssNode.href = cssFile;
		cssNode.media = 'screen';
		document.getElementsByTagName("head")[0].appendChild(cssNode);
	}
}

}); // end of Controller

dojo.addOnLoad(
	function() {
		//// CREATE TAB
		////console.log("admin.Controller.addOnLoad    BEFORE createTab");
		//Agua.controllers["admin"].createTab();		
		////console.log("admin.Controller.addOnLoad    AFTER createTab");
	}
);


}

if(!dojo._hasResource["plugins.apps.PackageRow"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.apps.PackageRow"] = true;
dojo.provide("plugins.apps.PackageRow");

dojo.declare( "plugins.apps.PackageRow",
	[ dijit._Widget, dijit._Templated ],
{
//Path to the template of this widget. 
templateString:"<div dojoAttachPoint=\"containerNode\">\n    <table width=\"100%\" cellspacing=\"2\">\n        <tr>\n            <td\n                dojoAttachPoint=\"package\"\n                class=\"package\"\n\t\t\t\ttitle=\"package: Name of package\"\n                >${package}</td>\n            <td\n                dojoAttachPoint=\"privacy\"\n                class=\"privacy\"\n\t\t\t\ttitle=\"privacy: Name of privacy\"\n                >${privacy}</td>\n            <td\n                colspan=\"1\"\n                dojoAttachPoint=\"version\"\n                class=\"version\"\n\t\t\t\ttitle=\"version: Version number of package (e.g., '0.8.0')\"\n                >${version}</td>\n        </tr>\n\n\n<!-- TOGGLED PORTION STARTS HERE -->\n<!-- TOGGLED PORTION STARTS HERE -->\n<!-- TOGGLED PORTION STARTS HERE -->\n\n\n        <tr>\n\t\t\t<td\n\t\t\t\talign=\"right\"\n\t\t\t\tcolspan=\"3\"\n\t\t\t\tstyle=\"background-color: AFA !important\"\n\t\t\t>\n\t\t\t\t<table width=\"99%\" style=\"background-color: #FFF;\">\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td\n\t\t\t\t\t\t\tdojoAttachPoint=\"opsdir\"\n\t\t\t\t\t\t\tclass='opsdir'\n\t\t\t\t\t\t\ttitle=\"opsdir: Absolute path to directory containing *.ops file\"\n\t\t\t\t\t\t>${opsdir}</td>\n\t\t\t\t\t</tr>\n\t\t\t\t</table>\n\t\t\t</td>\n        </tr>\n\n        <tr>\n\t\t\t<td\n\t\t\t\talign=\"right\"\n\t\t\t\tcolspan=\"3\"\n\t\t\t\tstyle=\"background-color: AFA !important\"\n\t\t\t>\n\t\t\t\t<table width=\"99%\" style=\"background-color: #FFF;\">\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td\n\t\t\t\t\t\t\tdojoAttachPoint=\"installdir\"\n\t\t\t\t\t\t\tclass='installdir'\n\t\t\t\t\t\t\ttitle=\"installdir: Absolute path to base installation directory\"\n\t\t\t\t\t\t>${installdir}</td>\n\t\t\t\t\t</tr>\n\t\t\t\t</table>\n\t\t\t</td>\n        </tr>\n\n        <tr>\n\t\t\t<td\n\t\t\t\talign=\"right\"\n\t\t\t\tcolspan=\"3\"\n\t\t\t\tstyle=\"background-color: AFA !important\"\n\t\t\t>\n\t\t\t\t<table width=\"99%\" style=\"background-color: #FFF;\">\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td\n\t\t\t\t\t\t\tdojoAttachPoint=\"description\"\n\t\t\t\t\t\t\tclass='description'\n\t\t\t\t\t\t\ttitle=\"description: A brief description of the package\"\n\t\t\t\t\t\t>${description}</td>\n\t\t\t\t\t</tr>\n\t\t\t\t</table>\n\t\t\t</td>\n        </tr>\n\n        <tr>\n\t\t\t<td\n\t\t\t\talign=\"right\"\n\t\t\t\tcolspan=\"3\"\n\t\t\t\tstyle=\"background-color: AFA !important\"\n\t\t\t>\n\t\t\t\t<table width=\"99%\" style=\"background-color: #FFF;\">\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td\n\t\t\t\t\t\t\tdojoAttachPoint=\"notes\"\n\t\t\t\t\t\t\tclass='notes'\n\t\t\t\t\t\t\ttitle=\"notes: Notes on the package (e.g., release notes)\"\n\t\t\t\t\t\t>${notes}</td>\n\t\t\t\t\t</tr>\n\t\t\t\t</table>\n\t\t\t</td>\n        </tr>\n        <tr>\n\t\t\t<td\n\t\t\t\talign=\"right\"\n\t\t\t\tcolspan=\"3\"\n\t\t\t\tstyle=\"background-color: AFA !important\"\n\t\t\t>\n\t\t\t\t<table width=\"99%\" style=\"background-color: #FFF;\">\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td\n\t\t\t\t\t\t\tdojoAttachPoint=\"url\"\n\t\t\t\t\t\t\tclass='url'\n\t\t\t\t\t\t\ttitle=\"url: Web address of website providing further details (e.g., http://mysite.com/packages)\"\n\t\t\t\t\t\t>${url}</td>\n\t\t\t\t\t</tr>\n\t\t\t\t</table>\n\t\t\t</td>\n        </tr>\n    </table>\n</div>\n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

// PARENT plugins.apps.Packages WIDGET
parentWidget : null,

/////}}}

constructor : function(args) {
	////console.log("PackageRow.constructor    plugins.workflow.PackageRow.constructor()");
	////console.log("PackageRow.constructor    args.submit: " + args.submit);
	this.parentWidget = args.parentWidget;
	this.formInputs = this.parentWidget.formInputs;
},


postCreate : function() {
	this.startup();
},

startup : function () {
	console.log("PackageRow.startup    this: " + this);

	this.inherited(arguments);
	
	// CONNECT TOGGLE EVENT
	this.setToggle();

	// ADD 'EDIT' ONCLICKS
	this.setEdit();
},

setToggle : function () {
// CONNECT TOGGLE EVENT
	var thisObject = this;
	var array = [ "package", "version" ];
	for ( var i in array )
	{
		dojo.connect(this[array[i]], "onclick", function(event) {
		//dojo.connect( this.package, "onclick", function(event) {
			thisObject.toggle();
		});
	}	
},

setEdit : function () {
// ADD 'EDIT' ONCLICKS
	var thisObject = this;
	var array = [ "opsdir", "description", "notes", "url" ];
	for ( var i in array )
	{
		dojo.connect(this[array[i]], "onclick", function(event)
			{
				//console.log("PackageRow.startup    onclick fired. event.target: " + event.target);
				thisObject.parentWidget.editRow(thisObject, event.target);
				event.stopPropagation(); //Stop Event Bubbling
			}
		);
	}
},

// TOGGLE HIDDEN DETAILS	
toggle : function () {
	////console.log("PackageRow.toggle    plugins.workflow.PackageRow.toggle()");
	//////console.log("PackageRow.toggle    this.description: " + this.description);
	var array = [ "opsdir", "installdir", "description", "notes", "url" ];
	for ( var i in array )
	{
		//console.log("PackageRow.toggle    this[" + array[i] + "] :" + this[array[i]]);
		if ( this[array[i]].style.display == 'inline-block' )	
			this[array[i]].style.display='none';
		else
			this[array[i]].style.display = 'inline-block';
	}
}

});
	

}

if(!dojo._hasResource["plugins.apps.Packages"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.apps.Packages"] = true;
dojo.provide("plugins.apps.Packages");

// ALLOW THE USER TO ADD, REMOVE AND MODIFY APPS

// EXTERNAL MODULES









// INTERNAL MODULES




// HAS A


dojo.declare("plugins.apps.Packages",
	[ dijit._Widget, dijit._Templated, plugins.core.Common, plugins.form.EditForm ],
{
		
//Path to the template of this widget. 
templateString:"<div dojoattachpoint=\"containerNode\">\n\n\t<!-- APPS TAB -->\n\t<div\n\t\tdojoAttachPoint=\"mainTab\"\n\t\tclass=\"packages\"\n\t\tdojoType=\"dijit.layout.ContentPane\"\n\t\ttitle=\"Packages\"\n\t\tstyle=\"height: 100% !important; max-height: auto !important; width: 390px !important; padding: 0 !important;\"\n\t\t>\n\n<table width=\"100%\">\n\t<tr valign=\"top\" width=\"100%\">\n\t\t<td colspan=\"2\" class=\"tabTitle\" align=\"center\">\n\t\t\t<!--<div class=\"tabTitleIcon\">-->\n\t\t\t\tPackages\n\t\t\t<!--</div>-->\n\t\t</td>\n\t</tr>\n\n\t<tr valign=\"top\" width=\"95%\">\n\t\t<td width=\"100%\">\n\t\t\t<!--<div class=\"label\"> New Package </div>-->\n\t\t\t<table width=\"100%\">\n\t\t\t\t<tr width=\"100%\">\n\n\t\t\t\t\t<td colspan=\"3\" height=\"32px\">\n\t\t\t\t\t\t\n\t\t\t\t\t\t<table cellspacing=\"0\" cellpadding=\"0\" border=\"0\" style=\"padding: 0; margin: 0;\">\n\n\t\t\t\t\t\t\t<tr>\n\n\t\t\t\t\t\t\t\t<td \n\t\t\t\t\t\t\t\t\tstyle=\"padding-right: 10px;\" >\n\t\t\t\t\t\t\t\t\t<textarea\n\t\t\t\t\t\t\t\t\t\tspellcheck=\"false\"\n\t\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"package\"\n\t\t\t\t\t\t\t\t\t\tclass=\"package\"\n\t\t\t\t\t\t\t\t\t\tcols=\"30\"\n\t\t\t\t\t\t\t\t\t\trows=\"1\"\n\t\t\t\t\t\t\t\t\t\ttitle=\"name: Name of package\"\n\t\t\t\t\t\t\t\t\t\t>Name</textarea>\n\t\t\t\t\t\t\t\t</td>\n\t\n\t\t\t\t\t\t\t\t<td height=\"20px\"\n\t\t\t\t\t\t\t\t\twidth=\"120px\"\n\t\t\t\t\t\t\t\t\talign=\"right\">\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"addPackageButton\"\n\t\t\t\t\t\t\t\t\t\tclass=\"addPackageButton\"\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\tNew Package\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t</table>\n\t\t\t\t\t</td>\n\n\t\t\t\t</tr>\n\n\t\t\t\t<tr class=\"headerRow\" width=\"100%\" height=\"8px\">\n\t\t\t\t\t<td >Version</td>\n\t\t\t\t\t<td>Privacy</td>\n\t\t\t\t</tr>\n\n\t\t\t\t<tr width=\"100%\">\n\t\t\t\t\t<td >\n\t\t\t\t\t\t<textarea\n\t\t\t\t\t\t\tspellcheck=\"false\"\n\t\t\t\t\t\t\tdojoAttachPoint=\"version\"\n\t\t\t\t\t\t\tclass=\"version\"\n\t\t\t\t\t\t\tcols=\"40\"\n\t\t\t\t\t\t\trows=\"1\"\n\t\t\t\t\t\t\ttitle=\"version: Version of package (format: N.N.N, i.e., major.minor.patch)\"\n\t\t\t\t\t\t\t>Version</textarea>\n\t\t\t\t\t</td>\n\t\t\t\t\t\n\t\t\t\t\t<td>\n\t\t\t\t\t\t<select\n\t\t\t\t\t\t\tclass=\"privacy\"\n\t\t\t\t\t\t\tdojoAttachPoint=\"privacy\"\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<option value=\"public\">public</option>\n\t\t\t\t\t\t\t<option value=\"private\">private</option>\n\t\t\t\t\t\t</select>\n\t\t\t\t\t</td>\n\t\t\t\t</tr>\n\n\t\t\t\t<tr class=\"headerRow\" width=\"100%\" height=\"8px\">\n\t\t\t\t\t<td width=\"100%\" colspan=\"3\">Opsdir</td>\n\t\t\t\t</tr>\n\n\t\t\t\t<tr width=\"100%\">\n\t\t\t\t\t<td colspan=\"3\">\n\t\t\t\t\t\t<textarea\n\t\t\t\t\t\t\tspellcheck=\"false\"\n\t\t\t\t\t\t\tdojoAttachPoint=\"opsdir\"\n\t\t\t\t\t\t\tclass=\"opsdir\"\n\t\t\t\t\t\t\tstyle=\"width: 100%; font-weight: bolder; font-family: Verdana;\";\n\t\t\t\t\t\t\tcols=\"40\"\n\t\t\t\t\t\t\trows=\"1\"\n\t\t\t\t\t\t\ttitle=\"opsdir: Absolute path to directory containing *.ops file\"\n\t\t\t\t\t\t\t>Opsdir</textarea>\n\t\t\t\t\t</td>\n\t\t\t\t</tr>\n\n\t\t\t\t<tr class=\"headerRow\" width=\"100%\" height=\"8px\">\n\t\t\t\t\t<td width=\"100%\" colspan=\"3\">Installdir</td>\n\t\t\t\t</tr>\n\n\t\t\t\t<tr width=\"100%\">\n\t\t\t\t\t<td colspan=\"3\">\n\t\t\t\t\t\t<textarea\n\t\t\t\t\t\t\tspellcheck=\"false\"\n\t\t\t\t\t\t\tdojoAttachPoint=\"installdir\"\n\t\t\t\t\t\t\tclass=\"installdir\"\n\t\t\t\t\t\t\tstyle=\"width: 100%; font-weight: bolder; font-family: Verdana;\";\n\t\t\t\t\t\t\tcols=\"40\"\n\t\t\t\t\t\t\trows=\"1\"\n\t\t\t\t\t\t\ttitle=\"installdir: Absolute path to base installation directory\"\n\t\t\t\t\t\t\t>Installdir</textarea>\n\t\t\t\t\t</td>\n\t\t\t\t</tr>\n\n\t\t\t\t<tr class=\"headerRow\" width=\"100%\">\n\t\t\t\t\t<td colspan=\"3\"\n\t\t\t\t\t\tclass=\"toggleTitle\"\n\t\t\t\t\t\tdojoAttachEvent=\"onclick:toggle\"\n\t\t\t\t\t\ttitle=\"description: A brief description of the package\"\n\t\t\t\t\t> Details (Click to toggle)</td>\n\t\t\t\t</tr>\n\n\t\t\t\t<tr class=\"headerRow\" width=\"100%\">\n\t\t\t\t\t<td colspan=\"3\"\n\t\t\t\t\t\tstyle=\"display: none;\"\n\t\t\t\t\t\ttitle=\"notes: A brief description of the package\"\n\t\t\t\t\t\tdojoAttachPoint=\"descriptionTitle\"\n\t\t\t\t\t>Description</td>\n\t\t\t\t</tr>\n\t\t\t\t<tr>\n\t\t\t\t\t<td colspan=\"3\">\n\t\t\t\t\t\t<textarea\n\t\t\t\t\t\t\tspellcheck=\"false\"\n\t\t\t\t\t\t\tdojoAttachPoint=\"description\"\n\t\t\t\t\t\t\tclass=\"description\"\n\t\t\t\t\t\t\tstyle=\"display: none; width:100%; font-weight: bolder; font-family: Verdana;\";\n\t\t\t\t\t\t\tcols=\"40\"\n\t\t\t\t\t\t\trows=\"1\"\n\t\t\t\t\t\t\ttitle=\"description: A brief description of the package\"\n\t\t\t\t\t\t>Description</textarea>\n\t\t\t\t\t</td>\n\t\t\t\t</tr>\n\n\t\t\t\t<tr class=\"headerRow\" width=\"100%\">\n\t\t\t\t\t<td colspan=\"3\"\n\t\t\t\t\t\tstyle=\"display: none;\"\n\t\t\t\t\t\ttitle=\"notes: Notes on the package (e.g., release notes)\"\n\t\t\t\t\t\tdojoAttachPoint=\"notesTitle\"\n\t\t\t\t\t>Notes</td>\n\t\t\t\t</tr>\n\n\t\t\t\t<tr>\n\t\t\t\t\t<td colspan=\"3\">\n\t\t\t\t\t\t<textarea\n\t\t\t\t\t\t\tspellcheck=\"false\"\n\t\t\t\t\t\t\tdojoAttachPoint=\"notes\"\n\t\t\t\t\t\t\tclass=\"notes\"\n\t\t\t\t\t\t\tvalue=\"Notes\"\n\t\t\t\t\t\t\tstyle=\"display: none; width:100%; font-weight: bolder; font-family: Verdana;\";\n\t\t\t\t\t\t\tcols=\"40\"\n\t\t\t\t\t\t\trows=\"1\"\n\t\t\t\t\t\t\ttitle=\"notes: Notes on the package (e.g., release notes)\"\n\t\t\t\t\t\t>Notes</textarea>\n\t\t\t\t\t</td>\n\t\t\t\t</tr>\n\n\t\t\t\t<tr class=\"headerRow\" width=\"100%\">\n\t\t\t\t\t<td\n\t\t\t\t\t\tcolspan=\"3\"\n\t\t\t\t\t\tstyle=\"display: none;\"\n\t\t\t\t\t\tdojoAttachPoint=\"urlTitle\"\n\t\t\t\t\t\ttitle=\"url: Web address of website providing further details (e.g., http://mysite.com/packages)\"\n\t\t\t\t\t\t>URL</td>\n\t\t\t\t</tr>\n\n\t\t\t\t<tr>\n\t\t\t\t\t<td colspan=\"3\">\n\t\t\t\t\t\t<textarea\n\t\t\t\t\t\t\tspellcheck=\"false\"\n\t\t\t\t\t\t\tdojoAttachPoint=\"url\"\n\t\t\t\t\t\t\tclass=\"url\"\n\t\t\t\t\t\t\tvalue=\"URL\"\n\t\t\t\t\t\t\tstyle=\"display: none; width:100%; font-weight: bolder; font-family: Verdana;\";\n\t\t\t\t\t\t\tcols=\"40\"\n\t\t\t\t\t\t\trows=\"1\"\n\t\t\t\t\t\t\ttitle=\"url: Web address of website providing further details (e.g., http://mysite.com/packages)\"\n\t\t\t\t\t\t>URL</textarea>\n\t\t\t\t\t</td>\n\t\t\t\t</tr>\n\n\t\t\t</table>\n\t\t</td>\n\t</tr>\n\t\n\t<tr>\n\t\t<td>\n\t\t\t<div\n\t\t\t\tdojoAttachPoint=\"dragSourceNode\"\n\t\t\t\tclass=\"dragSource\"\n\t\t\t\tstyle=\"height: 385px; width: 96%;\"\n\t\t\t>\n\t\t\t</div>\n\t\t</td>\n\t</tr>\n\n\t<tr align=\"center\">\n\t\t<td align=\"center\">\n\n\t\t\t<!-- TRASH CONTAINER -->\n\t\t\t<div\n\t\t\t\tdojoAttachPoint=\"trashContainer\"\n\t\t\t\tclass=\"trash\"\n\t\t\t\tstyle=\"height: 60px; width: 150px; align: center;\" \n\t\t\t\t>\n\t\t\t\t<div\n\t\t\t\t\tdojoAttachPoint=\"trashIcon\"\n\t\t\t\t\tclass=\"trashIcon\"\n\t\t\t\t\tstyle=\"height: 60px; width: 60px;\"\n\t\t\t\t\t>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</td>\n\t</tr>\n</table>\n\n\n\n\t</div>\n\t<!-- END SOURCES TAB -->\n\t\n</div> \n\n\n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

//addingPackage STATE
addingPackage : false,

// OR USE @import IN HTML TEMPLATE
cssFiles : [ dojo.moduleUrl("plugins", "apps/css/packages.css") ],

// PARENT WIDGET
parentWidget : null,

formInputs : {
	"package"		:	"word",
	"version"		:	"word",
	"privacy"		:	"word",
	"opsdir"		:	"word",
	"installdir"	:	"word",
	"description"	:	"phrase",
	"notes"			:	"phrase",
	"url"			:	"word"
},

requiredInputs : {
// REQUIRED INPUTS CANNOT BE ''
	'package' 	:	1,
	version 	:	1, 
	opsdir		:	1,
	installdir	:	1
},

invalidInputs : {
// THESE INPUTS ARE INVALID
	'package' 	: 	"Name",
	version     : 	"Version", 
	privacy		: 	"Privacy",
	opsdir		: 	"Opsdir",
	installdir	: 	"Installdir",
	description	: 	"Description",
	notes		: 	"Notes",
	url			: 	"URL"
},

defaultInputs : {
// THESE INPUTS ARE default
	'package' 	: 	"Name",
	version 	: 	"Version", 
	privacy		: 	"Privacy",
	opsdir		: 	"Opsdir",
	installdir	: 	"Installdir",
	description	: 	"Description",
	notes		: 	"Notes",
	url			: 	"URL"
},

dataFields : ["package", "version", "privacy", "opsdir", "installdir"],

avatarItems : [ "package", "description" ],

rowClass : "plugins.apps.PackageRow",

/////}}}
constructor : function(args) {
	////////////console.log("Packages.constructor     plugins.apps.Packages.constructor");			
	// GET INFO FROM ARGS
	this.parentWidget = args.parentWidget;
	this.packages = args.parentWidget.packages;

},
postCreate : function() {
	////////////console.log("Controller.postCreate    plugins.apps.Controller.postCreate()");
	// LOAD CSS
	this.loadCSS();		

	this.startup();
},
startup : function () {
	//console.log("Packages.startup    plugins.apps.Packages.startup()");

	// COMPLETE CONSTRUCTION OF OBJECT
	this.inherited(arguments);	 

	// ADD TO TAB CONTAINER		
	this.tabContainer.addChild(this.mainTab);
	this.tabContainer.selectChild(this.mainTab);

	// SET DRAG SOURCE
	this.setDragSource();

	// SET NEW APP FORM
	this.setForm();

	// SUBSCRIBE TO UPDATES
	Agua.updater.subscribe(this, "updatePackages");

	// SET TRASH
	this.setTrash(this.dataFields);	
},
updatePackages : function (args) {
// RELOAD GROUP COMBO AND DRAG SOURCE AFTER CHANGES
// TO SOURCES OR GROUPS DATA IN OTHER TABS
	console.log("Packages.updatePackages    Packages.updatePackages(args)");
	console.log("Packages.updatePackages    args:");
	console.dir(args);

	// CHECK ARGS
	if ( args != null && args.reload == false )	return;
	if ( args.originator && args.originator == this )	return;
	
	// SET DRAG SOURCE
	console.log("Packages.updatePackages    Calling setDragSource()");
	
	this.setDragSource();
},
setForm : function () {
	// SET ADD ONCLICK
	dojo.connect(this.addPackageButton, "onclick", dojo.hitch(this, "saveInputs", null, { reload: true }));

	// SET ONCLICK TO CANCEL INVALID TEXT
	this.setClearValues();

	// CHAIN TOGETHER INPUTS ON 'RETURN' KEYPRESS
	this.chainInputs(["package", "type", "executor", "version", "location", "description", "notes", "url", "addPackageButton"]);	
},
getItemArray : function () {
	//console.log("Packages.getItemArray     plugins.apps.Packages.getItemArray()");
	var itemArray = Agua.getPackages();
	//console.log("Packages.getItemArray     itemArray: " + dojo.toJson(itemArray));
	console.log("Packages.getItemArray    itemArray.length: " + itemArray.length);

	itemArray = itemArray.sort();
	return itemArray;
},
changeDragSource : function () {
	//console.log("Packages.changeDragSource     plugins.apps.Packages.changeDragSource()");
	//console.log("Packages.changeDragSource     this.dragSourceOnchange: " + this.dragSourceOnchange);
	
	//if ( this.dragSourceOnchange == false )
	//{
	//	//console.log("Packages.changeDragSource     this.dragSourceOnchange is false. Returning");
	//	this.dragSourceOnchange = true;
	//	return;
	//}
	
	//console.log("Packages.changeDragSource     Doing this.setDragSource");
	this.setDragSource();
},
deleteItem : function (packageObject) {
// DELETE APPLICATION FROM Agua.packages OBJECT AND IN REMOTE DATABASE
	////console.log("Packages.deleteItem    plugins.apps.Packages.deleteItem(package)");
	////console.log("Packages.deleteItem    package: " + package);

	// CLEAN UP WHITESPACE
	packageObject["package"] = packageObject["package"].replace(/\s+$/,'');
	packageObject["package"] = packageObject["package"].replace(/^\s+/,'');

	// REMOVING APP FROM Agua.packages
	Agua.removePackage(packageObject, "custom");
	
	var url = Agua.cgiUrl + "admin.cgi?";
	////console.log("Packages.deleteStore     url: " + url);		

	// CREATE JSON QUERY
	var query = new Object;
	query.username = Agua.cookie('username');
	query.sessionid = Agua.cookie('sessionid');
	query.mode = "removePackage";
	query.data = packageObject;
	console.log("Packages.deleteItem    query: " + dojo.toJson(query));

	this.doPut({url: url, query: query, doToast: false});
	
	// RELOAD RELEVANT DISPLAYS
	Agua.updater.update("updatePackages", { originator: this });

	// RELOAD RELEVANT DISPLAYS
	
}, // Packages.deleteItem
saveInputs : function (inputs, updateArgs) {
//	SAVE AN APPLICATION TO Agua.packages AND TO REMOTE DATABASE
	console.log("Packages.saveInputs    caller: " + this.saveInputs.caller.nom);
	console.log("Packages.saveInputs    inputs: ");
	console.dir({inputs:inputs});

	if ( this.savingPackage == true )	return;
	this.savingPackage = true;

	if ( inputs == null )
	{
		inputs = this.getFormInputs(this);

		// RETURN IF INPUTS ARE NULL
		if ( inputs == null )
		{
			this.savingPackage = false;
			return;
		}
	}
	console.log("Packages.saveInputs    FINAL inputs: ");
	console.dir({inputs:inputs});

	// RETURN IF PACKAGE ALREADY EXISTS
	var isPackage = Agua.isPackage(inputs["package"]);
	console.log("Packages.saveInputs    isPackage: " + isPackage)
	if ( isPackage ) {
		console.log("Packages.saveInputs    package exits already. Returning");
		this.setInvalid(this["package"]);
		Agua.toastMessage({
			message: "Package exists already: " + inputs["package"],
			type: "error"
		});
		this.savingPackage = false;
		return;
	}	

	inputs.owner = Agua.cookie('username');
	inputs.username = Agua.cookie('username');

	// REMOVE ORIGINAL APPLICATION OBJECT FROM Agua.packages 
	// THEN ADD NEW APPLICATION OBJECT TO Agua.packages
	Agua.removePackage({ thisPackage: inputs["package"] });
	Agua.addPackage(inputs);

	// CREATE JSON QUERY
	var query = new Object;
	query.username = Agua.cookie('username');
	query.sessionid = Agua.cookie('sessionid');
	query.mode = "addPackage";
	query.data = inputs;
	var url = Agua.cgiUrl + "admin.cgi?";
	////////////console.log("Packages.saveInputs    query: " + dojo.toJson(query));
	
	// SEND TO SERVER
	dojo.xhrPut(
		{
			url: url,
			contentType: "text",
			putData: dojo.toJson(query),
			//timeout: 15000,
			handle: function(response, ioArgs) {
				////////////console.log("Packages.saveInputs    JSON Post worked.");
				return response;
			},
			error: function(response, ioArgs) {
				////////////console.log("Packages.saveInputs    Error with JSON Post, response: " + response + ", ioArgs: " + ioArgs);
				return response;
			}
		}
	);

	this.savingPackage = false;

	// TRIGGER UPDATES
	// NB: updateArgs.reload = true
	Agua.updater.update("updatePackages", updateArgs);

}, // Packages.saveInputs
toggle : function () {
// TOGGLE HIDDEN DETAILS	
	////console.log("Packages.toggle    plugins.workflow.Packages.toggle()");
	//////console.log("Packages.toggle    this.description: " + this.description);
	var array = [ "descriptionTitle", "description", "notesTitle", "notes", "urlTitle" , "url" ];
	
	for ( var i in array )
	{
		//console.log("PackageRow.toggle    this[" + array[i] + "] :" + this[array[i]]);
		if ( this[array[i]].style.display == 'inline' )	
			this[array[i]].style.display='none';
		else
			this[array[i]].style.display = 'inline';
	}
},
getFormInputs : function (widget) {
// GET INPUTS FROM THE EDITED ITEM
	////console.log("Packages.getFormInputs    plugins.apps.Packages.getFormInputs(textarea)");
	//////console.log("Packages.getFormInputs    widget: " + widget);
	var inputs = new Object;
	for ( var name in this.formInputs )
	{
		inputs[name]  = this.processWidgetValue(widget, name);
		////console.log("Packages.getFormInputs    inputs[name]: " + inputs[name]);
	}

	inputs = this.checkInputs(widget, inputs);
	////console.log("Packages.getFormInputs    FINAL inputs: " + dojo.toJson(inputs));

	return inputs;
}


}); // plugins.apps.Packages

}

if(!dojo._hasResource["plugins.apps.ParameterRow"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.apps.ParameterRow"] = true;
dojo.provide("plugins.apps.ParameterRow");

dojo.declare( "plugins.apps.ParameterRow",
	[ dijit._Widget, dijit._Templated ],
{
	////}}
//Path to the template of this widget. 
templateString:"<div dojoAttachPoint=\"containerNode\">\n    <table class=\"parameterrow\" width=\"100%\" cellspacing=\"2\">\n        <tr>\n            <td\n                colspan=\"1\"\n                dojoAttachPoint=\"name\"\n                class=\"name\"\n                width=\"100px\"\n                title=\"name: Name of parameter\"\n                >${name}</td>\n\n\n            <td colspan=\"1\"\n                width=\"100px\"\n                class=\"lockedValueTypeContainer\"\n            >\n\n                <table>\n                    <tr>\n                        <td dojoAttachPoint=\"locked\"\n                            dojoAttachEvent=\"onclick:toggleLock\"\n                            class=\"unlocked\"\n                        >\n                        </td>\n                        \n                        <td\n                            colspan=\"1\"\n                        >\n            \n                            <select\n                                dojoAttachPoint=\"paramtype\"\n                                class='paramtype'\n                                title=\"paramtype: Select type of parameter (input, resource or output)\"\n                                >\n                                <option selected=\"true\" class=\"default\" value=\"${paramtype}\">${paramtype}</option>\n                                <option value=\"input\">input</option>\n                                <option value=\"resource\">resource</option>\n                                <option value=\"output\">output</option>\n                            </select>\n                        \n                        </td>\n                    </tr>\n                </table>\n            \n            </td>\n\n            <td\n                colspan=\"1\"\n                width=\"100px\"\n                class=\"discretion\"\n            >\n\n                <select\n                    dojoAttachPoint=\"discretion\"\n                    class='discretionSelect'\n                    title=\"discretion: Select 'optional',  'required' (must not be empty) or 'essential' (file/directory must be present)\"\n                >\n                    <option selected=\"true\" class=\"default\" value=\"${discretion}\">${discretion}</option>\n                    <option value=\"essential\">essential</option>\n                    <option value=\"required\">required</option>\n                    <option value=\"optional\">optional</option>\n                </select>\n            \n            </td>\n        </tr>\n        \n        \n<!-- TOGGLED PORTION STARTS HERE -->\n<!-- TOGGLED PORTION STARTS HERE -->\n<!-- TOGGLED PORTION STARTS HERE -->\n\n        \n        <tr>\n            <td \n                dojoAttachPoint=\"argument\"\n                colspan=\"1\"\n                class=\"argument\"\n                title=\"argument: Command line argument for parameter (e.g., '--inputfile')\"\n                >${argument}</td>\n\n            <td\n                dojoAttachPoint=\"valuetypeToggle\"\n                class=\"valuetype\"\n                colspan=\"1\"\n                >\n\n                <select\n                    dojoAttachPoint=\"valuetype\"\n                    class=\"valuetype\"\n                    title=\"valuetype: Type of parameter may be physical (e.g., file or directory) or abstract (e.g., integer or text string)\"\n                    >\n                    <option selected=\"true\" value=\"${valuetype}\">${valuetype}</option>\n                    <option value=\"file\">file</option>\n                    <option value=\"files\">files</option>\n                    <option value=\"directory\">directory</option>\n                    <option value=\"directories\">directories</option>\n                    <option value=\"integer\">integer</option>\n                    <option value=\"string\">string</option>\n                    <option value=\"flag\">flag</option>\n                </select>            \n            </td>\n\n            <td\n                colspan=\"1\"\n                dojoAttachPoint=\"category\"\n                class=\"category\"\n                title=\"category: User-defined category for parameter to be used with input/output chaining. (E.g, the category 'inputfile' includes parameters with arguments '-i', '-infile' and '--inputfile'.)\"\n                >${category}</td>\n        </tr>\n        <tr>\n            <td colspan=\"2\"\n                dojoAttachPoint=\"value\"\n                class='value'\n                title=\"value: Default value of parameter (use '%project%/%workflow%/' for default file path)\"\n                >${value}</td>\n\n            <td colspan=\"1\"\n                class=\"ordinal\"\n                dojoAttachPoint=\"ordinalToggle\"\n            >\n                <table>\n                    <tr>\n                        <td>\n                            <select\n                                class=\"ordinal\"\n                                dojoAttachPoint=\"ordinal\"\n                                title=\"ordinal: Adjust the ordinal value if your application requires the parameters to be in a certain order. Parameters with the same ordinal will be grouped together in alphabetical order.\"\n                                >\n                                <option selected=\"true\" value=\"${ordinal}\">${ordinal}</option>\n                                <option value=\"0\">0</option>\n                                <option value=\"1\">1</option>\n                                <option value=\"2\">2</option>\n                                <option value=\"3\">3</option>\n                                <option value=\"4\">4</option>\n                                <option value=\"5\">5</option>\n                                <option value=\"6\">6</option>\n                                <option value=\"7\">7</option>\n                                <option value=\"8\">8</option>\n                                <option value=\"9\">9</option>\n                                <option value=\"10\">10</option>\n                                <option value=\"11\">11</option>\n                                <option value=\"12\">12</option>\n                                <option value=\"13\">13</option>\n                                <option value=\"14\">14</option>\n                                <option value=\"15\">15</option>\n                            </select>            \n            \n            \n                        <td \n                            colspan=\"1\"\n                            dojoAttachPoint=\"format\"\n                            class=\"format\"\n                            title=\"format: Special file format, to be used for parameter chaining or file checking (e.g., FASTA, FASTQ)\"\n                        >${format}</td>\n\n                    </tr>\n                </table>\n\n            </td>\n            \n        </tr>\n\n        <tr>\n            <td colspan=\"3\"\n                dojoAttachPoint=\"description\"\n                class='description'\n                title=\"description: A description of the parameter and its usage\"\n            >${description}</td>\n\n        </tr>\n\n        <tr>\n            <td\n                colspan=\"1\"\n                dojoAttachPoint=\"args\"\n                class=\"args\"\n                title=\"args: Arguments for input/output chaining function (e.g., 'input.inputfile.value')\"\n            >${args}</td>\n            <td\n                colspan=\"2\"\n                dojoAttachPoint=\"inputParams\"\n                class=\"inputParams\"\n                title=\"inputParams: Comma-separated list of variable names for each arg in the list of args for the paramFunction (e.g., 'inputfile')\"\n            >${inputParams}</td>\n        </tr>\n\n        <tr>\n            <td colspan=\"3\"\n                width=\"360px\"\n                dojoAttachPoint=\"paramFunction\"\n                class='paramFunction'\n                title=\"paramFunction: Input/output chaining function to automatically determine parameter value from the application itself or the preceding application in the workflow (e.g., 'if ( inputfile != null ) return inputfile')\"\n            >${paramFunction}</td>\n        </tr>\n\n    </table>\n</div>\n\n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

// PARENT plugins.apps.Apps WIDGET
parentWidget : null,

constructor : function(args) {
	//console.log("ParameterRow.constructor    plugins.workflow.ParameterRow.constructor(args)");

	this.parentWidget = args.parentWidget;
	this.lockedValue = args.locked;
},

postCreate : function(args) {
	//console.log("ParameterRow.postCreate    plugins.workflow.ParameterRow.postCreate(args)");
	this.formInputs = this.parentWidget.formInputs;
	this.startup();
},

startup : function () {
	//console.log("ParameterRow.startup    plugins.workflow.ParameterRow.startup()");
	this.inherited(arguments);
	
	// CONNECT TOGGLE EVENT
	var thisObject = this;
	dojo.connect( this.name, "onclick", function(event) {
		thisObject.toggle();
	});

	// SET LISTENER TO LEVEL ROW HEIGHTS
	this.setRowHeightListeners();

	// LEVEL ROW HEIGHT
	//this.levelRowHeight(this);
	//this.levelRowHeight(this);
	//this.toggleNode(this.args);
	//this.toggleNode(this.inputParams);

	//console.log("ParameterRow.startup    this.lockedValue: " + this.lockedValue);
	// SET LOCKED CLASS
	if ( this.lockedValue == 1 )	{
		dojo.removeClass(this.locked,'unlocked');
		dojo.addClass(this.locked,'locked');
	}
	else	{
		dojo.removeClass(this.locked,'locked');
		dojo.addClass(this.locked,'unlocked');
	}

	// ADD 'ONCLICK' EDIT VALUE LISTENERS
	var thisObject = this;
	var onclickArray = [ "argument", "category", "value", "description", "format", "args", "inputParams", "paramFunction" ];
	for ( var i in onclickArray )
	{
		dojo.connect(this[onclickArray[i]], "onclick", function(event)
			{
				console.log("ParameterRow.startup    onclick listener fired: " + onclickArray[i]);
				thisObject.parentWidget.editRow(thisObject, event.target);
				event.stopPropagation(); //Stop Event Bubbling
			}
		);
	}

	// ADD 'ONCHANGE' COMBO BOX LISTENERS
	var thisObject = this;
	var onchangeArray = [ "valuetype", "ordinal", "discretion", "paramtype" ];
	for ( var i in onchangeArray )
	{
		dojo.connect(this[onchangeArray[i]], "onchange", function(event)
			{
				console.log("ParameterRow.startup    onchange listener fired: " + onchangeArray[i]);
				var inputs = thisObject.parentWidget.getFormInputs(thisObject);
				thisObject.parentWidget.saveInputs(inputs, {originator: thisObject.parentWidget, reload: false});
				event.stopPropagation(); //Stop Event Bubbling
			}
		);
	}	
},

setRowHeightListeners : function () {

	var thisObject = this;
	dojo.connect(this.args, 'onchange', dojo.hitch(function (event) {
		////console.log("ParameterRow.setRowHeightListeners    args    this: " + this);
		////console.log("ParameterRow.setRowHeightListeners    args    thisObject: " + thisObject);
		////console.log("ParameterRow.setRowHeightListeners    args.onchange");
		//thisObject.levelRowHeight(thisObject);
		setTimeout(function(thisObj){ thisObj.levelRowHeight(thisObj)}, 100, thisObject);
		event.stopPropagation();
	}));
	dojo.connect(this.inputParams, 'onchange', dojo.hitch(function (event) {
		////console.log("ParameterRow.setRowHeightListeners    inputParams    this: " + this);
		////console.log("ParameterRow.setRowHeightListeners    inputParams    thisObject: " + thisObject);
		////console.log("ParameterRow.setRowHeightListeners    inputParams.onchange");
		setTimeout(function(thisObj){ thisObj.levelRowHeight(thisObj)}, 100, thisObject);
		event.stopPropagation();
	}));
	
},

levelRowHeight : function (paramRow) {
	//console.log("XXXX ParameterRow.levelRowHeight    plugins.workflow.ParameterRow.levelRowHeight()");
	//console.log("ParameterRow.levelRowHeight    BEFORE paramRow.args.clientHeight: " + paramRow.args.clientHeight);
	//console.log("ParameterRow.levelRowHeight    BEFORE this.inputParams.clientHeight: " + paramRow.inputParams.clientHeight);
	//console.log("ParameterRow.levelRowHeight    BEFORE paramRow.args.offsetHeight: " + paramRow.args.offsetHeight);
	//console.log("ParameterRow.levelRowHeight    BEFORE this.inputParams.offsetHeight: " + paramRow.inputParams.offsetHeight);

	// VIEW CURRENT STYLES
	//console.log("paramRow.args.style : " + dojo.attr(paramRow.args, 'style'));
	//console.log("paramRow.inputParams.style : " + dojo.attr(paramRow.inputParams, 'style'));

	// SET STYLES TO max-height TO SQUASH DOWN EMPTY SPACE
	dojo.attr(paramRow.inputParams, 'style', 'display: inline-block; max-height: ' + paramRow.inputParams.clientHeight + 'px !important');
	dojo.attr(paramRow.args, 'style', 'display: inline-block; max-height: ' + paramRow.args.clientHeight + 'px !important');
	dojo.attr(paramRow.inputParams, 'style', { display: "inline-block", "min-height": "20px !important" });
	dojo.attr(paramRow.args, 'style', {	display: "inline-block", "min-height": "20px !important" });
	//console.log("ParameterRow.levelRowHeight    AFTER max-height this.args.clientHeight       : " + paramRow.args.clientHeight);
	//console.log("ParameterRow.levelRowHeight    AFTER max-height this.inputParams.clientHeight: " + paramRow.inputParams.clientHeight);

	//console.log("AFTER max-height    paramRow.args        : " + dojo.attr(paramRow.args, 'style'));
	//console.log("AFTER max-height    paramRow.inputParams : " + dojo.attr(paramRow.inputParams, 'style'));
	
	if ( paramRow.inputParams.clientHeight < paramRow.args.clientHeight )
	{
		//console.log("paramRow.inputParams.height < paramRow.args.height");
		//console.log("Doing set inputParams height = args height")
	
		dojo.attr(paramRow.inputParams, 'style', 'display: inline-block; height: 0px !important');
		dojo.attr(paramRow.inputParams, 'style', 'display: inline-block; min-height: ' + paramRow.args.offsetHeight + 'px !important');
	
	}
	else if ( paramRow.inputParams.clientHeight >= paramRow.args.clientHeight )
	{
			//console.log("paramRow.inputParams.clientHeight >= paramRow.args.clientHeight");
		
			dojo.attr(paramRow.args, 'style', 'display: inline-block; height: 0px !important');
			dojo.attr(paramRow.args, 'style', 'display: inline-block; min-height: ' + paramRow.inputParams.offsetHeight + 'px !important');
	}

	//console.log("ParameterRow.levelRowHeight    AFTER paramRow.args.clientHeight   : " + paramRow.args.clientHeight);
	//console.log("ParameterRow.levelRowHeight    AFTER this.inputParams.clientHeight: " + paramRow.inputParams.clientHeight);
	//console.log("ParameterRow.levelRowHeight    AFTER paramRow.args.offsetHeight   : " + paramRow.args.offsetHeight);
	//console.log("ParameterRow.levelRowHeight    AFTER this.inputParams.offsetHeight: " + paramRow.inputParams.offsetHeight);

	//console.log("paramRow.args.style : " + dojo.attr(paramRow.args, 'style'));
	//console.log("paramRow.inputParams.style : " + dojo.attr(paramRow.inputParams, 'style'));
},

toggle : function () {
// TOGGLE HIDDEN NODES
	//////console.log("ParameterRow.toggle    plugins.workflow.ParameterRow.toggle()");
	//////console.log("ParameterRow.toggle    this.description: " + this.description);

	var array = [ "argument", "valuetype", "valuetypeToggle", "category", "value", "ordinal", "ordinalToggle", "description", "format", "args", "inputParams", "paramFunction" ];
	for ( var i in array )
	{
		this.toggleNode(this[array[i]]);
	}


	var style = dojo.attr(this.args, 'style');
	var display = style.match(/display:\s*([^;]+)/)[1];
	if ( display == "inline-block" )
		this.levelRowHeight(this);
},

toggleNode : function(node) {
	if ( node.style.display == 'inline-block' ) node.style.display='none';
	else node.style.display = 'inline-block';
	
},

toggleLock : function (event) {
	console.log("ParameterRow.toggleLock    plugins.apps.Parameter.toggleLock(name)");
	
	if ( dojo.hasClass(this.locked, 'locked')	){
		dojo.removeClass(this.locked, 'locked');
		dojo.addClass(this.locked, 'unlocked');
		Agua.toastMessage({
			message: "ParameterRow has been unlocked. Users can change this parameter",
			type: warning
		});
	}	
	else {
		dojo.removeClass(this.locked, 'unlocked');
		dojo.addClass(this.locked, 'locked');

		Agua.toastMessage({
			message: "ParameterRow has been locked. Users cannot change this parameter",
			type: "warning" 
		});
	}	

	var inputs = this.parentWidget.getFormInputs(this);
	this.parentWidget.saveInputs(inputs, null);
	event.stopPropagation(); //Stop Event Bubbling
},

formInputs : {
// FORM INPUTS AND TYPES (word|phrase)
	locked : "",
	name: "word",
	argument: "word",
	type: "word",
	category: "word",
	value: "word",
	discretion: "word",
	description: "phrase",
	format: "word",
	args: "word",
	inputParams: "phrase",
	paramFunction: "phrase"
}




});

}

if(!dojo._hasResource["plugins.apps.Parameters"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.apps.Parameters"] = true;
dojo.provide("plugins.apps.Parameters");

// ALLOW THE USER TO ADD, REMOVE AND MODIFY PARAMETERS

// EXTERNAL MODULES






//

// INTERNAL MODULES




// HAS A


dojo.declare("plugins.apps.Parameters",
	[ plugins.form.DndSource, plugins.form.Inputs, plugins.form.EditRow, plugins.form.DndTrash, plugins.core.Common, dijit._Widget, dijit._Templated ],
{
//Path to the template of this widget. 
templateString:"<div dojoattachpoint=\"containerNode\">\n\n\t<!-- SOURCES TAB -->\n\t<div\n\t\tdojoAttachPoint=\"parametersTab\"\n\t\tclass=\"parameters\"\n\t\tdojoType=\"dijit.layout.ContentPane\"\n\t\ttitle=\"Parameters\"\n\t\tstyle=\"height: 100% !important; max-height: auto !important; width: 390px !important; padding: 0 !important;\"\n\t\t>\n\n<table width=\"100%\">\n\t<tr valign=\"top\" width=\"100%\">\n\t\t<td colspan=\"2\" class=\"tabTitle\" align=\"center\">\n\t\t\tParameters\n\t\t</td>\n\t</tr>\n\n\t<tr class=\"inputs\" valign=\"top\" width=\"95%\">\n\t\t<td>\n\t\t\t<table width=\"100%\" style=\"padding: 0px;\">\n\t\t\t\t<tr width=\"100%\">\n\t\t\t\t\t\n\t\t\t\t\t<td colspan=\"3\" height=\"32px\" width=\"100%\">\n\t\t\t\t\t\t\n\t\t\t\t\t\t<table cellspacing=\"0px\" cellpadding=\"0px\" border=\"0\" style=\"padding: 0; margin: 0;\">\n\t\t\t\t\t\t\t<tr>\n\n\t\t\t\t\t\t\t\t<td align=\"center\" >\n\t\t\t\t\t\t\t\t\t<table>\n\t\t\t\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t\t\t\t<td align=\"center\">\n\t\t\t\t\t\t\t\t\t\t\t\t<textarea\n\t\t\t\t\t\t\t\t\t\t\t\t\tspellcheck=\"false\"\n\t\t\t\t\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"name\"\n\t\t\t\t\t\t\t\t\t\t\t\t\tclass=\"name\"\n\t\t\t\t\t\t\t\t\t\t\t\t\tstyle=\"width: 220px !important; font-weight: bolder;\"\n\t\t\t\t\t\t\t\t\t\t\t\t\tcols=\"30\"\n\t\t\t\t\t\t\t\t\t\t\t\t\trows=\"1\"\n\t\t\t\t\t\t\t\t\t\t\t\t\ttitle=\"name: Name of parameter\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t>Name</textarea>\n\t\t\t\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t\t\t\t<td dojoAttachPoint=\"locked\"\n\t\t\t\t\t\t\t\t\t\t\t\tdojoAttachEvent=\"onclick:toggleLock\"\n\t\t\t\t\t\t\t\t\t\t\t\tclass=\"unlocked\"\n\t\t\t\t\t\t\t\t\t\t\t\ttitle=\"locked: Click to lock/unlock user access to edit this parameter\">\n\t\t\t\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t\t\t</table>\n\t\t\t\t\t\t\t\t</td>\n\t\n\t\t\t\t\t\t\t\t<td height=\"20px\"\n\t\t\t\t\t\t\t\t\twidth=\"120px\"\n\t\t\t\t\t\t\t\t\talign=\"right\">\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"addParameterButton\"\n\t\t\t\t\t\t\t\t\t\tclass=\"addParameterButton\"\n\t\t\t\t\t\t\t\t\t\ttitle=\"Click to create new parameter\"\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\tNew Param\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t</table>\n\t\t\t\t\t</td>\n\n\t\t\t\t</tr>\n\n\t\t\t\t<tr class=\"headerRow\" width=\"100%\" height=\"8px\">\n\t\t\t\t\t<td width=\"160px\">Argument</td>\n\t\t\t\t\t<td width=\"100px\">ParamType</td>\n\t\t\t\t\t<td width=\"33%\">Discretion</td>\n\t\t\t\t</tr>\n\t\t\t\t\t\n\t\t\t\t<tr width=\"100%\">\n\n\t\t\t\t\t<td width=\"160px\">\n\t\t\t\t\t\t<textarea\n\t\t\t\t\t\t\tspellcheck=\"false\"\n\t\t\t\t\t\t\tdojoAttachPoint=\"argument\"\n\t\t\t\t\t\t\tclass=\"argument\"\n\t\t\t\t\t\t\tstyle=\"width: 160px !important; font-weight: bolder; font-family: Verdana;\";\n\t\t\t\t\t\t\tcols=\"40\"`\n\t\t\t\t\t\t\trows=\"1\"\n\t\t\t\t\t\t\ttitle=\"argument: Command line argument for parameter (e.g., '--inputfile')\"\n\t\t\t\t\t\t\t>Argument</textarea>\n\t\t\t\t\t</td>\n\n\n\t\t\t\t\t<td colspan=\"1\" width=\"100px\">\n\t\t\t\t\t\t<select\n\t\t\t\t\t\t\tdojoAttachPoint=\"paramtype\"\n\t\t\t\t\t\t\tclass=\"paramtype\"\n\t\t\t\t\t\t\tvalue=\"Paramtype\"\n\t\t\t\t\t\t\tstyle=\"width: 100px !important; font-weight: bolder; font-family: Verdana;\";\n\t\t\t\t\t\t\ttitle=\"paramtype: Select type of parameter (input, resource or output)\"\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<option style=\"text-style: italic; text-weight: normal; background-color: #DDD;\" value=\"Paramtype\">Paramtype</option>\n\t\t\t\t\t\t\t<option value=\"input\">input</option>\n\t\t\t\t\t\t\t<option value=\"resource\">resource</option>\n\t\t\t\t\t\t\t<option value=\"output\">output</option>\n\t\t\t\t\t\t</select>\n\t\t\t\t\t</td>\n\n\t\t\t\t\t<td colspan=\"1\" width=\"100px\">\n\t\t\t\t\t\t<select\n\t\t\t\t\t\t\tdojoAttachPoint=\"discretion\"\n\t\t\t\t\t\t\tclass=\"discretion\"\n\t\t\t\t\t\t\tvalue=\"Discretion\"\n\t\t\t\t\t\t\tstyle=\"width: 100px !important; font-weight: bolder; font-family: Verdana;\";\n\t\t\t\t\t\t\ttitle=\"discretion: Select optional, required (must not be empty) or essential (file/directory must be present)\"\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<option style=\"text-style: italic; text-weight: normal; background-color: #DDD;\" value=\"Discretion\">Discretion</option>\n\t\t\t\t\t\t\t<option value=\"essential\">essential</option>\n\t\t\t\t\t\t\t<option value=\"required\">required</option>\n\t\t\t\t\t\t\t<option value=\"optional\">optional</option>\n\t\t\t\t\t\t</select>\n\t\t\t\t\t</td>\n\n\t\t\t\t</tr>\n\n\t\t\t\t<tr class=\"headerRow\" width=\"100%\" height=\"8px\">\n\t\t\t\t\t<td width=\"160px\">Value</td>\n\t\t\t\t\t<td width=\"100px\">Ordinal</td>\n\n\t\t\t\t</tr>\n\n\t\t\t\t<tr width=\"100%\">\n\t\t\t\t\t<td colspan=\"1\" width=\"160px\">\n\t\t\t\t\t\t<textarea\n\t\t\t\t\t\t\tspellcheck=\"false\"\n\t\t\t\t\t\t\tdojoAttachPoint=\"value\"\n\t\t\t\t\t\t\tclass=\"value\"\n\t\t\t\t\t\t\tstyle=\"width: 160px !important; font-weight: bolder; font-family: Verdana; overflow: hidden !important;\";\n\t\t\t\t\t\t\tcols=\"40\"\n\t\t\t\t\t\t\trows=\"1\"\n\t\t\t                title=\"value: Default value of parameter (use '%project%/%workflow%/' for default file path)\"\n\t\t\t\t\t\t\t>Value</textarea>\n\t\t\t\t\t</td>\n\n\t\t\t\t\t<td width=\"100px\">\n\t\t\t\t\t\t<select\n\t\t\t\t\t\t\tdojoAttachPoint=\"valuetype\"\n\t\t\t\t\t\t\tclass=\"valuetype\"\n\t\t\t\t\t\t\tstyle=\"width: 100px !important; font-weight: bolder; font-family: Verdana;\";\n\t\t                    title=\"valuetype: Type of parameter may be physical (e.g., file or directory) or abstract (e.g., integer or text string)\"\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<option selected=\"true\" class=\"default\" value=\"Type\">ValueType</option>\n\t\t\t\t\t\t\t<option value=\"file\">file</option>\n\t\t\t\t\t\t\t<option value=\"files\">files</option>\n\t\t\t\t\t\t\t<option value=\"directory\">directory</option>\n\t\t\t\t\t\t\t<option value=\"directories\">directories</option>\n\t\t\t\t\t\t\t<option value=\"integer\">integer</option>\n\t\t\t\t\t\t\t<option value=\"string\">string</option>\n\t\t\t\t\t\t\t<option value=\"flag\">flag</option>\n\t\t\t\t\t\t</select>\n\t\t\t\t\t</td>\n\n\n\t\t\t\t\t<td width=\"100px\"\n\t\t\t\t\t\tstyle=\"padding-left: 5px;\">\n\t\t\t\t\t\t<textarea\n\t\t\t\t\t\t\tspellcheck=\"false\"\n\t\t\t\t\t\t\tdojoAttachPoint=\"category\"\n\t\t\t\t\t\t\tclass=\"category\"\n\t\t\t\t\t\t\tstyle=\"width: 90px !important; font-weight: bolder; font-family: Verdana;\";\n\t\t\t\t\t\t\tcols=\"40\"\n\t\t\t\t\t\t\trows=\"1\"\n\t\t\t                title=\"category: User-defined category for parameter to be used with input/output chaining. (E.g, the category 'inputfile' includes parameters with arguments '-i', '-infile' and '--inputfile'.)\"\n\t\t\t\t\t\t\t>Category</textarea>\n\t\t\t\t\t</td>\n\t\t\t\t</tr>\n\n\t\t\t\t<tr class=\"headerRow\">\n\t\t\t\t\t<td width=\"100%\"\n\t\t\t\t\t\tcolspan=\"3\"\n\t\t\t\t\t\tclass=\"toggleTitle\"\n\t\t\t\t\t\tdojoAttachEvent=\"onclick:toggleDescription\"\n\t\t\t\t\t> Details (Click to toggle)</td>\n\t\t\t\t</tr>\n\n\t\t\t</table>\n\t\t</td>\n\n\t</tr>\n\t<tr class=\"inputs\" >\n\t\t<td>\n\n\t\t\t<table\n\t\t\t\tstyle=\"display: none\"\n\t\t\t\tdojoAttachPoint=\"togglePoint\"\n\t\t\t\twidth=\"100%\"\n\t\t\t\tstyle=\"padding: 0px;\"\n\t\t\t>\n\n\t\t\t\t<tr class=\"headerRow\">\n\t\t\t\t\t<td width=\"67%\"\n\t\t\t\t\t\tcolspan=\"2\"\n\t\t\t\t\t>Description</td>\n\n\t\t\t\t\t<td width=\"33%\"\n\t\t\t\t\t>Ordinal</td>\n\n\t\t\t\t</tr>\n\n\t\t\t\t<tr>\n\t\t\t\t\t<td\n\t\t\t\t\tcolspan=\"3\">\n\t\t\t\t\t\t\n\t\t\t\t\t\t<table>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td colspan=\"2\" width=\"270px\">\n\t\t\t\t\t\t\t\t\t<textarea\n\t\t\t\t\t\t\t\t\t\tspellcheck=\"false\"\n\t\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"description\"\n\t\t\t\t\t\t\t\t\t\tclass=\"description\"\n\t\t\t\t\t\t\t\t\t\tstyle=\"width: 270px !important; font-weight: bolder; font-family: Verdana;\";\n\t\t\t\t\t\t\t\t\t\tcols=\"24\"\n\t\t\t\t\t\t\t\t\t\trows=\"1\"\n\t\t\t\t\t\t\t\t\t\ttitle=\"description: A brief description of the parameter\"\n\t\t\t\t\t\t\t\t\t>Description</textarea>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\n\t\t\t\t\t\t\t\t<td width=\"100px\">\n\t\t\t\t\t\t\t\t\t<select\n\t\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"ordinal\"\n\t\t\t\t\t\t\t\t\t\tclass=\"ordinal\"\n\t\t\t\t\t\t\t\t\t\tstyle=\"width: 100px !important; font-weight: bolder; font-family: Verdana;\";\n\t\t\t\t\t\t\t\t\t\ttitle=\"ordinal: Adjust the ordinal value if your application requires the parameters to be in a certain order. Parameters with the same ordinal will be grouped together in alphabetical order.\"\n\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t<option selected=\"true\" class=\"default\" value=\"1\">Ordinal</option>\n\t\t\t\t\t\t\t\t\t\t<option value=\"1\">1</option>\n\t\t\t\t\t\t\t\t\t\t<option value=\"2\">2</option>\n\t\t\t\t\t\t\t\t\t\t<option value=\"3\">3</option>\n\t\t\t\t\t\t\t\t\t\t<option value=\"4\">4</option>\n\t\t\t\t\t\t\t\t\t\t<option value=\"5\">5</option>\n\t\t\t\t\t\t\t\t\t\t<option value=\"6\">6</option>\n\t\t\t\t\t\t\t\t\t\t<option value=\"7\">7</option>\n\t\t\t\t\t\t\t\t\t\t<option value=\"8\">8</option>\n\t\t\t\t\t\t\t\t\t\t<option value=\"9\">9</option>\n\t\t\t\t\t\t\t\t\t\t<option value=\"10\">10</option>\n\t\t\t\t\t\t\t\t\t\t<option value=\"11\">11</option>\n\t\t\t\t\t\t\t\t\t\t<option value=\"12\">12</option>\n\t\t\t\t\t\t\t\t\t\t<option value=\"13\">13</option>\n\t\t\t\t\t\t\t\t\t\t<option value=\"14\">14</option>\n\t\t\t\t\t\t\t\t\t\t<option value=\"15\">15</option>\n\t\t\t\t\t\t\t\t\t</select>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\n\t\t\t\t\t\t\t</tr>\n\t\t\t\n\t\t\t\n\t\t\t\t\t\t\t<tr class=\"headerRow\" width=\"100%\" height=\"8px\">\n\t\t\t\t\t\t\t\t<td width=\"160px\">Format</td>\n\t\t\t\t\t\t\t\t<td width=\"100px\">Arguments</td>\n\t\t\t\t\t\t\t\t<td width=\"100px\">Parameters</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\n\t\t\t\t\t\t\t<tr width=\"100%\">\n\t\t\t\t\t\t\t\t<td width=\"162px\">\n\t\t\t\t\t\t\t\t\t<textarea\n\t\t\t\t\t\t\t\t\t\tspellcheck=\"false\"\n\t\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"format\"\n\t\t\t\t\t\t\t\t\t\tclass=\"format\"\n\t\t\t\t\t\t\t\t\t\tstyle=\"width: 162px !important; font-weight: bolder; font-family: Verdana;\";\n\t\t\t\t\t\t\t\t\t\tcols=\"24\"\n\t\t\t\t\t\t\t\t\t\trows=\"1\"\n\t\t\t\t\t\t\t\t\t\ttitle=\"format: Special file format, to be used for parameter chaining or file checking (e.g., FASTA, FASTQ)\"\n\t\t\t\t\t\t\t\t\t\t>Format</textarea>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"100px\"\n\t\t\t\t\t\t\t\t\tstyle=\"padding-left: 4px; padding-right: 4px;\" >\n\t\t\t\t\t\t\t\t\t<textarea\n\t\t\t\t\t\t\t\t\t\tspellcheck=\"false\"\n\t\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"args\"\n\t\t\t\t\t\t\t\t\t\tclass=\"args\"\n\t\t\t\t\t\t\t\t\t\tstyle=\"width: 100px !important; font-weight: bolder; font-family: Verdana;\";\n\t\t\t\t\t\t\t\t\t\tcols=\"40\"\n\t\t\t\t\t\t\t\t\t\trows=\"1\"\n\t\t\t\t\t\t\t\t\t\ttitle=\"args: Arguments for input/output chaining function (e.g., 'input.inputfile.value')\"\n\t\t\t\t\t\t\t\t\t\t>Args</textarea>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\n\t\t\t\t\t\t\t\t<td width=\"100px\">\n\t\t\t\t\t\t\t\t\t<textarea\n\t\t\t\t\t\t\t\t\t\tspellcheck=\"false\"\n\t\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"inputParams\"\n\t\t\t\t\t\t\t\t\t\tclass=\"inputParams\"\n\t\t\t\t\t\t\t\t\t\tstyle=\"width: 96px !important; font-weight: bolder; font-family: Verdana;\";\n\t\t\t\t\t\t\t\t\t\tcols=\"10\"\n\t\t\t\t\t\t\t\t\t\trows=\"1\"\n\t\t\t\t\t\t\t\t\t\ttitle=\"inputParams: Comma-separated list of variable names for each arg in the list of args for the paramFunction (e.g., 'inputfile')\"\n\t\t\t\t\t\t\t\t\t\t>Params</textarea>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\n\t\t\t\t\t\t\t<tr class=\"headerRow\" width=\"100%\" height=\"8px\">\n\t\t\t\t\t\t\t\t<td colspan=\"3\">Parameter Function</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td colspan=\"3\" width=\"380px\">\n\t\t\t\t\t\t\t\t\t<textarea\n\t\t\t\t\t\t\t\t\t\tspellcheck=\"false\"\n\t\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"paramFunction\"\n\t\t\t\t\t\t\t\t\t\tclass=\"paramFunction\"\n\t\t\t\t\t\t\t\t\t\tstyle=\"width: 380px !important; font-weight: bolder; font-family: Verdana;\";\n\t\t\t\t\t\t\t\t\t\tcols=\"40\"\n\t\t\t\t\t\t\t\t\t\trows=\"1\"\n\t\t\t\t\t\t\t\t\t\ttitle=\"paramFunction: Input/output chaining function to automatically determine parameter value from the application itself or the preceding application in the workflow (e.g., 'if ( inputfile != null ) return inputfile')\"\n\t\t\t\t\t\t\t\t\t>ParamFunction</textarea>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\n\t\t\t\t\t\t</table>\n\t\t\t\t\t</td>\n\t\t\t\t</tr>\n\n\t\t\t</table>\n\t\t</td>\n\t</tr>\n\t\n\t<tr>\n\t\t<td width=\"50%\" align=\"center\">\n\t\t\t<table>\n\t\t\t\t<tr>\n\t\t\t\t\t<td>\n\t\t\t\t\t\t\n\n\t\t\t\t\t\t<table>\t\t\t\n\t\t\t\t\t\t\t<tr valign=\"top\" width=\"95%\">\n\t\t\t\t\t\t\t\t<td width=\"95%\">\n\t\t\t\t\t\t\t\t\t<div class=\"label\"> Application </div>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"appsCombo\"\n\t\t\t\t\t\t\t\t\t\tdojoType=\"dijit.form.ComboBox\"\n\t\t\t\t\t\t\t\t\t\tclass=\"appsCombo\"\n\t\t\t\t\t\t\t\t\t\tpopupClass=\"parameters appsCombo dijitReset dijitMenu\"\n\t\t\t\t\t\t\t\t\t\tautocomplete=\"true\"\n\t\t\t\t\t\t\t\t\t\thasDownArrow=\"true\"\n\t\t\t\t\t\t\t\t\t\tdisabled=\"false\"\n\t\t\t\t\t\t\t\t\t\tstyle=\"width: 150px;\"\n\t\t\t\t\t\t\t\t\t\ttitle=\"Select the order of the displayed applications\"\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td align=\"center\">\n\t\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"appNamesCombo\"\n\t\t\t\t\t\t\t\t\t\tdojoType=\"dijit.form.ComboBox\"\n\t\t\t\t\t\t\t\t\t\tclass=\"appNamesCombo\"\n\t\t\t\t\t\t\t\t\t\tautocomplete=\"true\"\n\t\t\t\t\t\t\t\t\t\thasDownArrow=\"true\"\n\t\t\t\t\t\t\t\t\t\tdisabled=\"false\"\n\t\t\t\t\t\t\t\t\t\tstyle=\"width: 150px;\"\n\t\t\t\t\t\t\t\t\t\ttitle=\"Select an application to view its inputs below\"\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t</table>\n\t\t\t\t\t</td>\n\t\t\t\t\t<td width=\"50%\" align=\"center\" valign=\"top\">\n\t\t\t\t\t\t<table valign=\"top\">\n\t\t\t\t\t\t\t<tr valign=\"top\">\n\t\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t\t<div class=\"label paramTypes\"> Parameters </div>\n\t\t\t\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td align=\"center\">\n\t\t\t\t\n\t\t\t\t\t\t\t\t\t<select\n\t\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"paramOrderCombo\"\n\t\t\t\t\t\t\t\t\t\tclass='paramOrderCombo'\n\t\t\t\t\t\t\t\t\t\ttitle=\"Filter displayed parameters\"\n\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t<option \n\t\t\t\t\t\t\t\t\t\t\t\tclass=\"option\"\n\t\t\t\t\t\t\t\t\t\t\t\tselected=\"true\"\n\t\t\t\t\t\t\t\t\t\t\t\tvalue=\"Order by Name\">Order by Name</option>\n\t\t\t\t\t\t\t\t\t\t<option \n\t\t\t\t\t\t\t\t\t\t\t\tclass=\"option\"\n\t\t\t\t\t\t\t\t\t\t\t\tvalue=\"Order by Ordinal\">Order by Ordinal</option>\n\t\t\t\t\t\t\t\t\t\t<option\n\t\t\t\t\t\t\t\t\t\t\t\tclass=\"option\"\n\t\t\t\t\t\t\t\t\t\t\t\tvalue=\"Order by Type\">Order by Type</option>\n\t\t\t\t\t\t\t\t\t</select>\n\t\t\t\t\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td align=\"center\">\n\t\t\t\t\n\t\t\t\t\t\t\t\t\t<select\n\t\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"paramFilterCombo\"\n\t\t\t\t\t\t\t\t\t\tclass='paramFilterCombo'\n\t\t\t\t\t\t\t\t\t\ttitle=\"Filter displayed parameters\"\n\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t<option\n\t\t\t\t\t\t\t\t\t\t\t\tclass=\"option\"\n\t\t\t\t\t\t\t\t\t\t\t\tselected=\"true\"\n\t\t\t\t\t\t\t\t\t\t\t\tvalue=\"All\">All</option>\n\t\t\t\t\t\t\t\t\t\t<option\n\t\t\t\t\t\t\t\t\t\t\t\tclass=\"option\"\n\t\t\t\t\t\t\t\t\t\t\t\tvalue=\"input\">input</option>\n\t\t\t\t\t\t\t\t\t\t<option\n\t\t\t\t\t\t\t\t\t\t\t\tclass=\"option\"\n\t\t\t\t\t\t\t\t\t\t\t\tvalue=\"resource\">resource</option>\n\t\t\t\t\t\t\t\t\t\t<option\n\t\t\t\t\t\t\t\t\t\t\t\tclass=\"option\"\n\t\t\t\t\t\t\t\t\t\t\t\tvalue=\"output\">output</option>\n\t\t\t\t\t\t\t\t\t</select>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\t\t\t\n\n\n\t\t\t\t\t\t</table>\n\t\t\t\t\t</td>\n\t\t\t\t</tr>\n\t\t\t</table>\n\t\t</td>\n\t</tr>\n\n\t<tr>\n\t\t<td>\n\t\t\t<div\n\t\t\t\tdojoAttachPoint=\"dragSourceNode\"\n\t\t\t\tclass=\"dragSource\"\n\t\t\t\tstyle=\"height: 361px; width: 94%;\"\n\t\t\t>\n\t\t\t</div>\n\t\t</td>\n\t</tr>\n\n\t<tr align=\"center\">\n\t\t<td align=\"center\">\n\n\t\t\t<!-- TRASH CONTAINER -->\n\t\t\t<div\n\t\t\t\tdojoAttachPoint=\"trashContainer\"\n\t\t\t\tclass=\"trash\"\n\t\t\t\tstyle=\"height: 60px; width: 150px; align: center;\" \n\t\t\t\t>\n\t\t\t\t<div\n\t\t\t\t\tdojoAttachPoint=\"trashIcon\"\n\t\t\t\t\tclass=\"trashIcon\"\n\t\t\t\t\tstyle=\"height: 60px; width: 60px;\"\n\t\t\t\t\t>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</td>\n\t</tr>\n</table>\n\n\n\n\t</div>\n\t<!-- END SOURCES TAB -->\n\t\n</div> \n\n\n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

//addingParameter STATE
addingParameter : false,

// OR USE @import IN HTML TEMPLATE
cssFiles : [
	dojo.moduleUrl("plugins", "apps/css/parameters.css"),
	dojo.moduleUrl("dojo", "tests/dnd/dndDefault.css")
],

// PARENT WIDGET
parentWidget : null,

formInputs : {
// FORM INPUTS AND TYPES (word|phrase)
	locked: "",
	name: "word",
	argument: "word",
	valuetype: "word",
	category: "word",
	value: "word",
	ordinal: "word",
	discretion: "word",
	description: "phrase",
	paramtype: "paramtype",
	format: "word",
	args: "word",
	inputParams: "phrase",
	paramFunction: "phrase"
},

defaultInputs : {
	name : "Name",
	argument : "Argument", 
	//type : "ValueType", 
	category: "Category",
	value: "Value",
	//discretion: "Discretion",
	description: "Description",
	format: "Format",
	//paramtype: "Paramtype",
	args: "Args",
	inputParams: "Params",
	paramFunction: "ParamFunction"
},

requiredInputs : {
// REQUIRED INPUTS CANNOT BE ''
	name : 1,
	paramtype : 1, 
	valuetype: 1,
	category: 1,
	discretion: 1,
	paramtype: 1
},

invalidInputs : {
// INVALID INPUTS (e.g., DEFAULT INPUTS)
	name : "Name",
	argument : "Argument", 
	valuetype : "ValueType", 
	category: "Category",
	value: "Value",
	discretion: "Discretion",
	description: "Description",
	paramtype: "Paramtype",
	format: "Format",
	args: "Args",
	inputParams: "Params",
	paramFunction: "ParamFunction"
},

// DATA FIELDS TO BE RETRIEVED FROM DELETED ITEM
dataFields : [ "name", "appname", "paramtype" ],

rowClass : "plugins.apps.ParameterRow",

avatarItems: [ "name", "description"],

avatarType : "parameters",

// LOADED DND WIDGETS
childWidgets : [],

/////}}		

constructor : function(args) {
	////console.log("Parameters.constructor     plugins.apps.Parameters.constructor");			
	// GET INFO FROM ARGS
	this.parentWidget = args.parentWidget;
},

postCreate : function() {
	////console.log("Controller.postCreate    plugins.apps.Controller.postCreate()");

	// LOAD CSS
	this.loadCSS();		

	////console.log("Controller.postCreate    this.trash:");
	////console.dir(this.trash);

	// COMPLETE CONSTRUCTION OF OBJECT
	////console.log("Parameters.postCreate    DOING this.inherited(arguments)");
	this.inherited(arguments);	 
	////console.log("Parameters.postCreate    AFTER this.inherited(arguments)");

//	////console.dir(this.dragSouce);

	this.startup();
},

startup : function () {
	////console.log("Parameters.startup    plugins.apps.Parameters.startup()");

	// COMPLETE CONSTRUCTION OF OBJECT
	////console.log("Parameters.startup    DOING this.inherited(arguments)");
	this.inherited(arguments);	 
	////console.log("Parameters.startup    AFTER this.inherited(arguments)");

	// ADD TO TAB CONTAINER		
	this.tabContainer.addChild(this.parametersTab);
	this.tabContainer.selectChild(this.parametersTab);

	// SET PARAMETERS COMBO
	this.setAppTypesCombo();

	// SET NEW PARAMETER FORM
	this.setForm();

	// SET TRASH
	this.setTrash(this.dataFields);	

	// SET COMBOBOX onChange LISTENERS
	setTimeout( function(thisObj){ thisObj.setComboListeners(); }, 1000, this);

	// SUBSCRIBE TO UPDATES
	Agua.updater.subscribe(this, "updateApps");

	// SUBSCRIBE TO UPDATES
	Agua.updater.subscribe(this, "updateParameters");
},

updateApps : function (args) {
// RELOAD AFTER DATA CHANGES IN OTHER TABS
	////console.log("Parameters.updateApps    admin.Parameter.updateApps(args)");
	////console.log("Parameters.updateApps    args: ");
	////console.dir(args);

	// DO NOTHING AS THIS IS THE SOURCE OF PARAMETER CHANGES	
	// SET PARAMTYPES COMBO
	////console.log("Parameters.updateApps    Calling setAppNamesCombo()");
	this.setAppNamesCombo();
	
	// SET APPS COMBO
	////console.log("Parameters.updateApps    Calling setAppTypesCombo()");
	this.setAppTypesCombo();
	
	// SET DRAG SOURCE
	////console.log("Parameters.updateApps    Calling setDragSource()");
	this.setDragSource();
},

updateParameters : function (args) {
// RELOAD AFTER DATA CHANGES IN OTHER TABS
	////console.log("Parameters.updateParameters    admin.Parameter.updateParameters(args)");
	////console.log("Parameters.updateParameters    args: ");
	////console.dir(args);
	
	// REDO PARAMETER TABLE
	if ( args.originator == this )
	{
		if ( args.reload == false )	return;
	}

	this.setDragSource();
},

toggleDescription : function () {
// TOGGLE DESCRIPTION DETAILS
	console.log("Packages.toggle    this.togglePoint.style.display: " + this.togglePoint.style.display);
	if ( this.togglePoint.style.display == 'inline-block' )	
		this.togglePoint.style.display='none';
	else
		this.togglePoint.style.display = 'inline-block';
},

setAppTypesCombo : function (type) {
// SET PARAMETERS COMBO BOX
	////console.log("Parameters.setAppTypesCombo     plugins.apps.Parameters.setAppTypesCombo()");

	// GET PARAMETERS NAMES		
	var apps = Agua.getApps();
	////console.log("Parameters.setAppTypesCombo     plugins.apps.Parameters.setAppTypesCombo()");

	var typesArray = this.hashArrayKeyToArray(apps, "type");
	typesArray = this.uniqueValues(typesArray);
	////console.log("Parameters.setAppTypesCombo     typesArray: " + dojo.toJson(typesArray));
	typesArray = this.sortNoCase(typesArray);
	typesArray.splice(0,0, 'Order by Type');
	typesArray.splice(0,0, 'Order by Name');

	// SET STORE
	var data = {identifier: "name", items: []};
	for ( var i = 0; i < typesArray.length; i++ )
	{
		//////console.log("Parameters.setAppTypesCombo     Adding to data: " + typesArray[i]);
		data.items[i] = { name: typesArray[i]	};
	}
	////////console.log("Parameters.setAppTypesCombo     data: " + dojo.toJson(data));
	var store = new dojo.data.ItemFileWriteStore(	{	data: data	}	);
	////////console.log("Parameters.setAppTypesCombo     store: " + store);

	// SET COMBO
	this.appsCombo.store = store;
	this.appsCombo.startup();
	//////console.log("Parameters.setAppTypesCombo::setCombo     AFTER this.appsCombo.startup()");

	// SET COMBO VALUE
	var firstValue = typesArray[0];
	this.appsCombo.set('value', firstValue);
	//////console.log("Parameters.setAppTypesCombo::setCombo     AFTER this.appsCombo.setValue(firstValue)");

	// SET PARAMETER NAMES COMBO
	this.setAppNamesCombo();
},

setAppNamesCombo : function () {
/* SET APP NAMES COMBO DEPENDENT ON THE CURRENT SELECTION
	IN THE APP COMBO
*/
	////console.log("Parameters.setAppNamesCombo     plugins.apps.Parameters.setAppNamesCombo()");

	// GET SOURCE ARRAY AND FILTER BY PARAMETER NAME
	var type = this.appsCombo.get('value');
	////console.log("Parameters.setAppNamesCombo     type: " + type);
	var itemArray = Agua.getApps();
	////console.log("Parameters.setAppNamesCombo     BEFORE itemArray.length: " + itemArray.length);
	////console.log("Parameters.setAppNamesCombo     BEFORE itemArray[0]: " + dojo.toJson(itemArray[0]));
	var keyArray = ["type"];
	var valueArray = [type];
	//////console.log("Parameters.setAppNamesCombo     valueArray: " + dojo.toJson(valueArray));
	if ( type == "Order by Name" )
		itemArray = this.sortHasharray(itemArray, 'name');
	else if ( type == "Order by Type" )
	{
		itemArray = this.sortHasharray(itemArray, 'name');	
		itemArray = this.sortHasharray(itemArray, 'type');
	}
	else
		itemArray = this.filterByKeyValues(itemArray, keyArray, valueArray);
	////console.log("Parameters.setAppNamesCombo     AFTER itemArray.length: " + itemArray.length);
	
	// CHECK itemArray IS NOT NULL OR EMPTY
	if ( itemArray == null || itemArray.length == 0 )	return;

	// SET STORE
	var data = {identifier: "name", items: []};
	for ( var i = 0; i < itemArray.length; i++ )
	{
		data.items[i] = { name: itemArray[i].name	};
	}
	////////console.log("Apps.setAppNamesCombo     data: " + dojo.toJson(data));
	var store = new dojo.data.ItemFileWriteStore(	{	data: data	}	);
	////////console.log("Apps.setAppNamesCombo     store: " + store);

	// SET COMBO
	this.appNamesCombo.store = store;
	this.appNamesCombo.startup();

	// SET COMBO VALUE
	var firstValue = itemArray[0].name;
	this.appNamesCombo.set('value', firstValue);
	

	// SET PARAMETERS COMBO
	////console.log("Parameters.setAppNamesCombo    Completed. Now calling setDragSource");
	this.setDragSource();
},

setComboListeners : function () {
	////console.log("Parameters.setComboListeners    Parameter.setComboListeners()");

	// SET LISTENER FOR PARAM ORDER COMBO
	dojo.connect(this.paramOrderCombo, "onchange", this, "setDragSource");

	// SET LISTENER FOR PARAM FILTER COMBO
	dojo.connect(this.paramFilterCombo, "onchange", this, "setDragSource");


	dojo.connect(this.appsCombo, "onChange", dojo.hitch(this, function(){
		////console.log("Parameters.setComboListeners    **** appsCombo.onChange fired");
		////console.log("Parameters.setComboListeners    this: " + this);
		////console.log("Parameters.setComboListeners    Doing this.setAppNamesCombo()");
		this.setAppNamesCombo();
	}));
	
	var thisObject = this;
	dojo.connect(this.appNamesCombo, "onChange", dojo.hitch(this, function(){
		////console.log("Parameters.setComboListeners    **** appNamesCombo.onChange fired");
		////console.log("Parameters.setComboListeners    this: " + this);
		////console.log("Parameters.setComboListeners    thisObject: " + thisObject);
		////console.log("Parameters.setComboListeners    Doing this.setDragSource()");
		thisObject.setDragSource();
	}));

},

toggleLock : function () {
	////console.log("Parameters.toggleLock    plugins.apps.Parameters.toggleLock(name)");	
	if ( dojo.hasClass(this.locked, 'locked') ) {
		dojo.removeClass(this.locked, 'locked');
		dojo.addClass(this.locked, 'unlocked');
		Agua.warning("Parameter has been unlocked. Users can change this parameter");
	}	
	else {
		dojo.removeClass(this.locked, 'unlocked');
		dojo.addClass(this.locked, 'locked');
		Agua.warning("Parameter has been locked. Users cannot change this parameter");
	}	
},

setForm : function () {
// SET LISTENERS TO ACTIVATED SAVE BUTTON AND TO CLEAR DEFAULT TEXT
// WHEN INPUTS ARE CLICKED ON
	////console.log("Parameters.setForm    plugins.apps.Parameters.setForm()");

	// SET ADD PARAMETER ONCLICK
	dojo.connect(this.addParameterButton, "onclick", dojo.hitch(this, "saveInputs", null, {originator: this, reload: true}));

	// SET ONCLICK TO CANCEL INVALID TEXT
	this.setClearValues();

	// CHAIN TOGETHER INPUTS ON 'RETURN' KEYPRESS
	this.chainInputs(["name", "argument", "valuetype", "category", "value", "ordinal", "paramtype", "description", "discretion", "format", "args", "inputParams", "paramFunction", "addParameterButton"]);
},


getItemArray : function () {
	// FILTER SOURCE ARRAY BY type
	var appName = this.appNamesCombo.get('value');
	////console.log("Parameters.getItemArray    appName: " + appName);

	var itemArray = Agua.getParametersByAppname(appName);
	////console.log("Parameters.getItemArray    BEFORE SORT itemArray.length: " + itemArray.length);

	// ORDER APPS 
	var paramOrder = this.paramOrderCombo.value;
	////console.log("Parameters.getItemArray    paramOrder: " + paramOrder);
	if ( paramOrder == "Order by Name" )
		itemArray = this.sortHasharray(itemArray, 'name');
	else if ( paramOrder == "Order by Type" )
		itemArray = this.sortHasharray(itemArray, 'paramtype');
	else if ( paramOrder == "Order by Ordinal" )
		itemArray = this.sortHasharray(itemArray, 'ordinal');
	else
		itemArray = this.sortHasharray(itemArray, 'name');

	////console.log("Parameters.getItemArray    AFTER SORT itemArray.length: " + itemArray.length);

	//////console.log("Parameters.getItemArray    AFTER SORT itemArray: " + dojo.toJson(itemArray, true));

	// FILTER APPS 
	var paramFilter = this.paramFilterCombo.value;
	////console.log("Parameters.getItemArray    paramFilter: " + paramFilter);
	var keyArray = ["paramtype"];
	var valueArray = [paramFilter];
	if ( paramFilter == "All" ){
		////console.log("Parameters.getItemArray    No filter with paramfilter: " + paramFilter);			// do NOTHING
	}
	else
		itemArray = this.filterByKeyValues(itemArray, keyArray, valueArray);

	////console.log("Parameters.getItemArray    itemArray.length: " + itemArray.length);	
	return itemArray;
},

deleteItem : function (itemObject) {
// DELETE PARAMETER FROM Agua.parameters OBJECT AND IN REMOTE DATABASE
	////console.log("Parameters.deleteItem    plugins.apps.Parameters.deleteItem(name)");
	////console.log("Parameters.deleteItem    itemObject: " + dojo.toJson(itemObject));
	if ( itemObject.name == null ) 	return;
	if ( itemObject.appname == null ) 	return;

	itemObject.owner = Agua.cookie('username');

	// REMOVING PARAMETER FROM Agua.parameters
	Agua.removeParameter(itemObject)
	
	// RELOAD RELEVANT DISPLAYS
	Agua.updater.update("updateParameters", { originator: this });

}, // Parameter.deleteItem


saveInputs : function (inputs, updateArgs) {
	//	SAVE A PARAMETER TO Agua.parameters AND TO REMOTE DATABASE
	////console.log("Parameters.saveInputs    plugins.apps.Parameters.saveInputs(inputs, updateArgs)");
	////console.log("Parameters.saveInputs    inputs: " + dojo.toJson(inputs));	

	if ( this.savingInputs == true )	return;
	this.savingInputs = true;

	if ( inputs == null )
	{
		inputs = this.getFormInputs(this);
		//console.log("Parameters.saveInputs    this.allValid: " + this.allValid);	

		// RETURN IF INPUTS ARE NULL OR INVALID
		if ( inputs == null || this.allValid == false )
		{
			this.savingInputs = false;
			return;
		}
	}
	// SET OWNER AS SELF
	inputs.owner = Agua.cookie('username');

	// SET inputs APPLICATION NAME AND TYPE
	var appName = this.appNamesCombo.get('value');
	inputs.appname = appName;
	////console.log("Parameters.saveInputs    appName: " + appName);
	var appType = Agua.getAppType(appName);
	inputs.apptype = appType;
	////console.log("Parameters.saveInputs    appType: " + appType);

	// ADD NEW PARAMETER OBJECT TO Agua.parameters ARRAY
	Agua.addParameter(inputs);

	// REMOVE INVALID VALUES
	for ( var name in this.invalidInputs )
	{
		////console.log("Parameters.saveInputs    name: " + name);
		if ( inputs[name] == null ) inputs[name] = '';
		if ( inputs[name] == this.invalidInputs[name] )	inputs[name] = '';		
		inputs[name] = inputs[name].replace(/'/g, '"');
	}
	//////console.log("Parameters.saveInputs    AFTER replace DEFAULTS inputs: " + dojo.toJson(inputs));

	// DOUBLE-UP BACKSLASHES
	for ( var i = 0; i < inputs.length; i++ )
	{
		inputs[i] = this.convertBackslash(inputs[i], "expand");
	}

	// *** NOTE *** : SHIFT TO Agua.addParameter LATER

	// SAVE NEW PARAMETER TO REMOTE DATABASE
	var url = Agua.cgiUrl + "admin.cgi?";
	var query = new Object;
	query.username = Agua.cookie('username');
	query.sessionid = Agua.cookie('sessionid');
	query.mode = "saveParameter";
	query.data = inputs;
	//////console.log("Parameters.saveInputs    query: " + dojo.toJson(query));
	this.doPut({ url: url, query: query, sync: false });

	this.savingInputs = false;

	// RELOAD RELEVANT DISPLAYS
	Agua.updater.update("updateParameters", updateArgs);

}, // Parameter.saveInputs


getFormInputs : function (widget) {
	////console.log("Parameters.getFormInputs    plugins.apps.Parameterss.getFormInputs(widget)");
	////console.log("Parameters.getFormInputs    widget: " + widget);
	//////console.dir(widget);
	
	var inputs = new Object;	
	for ( var name in this.formInputs )
	{
		var value;
		// GET 'LOCKED' / 'UNLOCKED'
		if (dojo.hasClass(widget[name], 'locked'))
			value = "1";
		else if (dojo.hasClass(widget[name], 'unlocked'))
			value = "0";
		else value = this.getWidgetValue(widget[name]);			
		////console.log("Parameters.getFormInputs    " + name + ": " + value);
		inputs[name] = value;
		//////console.log("Parameters.getFormInputs    node " + name + " value: " + value);
	}
	////////console.log("Parameters.getFormInputs    inputs: " + dojo.toJson(inputs));
	
	inputs = this.checkInputs(widget, inputs);
	
	return inputs;
},

checkInputs : function (widget, inputs) {
	// SET INPUT FLAG SO THESE INPUTS ARE IGNORED:
	// 	argument AND discretion
	var inputFlag = false;
	//console.log("Parameters.checkInputs    this.paramtype: " + this.paramtype);
	var paramType = this.paramtype.value;
	//console.log("Parameters.checkInputs    paramType: " + paramType);
	if ( paramType == 'input' )	inputFlag = true;
	//console.log("Parameters.checkInputs    inputFlag: " + inputFlag);
	
	// CHECK INPUTS ARE VALID AND REQUIRED INPUTS ARE NOT EMPTY
	this.allValid = true;	
	for ( var key in this.formInputs )
	{
		// IGNORE THE argument AND discretion INPUTS IF IT'S NOT AN INPUT PARAMETER
		//if ( (key == "argument" || key == "discretion")
		if ( key == "argument" 
			&& inputFlag == false )
		{
			dojo.removeClass(widget[key], 'invalid');
			continue;
		}

		//console.log("Parameters.checkInputs    BEFORE inputs[key]: " + dojo.toJson(inputs[key]));
		inputs[key] = this.convertString(inputs[key], "htmlToText");
		inputs[key] = this.convertBackslash(inputs[key], "expand");
		////console.log("Parameters.checkInputs    AFTER inputs[key]: " + dojo.toJson(inputs[key]));
		
		if ( (this.isValidInput(key, inputs[key]) == false
				&& this.requiredInputs[key] != null)
			|| (this.requiredInputs[key] != null
				&& (inputs[key] == null || inputs[key] == '') ) )
		{
			////console.log("Parameters.this.allValid    invalid input " + key + ": " + inputs[key]);
			this.addClass(widget[key], 'invalid');
			this.allValid = false;
		}
		else{
			this.removeClass(widget[key], 'invalid');
		}
	}

	this.checkArgsBalance(widget);
	this.checkSyntax(widget);
	

	if ( this.allValid == false )	return null;
	return inputs;
},

checkArgsBalance : function(widget) {
	console.log("Parameters.checkArgsBalance    plugins.apps.Parameters.checkArgsBalance(widget)");
	console.log("Parameters.checkArgsBalance    console.dir(widget):");
	console.dir({widget: widget});
	
	var args = widget.args.innerHTML;
	var inputParams = widget.inputParams.innerHTML;

	console.log("Parameters.checkArgsBalance    args: " + args);
	console.log("Parameters.checkArgsBalance    inputParams: " + inputParams);
	
	var argsArray = args.split(/,/);
	console.log("Parameters.checkArgsBalance    argsArray.length: " + argsArray.length);
	
	var paramsArray = inputParams.split(/,/);
	console.log("Parameters.checkArgsBalance    paramsArray.length: " + paramsArray.length);
	if ( paramsArray == null )	return;
	if ( paramsArray.length == null || paramsArray.length == 0 )	return;
	
	if ( argsArray.length == null
		|| argsArray.length != paramsArray.length )
	{
		this.allValid = false;
		this.setInvalid(widget.args);
		this.setInvalid(widget.inputParams);
	}
	else {
		this.setValid(widget.args);
		this.setValid(widget.inputParams);
	}
	
	console.log("Parameters.checkArgsBalance    FINAL this.allValid: " + this.allValid);
},

checkSyntax : function(widget) {
	console.log("Parameters.checkSyntax    plugins.apps.Parameterss.checkSyntax(widget)");
	console.log("Parameters.checkSyntax    console.dir(widget):");
	console.dir({widget: widget});

	var inputParams = widget.inputParams.innerHTML;
	var paramFunction = widget.paramFunction.innerHTML;

	console.log("Parameters.checkSyntax    inputParams: " + inputParams);
	console.log("Parameters.checkSyntax    paramFunction: " + paramFunction);

	try {
		var funcString = "var func = function(" + inputParams + ") {" + paramFunction + "}";
		console.log("Parameters.checkSyntax    funcString: " + funcString);
		eval(funcString);
		console.log("Parameters.checkSyntax    eval OK");
		this.setValid(widget.paramFunction);
	}
	catch (error) {
		console.log("error: " + error);
		this.allValid = false;
		this.setInvalid(widget.paramFunction);
	}

	console.log("Parameters.checkArgsBalance    FINAL this.allValid: " + this.allValid);
}





}); // plugins.apps.Parameters

}

if(!dojo._hasResource["dojo.number"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.number"] = true;
dojo.provide("dojo.number");





dojo.getObject("number", true, dojo);

/*=====
dojo.number = {
	// summary: localized formatting and parsing routines for Number
}

dojo.number.__FormatOptions = function(){
	//	pattern: String?
	//		override [formatting pattern](http://www.unicode.org/reports/tr35/#Number_Format_Patterns)
	//		with this string.  Default value is based on locale.  Overriding this property will defeat
	//		localization.  Literal characters in patterns are not supported.
	//	type: String?
	//		choose a format type based on the locale from the following:
	//		decimal, scientific (not yet supported), percent, currency. decimal by default.
	//	places: Number?
	//		fixed number of decimal places to show.  This overrides any
	//		information in the provided pattern.
	//	round: Number?
	//		5 rounds to nearest .5; 0 rounds to nearest whole (default). -1
	//		means do not round.
	//	locale: String?
	//		override the locale used to determine formatting rules
	//	fractional: Boolean?
	//		If false, show no decimal places, overriding places and pattern settings.
	this.pattern = pattern;
	this.type = type;
	this.places = places;
	this.round = round;
	this.locale = locale;
	this.fractional = fractional;
}
=====*/

dojo.number.format = function(/*Number*/value, /*dojo.number.__FormatOptions?*/options){
	// summary:
	//		Format a Number as a String, using locale-specific settings
	// description:
	//		Create a string from a Number using a known localized pattern.
	//		Formatting patterns appropriate to the locale are chosen from the
	//		[Common Locale Data Repository](http://unicode.org/cldr) as well as the appropriate symbols and
	//		delimiters.
	//		If value is Infinity, -Infinity, or is not a valid JavaScript number, return null.
	// value:
	//		the number to be formatted

	options = dojo.mixin({}, options || {});
	var locale = dojo.i18n.normalizeLocale(options.locale),
		bundle = dojo.i18n.getLocalization("dojo.cldr", "number", locale);
	options.customs = bundle;
	var pattern = options.pattern || bundle[(options.type || "decimal") + "Format"];
	if(isNaN(value) || Math.abs(value) == Infinity){ return null; } // null
	return dojo.number._applyPattern(value, pattern, options); // String
};

//dojo.number._numberPatternRE = /(?:[#0]*,?)*[#0](?:\.0*#*)?/; // not precise, but good enough
dojo.number._numberPatternRE = /[#0,]*[#0](?:\.0*#*)?/; // not precise, but good enough

dojo.number._applyPattern = function(/*Number*/value, /*String*/pattern, /*dojo.number.__FormatOptions?*/options){
	// summary:
	//		Apply pattern to format value as a string using options. Gives no
	//		consideration to local customs.
	// value:
	//		the number to be formatted.
	// pattern:
	//		a pattern string as described by
	//		[unicode.org TR35](http://www.unicode.org/reports/tr35/#Number_Format_Patterns)
	// options: dojo.number.__FormatOptions?
	//		_applyPattern is usually called via `dojo.number.format()` which
	//		populates an extra property in the options parameter, "customs".
	//		The customs object specifies group and decimal parameters if set.

	//TODO: support escapes
	options = options || {};
	var group = options.customs.group,
		decimal = options.customs.decimal,
		patternList = pattern.split(';'),
		positivePattern = patternList[0];
	pattern = patternList[(value < 0) ? 1 : 0] || ("-" + positivePattern);

	//TODO: only test against unescaped
	if(pattern.indexOf('%') != -1){
		value *= 100;
	}else if(pattern.indexOf('\u2030') != -1){
		value *= 1000; // per mille
	}else if(pattern.indexOf('\u00a4') != -1){
		group = options.customs.currencyGroup || group;//mixins instead?
		decimal = options.customs.currencyDecimal || decimal;// Should these be mixins instead?
		pattern = pattern.replace(/\u00a4{1,3}/, function(match){
			var prop = ["symbol", "currency", "displayName"][match.length-1];
			return options[prop] || options.currency || "";
		});
	}else if(pattern.indexOf('E') != -1){
		throw new Error("exponential notation not supported");
	}
	
	//TODO: support @ sig figs?
	var numberPatternRE = dojo.number._numberPatternRE;
	var numberPattern = positivePattern.match(numberPatternRE);
	if(!numberPattern){
		throw new Error("unable to find a number expression in pattern: "+pattern);
	}
	if(options.fractional === false){ options.places = 0; }
	return pattern.replace(numberPatternRE,
		dojo.number._formatAbsolute(value, numberPattern[0], {decimal: decimal, group: group, places: options.places, round: options.round}));
};

dojo.number.round = function(/*Number*/value, /*Number?*/places, /*Number?*/increment){
	//	summary:
	//		Rounds to the nearest value with the given number of decimal places, away from zero
	//	description:
	//		Rounds to the nearest value with the given number of decimal places, away from zero if equal.
	//		Similar to Number.toFixed(), but compensates for browser quirks. Rounding can be done by
	//		fractional increments also, such as the nearest quarter.
	//		NOTE: Subject to floating point errors.  See dojox.math.round for experimental workaround.
	//	value:
	//		The number to round
	//	places:
	//		The number of decimal places where rounding takes place.  Defaults to 0 for whole rounding.
	//		Must be non-negative.
	//	increment:
	//		Rounds next place to nearest value of increment/10.  10 by default.
	//	example:
	//		>>> dojo.number.round(-0.5)
	//		-1
	//		>>> dojo.number.round(162.295, 2)
	//		162.29  // note floating point error.  Should be 162.3
	//		>>> dojo.number.round(10.71, 0, 2.5)
	//		10.75
	var factor = 10 / (increment || 10);
	return (factor * +value).toFixed(places) / factor; // Number
};

if((0.9).toFixed() == 0){
	// (isIE) toFixed() bug workaround: Rounding fails on IE when most significant digit
	// is just after the rounding place and is >=5
	(function(){
		var round = dojo.number.round;
		dojo.number.round = function(v, p, m){
			var d = Math.pow(10, -p || 0), a = Math.abs(v);
			if(!v || a >= d || a * Math.pow(10, p + 1) < 5){
				d = 0;
			}
			return round(v, p, m) + (v > 0 ? d : -d);
		};
	})();
}

/*=====
dojo.number.__FormatAbsoluteOptions = function(){
	//	decimal: String?
	//		the decimal separator
	//	group: String?
	//		the group separator
	//	places: Number?|String?
	//		number of decimal places.  the range "n,m" will format to m places.
	//	round: Number?
	//		5 rounds to nearest .5; 0 rounds to nearest whole (default). -1
	//		means don't round.
	this.decimal = decimal;
	this.group = group;
	this.places = places;
	this.round = round;
}
=====*/

dojo.number._formatAbsolute = function(/*Number*/value, /*String*/pattern, /*dojo.number.__FormatAbsoluteOptions?*/options){
	// summary:
	//		Apply numeric pattern to absolute value using options. Gives no
	//		consideration to local customs.
	// value:
	//		the number to be formatted, ignores sign
	// pattern:
	//		the number portion of a pattern (e.g. `#,##0.00`)
	options = options || {};
	if(options.places === true){options.places=0;}
	if(options.places === Infinity){options.places=6;} // avoid a loop; pick a limit

	var patternParts = pattern.split("."),
		comma = typeof options.places == "string" && options.places.indexOf(","),
		maxPlaces = options.places;
	if(comma){
		maxPlaces = options.places.substring(comma + 1);
	}else if(!(maxPlaces >= 0)){
		maxPlaces = (patternParts[1] || []).length;
	}
	if(!(options.round < 0)){
		value = dojo.number.round(value, maxPlaces, options.round);
	}

	var valueParts = String(Math.abs(value)).split("."),
		fractional = valueParts[1] || "";
	if(patternParts[1] || options.places){
		if(comma){
			options.places = options.places.substring(0, comma);
		}
		// Pad fractional with trailing zeros
		var pad = options.places !== undefined ? options.places : (patternParts[1] && patternParts[1].lastIndexOf("0") + 1);
		if(pad > fractional.length){
			valueParts[1] = dojo.string.pad(fractional, pad, '0', true);
		}

		// Truncate fractional
		if(maxPlaces < fractional.length){
			valueParts[1] = fractional.substr(0, maxPlaces);
		}
	}else{
		if(valueParts[1]){ valueParts.pop(); }
	}

	// Pad whole with leading zeros
	var patternDigits = patternParts[0].replace(',', '');
	pad = patternDigits.indexOf("0");
	if(pad != -1){
		pad = patternDigits.length - pad;
		if(pad > valueParts[0].length){
			valueParts[0] = dojo.string.pad(valueParts[0], pad);
		}

		// Truncate whole
		if(patternDigits.indexOf("#") == -1){
			valueParts[0] = valueParts[0].substr(valueParts[0].length - pad);
		}
	}

	// Add group separators
	var index = patternParts[0].lastIndexOf(','),
		groupSize, groupSize2;
	if(index != -1){
		groupSize = patternParts[0].length - index - 1;
		var remainder = patternParts[0].substr(0, index);
		index = remainder.lastIndexOf(',');
		if(index != -1){
			groupSize2 = remainder.length - index - 1;
		}
	}
	var pieces = [];
	for(var whole = valueParts[0]; whole;){
		var off = whole.length - groupSize;
		pieces.push((off > 0) ? whole.substr(off) : whole);
		whole = (off > 0) ? whole.slice(0, off) : "";
		if(groupSize2){
			groupSize = groupSize2;
			delete groupSize2;
		}
	}
	valueParts[0] = pieces.reverse().join(options.group || ",");

	return valueParts.join(options.decimal || ".");
};

/*=====
dojo.number.__RegexpOptions = function(){
	//	pattern: String?
	//		override [formatting pattern](http://www.unicode.org/reports/tr35/#Number_Format_Patterns)
	//		with this string.  Default value is based on locale.  Overriding this property will defeat
	//		localization.
	//	type: String?
	//		choose a format type based on the locale from the following:
	//		decimal, scientific (not yet supported), percent, currency. decimal by default.
	//	locale: String?
	//		override the locale used to determine formatting rules
	//	strict: Boolean?
	//		strict parsing, false by default.  Strict parsing requires input as produced by the format() method.
	//		Non-strict is more permissive, e.g. flexible on white space, omitting thousands separators
	//	places: Number|String?
	//		number of decimal places to accept: Infinity, a positive number, or
	//		a range "n,m".  Defined by pattern or Infinity if pattern not provided.
	this.pattern = pattern;
	this.type = type;
	this.locale = locale;
	this.strict = strict;
	this.places = places;
}
=====*/
dojo.number.regexp = function(/*dojo.number.__RegexpOptions?*/options){
	//	summary:
	//		Builds the regular needed to parse a number
	//	description:
	//		Returns regular expression with positive and negative match, group
	//		and decimal separators
	return dojo.number._parseInfo(options).regexp; // String
};

dojo.number._parseInfo = function(/*Object?*/options){
	options = options || {};
	var locale = dojo.i18n.normalizeLocale(options.locale),
		bundle = dojo.i18n.getLocalization("dojo.cldr", "number", locale),
		pattern = options.pattern || bundle[(options.type || "decimal") + "Format"],
//TODO: memoize?
		group = bundle.group,
		decimal = bundle.decimal,
		factor = 1;

	if(pattern.indexOf('%') != -1){
		factor /= 100;
	}else if(pattern.indexOf('\u2030') != -1){
		factor /= 1000; // per mille
	}else{
		var isCurrency = pattern.indexOf('\u00a4') != -1;
		if(isCurrency){
			group = bundle.currencyGroup || group;
			decimal = bundle.currencyDecimal || decimal;
		}
	}

	//TODO: handle quoted escapes
	var patternList = pattern.split(';');
	if(patternList.length == 1){
		patternList.push("-" + patternList[0]);
	}

	var re = dojo.regexp.buildGroupRE(patternList, function(pattern){
		pattern = "(?:"+dojo.regexp.escapeString(pattern, '.')+")";
		return pattern.replace(dojo.number._numberPatternRE, function(format){
			var flags = {
				signed: false,
				separator: options.strict ? group : [group,""],
				fractional: options.fractional,
				decimal: decimal,
				exponent: false
				},

				parts = format.split('.'),
				places = options.places;

			// special condition for percent (factor != 1)
			// allow decimal places even if not specified in pattern
			if(parts.length == 1 && factor != 1){
			    parts[1] = "###";
			}
			if(parts.length == 1 || places === 0){
				flags.fractional = false;
			}else{
				if(places === undefined){ places = options.pattern ? parts[1].lastIndexOf('0') + 1 : Infinity; }
				if(places && options.fractional == undefined){flags.fractional = true;} // required fractional, unless otherwise specified
				if(!options.places && (places < parts[1].length)){ places += "," + parts[1].length; }
				flags.places = places;
			}
			var groups = parts[0].split(',');
			if(groups.length > 1){
				flags.groupSize = groups.pop().length;
				if(groups.length > 1){
					flags.groupSize2 = groups.pop().length;
				}
			}
			return "("+dojo.number._realNumberRegexp(flags)+")";
		});
	}, true);

	if(isCurrency){
		// substitute the currency symbol for the placeholder in the pattern
		re = re.replace(/([\s\xa0]*)(\u00a4{1,3})([\s\xa0]*)/g, function(match, before, target, after){
			var prop = ["symbol", "currency", "displayName"][target.length-1],
				symbol = dojo.regexp.escapeString(options[prop] || options.currency || "");
			before = before ? "[\\s\\xa0]" : "";
			after = after ? "[\\s\\xa0]" : "";
			if(!options.strict){
				if(before){before += "*";}
				if(after){after += "*";}
				return "(?:"+before+symbol+after+")?";
			}
			return before+symbol+after;
		});
	}

//TODO: substitute localized sign/percent/permille/etc.?

	// normalize whitespace and return
	return {regexp: re.replace(/[\xa0 ]/g, "[\\s\\xa0]"), group: group, decimal: decimal, factor: factor}; // Object
};

/*=====
dojo.number.__ParseOptions = function(){
	//	pattern: String?
	//		override [formatting pattern](http://www.unicode.org/reports/tr35/#Number_Format_Patterns)
	//		with this string.  Default value is based on locale.  Overriding this property will defeat
	//		localization.  Literal characters in patterns are not supported.
	//	type: String?
	//		choose a format type based on the locale from the following:
	//		decimal, scientific (not yet supported), percent, currency. decimal by default.
	//	locale: String?
	//		override the locale used to determine formatting rules
	//	strict: Boolean?
	//		strict parsing, false by default.  Strict parsing requires input as produced by the format() method.
	//		Non-strict is more permissive, e.g. flexible on white space, omitting thousands separators
	//	fractional: Boolean?|Array?
	//		Whether to include the fractional portion, where the number of decimal places are implied by pattern
	//		or explicit 'places' parameter.  The value [true,false] makes the fractional portion optional.
	this.pattern = pattern;
	this.type = type;
	this.locale = locale;
	this.strict = strict;
	this.fractional = fractional;
}
=====*/
dojo.number.parse = function(/*String*/expression, /*dojo.number.__ParseOptions?*/options){
	// summary:
	//		Convert a properly formatted string to a primitive Number, using
	//		locale-specific settings.
	// description:
	//		Create a Number from a string using a known localized pattern.
	//		Formatting patterns are chosen appropriate to the locale
	//		and follow the syntax described by
	//		[unicode.org TR35](http://www.unicode.org/reports/tr35/#Number_Format_Patterns)
    	//		Note that literal characters in patterns are not supported.
	// expression:
	//		A string representation of a Number
	var info = dojo.number._parseInfo(options),
		results = (new RegExp("^"+info.regexp+"$")).exec(expression);
	if(!results){
		return NaN; //NaN
	}
	var absoluteMatch = results[1]; // match for the positive expression
	if(!results[1]){
		if(!results[2]){
			return NaN; //NaN
		}
		// matched the negative pattern
		absoluteMatch =results[2];
		info.factor *= -1;
	}

	// Transform it to something Javascript can parse as a number.  Normalize
	// decimal point and strip out group separators or alternate forms of whitespace
	absoluteMatch = absoluteMatch.
		replace(new RegExp("["+info.group + "\\s\\xa0"+"]", "g"), "").
		replace(info.decimal, ".");
	// Adjust for negative sign, percent, etc. as necessary
	return absoluteMatch * info.factor; //Number
};

/*=====
dojo.number.__RealNumberRegexpFlags = function(){
	//	places: Number?
	//		The integer number of decimal places or a range given as "n,m".  If
	//		not given, the decimal part is optional and the number of places is
	//		unlimited.
	//	decimal: String?
	//		A string for the character used as the decimal point.  Default
	//		is ".".
	//	fractional: Boolean?|Array?
	//		Whether decimal places are used.  Can be true, false, or [true,
	//		false].  Default is [true, false] which means optional.
	//	exponent: Boolean?|Array?
	//		Express in exponential notation.  Can be true, false, or [true,
	//		false]. Default is [true, false], (i.e. will match if the
	//		exponential part is present are not).
	//	eSigned: Boolean?|Array?
	//		The leading plus-or-minus sign on the exponent.  Can be true,
	//		false, or [true, false].  Default is [true, false], (i.e. will
	//		match if it is signed or unsigned).  flags in regexp.integer can be
	//		applied.
	this.places = places;
	this.decimal = decimal;
	this.fractional = fractional;
	this.exponent = exponent;
	this.eSigned = eSigned;
}
=====*/

dojo.number._realNumberRegexp = function(/*dojo.number.__RealNumberRegexpFlags?*/flags){
	// summary:
	//		Builds a regular expression to match a real number in exponential
	//		notation

	// assign default values to missing parameters
	flags = flags || {};
	//TODO: use mixin instead?
	if(!("places" in flags)){ flags.places = Infinity; }
	if(typeof flags.decimal != "string"){ flags.decimal = "."; }
	if(!("fractional" in flags) || /^0/.test(flags.places)){ flags.fractional = [true, false]; }
	if(!("exponent" in flags)){ flags.exponent = [true, false]; }
	if(!("eSigned" in flags)){ flags.eSigned = [true, false]; }

	var integerRE = dojo.number._integerRegexp(flags),
		decimalRE = dojo.regexp.buildGroupRE(flags.fractional,
		function(q){
			var re = "";
			if(q && (flags.places!==0)){
				re = "\\" + flags.decimal;
				if(flags.places == Infinity){
					re = "(?:" + re + "\\d+)?";
				}else{
					re += "\\d{" + flags.places + "}";
				}
			}
			return re;
		},
		true
	);

	var exponentRE = dojo.regexp.buildGroupRE(flags.exponent,
		function(q){
			if(q){ return "([eE]" + dojo.number._integerRegexp({ signed: flags.eSigned}) + ")"; }
			return "";
		}
	);

	var realRE = integerRE + decimalRE;
	// allow for decimals without integers, e.g. .25
	if(decimalRE){realRE = "(?:(?:"+ realRE + ")|(?:" + decimalRE + "))";}
	return realRE + exponentRE; // String
};

/*=====
dojo.number.__IntegerRegexpFlags = function(){
	//	signed: Boolean?
	//		The leading plus-or-minus sign. Can be true, false, or `[true,false]`.
	//		Default is `[true, false]`, (i.e. will match if it is signed
	//		or unsigned).
	//	separator: String?
	//		The character used as the thousands separator. Default is no
	//		separator. For more than one symbol use an array, e.g. `[",", ""]`,
	//		makes ',' optional.
	//	groupSize: Number?
	//		group size between separators
	//	groupSize2: Number?
	//		second grouping, where separators 2..n have a different interval than the first separator (for India)
	this.signed = signed;
	this.separator = separator;
	this.groupSize = groupSize;
	this.groupSize2 = groupSize2;
}
=====*/

dojo.number._integerRegexp = function(/*dojo.number.__IntegerRegexpFlags?*/flags){
	// summary:
	//		Builds a regular expression that matches an integer

	// assign default values to missing parameters
	flags = flags || {};
	if(!("signed" in flags)){ flags.signed = [true, false]; }
	if(!("separator" in flags)){
		flags.separator = "";
	}else if(!("groupSize" in flags)){
		flags.groupSize = 3;
	}

	var signRE = dojo.regexp.buildGroupRE(flags.signed,
		function(q){ return q ? "[-+]" : ""; },
		true
	);

	var numberRE = dojo.regexp.buildGroupRE(flags.separator,
		function(sep){
			if(!sep){
				return "(?:\\d+)";
			}

			sep = dojo.regexp.escapeString(sep);
			if(sep == " "){ sep = "\\s"; }
			else if(sep == "\xa0"){ sep = "\\s\\xa0"; }

			var grp = flags.groupSize, grp2 = flags.groupSize2;
			//TODO: should we continue to enforce that numbers with separators begin with 1-9?  See #6933
			if(grp2){
				var grp2RE = "(?:0|[1-9]\\d{0," + (grp2-1) + "}(?:[" + sep + "]\\d{" + grp2 + "})*[" + sep + "]\\d{" + grp + "})";
				return ((grp-grp2) > 0) ? "(?:" + grp2RE + "|(?:0|[1-9]\\d{0," + (grp-1) + "}))" : grp2RE;
			}
			return "(?:0|[1-9]\\d{0," + (grp-1) + "}(?:[" + sep + "]\\d{" + grp + "})*)";
		},
		true
	);

	return signRE + numberRE; // String
};

}

if(!dojo._hasResource["dijit.form.NumberTextBox"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.NumberTextBox"] = true;
dojo.provide("dijit.form.NumberTextBox");




/*=====
dojo.declare(
	"dijit.form.NumberTextBox.__Constraints",
	[dijit.form.RangeBoundTextBox.__Constraints, dojo.number.__FormatOptions, dojo.number.__ParseOptions], {
	// summary:
	//		Specifies both the rules on valid/invalid values (minimum, maximum,
	//		number of required decimal places), and also formatting options for
	//		displaying the value when the field is not focused.
	// example:
	//		Minimum/maximum:
	//		To specify a field between 0 and 120:
	//	|		{min:0,max:120}
	//		To specify a field that must be an integer:
	//	|		{fractional:false}
	//		To specify a field where 0 to 3 decimal places are allowed on input:
	//	|		{places:'0,3'}
});
=====*/

dojo.declare("dijit.form.NumberTextBoxMixin",
	null,
	{
		// summary:
		//		A mixin for all number textboxes
		// tags:
		//		protected

		// Override ValidationTextBox.regExpGen().... we use a reg-ex generating function rather
		// than a straight regexp to deal with locale (plus formatting options too?)
		regExpGen: dojo.number.regexp,

		/*=====
		// constraints: dijit.form.NumberTextBox.__Constraints
		//		Despite the name, this parameter specifies both constraints on the input
		//		(including minimum/maximum allowed values) as well as
		//		formatting options like places (the number of digits to display after
		//		the decimal point).  See `dijit.form.NumberTextBox.__Constraints` for details.
		constraints: {},
		======*/

		// value: Number
		//		The value of this NumberTextBox as a Javascript Number (i.e., not a String).
		//		If the displayed value is blank, the value is NaN, and if the user types in
		//		an gibberish value (like "hello world"), the value is undefined
		//		(i.e. get('value') returns undefined).
		//
		//		Symmetrically, set('value', NaN) will clear the displayed value,
		//		whereas set('value', undefined) will have no effect.
		value: NaN,

		// editOptions: [protected] Object
		//		Properties to mix into constraints when the value is being edited.
		//		This is here because we edit the number in the format "12345", which is
		//		different than the display value (ex: "12,345")
		editOptions: { pattern: '#.######' },

		/*=====
		_formatter: function(value, options){
			// summary:
			//		_formatter() is called by format().  It's the base routine for formatting a number,
			//		as a string, for example converting 12345 into "12,345".
			// value: Number
			//		The number to be converted into a string.
			// options: dojo.number.__FormatOptions?
			//		Formatting options
			// tags:
			//		protected extension

			return "12345";		// String
		},
		 =====*/
		_formatter: dojo.number.format,

		_setConstraintsAttr: function(/*Object*/ constraints){
			var places = typeof constraints.places == "number"? constraints.places : 0;
			if(places){ places++; } // decimal rounding errors take away another digit of precision
			if(typeof constraints.max != "number"){
				constraints.max = 9 * Math.pow(10, 15-places);
			}
			if(typeof constraints.min != "number"){
				constraints.min = -9 * Math.pow(10, 15-places);
			}
			this.inherited(arguments, [ constraints ]);
			if(this.focusNode && this.focusNode.value && !isNaN(this.value)){
				this.set('value', this.value);
			}
		},

		_onFocus: function(){
			if(this.disabled){ return; }
			var val = this.get('value');
			if(typeof val == "number" && !isNaN(val)){
				var formattedValue = this.format(val, this.constraints);
				if(formattedValue !== undefined){
					this.textbox.value = formattedValue;
				}
			}
			this.inherited(arguments);
		},

		format: function(/*Number*/ value, /*dojo.number.__FormatOptions*/ constraints){
			// summary:
			//		Formats the value as a Number, according to constraints.
			// tags:
			//		protected

			var formattedValue = String(value);
			if(typeof value != "number"){ return formattedValue; }
			if(isNaN(value)){ return ""; }
			// check for exponential notation that dojo.number.format chokes on
			if(!("rangeCheck" in this && this.rangeCheck(value, constraints)) && constraints.exponent !== false && /\de[-+]?\d/i.test(formattedValue)){
				return formattedValue;
			}
			if(this.editOptions && this._focused){
				constraints = dojo.mixin({}, constraints, this.editOptions);
			}
			return this._formatter(value, constraints);
		},

		/*=====
		_parser: function(value, constraints){
			// summary:
			//		Parses the string value as a Number, according to constraints.
			// value: String
			//		String representing a number
			// constraints: dojo.number.__ParseOptions
			//		Formatting options
			// tags:
			//		protected

			return 123.45;		// Number
		},
		=====*/
		_parser: dojo.number.parse,

		parse: function(/*String*/ value, /*dojo.number.__FormatOptions*/ constraints){
			// summary:
			//		Replacable function to convert a formatted string to a number value
			// tags:
			//		protected extension

			var v = this._parser(value, dojo.mixin({}, constraints, (this.editOptions && this._focused) ? this.editOptions : {}));
			if(this.editOptions && this._focused && isNaN(v)){
				v = this._parser(value, constraints); // parse w/o editOptions: not technically needed but is nice for the user
			}
			return v;
		},

		_getDisplayedValueAttr: function(){
			var v = this.inherited(arguments);
			return isNaN(v) ? this.textbox.value : v;
		},

		filter: function(/*Number*/ value){
			// summary:
			//		This is called with both the display value (string), and the actual value (a number).
			//		When called with the actual value it does corrections so that '' etc. are represented as NaN.
			//		Otherwise it dispatches to the superclass's filter() method.
			//
			//		See `dijit.form.TextBox.filter` for more details.
			return (value === null || value === '' || value === undefined) ? NaN : this.inherited(arguments); // set('value', null||''||undefined) should fire onChange(NaN)
		},

		serialize: function(/*Number*/ value, /*Object?*/ options){
			// summary:
			//		Convert value (a Number) into a canonical string (ie, how the number literal is written in javascript/java/C/etc.)
			// tags:
			//		protected
			return (typeof value != "number" || isNaN(value)) ? '' : this.inherited(arguments);
		},

		_setBlurValue: function(){
			var val = dojo.hitch(dojo.mixin({}, this, { _focused: true }), "get")('value'); // parse with editOptions
			this._setValueAttr(val, true);
		},

		_setValueAttr: function(/*Number*/ value, /*Boolean?*/ priorityChange, /*String?*/ formattedValue){
			// summary:
			//		Hook so set('value', ...) works.
			if(value !== undefined && formattedValue === undefined){
				formattedValue = String(value);
				if(typeof value == "number"){
					if(isNaN(value)){ formattedValue = '' }
					// check for exponential notation that dojo.number.format chokes on
					else if(("rangeCheck" in this && this.rangeCheck(value, this.constraints)) || this.constraints.exponent === false || !/\de[-+]?\d/i.test(formattedValue)){
						formattedValue = undefined; // lets format comnpute a real string value
					}
				}else if(!value){ // 0 processed in if branch above, ''|null|undefined flow thru here
					formattedValue = '';
					value = NaN;
				}else{ // non-numeric values
					value = undefined;
				}
			}
			this.inherited(arguments, [value, priorityChange, formattedValue]);
		},

		_getValueAttr: function(){
			// summary:
			//		Hook so get('value') works.
			//		Returns Number, NaN for '', or undefined for unparsable text
			var v = this.inherited(arguments); // returns Number for all values accepted by parse() or NaN for all other displayed values

			// If the displayed value of the textbox is gibberish (ex: "hello world"), this.inherited() above
			// returns NaN; this if() branch converts the return value to undefined.
			// Returning undefined prevents user text from being overwritten when doing _setValueAttr(_getValueAttr()).
			// A blank displayed value is still returned as NaN.
			if(isNaN(v) && this.textbox.value !== ''){
				if(this.constraints.exponent !== false && /\de[-+]?\d/i.test(this.textbox.value) && (new RegExp("^"+dojo.number._realNumberRegexp(dojo.mixin({}, this.constraints))+"$").test(this.textbox.value))){	// check for exponential notation that parse() rejected (erroneously?)
					var n = Number(this.textbox.value);
					return isNaN(n) ? undefined : n; // return exponential Number or undefined for random text (may not be possible to do with the above RegExp check)
				}else{
					return undefined; // gibberish
				}
			}else{
				return v; // Number or NaN for ''
			}
		},

		isValid: function(/*Boolean*/ isFocused){
			// Overrides dijit.form.RangeBoundTextBox.isValid to check that the editing-mode value is valid since
			// it may not be formatted according to the regExp vaidation rules
			if(!this._focused || this._isEmpty(this.textbox.value)){
				return this.inherited(arguments);
			}else{
				var v = this.get('value');
				if(!isNaN(v) && this.rangeCheck(v, this.constraints)){
					if(this.constraints.exponent !== false && /\de[-+]?\d/i.test(this.textbox.value)){ // exponential, parse doesn't like it
						return true; // valid exponential number in range
					}else{
						return this.inherited(arguments);
					}
				}else{
					return false;
				}
			}
		}
	}
);

dojo.declare("dijit.form.NumberTextBox",
	[dijit.form.RangeBoundTextBox,dijit.form.NumberTextBoxMixin],
	{
		// summary:
		//		A TextBox for entering numbers, with formatting and range checking
		// description:
		//		NumberTextBox is a textbox for entering and displaying numbers, supporting
		//		the following main features:
		//
		//			1. Enforce minimum/maximum allowed values (as well as enforcing that the user types
		//				a number rather than a random string)
		//			2. NLS support (altering roles of comma and dot as "thousands-separator" and "decimal-point"
		//				depending on locale).
		//			3. Separate modes for editing the value and displaying it, specifically that
		//				the thousands separator character (typically comma) disappears when editing
		//				but reappears after the field is blurred.
		//			4. Formatting and constraints regarding the number of places (digits after the decimal point)
		//				allowed on input, and number of places displayed when blurred (see `constraints` parameter).

		baseClass: "dijitTextBox dijitNumberTextBox"
	}
);

}

if(!dojo._hasResource["plugins.form.ValidationTextarea"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.form.ValidationTextarea"] = true;
dojo.provide("plugins.form.ValidationTextarea");



dojo.declare("plugins.form.ValidationTextarea",
    [dijit.form.ValidationTextBox,dijit.form.SimpleTextarea],
    {
        invalidMessage: "This field is required",

        regExp: "(.|\\s)*",

        preamble : function(args)
        {
            //////console.log("plugins.form.ValidationTextarea.preamble    plugins.form.ValidationTextarea.preamble(arguments)");
            //////console.log("plugins.form.ValidationTextarea.preamble    args:" + dojo.toJson(args));
            //////console.log("plugins.form.ValidationTextarea.preamble   this.invalidMessage: " + this.invalidMessage);
            //
            this.invalidMessage = args.invalidMessage;
        },


        constructor : function(args)
        {
            //////console.log("plugins.form.ValidationTextarea.constructor    plugins.form.ValidationTextarea.constructor(arguments)");
            //////console.log("plugins.form.ValidationTextarea.constructor    args:" + dojo.toJson(args));
            //////console.log("plugins.form.ValidationTextarea.constructor   this.invalidMessage: " + this.invalidMessage);
            //
            this.invalidMessage = args.invalidMessage;
            this.promptMessage = args.promptMessage;
        },

        postCreate: function() {
            //////console.log("plugins.form.ValidationTextarea.postCreate    plugins.form.ValidationTextarea.postCreate(arguments)");
            //////console.log("plugins.form.ValidationTextarea.postCreate    arguments:" + dojo.toJson(arguments));
            //////console.log("plugins.form.ValidationTextarea.postCreate    this.invalidMessage: " + this.invalidMessage);
            
            // SAVE INVALID MESSAGE
            var tempInvalidMessage = this.invalidMessage;
            var tempPromptMessage = this.promptMessage;

            this.inherited(arguments);
            
            // RESTORE INVALID MESSAGEA
            this.invalidMessage = tempInvalidMessage;
            this.promptMessage = tempPromptMessage;
            //////console.log("plugins.form.ValidationTextarea.postCreate    this.invalidMessage: " + this.invalidMessage);
        },

        validate: function() {
            //////console.log("plugins.form.ValidationTextarea.validate    plugins.form.ValidationTextarea.validate(arguments)");
            //////console.log("plugins.form.ValidationTextarea.validate    arguments:" + dojo.toJson(arguments));
            //////console.log("plugins.form.ValidationTextarea.validate    this.invalidMessage: " + this.invalidMessage);

            this.inherited(arguments);

            if (arguments.length==0) this.validate(false);
        },

        onFocus: function() {
            if (!this.isValid()) {
                this.displayMessage(this.getErrorMessage());
            }
        },

        onBlur: function() {
            this.validate(false);
        }
     }
);

}

if(!dojo._hasResource["plugins.cloud.AmiRow"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.cloud.AmiRow"] = true;
dojo.provide("plugins.cloud.AmiRow");



dojo.declare( "plugins.cloud.AmiRow",
	[ dijit._Widget, dijit._Templated, plugins.core.Common ],
{
//Path to the template of this widget. 
templateString:"<div dojoAttachPoint=\"containerNode\">\n\n    <table class=\"amiRow\" width=\"100%\">\n        <tr width=\"95%\">\n            \n            <td\n\t\t\t\tdojoAttachEvent=\"onclick:toggle\"\n\t\t\t\talign=\"center\"\n\t\t\t\tclass=\"amiid\"\n\t\t\t\tdojoAttachPoint=\"amiid\"\n\t\t\t>${amiid}\n\t\t\t</td>\n\t\t\t<td\n                dojoAttachPoint=\"cluster\"\n                class=\"aminame\"\n                title=\"AMI Name\"\n            >\n\t\t\t\t<input\n\t\t\t\t\tdojoAttachPoint=\"aminame\"\n\t\t\t\t\tclass=\"aminame\"\n\t\t\t\t\ttype=\"text\"\n\t\t\t\t\tvalue=\"${aminame}\"\n\t\t\t\t\tdojoType=\"dijit.form.ValidationTextBox\"\n\t\t\t\t\tregExp=\"^\\S{1,20}$\"\n\t\t\t\t\tmaxlength=\"20\" \n\t\t\t\t\tpromptMessage=\"AMI name: up to 20 characters (no spaces)\" \n\t\t\t\t\tinvalidMessage=\"AMI name: up to 20 characters (no spaces)\"\n\t\t\t\t\ttooltipPosition=\"below\"\n\t\t\t\t\twrap=\"off\"\n\t\t\t\t\t>\n\t\t\t</td>\n            <td class=\"amitype\">\n                <select\n                    dojoAttachPoint=\"amitype\"\n\t\t\t\t\tclass=\"amitype\"\n\t\t\t\t\ttitle=\"AMI type: EBS-backed (stop/startable, retains its state) or emphemeral S3 type\">\n\t\t\t\t\t<option value=\"${amitype}\">${amitype}</option> \n\t\t\t\t\t<option value=\"S3\">S3</option>\n\t\t\t\t\t<option value=\"EBS\">EBS</option> \n                </select>\n            </td>\n\n\t\t</tr>\n\t\t<tr width=\"95%\">\n\t\t\t<td\n                align=\"center\"\n                colspan=\"3\"\n                dojoAttachPoint=\"description\"\n                dojoAttachEvent=\"onclick:editCluster\"\n                class=\"description\"\n                width=\"100%\"\n                title=\"A brief description of the cluster group\"\n            >${description}</td>\n\t\t</tr>\n    </table>\n\n</div>\n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

// PARENT plugins.cloud.Apps WIDGET
parentWidget : null,

////}}}

constructor : function(args) {
	this.parentWidget = args.parentWidget;
	this.lockedValue = args.locked;
	this.args = args;
},

postCreate : function() {
	////console.log("AmiRow.postCreate    plugins.workflow.AmiRow.postCreate()");
	this.formInputs = this.parentWidget.formInputs;
	////console.log("AmiRow.postCreate    this.formInputs: " + dojo.toJson(this.formInputs));

	this.startup();
},

startup : function () {
	//console.log("AmiRow.startup    plugins.workflow.AmiRow.startup()");
	////console.log("AmiRow.startup    this.parentWidget: " + this.parentWidget);
	this.inherited(arguments);

	// SET AVAILABILITY ZONE COMBO
	var fakeEvent = {
		target: {
			selectedIndex: 0,
			options : [ {text: "us-east-1"} ]
		}
	};

	// SET LISTENER FOR CHANGES TO AMI NAME
	this.setOnkeyListeners(["aminame"]);

	setTimeout(function(thisObj) {
		////console.log("AmiRow.startup    Doing setTimeout(thisObj.setComboListeners");
		thisObj.setComboListeners();
	}, 2000, this);
},

setOnkeyListeners : function (names) {

	var thisObject = this;
	for ( var i in names )
	{
		dojo.connect(thisObject[names[i]], "onKeyPress", function(evt){
			var key = evt.charOrCode;
			evt.stopPropagation();
			//console.log("AmiRow.setOnkeyListeners    key: " + key);	
			if ( key == 13 )	thisObject.saveInputs();
		});
	}
},


setComboListeners : function () {
	////console.log("AmiRow.setComboListeners    AmiRow.setComboListeners()");
	var thisObject = this;
	dojo.connect(this.amitype, "onchange", function(event)
		{
			////console.log("AmiRow.setComboListeners    onchange fired: " + onchangeArray[i]);
			//console.log("AmiRow.setComboListeners    onchange    event: " + event);
			if ( event.stopPropagation == null )	return;
			var inputs = thisObject.parentWidget.getFormInputs(thisObject);
			thisObject.parentWidget.saveInputs(inputs, {reload: false});
			event.stopPropagation(); //Stop Event Bubbling
		}
	);
},

saveInputs : function () {
	////console.log("AmiRow.saveInputs    plugins.workflow.AmiRow.saveInputs()");
	////console.log("AmiRow.saveInputs    this.parentWidget: " + this.parentWidget);
	
	var inputs = this.parentWidget.getFormInputs(this);
	//console.log("AmiRow.saveInputs    inputs: " + dojo.toJson(inputs));

	this.parentWidget.saveInputs(inputs, {reload: false});
},

editCluster : function (event) {
	//console.log("AmiRow.editCluster    plugins.workflow.AmiRow.editCluster()");
	//console.log("AmiRow.editCluster    this.parentWidget: " + this.parentWidget);

	this.parentWidget.editRow(this, event.target);
	event.stopPropagation(); //Stop Event Bubbling
},

toggle : function () {
// TOGGLE HIDDEN NODES
	console.log("AmiRow.toggle    plugins.workflow.AmiRow.toggle()");
	console.log("AmiRow.toggle    this.description: " + this.description);

	var array = [ "description" ];
	for ( var i in array )
	{
		console.log("AmiRow.toggle    toggling: " + array[i]);
		if ( this[array[i]].style.display == 'table-cell' )
			this[array[i]].style.display='none';
		else
			this[array[i]].style.display = 'table-cell';
	}
}


});

}

if(!dojo._hasResource["plugins.cloud.Ami"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.cloud.Ami"] = true;
dojo.provide("plugins.cloud.Ami");

// ALLOW THE USER TO ADD, REMOVE AND MODIFY StarAmis CLUSTER GROUPS

// // optimize: load dijit layer







// FORM VALIDATION






// HAS A


dojo.declare("plugins.cloud.Ami",
	[ dijit._Widget, dijit._Templated, plugins.core.Common, plugins.form.EditForm ],
{

//Path to the template of this widget. 
templateString:"<div dojoattachpoint=\"containerNode\">\n\n\t<!--http://aws.amazon.com/ec2/instance-types/-->\n\n\t<!-- ami TAB -->\n\t<div\n\t\tdojoAttachPoint=\"mainTab\"\n\t\tclass=\"ami\"\n\t\tdojoType=\"dijit.layout.ContentPane\"\n\t\ttitle=\"AMIs\"\n\t\tstyle=\"height: 100% !important; max-height: auto !important; width: 390px !important; padding: 0 !important;\"\n\t>\n\n\t<table align=\"center\" width=\"100%\">\n\n\t\t<tr valign=\"top\" width=\"100%\">\n\t\t\t<td colspan=\"3\" class=\"tabTitle\" align=\"center\">AMIs</td>\n\t\t</tr>\n\n\t\t<tr height=\"20px\">\n\t\t\t<td align=\"center\" colspan=\"3\">\n\t\t\t\t<div\n\t\t\t\t\tdojoAttachPoint=\"addAmiButton\"\n\t\t\t\t\tclass=\"addAmiButton\"\n\t\t\t\t\t>Add AMI</div>\n\t\t\t</td>\n\t\t</tr>\n\n\t\t<tr class=\"headerRow\">\n\t\t\t<td>AMI ID</td>\n\t\t\t<td>AMI Name</td>\n\t\t\t<td>AMI Type</td>\n\t\t</tr>\n\n\t\t<tr>\n\t\t\t<td>\n\t\t\t\t<input\n\t\t\t\t\tdojoAttachPoint=\"amiid\"\n\t\t\t\t\tclass=\"amiid\"\n\t\t\t\t\ttype=\"text\"\n\t\t\t\t\tvalue=\"ami-d1c42db8\"\n\t\t\t\t\ttitle=\"AMI ID of the Starcluster image used for all cluster nodes (The base x86_64 StarCluster AMI is ami-d1c42db8)\"\n\t\t\t\t\tdojoType=\"dijit.form.ValidationTextBox\"\n\t\t\t\t\tregExp=\"^ami-[A-F0-9a-f]{8}$\"\n\t\t\t\t\tmaxlength=\"12\" \n\t\t\t\t\tpromptMessage=\"AMI identifier. Must be 'ami-XXXXXXXX' in hexadecimal (a-f0-09), e.g. ami-d1c42db8\" \n\t\t\t\t\tinvalidMessage=\"AMI identifier. Must be 'ami-XXXXXXXX' in hexadecimal (a-f0-09), e.g., ami-d1c42db8\" \n\t\t\t\t\ttooltipPosition=\"below\"\n\t\t\t\t\twrap=\"off\"\n\t\t\t\t>\n\t\t\t</td>\n\t\t\t<td>\n\t\t\t\t<input\n\t\t\t\t\tdojoAttachPoint=\"aminame\"\n\t\t\t\t\tclass=\"aminame\"\n\t\t\t\t\ttype=\"text\"\n\t\t\t\t\tvalue=\"myAmi\"\n\t\t\t\t\tdojoType=\"dijit.form.ValidationTextBox\"\n\t\t\t\t\tregExp=\"^\\S{1,20}$\"\n\t\t\t\t\tmaxlength=\"20\" \n\t\t\t\t\tpromptMessage=\"AMI name: up to 20 characters (no spaces)\" \n\t\t\t\t\tinvalidMessage=\"AMI name: up to 20 characters (no spaces)\"\n\t\t\t\t\ttooltipPosition=\"below\"\n\t\t\t\t\twrap=\"off\"\n\t\t\t\t\t>\n\t\t\t</td>\n\t\t\t<td>\n\t\t\t\t<select\n\t\t\t\t\tdojoAttachPoint=\"amitype\"\n\t\t\t\t\tclass=\"amitype\"\n\t\t\t\t\ttitle=\"AMI type: EBS-backed (stop/startable, retains its state) or emphemeral S3 type\">\n\t\t\t\t\t<option value=\"EBS\">EBS</option> \n\t\t\t\t\t<option value=\"S3\">S3</option>\n\t\t\t\t</select>\n\t\t\t</td>\n\t\t</tr>\n\n\t\t<tr class=\"headerRow\" width=\"95%\" height=\"8px\">\n\t\t\t<td colspan=\"3\">Description</td>\n\t\t</tr>\n\n\t\t<tr width=\"95%\" >\n\t\t\t<td align=\"center\" colspan=\"3\">\n\t\t\t\t<textarea\n\t\t\t\t\tspellcheck=\"false\"\n\t\t\t\t\tdojoAttachPoint=\"description\"\n\t\t\t\t\tclass=\"description\"\n\t\t\t\t\tcols=\"40\"\n\t\t\t\t\trows=\"1\"\n\t\t\t\t\ttitle=\"A brief description of the cluster group\"\n\t\t\t\t>Description</textarea>\n\t\t\t</td>\n\t\t</tr>\n\n\t\t<tr valign=\"top\" width=\"95%\">\n\t\t\t<td colspan=\"3\" width=\"95%\">\n\t\t\t\t<div class=\"label\"> AMIs </div>\n\t\t\t\t<div\n\t\t\t\t\tdojoAttachPoint=\"dragSourceNode\"\n\t\t\t\t\tclass=\"dragSource\"\n\t\t\t\t\tstyle=\"height: 327px; width: 95%;\"\n\t\t\t\t>\n\t\t\t\t</div>\n\t\t\t</td>\n\t\t</tr>\n\n\t\t<tr align=\"center\">\n\t\t\t<td colspan=\"3\" align=\"center\">\n\n\t\t\t\t<!-- TRASH CONTAINER -->\n\t\t\t\t<div\n\t\t\t\t\tdojoAttachPoint=\"trashContainer\"\n\t\t\t\t\tclass=\"trash\"\n\t\t\t\t\tstyle=\"height: 60px; width: 150px; align: center;\" \n\t\t\t\t\t>\n\t\t\t\t\t<div\n\t\t\t\t\t\tdojoAttachPoint=\"trashIcon\"\n\t\t\t\t\t\tclass=\"trashIcon\"\n\t\t\t\t\t\tstyle=\"height: 60px; width: 60px;\"\n\t\t\t\t\t\t>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</td>\n\t\t</tr>\n\t</table>\n\n\n\t</div>\n\t<!-- END ami TAB -->\n\t\n</div> \n\n\n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

//addingUser STATE
addingUser : false,

// OR USE @import IN HTML TEMPLATE
cssFiles : [ dojo.moduleUrl("plugins") + "/cloud/css/ami.css"],

// PARENT WIDGET
parentWidget : null,

formInputs : {
// FORM INPUTS AND TYPES (word|phrase)
	aminame		:	"word",
	amiid		:	"word",
	amitype		:	"word",
	description	:	"phrase"
},

defaultInputs : {
// DEFAULT INPUTS
	aminame 	: 	"myAmi",
	amiid		:	"AMI ID",
	description	:	"Description"
},

requiredInputs : {
// REQUIRED INPUTS CANNOT BE ''
// combo INPUTS ARE AUTOMATICALLY NOT ''
	aminame 	: 1,
	amiid		: 1
},

invalidInputs : {
// THESE INPUTS ARE INVALID
	aminame 	: 	"myAmi",
	amiid		:	"AMI ID",
	description	:	"Description"
},

dataFields : [
	"amiid",
	"aminame"
],

rowClass : "plugins.cloud.AmiRow",

avatarType : "parameters",

avatarItems: [ "aminame", "amiid", "amitype", "description"],

/////}}}

// STARTUP METHODS
constructor : function(args) {
	//console.log("Ami.constructor     plugins.cloud.Ami.constructor");			
	// GET INFO FROM ARGS
	this.parentWidget = args.parentWidget;
	this.ami = args.parentWidget.ami;

	// LOAD CSS
	this.loadCSS();		
},

postCreate : function() {
	//console.log("Controller.postCreate    plugins.cloud.Controller.postCreate()");

	this.startup();
},

startup : function () {
	console.log("Ami.startup    plugins.cloud.Ami.startup()");

	// COMPLETE CONSTRUCTION OF OBJECT
	this.inherited(arguments);	 

	// ADD ADMIN TAB TO TAB CONTAINER		
	this.tabContainer.addChild(this.mainTab);
	this.tabContainer.selectChild(this.mainTab);

	// SET NEW PARAMETER FORM
	this.setForm();

	// SET CLEAR VALUES
	this.setClearValues();

	// SET DRAG SOURCE - LIST OF CLUSTERS
	this.setDragSource();

	console.log("Ami.startup    BEFORE this.setTrash(this.dataFields), I.E., plugins.form.DndTrash.startup()");
	this.setTrash(this.dataFields);	
	console.log("Ami.startup    AFTER this.setTrash(this.dataFields), I.E., plugins.form.DndTrash.startup()");

	// SUBSCRIBE TO UPDATES
	Agua.updater.subscribe(this, "updateAmis");
},

updateAmis : function (args) {
// RELOAD THE COMBO AND DRAG SOURCE AFTER CHANGES
// TO DATA IN OTHER TABS
	console.log("Ami.updateAmis(args)");
	console.log("Ami.updateAmis    args: " );
	console.dir(args);
	
	if ( args.originator == this )
	{
		if ( args.reload == false )	return;
	}
	console.log("Ami.updateAmis    Calling setDragSource()");
	this.setDragSource();
},

setForm : function () {
// SET LISTENERS TO ACTIVATED SAVE BUTTON AND TO CLEAR DEFAULT TEXT
// WHEN INPUTS ARE CLICKED ON
	console.log("Ami.setForm    plugins.cloud.Ami.setForm()");

	// SET ADD PARAMETER ONCLICK
	dojo.connect(this.addAmiButton, "onclick", dojo.hitch(this, "saveInputs", null, null));	
	// SET CLEARVALUE ON CLUSTER VALIDATION TEXT BOX
	dojo.connect(this.aminame, "onFocus", dojo.hitch(this, "clearValue", this.aminame, this.invalidInputs["aminame"]));

	// SET TRASH, ETC.
	this.inherited(arguments);
},

getItemArray : function () {
// GET A LIST OF DATA ITEMS - ONE FOR EACH ROW
	return Agua.getAmis();
},

setDragSource : function () {
// SET THE DRAG SOURCE WITH PARAMETER OBJECTS
	console.log("Ami.setDragSource     plugins.cloud.Ami.setDragSource()");

	// GENERATE DND GROUP
	if ( this.dragSource == null ) {
		this.initialiseDragSource();
		this.setDragSourceCreator();
	}

	// DELETE EXISTING CONTENT
	this.clearDragSource();

	// INITIALISE USER INFO
	var itemArray = this.getItemArray();
	console.log("Ami.setDragSource     itemArray: " + dojo.toJson(itemArray));
	itemArray = this.sortHasharray(itemArray, 'aminame');
	console.log("Ami.setDragSource    itemArray: " + dojo.toJson(itemArray));
	
	// CHECK IF itemArray IS NULL
	if ( itemArray == null )
	{
		console.log("Ami.setDragSource     itemArray is null or empty. Returning.");
		return;
	}

	this.loadDragItems(itemArray);
},

saveInputs : function (inputs, reload) {
//	SAVE A PARAMETER TO Agua.parameters AND TO REMOTE DATABASE
	console.log("Ami.saveInputs    plugins.cloud.Ami.saveInputs(inputs, reload)");
	console.log("Ami.saveInputs    inputs: " + dojo.toJson(inputs));
	console.log("Ami.saveInputs    reload: ");
	console.dir(reload);
	
	if ( this.saving == true )	return;
	this.saving = true;

	if ( inputs == null )
	{
		inputs = this.getFormInputs(this);
		console.log("Ami.saveInputs    inputs: ");
		console.dir({inputs:inputs});
		
		// RETURN IF INPUTS ARE NULL OR INVALID
		
		if ( inputs == null )
		{
			this.saving = false;
			return;
		}
	}
	console.log("Ami.saveInputs    inputs: " + dojo.toJson(inputs));
	Agua.addAmi(inputs);
	
	this.saving = false;

	// RELOAD RELEVANT DISPLAYS
	Agua.updater.update("updateAmis", {originator: this, reload: reload});

}, // Amis.saveInputs

deleteItem : function (amiObject) {
	console.log("Ami.deleteItem    plugins.cloud.Ami.deleteItem(name)");
	console.log("Ami.deleteItem    amiObject: " + dojo.toJson(amiObject));

	Agua.removeAmi(amiObject);

	// RELOAD RELEVANT DISPLAYS
	Agua.updater.update("updateAmis", {originator: this, reload: false});
 	
}, // Amis.deleteItem

checkEnter : function (event) {
	console.log("Ami.checkEnter    event.keyCode: " + event.keyCode);

	if (event.keyCode == dojo.keys.ENTER)
	{
		this.saveInputs();
		dojo.stopEvent(event);
	}
},

checkEnterNodes : function (event) {
	console.log("Ami.checkEnterNodes    event.keyCode: " + event.keyCode);

	if (event.keyCode == dojo.keys.ENTER)
	{
		dojo.stopEvent(event);

		console.log("Ami.checkEnterNodes    setting document.body.focus()");
		document.body.focus();

		this.checkNodeNumbers();

		this.saveInputs();
	}
},
	
checkNodeNumbers : function () {
// SET MIN NODES VALUE TO SENSIBLE NUMBER 
	console.log("Ami.checkNodeNumbers     plugins.cloud.Ami.checkNodeNumbers()");
	console.log("Ami.checkNodeNumbers     this.minnodes.get('value'): " + this.minnodes.get('value'));
	console.log("Ami.checkNodeNumbers     this.maxnodes.get('value'): " + this.maxnodes.get('value'));
	
	if (this.minnodes.value > this.maxnodes.value )
	{
		console.log("Ami.checkNodeNumbers     this.minnodes.value > this.maxnodes.value");
		this.minnodes.set('value', this.maxnodes.value);
	}
}



}); // plugins.cloud.Ami


}

if(!dojo._hasResource["plugins.cloud.Aws"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.cloud.Aws"] = true;
dojo.provide("plugins.cloud.Aws");

// ADD USER'S AWS INFORMATION

// // optimize: load dijit layer

//
//
//




dojo.declare("plugins.cloud.Aws",
	[ dijit._Widget, dijit._Templated, plugins.core.Common ], {

//Path to the template of this widget. 
templateString:"<div dojoattachpoint=\"containerNode\">\n\n\t\n\t<!-- settings TAB -->\n\t<div\n\t\tdojoAttachPoint=\"mainTab\"\n\t\tclass=\"aws\"\n\t\tdojoType=\"dijit.layout.ContentPane\"\n\t\ttitle=\"AWS\"\n\t\tstyle=\"height: 700px; max-height: auto !important; width: 390px !important; padding: 0 !important;\"\n\t\t>\n\n\t\t<table width=\"100%\">\n\t\t\t<tr valign=\"top\" width=\"100%\">\n\t\t\t\t<td colspan=\"2\" class=\"tabTitle\" align=\"center\"> AWS </td>\n\t\t\t</tr>\n\t\t\t\n\t\t\t<tr valign=\"top\" width=\"95%\">\n\t\t\t\t<td width=\"95%\">\n\t\t\t\t\t<div class=\"label\"> Amazon Web Services </div>\n\t\t\t\t\t<div\n\t\t\t\t\t\tclass=\"subPane\"\n\t\t\t\t\t\tstyle=\"height: 680px; width: 95%;\"\n\t\t\t\t\t>\n\n\t\t\t\t\t<table width=\"100%\">\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td\n\t\t\t\t\t\t\t\tcolspan=\"2\"\n\t\t\t\t\t\t\t\tdojoAttachPoint=\"addAwsButton\"\n\t\t\t\t\t\t\t\tclass=\"addAwsButton\"\n\t\t\t\t\t\t\t\tdojoAttachEvent=\"onclick:addAws\"\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\tSave\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t</tr>\n\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td class=\"sublabel\">Amazon User ID</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td colspan=\"2\">\n\t\t\t\t\t\t\t\t<input\n\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"amazonuserid\"\n\t\t\t\t\t\t\t\t\tclass=\"amazonUserId\"\n\t\t\t\t\t\t\t\t\tdojoType=\"dijit.form.ValidationTextBox\"\n\t\t\t\t\t\t\t\t\twrap=\"off\"\n\t\t\t\t\t\t\t\t\tregExp=\"^\\d{12}$\"\n\t\t\t\t\t\t\t\t\tmaxlength=\"12\"\n\t\t\t\t\t\t\t\t\tpromptMessage=\"Enter your 12-digit Amazon User ID (numbers only)\" \n\t\t\t\t\t\t\t\t\tinvalidMessage=\"Invalid User ID (Must be 12 digits, numbers only).\"\n\t\t\t\t\t\t\t\t\tvalue=\"\"\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td class=\"sublabel\">AWS Key ID</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td colspan=\"2\">\n\t\t\t\t\t\t\t\t<input\n\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"awsaccesskeyid\"\n\t\t\t\t\t\t\t\t\tclass=\"accessKeyId\"\n\t\t\t\t\t\t\t\t\tdojoType=\"dijit.form.ValidationTextBox\"\n\t\t\t\t\t\t\t\t\ttype=\"text\"\n\t\t\t\t\t\t\t\t\tmaxlength=\"24\"\n\t\t\t\t\t\t\t\t\tuppercase=\"true\"\n\t\t\t\t\t\t\t\t\tregExp=\"[A-Z0-9]{16,24}\"\n\t\t\t\t\t\t\t\t\tinvalidMessage=\"16-24 characters: capital letters or numbers\"\n\t\t\t\t\t\t\t\t\tpromptMessage=\"16-24 characters: capital letters or numbers\"\n\t\t\t\t\t\t\t\t\tvalue=\"\"\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t</tr>\n\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td class=\"sublabel\">AWS Secret Key</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td colspan=\"2\">\n\t\t\t\t\t\t\t\t<input\n\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"awssecretaccesskey\"\n\t\t\t\t\t\t\t\t\tclass=\"secretAccessKey\"\n\t\t\t\t\t\t\t\t\tdojoType=\"dijit.form.ValidationTextBox\"\n\t\t\t\t\t\t\t\t\ttype=\"text\"\n\t\t\t\t\t\t\t\t\tmaxlength=\"45\"\n\t\t\t\t\t\t\t\t\tregExpGen=\"return '.{35,45}'\"\n\t\t\t\t\t\t\t\t\tinvalidMessage=\"35-45 characters\"\n\t\t\t\t\t\t\t\t\tpromptMessage=\"35-45 characters\"\n\t\t\t\t\t\t\t\t\tvalue=\"\"\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t</tr>\n\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td class=\"sublabel\">Private Key</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td colspan=\"2\">\n\t\t\t\t\t\t\t\t<textarea\n\t\t\t\t\t\t\t\t\tspellcheck=\"false\"\n\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"ec2privatekey\"\n\t\t\t\t\t\t\t\t\tclass=\"ec2privatekey\"\n\t\t\t\t\t\t\t\t\tstyle=\"width:100%;\";\n\t\t\t\t\t\t\t\t\tcols=\"40\"\n\t\t\t\t\t\t\t\t\trows=\"20\"></textarea>\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t</tr>\n\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td class=\"sublabel\">Public Certificate</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td colspan=\"2\">\n\t\t\t\t\t\t\t\t<textarea\n\t\t\t\t\t\t\t\t\tspellcheck=\"false\"\n\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"ec2publiccert\"\n\t\t\t\t\t\t\t\t\tclass=\"ec2publiccert\"\n\t\t\t\t\t\t\t\t\tstyle=\"width:100%;\";\n\t\t\t\t\t\t\t\t\tcols=\"40\"\n\t\t\t\t\t\t\t\t\trows=\"20\"\n\t\t\t\t\t\t\t\t></textarea>\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t</tr>\n\n\t\t\t\t\t</table>\n\n\t\n\t\t\t\t\t</div>\n\t\t\t\t</td>\n\t\t\t</tr>\n\t\t\n\t\t</table>\n\n\t</div>\n\t<!-- END settings TAB -->\n\t\n</div> \n\n\n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

//addingUser STATE
addingUser : false,

// OR USE @import IN HTML TEMPLATE
cssFiles : [
	dojo.moduleUrl("plugins", "cloud/css/aws.css"),
	//dojo.moduleUrl("dojo", "/tests/dnd/dndDefault.css")
],

requiredInputs : {
	amazonuserid 		: 1,
	awsaccesskeyid 		: 1,
	awssecretaccesskey 	: 1,
	ec2privatekey 		: 1,
	ec2publiccert 		: 1
},

// PARENT WIDGET
parentWidget : null,

/////}}}

constructor : function(args)  {
	// GET INFO FROM ARGS
	this.parentWidget = args.parentWidget;
	this.core = args.parentWidget.core;

	// LOAD CSS
	this.loadCSS();
},
postCreate : function() {
	this.startup();
},
startup : function () {
	//console.log("Aws.startup    plugins.cloud.GroupAws.startup()");

	// COMPLETE CONSTRUCTION OF OBJECT
	this.inherited(arguments);

	// ADD ADMIN TAB TO TAB CONTAINER		
	this.tabContainer.addChild(this.mainTab);
	this.tabContainer.selectChild(this.mainTab);

	// SET DRAG SOURCE - LIST OF USERS
	this.initialiseAws();
},
// SAVE TO REMOTE
addAws : function (event) {

console.clear();

	console.log("Aws.addAws    plugins.cloud.Aws.addAws(event)");
	console.log("Aws.addAws    event: " + event);
	
	if ( this.savingAws == true ) {
		console.log("Aws.addAws    this.savingAws: " + this.savingAws + ". Returning.");
		return;
	}
	this.savingAws = true;
	
	// VALIDATE INPUTS
	var inputs = this.validateInputs();
	if ( ! inputs ) {
		this.savingAws = false;
		return;
	}
	
	var query = inputs;
	query.username 			= Agua.cookie('username');
	query.sessionid 		= Agua.cookie('sessionid');
	query.repotype			= "github";
	query.mode = "addAws";
	
	console.log("Aws.addAws    query: ");
	console.dir({query:query});

	var url = Agua.cgiUrl + "workflow.cgi?";
	
	// SEND TO SERVER
	var thisObj = this;
	dojo.xhrPut(
		{
			url: url,
			contentType: "json",
			putData: dojo.toJson(query),
			handleAs: "json",
			load: function(response, ioArgs) {
				console.log("Aws.addAws    STATUS response:");
				console.dir({response:response});

				if ( ! response ) {
					Agua.toast({error:"No response from server on 'addAws'"});
					return;
				}
				
				if ( ! response.error ) {
					console.log("Aws.addAWS    DOING Agua.setAws(inputs)");
					Agua.setAws(inputs);
				}


				Agua.toast(response);
				
			},
			error: function(response, ioArgs) {
				console.log("Aws.addAws    ERROR response:");
				console.dir({response:response});
				Agua.toast(response);
			}
		}
	);

	this.savingAws = false;
},
validateInputs : function () {
	var inputs = new Object;
	this.isValid = true;
	for ( var input in this.requiredInputs ) {
		inputs[input] = this.verifyInput(input);
	}
	console.log("Aws.validateInputs    inputs: ");
	console.dir({inputs:inputs});

	if ( ! this.isValid ) 	return null;	
	return inputs;
},
verifyInput : function (input) {
	console.log("Aws.verifyInput    input: ");
	console.dir({this_input:this[input]});
	var value = this[input].value;
	value = this.cleanEdges(value);
	console.log("Aws.verifyInput    value: " + value);

	var className = this.getClassName(this[input]);
	console.log("Aws.verifyInput    className: " + className);
	if ( className ) {
		console.log("Aws.verifyInput    this[input].isValid(): " + this[input].isValid());
		if ( ! value || ! this[input].isValid() ) {
			console.log("Aws.verifyInput    input " + input + " value is empty. Adding class 'invalid'");
			dojo.addClass(this[input].domNode, 'invalid');
			this.isValid = false;
		}
		else {
			console.log("Aws.verifyInput    value is NOT empty. Removing class 'invalid'");
			dojo.removeClass(this[input].domNode, 'invalid');
			return value;
		}
	}
	else {
		if ( ! value ) {
			console.log("Aws.verifyInput    input " + input + " value is EMPTY. Adding class 'invalid'");
			dojo.addClass(this[input], 'invalid');
			this.isValid = false;
			return null;
		}
		else if ( input == "ec2privatekey" ) {
			if ( ! value.match(/^\s*-----BEGIN PRIVATE KEY-----[\s\S]+-----END PRIVATE KEY-----\S*$/) ) {
				console.log("Aws.verifyInput    value is INVALID. Adding class 'invalid'");
				dojo.addClass(this[input], 'invalid');
				this.isValid = false;
				return null;
			}
			
				console.log("Aws.verifyInput    value is VALID. Removing class 'invalid'");
			dojo.removeClass(this[input], 'invalid');
			return value;
		}
		else if ( input == "ec2publiccert" ) {
			if ( ! value.match(/^\s*-----BEGIN CERTIFICATE-----[\s\S]+-----END CERTIFICATE-----\S*$/) ) {
				console.log("Aws.verifyInput    value is INVALID. Adding class 'invalid'");
				dojo.addClass(this[input], 'invalid');
				this.isValid = false;
				return null;
			}
			
				console.log("Aws.verifyInput    value is VALID. Removing class 'invalid'");
			dojo.removeClass(this[input], 'invalid');
			return value;
		}
	}
	
	return null;
},
initialiseAws : function () {
	// INITIALISE AWS SETTINGS
	var aws = Agua.getAws();
	console.log("Aws.initialiseAws     aws: ");
	console.dir({aws:aws});

	this.amazonuserid.set('value', aws.amazonuserid);
	this.awsaccesskeyid.set('value', aws.awsaccesskeyid);
	this.awssecretaccesskey.set('value', aws.awssecretaccesskey);
	this.ec2privatekey.value = aws.ec2privatekey || "";
	this.ec2publiccert.value = aws.ec2publiccert || "";
},
cleanEdges : function (string ) {
// REMOVE WHITESPACE FROM EDGES OF TEXT
	string = string.toString();
	if ( string == null || ! string.replace)
		return null;
	string = string.replace(/^\s+/, '');
	string = string.replace(/\s+$/, '');

	return string;
}
}); // plugins.cloud.Aws


}

if(!dojo._hasResource["plugins.cloud.Cloud"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.cloud.Cloud"] = true;
dojo.provide("plugins.cloud.Cloud");



// DISPLAY DIFFERENT PAGES TO ALLOW THE admin AND ORDINARY
// USERS TO MODIFY THEIR SETTINGS

// DnD
 // Source & Target





// comboBox data store







// rightPane buttons


dojo.declare( "plugins.cloud.Cloud", 
	[ dijit._Widget, dijit._Templated, plugins.core.Common ], {
//Path to the template of this widget. 
templateString:"<div dojoAttachPoint=\"containerNode\">\n\n\t<!-- ADMIN TAB -->\n\t<div\n        dojoAttachPoint=\"mainTab\"\n        class=\"cloud\"\n\t\ticonClass=\"cloudIcon\"\n        style=\"min-width: 1140px !important; width: 100% !important; height:100% !important; max-height: auto !important; padding: 0px; background: #FFF;\"\n        dojoType=\"dijit.layout.BorderContainer\"\n\t\tclosable=\"true\"\t\t\n        title=\"Cloud\"\n        >\n        \n        <!-- LEFT PANE -->\n        <div\n            dojoAttachPoint=\"leftPane\"\n            class=\"leftPane\"\n\t\t\tlayoutAlign=\"left\" \n            dojoType=\"dijit.layout.ContentPane\" \n            style=\"position: absolute !important; width: 390px; height: 100% !important; max-height: auto !important; min-width: 25px; background: #FFF; padding: 0; border: none !important;\"\n            >\n\n            <!-- LEFT TAB CONTAINER-->\n            <div dojoAttachPoint=\"leftTabContainer\"\n                dojoType=\"dijit.layout.TabContainer\"\n                style=\"height: 100%; overflow: visible;\"\n                class=\"infoPane\">\n\n            </div>\n            <!-- END OF LEFT TAB CONTAINER-->\n\t\t\t\n        </div>\n        <!-- END OF LEFT PANE -->\n\n        <!-- MIDDLE PANE -->\n        <div\n            dojoAttachPoint=\"middlePane\"\n\t\t\tlayoutAlign=\"middle\" \n\t\t\tclass=\"middlePane\"\n            dojoType=\"dijit.layout.ContentPane\" \n            style=\"position: absolute !important; left: 390px !important; height: 100% !important; max-height: auto !important; width: 390px; min-width: 25px; background: #FFF; padding: 0; border: none !important;\"\n            >\n\n            <!-- MIDDLE TAB CONTAINER-->\n            <div\n                dojoAttachPoint=\"middleTabContainer\"\n                dojoType=\"dijit.layout.TabContainer\"\n                style=\"height: 100%; overflow: visible;\"\n                class=\"infoPane\">\n\n            </div>\n\n        </div>\n        <!-- END OF MIDDLE PANE -->\n\n\n        <!-- RIGHT PANE -->\n        <div\n            dojoAttachPoint=\"rightPane\" \n            class=\"rightPane\"\n\t\t\tlayoutAlign=\"right\"\n            dojoType=\"dijit.layout.ContentPane\" \n            style=\"position: absolute !important; left: 780px !important; height: 100% !important; max-height: auto !important; width: 390px !important; min-width: 25px; background: #FFF; padding: 0; border: none !important;\"\n            >\n\n            <!-- RIGHT TAB CONTAINER-->\n            <div dojoAttachPoint=\"rightTabContainer\"\n                dojoType=\"dijit.layout.TabContainer\"\n                style=\"height: 100%; overflow: visible; width: 390px !important; \"\n                class=\"infoPane\">\n\n            </div>\n            <!-- END OF RIGHT TAB CONTAINER-->\n\n        </div>\n        <!-- END OF RIGHT PANE -->\n\n\t</div>\n\t<!-- END OF ADMIN TAB -->\n\n</div>\n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

// PANE WIDGETS
paneWidgets : null,

// CORE WORKFLOW OBJECTS
core : new Object,

cssFiles : [
	dojo.moduleUrl("plugins", "cloud/css/cloud.css")
],

// DEBUG: LIST OF PANELS TO LOAD
// paneList: ';'-separated String
panelList: null,

// INPUTS PASSED FROM CONTROLLER
// inputs: ';'-separated String
inputs : null,

// LOAD PANELS
// loadPanels: array of names of panels to be loaded
loadPanels : null,

/////}}
constructor : function(args) {
	console.log("admin.Admin.constructor    args:");
	console.dir({args:args});

	// SET LOAD PANELS
	this.setLoadPanels(args);
	
	// LOAD CSS
	this.loadCSS();		
},
postCreate : function() {
	////console.log("Cloud.postCreate    plugins.cloud.Controller.postCreate()");

	this.startup();
},
startup : function () {
	//console.log("Cloud.startup    plugins.cloud.Controller.startup()");

    // ADD THIS WIDGET TO Agua.widgets
    Agua.addWidget("admin", this);

	// ADD ADMIN TAB TO TAB CONTAINER		
	Agua.tabs.addChild(this.mainTab);
	Agua.tabs.selectChild(this.mainTab);

	// CREATE HASH TO HOLD INSTANTIATED PANE WIDGETS
	this.paneWidgets = new Object;

	// LOAD HEADINGS FOR THIS USER
	this.headings = Agua.getCloudHeadings();
	console.log("Cloud.startup    this.headings:");
	console.dir({this_headings:this.headings});
	
	// LOAD PANES
	this.loadPanes();
},
reload : function (target) {
// RELOAD A WIDGET, WIDGETS IN A PANE OR ALL WIDGETS
	////console.log("Cloud.reload     plugins.cloud.Cloud.reload(target)");
	////console.log("Cloud.reload     target: " + target);

	if ( target == "all" )
	{
		for ( var mainPane in this.headings )
		{
			for ( var i in this.headings[mainPane] )
			{
				this.reloadWidget(this.headings[mainPane][i]);
			}
		}
	}
	else if ( target == "leftPane"
			|| target == "middlePane"
			|| target == "rightPane" )
	{
		for ( var i in this.headings[target] )
		{
			this.reloadWidget(this.headings[target][i]);
		}
	}
	
	// OTHERWISE, THE target MUST BE A PANE NAME
	else
	{
		try {
			this.reloadWidget(target);
		}
		catch (e) {}
	}		
},
reloadWidget : function (paneName) {
// REINSTANTIATE A PANE WIDGET
	////console.log("Cloud.reloadWidget     Reloading pane: " + paneName);

	delete this.paneWidgets[paneName];

	var adminObject = this;
	this.paneWidgets[paneName] = new plugins.cloud[paneName](
		{
			parentWidget: adminObject,
			tabContainer : adminObject.leftTabContainer
		}
	);
},
loadPanes : function () {
	var panes = ["left", "middle", "right"];
	for ( var i = 0; i < panes.length; i++ )
	{
		this.loadPane(panes[i]);
	}
},
loadPane : function(side) {
	console.log("Cloud.loadPane     side: " + side);
	console.log("Cloud.loadPane     this.loadPanels: ");
	console.dir({this_loadPanels:this.loadPanels});
	
	//console.log("Cloud.loadPane     side: " + dojo.toJson(side));
	var pane = side + "Pane";
	var tabContainer = side + "TabContainer";
	if ( this.headings == null || this.headings[pane] == null )	return;
	for ( var i = 0; i < this.headings[pane].length; i++ )
	{
		//console.log("Cloud.loadLeftPane     LOADING PANE this.headings[pane][" + i + "]: " + this.headings[pane][i]);

		var tabPaneName = this.headings[pane][i];
		console.log("Cloud.loadPane    dojo.require tabPaneName: " + tabPaneName);

		if ( this.loadPanels && ! this.loadPanels[tabPaneName.toLowerCase()] ) {
			console.log("Cloud.loadPane    Skipping panel: " + tabPaneName);
			continue;
		}

		var moduleName = "plugins.cloud." + tabPaneName;
		console.log("Cloud.loadPane    BEFORE dojo.require moduleName: " + moduleName);
		
		dojo["require"](moduleName);
		console.log("Cloud.loadPane    AFTER dojo.require moduleName: " + moduleName);
		
		var adminObject = this;
		var tabPane = new plugins["cloud"][tabPaneName](
			{
				parentWidget: adminObject,
				tabContainer : adminObject[tabContainer]
			}
		);
		
		// REGISTER THE NEW TAB PANE IN this.paneWidgets 
		if( this.paneWidgets[moduleName] == null )
			this.paneWidgets[moduleName] = new Array;
		this.paneWidgets[moduleName].push(tabPane);
	}
},
destroyRecursive : function () {
	console.log("Cloud.destroyRecursive    this.mainTab: ");
	console.dir({this_mainTab:this.mainTab});

	if ( Agua && Agua.tabs )
		Agua.tabs.removeChild(this.mainTab);
	
	this.inherited(arguments);
}

}); // end of plugins.cloud.Cloud


}

if(!dojo._hasResource["plugins.cloud.ClusterRow"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.cloud.ClusterRow"] = true;
dojo.provide("plugins.cloud.ClusterRow");



dojo.declare( "plugins.cloud.ClusterRow",
	[ dijit._Widget, dijit._Templated, plugins.core.Common ],
{
//Path to the template of this widget. 
templateString:"<div dojoAttachPoint=\"containerNode\">\n    <table class=\"clusterRow\" width=\"100%\">\n        \n        <tr>\n\t\t\t<td colspan=\"3\" width=\"100%\">\n\t\t\t\n\t\t\t\t<table width=\"100%\">\n\t\t\t\t\t<tr width=\"100%\">\n\t\t\t\t\t\t<td\n\t\t\t\t\t\t\tdojoAttachEvent=\"onclick:toggle\"\n\t\t\t\t\t\t\tdojoAttachPoint=\"cluster\"\n\t\t\t\t\t\t\tclass=\"cluster\"\n\t\t\t\t\t\t\ttitle=\"Cluster Name\"\n\t\t\t\t\t\t>${cluster}</td>\n\t\t\t\t\t\t\n\t\t\t\t\t\t<td class=\"nodesLabel\">Min nodes</td>\n\t\t\t\t\t\t<td class=\"minnodes\">\n\t\t\t\t\t\t\t<input\n\t\t\t\t\t\t\t\tdojoAttachPoint=\"minnodes\"\n\t\t\t\t\t\t\t\tdojoAttachEvent=\"onKeyPress:checkEnterNodes\"\n\t\t\t\t\t\t\t\tclass=\"minnodes\"\n\t\t\t\t\t\t\t\ttype=\"text\"\n\t\t\t\t\t\t\t\tvalue=\"${minnodes}\"\n\t\t\t\t\t\t\t\tdojoType=\"dijit.form.NumberTextBox\"\n\t\t\t\t\t\t\t\tvalue=\"0\"\n\t\t\t\t\t\t\t\tconstraints=\"{min:0,max:99999,places:0}\"\n\t\t\t\t\t\t\t\tmaxlength=\"4\" \n\t\t\t\t\t\t\t\tpromptMessage=\"Minimum nodes: from 1 to 99999\" \n\t\t\t\t\t\t\t\tinvalidMessage=\"Minimum nodes: from 1 to 99999\"\n\t\t\t\t\t\t\t\ttooltipPosition=\"above, below\"\n\t\t\t\t\t\t\t\tstyle=\"display: table-cell; text-align: center; width: 25px !important;\"\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\n\t\t\t\t\t\t<td class=\"nodesLabel\">Max nodes</td>\n\t\t\t\t\t\t<td class=\"maxnodes\">\n\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\tdojoAttachPoint=\"maxnodes\"\n\t\t\t\t\t\t\t\tdojoAttachEvent=\"onKeyPress:checkEnterNodes\"\n\t\t\t\t\t\t\t\tclass=\"maxnodes\"\n\t\t\t\t\t\t\t\tdojoType=\"dijit.form.NumberTextBox\"\n\t\t\t\t\t\t\t\tvalue=\"${maxnodes}\"\n\t\t\t\t\t\t\t\tconstraints=\"{min:0,max:99999,places:0}\"\n\t\t\t\t\t\t\t\tmaxlength=\"4\" \n\t\t\t\t\t\t\t\tpromptMessage=\"Maximum nodes: from 1 to 99999\" \n\t\t\t\t\t\t\t\tinvalidMessage=\"Maximum nodes: from 1 to 99999\"\n\t\t\t\t\t\t\t\ttooltipPosition=\"above, below\"\n\t\t\t\t\t\t\t\tstyle=\"display: table-cell; text-align: center; width: 25px !important;\"\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</td>\n\t\t\t\t\t</tr>\n\t\t\t\t</table>\n\t\t\t</td>\n        </tr>\n            \n        <tr>\n\t\t\t<td colspan=\"3\">\n\t\t\t\t<table>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td\n\t\t\t\t\t\t\tstyle=\"display: none;\"\n\t\t\t\t\t\t\tdojoAttachPoint=\"amiidContainer\"\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<input\n\t\t\t\t\t\t\t\tdojoAttachPoint=\"amiid\"\n\t\t\t\t\t\t\t\tdojoAttachEvent=\"onChange:setAmiInfo\"\n\t\t\t\t\t\t\t\tdojoType=\"dijit.form.ComboBox\"\n\t\t\t\t\t\t\t\tclass=\"amiid\"\n\t\t\t\t\t\t\t\ttype=\"text\"\n\t\t\t\t\t\t\t\tvalue=\"ami-d1c42db8\"\n\t\t\t\t\t\t\t\ttitle=\"AMI ID of the Starcluster image used for all cluster nodes (The base x86_64 StarCluster AMI is ami-d1c42db8)\"\n\t\t\t\t\t\t\t\tdojoType=\"dijit.form.ValidationTextBox\"\n\t\t\t\t\t\t\t\tregExp=\"^ami-[A-F0-9a-f]{8}$\"\n\t\t\t\t\t\t\t\tmaxlength=\"12\"\n\t\t\t\t\t\t\t\tpromptMessage=\"Amazon Machine Image (AMI) identifier. Must be 'ami-XXXXXXXX' in hexadecimal (a-f0-09), e.g., ami-d1c42db8\" \n\t\t\t\t\t\t\t\tinvalidMessage=\"Amazon Machine Image (AMI) identifier. Must be 'ami-XXXXXXXX' in hexadecimal (a-f0-09), e.g., ami-d1c42db8\" \n\t\t\t\t\t\t\t\ttooltipPosition=\"below\"\n\t\t\t\t\t\t\t\twrap=\"off\"\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t</td>\n\t\t\t\t\t\t<td\n\t\t\t\t\t\t\tdojoAttachPoint=\"aminame\"\n\t\t\t\t\t\t\tclass=\"aminame\"\n\t\t\t\t\t\t>\n\t\t\t\t\t\t</td>\n\t\t\t\t\t\t<td\n\t\t\t\t\t\t\tdojoAttachPoint=\"amitype\"\n\t\t\t\t\t\t\tclass=\"amitype\"\n\t\t\t\t\t\t>\n\t\t\t\t\t\t</td>\n\t\t\t\t\t</tr>\n\t\t\t\t</table>\n\t\t\t</td>\n        </tr>\n\n        <tr>\n            <td align=\"center\"\n                dojoAttachPoint=\"instancetypeContainer\"\n                style=\"display: none;\"\n                >\n                <select\n                    dojoAttachPoint=\"instancetype\"\n                    class=\"instancetype\">\n\t\t\t\t\t<option value=\"t1.micro\">t1.micro</option> \n\t\t\t\t\t<option value=\"m1.small\">m1.small</option>\n\t\t\t\t\t<option value=\"m1.large\">m1.large</option>\n\t\t\t\t\t<option value=\"m1.xlarge\">m1.xlarge</option>\n\t\t\t\t\t<option value=\"m1.xlarge\">m2.xlarge</option>\n\t\t\t\t\t<option value=\"m2.2xlarge\">m2.2xlarge</option>\n\t\t\t\t\t<option value=\"m2.4xlarge\">m2.4xlarge</option>\n\t\t\t\t\t<option value=\"c1.medium\">c1.medium</option>\n\t\t\t\t\t<option value=\"c1.xlarge\">c1.xlarge</option>\n\t\t\t\t\t<option value=\"cc1.4xlarge\">cc1.4xlarge</option>\n\t\t\t\t\t<option value=\"cg1.4xlarge\">cg1.4xlarge</option>\n                </select>\n            </td>\n            <td align=\"center\"\n\t\t\t\tdojoAttachPoint=\"regionContainer\"\n\t\t\t\tstyle=\"display: none;\"\n\t\t\t>\n\t\t\t\t<select\n\t\t\t\t\tdojoAttachPoint=\"region\"\n\t\t\t\t\tdojoAttachEvent=\"onchange:setAvailzoneCombo\"\n\t\t\t\t\tclass=\"region\">\n\t\t\t\t\t<option value=\"us-east-1\">us-east-1</option> \n\t\t\t\t\t<option value=\"us-west-1\">us-west-1</option> \n\t\t\t\t\t<option value=\"eu-west-1\">eu-west-1</option> \n\t\t\t\t\t<option value=\"ap-northeast-1\">ap-northeast-1</option> \n\t\t\t\t\t<option value=\"ap-southeast-1\">ap-southeast-1</option> \n\t\t\t\t</select>\n\t\t\t</td>\n\t\t\t<td align=\"center\"\n\t\t\t\tdojoAttachPoint=\"availzoneContainer\"\n\t\t\t\tstyle=\"display: none;\"\n\t\t\t>\n\t\t\t\t<div\n\t\t\t\t\tdojoAttachPoint=\"availzone\"\n\t\t\t\t\tdojoType=\"dijit.form.ComboBox\"\n\t                dojoAttachEvent=\"onchange:saveInputs\"\n\t\t\t\t\tclass=\"availzone\"\n\t\t\t\t\ttype=\"text\"\n\t\t\t\t\tpopupClass=\"clusters availzone dijitReset dijitMenu\"\n\t\t\t\t\tautocomplete=\"true\"\n\t\t\t\t\thasDownArrow=\"true\"\n\t\t\t\t\tdisabled=\"false\"\n\t\t\t\t\tstyle=\"width: 50px;\">\n\t\t\t\t</div>\n\t\t\t</td>\n        </tr>\n\n\t\t<tr width=\"95%\">\n\t\t\t<td\n                align=\"center\"\n                colspan=\"3\"\n                dojoAttachPoint=\"description\"\n                dojoAttachEvent=\"onclick:editCluster\"\n                class=\"description\"\n                style=\"display: none;\"\n                width=\"100%\"\n                title=\"A brief description of the cluster group\"\n            >${description}</td>\n\t\t</tr>\n\n    </table>\n\n</div>\n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

// PARENT plugins.cloud.Apps WIDGET
parentWidget : null,

////}}}

constructor : function(args) {
	this.parentWidget = args.parentWidget;
	this.lockedValue = args.locked;
	this.args = args;
},
postCreate : function() {
	//console.log("ClusterRow.postCreate    plugins.workflow.ClusterRow.postCreate()");
	this.formInputs = this.parentWidget.formInputs;
	//console.log("ClusterRow.postCreate    this.formInputs: " + dojo.toJson(this.formInputs));

	this.startup();
},
startup : function () {
	//console.log("ClusterRow.startup    plugins.workflow.ClusterRow.startup()");
	//console.log("ClusterRow.startup    this: " + this);
	this.inherited(arguments);

	// SET AVAILABILITY ZONE COMBO
	var fakeEvent = {
		target: {
			selectedIndex: 0,
			options : [ {text: "us-east-1"} ]
		}
	};
	this.setAvailzoneCombo(fakeEvent);
	if ( this.args.availzone != null )
		this.availzone.set('value', this.args.availzone);		

	// SET AMI COMBO BOX
	this.setAmiCombo(this.args.amiid);
	this.setAmiInfo();

	// SET LISTENER FOR CHANGES TO amiid
	this.setOnkeyListeners(["amiid"]);

	setTimeout(function(thisObj) {
		//console.log("ClusterRow.startup   *******  Doing setTimeout(thisObj.setComboListeners *******");
		thisObj.setComboListeners();
	}, 2000, this);
	// SUBSCRIBE TO UPDATES
	Agua.updater.subscribe(this, "updateClusters");

	// SUBSCRIBE TO UPDATES
	Agua.updater.subscribe(this, "updateAmis");
},
updateClusters : function (args) {
// RELOAD THE COMBO AND DRAG SOURCE AFTER CHANGES
// TO DATA IN OTHER TABS
	console.log("ClusterRow.updateClusters(args)");
	console.log("ClusterRow.updateClusters    args: " );
	console.dir(args);
	
	// SET DRAG SOURCE
	if ( args == null || args.reload != false )
	{
		//////console.log("Cluster.updateClusters    Calling setDragSource()");
	} 
},
updateAmis : function (args) {
// RELOAD THE COMBO AND DRAG SOURCE AFTER CHANGES
// TO DATA IN OTHER TABS
	//console.log("ClusterRow.updateAmis(args)");
	//console.log("ClusterRow.updateAmis    args: " );
	//console.dir(args);
	
	if ( args.originator == this )
	{
		if ( args.reload == false )	return;
	}

	//console.log("ClusterRow.updateAmis    Doing this.setAmiCombo()");

	// SET AMI COMBO BOX
	this.setAmiCombo();
},
setComboListeners : function () {
	//console.log("ClusterRow.setComboListeners    ClusterRow.setComboListeners()");
	var thisObject = this;
	dojo.connect(this.instancetype, "onchange", function(event)
		{
			//console.log("ClusterRow.setComboListeners    onchange fired: " + onchangeArray[i]);
			//console.log("ClusterRow.setComboListeners    onchange    event: " + event);
			if ( event.stopPropagation == null )	return;
			var inputs = thisObject.parentWidget.getFormInputs(thisObject);
			thisObject.parentWidget.saveInputs(inputs, {reload: false});
			event.stopPropagation(); //Stop Event Bubbling
		}
	);

	dojo.connect(this.availzone, "onChange", function(availzone)
		{
			//console.log("ClusterRow.setComboListeners    onChange    availzone: " + availzone);
			var inputs = thisObject.parentWidget.getFormInputs(thisObject);
			thisObject.parentWidget.saveInputs(inputs, {reload: false});
		}
	);
	
	
	dojo.connect(this.amiid, "onChange", function()
		{
			//console.log("ClusterRow.setComboListeners    onChange    this.amiid: " + this.amiid);
			var inputs = thisObject.parentWidget.getFormInputs(thisObject);
			thisObject.parentWidget.saveInputs(inputs, {reload: false});
		}
	);
	
	
},
setOnkeyListeners : function (names) {

	var thisObject = this;
	for ( var i in names )
	{
		dojo.connect(thisObject[names[i]], "onKeyPress", function(evt){
			var key = evt.charOrCode;
			evt.stopPropagation();
			//console.log("ClusterRow.setOnkeyListeners    key: " + key);	
			if ( key == 13 )	thisObject.saveInputs();
		});
	}
},
getItemsArray : function () {
	var amis = Agua.getAmis();	
	//console.log("ClusterRow.setAmiCombo     amis: " + dojo.toJson(amis));
	return this.hashArrayKeyToArray(amis, ["amiid"]); 	
},
setAmiCombo : function (amiid) {
	//console.log("ClusterRow.setAmiCombo     plugins.cloud.Clusters.setAmiCombo(amiid)");

	var amis = this.getItemsArray();	
	//console.log("ClusterRow.setAmiCombo     amis: " + dojo.toJson(amis));
	
	// SET STORE
	var data = {identifier: "name", items: []};
	for ( var i = 0; i < amis.length; i++ )
	{
		data.items[i] = { name: amis[i]	};
	}
	//console.log("ClusterRow.setAmiCombo     data: " + dojo.toJson(data));
	var store = new dojo.data.ItemFileWriteStore({	data: data	});

	// SET COMBO
	this.amiid.store = store;
	this.amiid.startup();
	//console.log("ClusterRow.setAmiCombo     AFTER this.amiid.startup()");

	// SET COMBO VALUE
	var firstValue = amiid;
	if ( firstValue == null )
		firstValue = amis[0];
	this.amiid.setValue(firstValue);
	//console.log("ClusterRow.setAmiCombo     AFTER this.amiid.setValue(firstValue)");

	this.setAmiInfo();
},
setAmiInfo : function () {
	//console.log("ClusterRow.setAmiInfo     plugins.cloud.Clusters.setAmiInfo()");
	//console.log("ClusterRow.setAmiInfo     //console.dir(this)");
	;

	var amiid = this.amiid.get('value');
	//console.log("ClusterRow.setAmiInfo     amiid: " + amiid);

	var amiObject = Agua.getAmiObjectById(amiid);
	//console.log("ClusterRow.setAmiInfo     amiObject: " + dojo.toJson(amiObject));
	if ( amiObject == null ) {
		this.aminame.innerHTML = "";
		this.amitype.innerHTML = "";
	}
	else
	{
		this.aminame.innerHTML = amiObject.aminame;
		this.amitype.innerHTML = amiObject.amitype;
	}

},
setAvailzoneCombo : function (event) {
	//console.log("ClusterRow.setAvailzoneCombo     plugins.cloud.ClustersRow.setAvailzoneCombo(event)");
	//console.log("ClusterRow.setAvailzoneCombo     this: " + this);
	//console.log("ClusterRow.setAvailzoneCombo     event.target: " + event.target);
	var region = this.getSelectedValue(event.target);
	//console.log("ClusterRow.setAvailzoneCombo     region: " + region);
	var availzones = Agua.getAvailzonesByRegion(region);	
	//console.log("ClusterRow.setAvailzoneCombo     availzones: " + dojo.toJson(availzones));
	
	// SET STORE
	var data = {identifier: "name", items: []};
	for ( var i = 0; i < availzones.length; i++ )
	{
		data.items[i] = { name: availzones[i]	};
	}
	//console.log("ClusterRow.setAvailzoneCombo     data: " + dojo.toJson(data));
	var store = new dojo.data.ItemFileWriteStore(	{	data: data	}	);

	// SET COMBO
	this.availzone.store = store;
	this.availzone.startup();

	// SET COMBO VALUE
	var firstValue = availzones[0];
	this.availzone.set('value', firstValue);
},
saveInputs : function () {
	//console.log("ClusterRow.saveInputs    XXXXXXXXXX plugins.workflow.ClusterRow.saveInputs()");
	//console.log("ClusterRow.saveInputs    this.saveInputs.caller.nom: " + this.saveInputs.caller.nom);
	//console.log("ClusterRow.saveInputs    this.parentWidget: " + this.parentWidget);
	
	this.setAmiInfo();
	
	this.checkNodeNumbers();
	//console.log("ClusterRow.saveInputs    AFTER checkNodeNumbers");

	var inputs = this.parentWidget.getFormInputs(this);
	//console.log("ClusterRow.saveInputs    inputs: " + dojo.toJson(inputs));

	this.parentWidget.saveInputs(inputs, {reload: false});
},
checkNodeNumbers : function() {
	//console.log("ClusterRow.checkNodeNumbers    plugins.workflow.ClusterRow.checkNodeNumbers()");
	//console.log("ClusterRow.checkNodeNumbers     this.minnodes.get('value'): " + this.minnodes.get('value'));
	//console.log("ClusterRow.checkNodeNumbers     this.maxnodes.get('value'): " + this.maxnodes.get('value'));
	
	if (this.minnodes.get('value') > this.maxnodes.get('value') )
	{
		//console.log("ClusterRow.checkNodeNumbers     this.minnodes.value > this.maxnodes.value");
		this.minnodes.set('value', this.maxnodes.get('value'));
	}
},
editCluster : function (event) {
	//console.log("ClusterRow.editCluster    plugins.workflow.ClusterRow.editCluster()");
	//console.log("ClusterRow.editCluster    this.parentWidget: " + this.parentWidget);

	this.parentWidget.editRow(this, event.target);
	event.stopPropagation(); //Stop Event Bubbling
},
checkEnterNodes : function (event) {
	//console.log("ClusterRow.checkEnterNodes    event.keyCode: " + event.keyCode);

	if (event.keyCode == dojo.keys.ENTER)
	{
		dojo.stopEvent(event);
		//console.log("ClusterRow.checkEnterNodes    setting document.body.focus()");
		document.body.focus();

		this.checkNodeNumbers();

		var inputs = this.parentWidget.getFormInputs(this);
		this.saveInputs(inputs, null);

		//console.log("ClusterRow.checkEnterNodes    Doing dojo.stopEvent(event)");
	}
},
toggle : function () {
// TOGGLE HIDDEN NODES
	//console.log("ClusterRow.toggle    plugins.workflow.ClusterRow.toggle()");
	//console.log("ClusterRow.toggle    this.description: " + this.description);

	var array = [ "aminame", "amitype", "instancetypeContainer", "amiidContainer", "regionContainer", "availzoneContainer", "description" ];
	for ( var i in array )
	{
		//console.log("ClusterRow.toggle    toggling: " + array[i]);
		if ( this[array[i]].style.display == 'table-cell' )
			this[array[i]].style.display='none';
		else
			this[array[i]].style.display = 'table-cell';
	}
}


});

}

if(!dojo._hasResource["plugins.cloud.Clusters"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.cloud.Clusters"] = true;
dojo.provide("plugins.cloud.Clusters");

// ALLOW THE USER TO ADD, REMOVE AND MODIFY StarCluster CLUSTER GROUPS

// // optimize: load dijit layer







// FORM VALIDATION





// HAS A


dojo.declare("plugins.cloud.Clusters",
	[ dijit._Widget, dijit._Templated, plugins.core.Common, plugins.form.EditForm ],
{

//Path to the template of this widget. 
templateString:"<div dojoattachpoint=\"containerNode\">\n\n\t<!--http://aws.amazon.com/ec2/instance-types/-->\n\n\t<!-- clusters TAB -->\n\t<div\n\t\tdojoAttachPoint=\"clustersTab\"\n\t\tclass=\"clusters\"\n\t\tdojoType=\"dijit.layout.ContentPane\"\n\t\ttitle=\"Clusters\"\n\t\tstyle=\"height: 100% !important; max-height: auto !important; width: 390px !important; padding: 0 !important;\"\n\t>\n\n\t<table align=\"center\" width=\"100%\">\n\n\t\t<tr valign=\"top\" width=\"100%\">\n\t\t\t<td colspan=\"3\" class=\"tabTitle\" align=\"center\">Clusters</td>\n\t\t</tr>\n\n\t\t<tr height=\"20px\">\n\t\t\t<td align=\"center\" colspan=\"3\">\n\t\t\t\t<div\n\t\t\t\t\tdojoAttachPoint=\"addClusterButton\"\n\t\t\t\t\tclass=\"addClusterButton\"\n\t\t\t\t\t>Add Cluster</div>\n\t\t\t</td>\n\t\t</tr>\n\n\t\t<tr class=\"headerRow\">\n\t\t\t<td>Name</td>\n\t\t\t<td>Min nodes</td>\n\t\t\t<td>Max nodes</td>\n\t\t</tr>\n\n\t\t<tr align=\"center\">\n\n\t\t\t<td>\n\t\t\t\t<input\n\t\t\t\t\tdojoAttachPoint=\"cluster\"\n\t\t\t\t\tclass=\"cluster\"\n\t\t\t\t\ttype=\"text\"\n\t\t\t\t\tvalue=\"myCluster\"\n\t\t\t\t\tdojoType=\"dijit.form.ValidationTextBox\"\n\t\t\t\t\tregExp=\"^\\S{1,20}$\"\n\t\t\t\t\tmaxlength=\"20\" \n\t\t\t\t\tpromptMessage=\"Cluster name: up to 20 characters (no spaces)\" \n\t\t\t\t\tinvalidMessage=\"Cluster name: up to 20 characters (no spaces)\"\n\t\t\t\t\ttooltipPosition=\"below\"\n\t\t\t\t\twrap=\"off\"\n\t\t\t\t\t>\n\t\t\t</td>\n\t\t\t<td>\n\t\t\t\t<input\n\t\t\t\t\tdojoAttachPoint=\"minnodes\"\n\t\t\t\t\tdojoAttachEvent=\"onChange:checkNodeNumbers\"\n\t\t\t\t\tclass=\"minnodes\"\n\t\t\t\t\tdojoType=\"dijit.form.NumberTextBox\"\n\t\t\t\t\tvalue=\"0\"\n\t\t\t\t\tconstraints=\"{min:0,max:99999,places:0}\"\n\t\t\t\t\tmaxlength=\"5\" \n\t\t\t\t\tpromptMessage=\"Minimum nodes: from 0 to 99999\" \n\t\t\t\t\tinvalidMessage=\"Minimum nodes: from 0 to 99999\"\n\t\t\t\t\ttooltipPosition=\"below\"\n\t\t\t\t>\n\t\t\t</td>\n\t\t\t<td>\n\t\t\t\t<div\n\t\t\t\t\tdojoAttachPoint=\"maxnodes\"\n\t\t\t\t\tdojoAttachEvent=\"onChange:checkNodeNumbers\"\n\t\t\t\t\tclass=\"maxnodes\"\n\t\t\t\t\tdojoType=\"dijit.form.NumberTextBox\"\n\t\t\t\t\tvalue=\"5\"\n\t\t\t\t\tconstraints=\"{min:1,max:99999,places:0}\"\n\t\t\t\t\tmaxlength=\"5\" \n\t\t\t\t\tpromptMessage=\"Maximum nodes: from 1 to 99999\" \n\t\t\t\t\tinvalidMessage=\"Maximum nodes: from 1 to 99999\"\n\t\t\t\t\ttooltipPosition=\"below\"\n\t\t\t\t</div>\n\t\t\t</td>\n\t\t</tr>\n\n\t\t<tr>\n\t\t\t<td align=\"center\" colspan=\"3\">\n\t\t\t\t<table width=\"100%\">\n\t\t\t\t\t<tr class=\"headerRow\">\n\t\t\t\t\t\t<td\n\t\t\t\t\t\ttitle=\"AMI ID of the Starcluster image used for all cluster nodes (The base x86_64 StarCluster AMI is ami-d1c42db8)\">AMI ID</td>\n\t\t\t\t\t\t<td>AMI Name</td>\n\t\t\t\t\t\t<td>AMI Type</td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td align=\"center\" dojoAttachPoint=\"amiidContainer\">\n\t\t\t\t\t\t\t<input\n\t\t\t\t\t\t\t\tdojoAttachPoint=\"amiid\"\n\t\t\t\t\t\t\t\tdojoAttachEvent=\"onChange:setAmiInfo\"\n\t\t\t\t\t\t\t\tdojoType=\"dijit.form.ComboBox\"\n\t\t\t\t\t\t\t\tclass=\"amiid\"\n\t\t\t\t\t\t\t\ttype=\"text\"\n\t\t\t\t\t\t\t\tdojoType=\"dijit.form.ValidationTextBox\"\n\t\t\t\t\t\t\t\tregExp=\"^ami-[A-F0-9a-f]{8}$\"\n\t\t\t\t\t\t\t\tmaxlength=\"12\" \n\t\t\t\t\t\t\t\tpromptMessage=\"Amazon Machine Image (AMI) identifier. Must be 'ami-XXXXXXXX' in hexadecimal (a-f0-09), e.g. ami-d1c42db8\" \n\t\t\t\t\t\t\t\tinvalidMessage=\"Amazon Machine Image (AMI) identifier. Must be 'ami-XXXXXXXX' in hexadecimal (a-f0-09), e.g., ami-d1c42db8\" \n\t\t\t\t\t\t\t\ttooltipPosition=\"below\"\n\t\t\t\t\t\t\t\twrap=\"off\"\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t</td>\n\t\t\t\t\t\t<td\n\t\t\t\t\t\t\tdojoAttachPoint=\"aminame\"\n\t\t\t\t\t\t\tclass=\"aminame\"\n\t\t\t\t\t\t>\n\t\t\t\t\t\t</td>\n\t\t\t\t\t\t<td\n\t\t\t\t\t\t\tdojoAttachPoint=\"amitype\"\n\t\t\t\t\t\t\tclass=\"amitype\"\n\t\t\t\t\t\t>\n\t\t\t\t\t\t</td>\n\t\t\t\t\t</tr>\n\n\t\t\t\t\t<tr class=\"headerRow\">\n\t\t\t\t\t\t<td class=\"info\">Instance Type\n\t\t\t\t\t\t\t<img src=\"plugins/core/images/info-16.png\" onClick=\"window.open('http://aws.amazon.com/ec2/instance-types', '_blank')\"></img>\n\t\t\t\t\t\t</td>\n\t\t\t\t\t\t<td class=\"info\">Region\n\t\t\t\t\t\t\t<img src=\"plugins/core/images/info-16.png\" onClick=\"window.open('http://docs.amazonwebservices.com/AWSEC2/latest/UserGuide/index.html?using-regions-availability-zones.html', '_blank')\"></img>\n\t\t\t\t\t\t</td>\n\t\t\t\t\t\t<td>Availability Zone</td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td align=\"center\" >\n\t\t\t\t\t\t\t<select\n\t\t\t\t\t\t\t\tdojoAttachPoint=\"instancetype\"\n\t\t\t\t\t\t\t\tdojoType=\"dijit.form.ComboBox\"\n\t\t\t\t\t\t\t\tclass=\"instancetype\">\n\t\t\t\t\t\t\t\t<option value=\"t1.micro\">t1.micro</option> \n\t\t\t\t\t\t\t\t<option value=\"m1.small\">m1.small</option>\n\t\t\t\t\t\t\t\t<option value=\"m1.large\">m1.large</option>\n\t\t\t\t\t\t\t\t<option value=\"m1.xlarge\">m1.xlarge</option>\n\t\t\t\t\t\t\t\t<option value=\"m1.xlarge\">m2.xlarge</option>\n\t\t\t\t\t\t\t\t<option value=\"m2.4xlarge\">m2.2xlarge</option>\n\t\t\t\t\t\t\t\t<option value=\"m2.4xlarge\">m2.4xlarge</option>\n\t\t\t\t\t\t\t\t<option value=\"c1.medium\">c1.medium</option>\n\t\t\t\t\t\t\t\t<option value=\"c1.xlarge\">c1.xlarge</option>\n\t\t\t\t\t\t\t\t<option value=\"c1.xlarge\">cc1.4xlarge</option>\n\t\t\t\t\t\t\t\t<option value=\"c1.xlarge\">cg1.4xlarge</option>\n\t\t\t\t\t\t\t</select>\n\t\t\t\t\t\t</td>\n\t\t\t\t\t\t<td align=\"center\" >\n\t\t\t\t\t\t\t<select\n\t\t\t\t\t\t\t\tdojoAttachPoint=\"region\"\n\t\t\t\t\t\t\t\tdojoType=\"dijit.form.ComboBox\"\n\t\t\t                    dojoAttachEvent=\"onChange:setAvailzoneCombo\"\n\t\t\t\t\t\t\t\tclass=\"region\">\n\t\t\t\t\t\t\t\t<option value=\"us-east-1\">us-east-1</option> \n\t\t\t\t\t\t\t\t<option value=\"us-west-1\">us-west-1</option> \n\t\t\t\t\t\t\t\t<option value=\"eu-west-1\">eu-west-1</option> \n\t\t\t\t\t\t\t\t<option value=\"ap-northeast-1\">ap-northeast-1</option> \n\t\t\t\t\t\t\t\t<option value=\"ap-southeast-1\">ap-southeast-1</option> \n\t\t\t\t\t\t\t</select>\n\t\t\t\t\t\t</td>\n\t\t\t\t\t\t<td align=\"center\">\n\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\tdojoAttachPoint=\"availzone\"\n\t\t\t\t\t\t\t\tdojoType=\"dijit.form.ComboBox\"\n\t\t\t\t\t\t\t\tclass=\"availzone\"\n\t\t\t\t\t\t\t\ttype=\"text\"\n\t\t\t\t\t\t\t\tpopupClass=\"clusters availzone dijitReset dijitMenu\"\n\t\t\t\t\t\t\t\tautocomplete=\"true\"\n\t\t\t\t\t\t\t\thasDownArrow=\"true\"\n\t\t\t\t\t\t\t\tdisabled=\"false\"\n\t\t\t\t\t\t\t\tstyle=\"width: 150px;\">\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t\n\t\t\t\t</table>\n\t\t\t</td>\n\t\t</tr>\n\n\t\t<tr class=\"headerRow\" width=\"95%\" height=\"8px\">\n\t\t\t<td colspan=\"3\">Description</td>\n\t\t</tr>\n\n\t\t<tr width=\"95%\" >\n\t\t\t<td align=\"center\" colspan=\"3\">\n\t\t\t\t<textarea\n\t\t\t\t\tspellcheck=\"false\"\n\t\t\t\t\tdojoAttachPoint=\"description\"\n\t\t\t\t\tclass=\"description\"\n\t\t\t\t\tcols=\"40\"\n\t\t\t\t\trows=\"1\"\n\t\t\t\t\ttitle=\"A brief description of the cluster group\"\n\t\t\t\t>Description</textarea>\n\t\t\t</td>\n\t\t</tr>\n\n\t\t<tr valign=\"top\" width=\"95%\">\n\t\t\t<td colspan=\"3\" width=\"95%\">\n\t\t\t\t<div class=\"label\"> Clusters </div>\n\t\t\t\t<div\n\t\t\t\t\tdojoAttachPoint=\"dragSourceNode\"\n\t\t\t\t\tclass=\"dragSource\"\n\t\t\t\t\tstyle=\"height: 350px; width: 95%;\"\n\t\t\t\t>\n\t\t\t\t</div>\n\t\t\t</td>\n\t\t</tr>\n\n\t\t<tr align=\"center\">\n\t\t\t<td colspan=\"3\" align=\"center\">\n\n\t\t\t\t<!-- TRASH CONTAINER -->\n\t\t\t\t<div\n\t\t\t\t\tdojoAttachPoint=\"trashContainer\"\n\t\t\t\t\tclass=\"trash\"\n\t\t\t\t\tstyle=\"height: 60px; width: 150px; align: center;\" \n\t\t\t\t\t>\n\t\t\t\t\t<div\n\t\t\t\t\t\tdojoAttachPoint=\"trashIcon\"\n\t\t\t\t\t\tclass=\"trashIcon\"\n\t\t\t\t\t\tstyle=\"height: 60px; width: 60px;\"\n\t\t\t\t\t\t>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</td>\n\t\t</tr>\n\t</table>\n\n\n\t</div>\n\t<!-- END clusters TAB -->\n\t\n</div> \n\n\n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

//addingUser STATE
addingUser : false,

// OR USE @import IN HTML TEMPLATE
cssFiles : [ dojo.moduleUrl("plugins") + "/cloud/css/clusters.css"],

// PARENT WIDGET
parentWidget : null,

instancetypeslots: {
	"t1.micro"	:	 1,
	"m1.small"	:  	 1,
	"m1.large"	:	 4,
	"m1.xlarge"	:	 8,
	"m2.xlarge"	:	 7,
	"m2.2xlarge":	13,
	"m2.4xlarge":	26,
	"c1.medium"	:	 5,
	"c1.xlarge"	:	20,
	"cc1.4xlarge":	34,
	"cg1.4xlarge":	34
},

formInputs : {
// FORM INPUTS AND TYPES (word|phrase)
	cluster		:	"word",
	minnodes	:	"number",
	maxnodes	:	"number",
	instancetype:	"combo",
	amiid		:	"word",
	availzone	:	"word",
	description	:	"phrase"
},

defaultInputs : {
// DEFAULT INPUTS
	cluster 	: 	"myCluster",
	minnodes	:	"minNodes",
	maxnodes	:	"maxNodes",
	instancetype:	"instanceType", 
	amiid		:	"AMI ID",
	description	:	"Description",
	notes		:	"Notes"
},

requiredInputs : {
// REQUIRED INPUTS CANNOT BE ''
// combo INPUTS ARE AUTOMATICALLY NOT ''
	cluster 	: 1,
	minnodes 	: 1, 
	maxnodes	: 1, 
	amiid		: 1
},

invalidInputs : {
// THESE INPUTS ARE INVALID
	cluster 	: 	"myCluster",
	minnodes	:	"",
	maxnodes	:	"",
	amiid		:	"",
	description	:	"Description"
},

dataFields : [
	"cluster"
],

rowClass : "plugins.cloud.ClusterRow",

avatarType : "parameters",

avatarItems: [ "cluster", "minnodes", "maxnodes", "instancetype", "description"],

/////}}}
// STARTUP METHODS
constructor : function(args) {
	////////console.log("Clusters.constructor     plugins.cloud.Clusters.constructor");			
	// GET INFO FROM ARGS
	this.parentWidget = args.parentWidget;
	this.clusters = args.parentWidget.clusters;

	// LOAD CSS
	this.loadCSS();
},
postCreate : function() {
	////////console.log("Controller.postCreate    plugins.cloud.Controller.postCreate()");
	this.startup();
},
startup : function () {
	console.log("Clusters.startup    plugins.cloud.Clusters.startup()");
	console.log("Clusters.startup    this: " + this);

	// COMPLETE CONSTRUCTION OF OBJECT
	this.inherited(arguments);	 

	// ADD ADMIN TAB TO TAB CONTAINER		
	this.tabContainer.addChild(this.clustersTab);
	this.tabContainer.selectChild(this.clustersTab);

	// SET NEW PARAMETER FORM
	this.setForm();

	// SET AMI COMBO BOX
	this.setAmiCombo();

	// SET DRAG SOURCE - LIST OF CLUSTERS
	this.setDragSource();

	//console.log("Clusters.startup    BEFORE this.setTrash(this.dataFields), I.E., plugins.form.DndTrash.startup()");
	this.setTrash(this.dataFields);	
	//console.log("Clusters.startup    AFTER this.setTrash(this.dataFields), I.E., plugins.form.DndTrash.startup()");

	// SUBSCRIBE TO UPDATES
	Agua.updater.subscribe(this, "updateClusters");

	// SUBSCRIBE TO UPDATES
	Agua.updater.subscribe(this, "updateAmis");
},
updateClusters : function (args) {
// RELOAD THE COMBO AND DRAG SOURCE AFTER CHANGES
// TO DATA IN OTHER TABS

	console.log("Cluster.updateClusters    args: " );
	console.dir(args);
	
	// SET DRAG SOURCE
	if ( args == null || args.reload != false ) {
		////console.log("Cluster.updateClusters    Calling setDragSource()");
		this.setDragSource();
	}
},
updateAmis : function (args) {
// RELOAD THE COMBO AND DRAG SOURCE AFTER CHANGES
// TO DATA IN OTHER TABS
	console.log("Amis.updateAmis(args)");
	console.log("Amis.updateAmis    args: " );
	console.dir(args);
	
	if ( args.originator == this )
	{
		if ( args.reload == false )	return;
	}

	console.log("Amis.updateAmis    Doing this.setAmiCombo()");

	// SET AMI COMBO BOX
	this.setAmiCombo();
},
setForm : function () {
// SET LISTENERS TO ACTIVATED SAVE BUTTON AND TO CLEAR DEFAULT TEXT
// WHEN INPUTS ARE CLICKED ON
	////console.log("Clusters.setForm    plugins.cloud.Clusters.setForm()");

	// SET ADD PARAMETER ONCLICK
	dojo.connect(this.addClusterButton, "onclick", dojo.hitch(this, "newCluster", null, null));	

	// SET CLEARVALUE ON CLUSTER VALIDATION TEXT BOX
	dojo.connect(this.cluster, "onFocus", dojo.hitch(this, "clearValue", this.cluster, this.invalidInputs["cluster"]));

	// SET AVAILABILITY ZONE COMBO
	var fakeEvent = {
		target: {
			selectedIndex: 0,
			options : [ {text: "us-east-1"} ]
		}
	};
	this.setAvailzoneCombo(fakeEvent);	

	// SET TRASH, ETC.
	this.inherited(arguments);
},
setAmiInfo : function (event) {
	console.log("Clusters.setAmiInfo     plugins.cloud.Clusters.setAmiInfo(event)");
	//console.log("Clusters.setAmiInfo     event.target: " + event.target);

	var amiid = this.amiid.get('value');
	console.log("Clusters.setAmiInfo     amiid: " + amiid);

	var amiObject = Agua.getAmiObjectById(amiid);
	console.log("Clusters.setAmiInfo     amiObject: " + dojo.toJson(amiObject));

	this.aminame.innerHTML = amiObject.aminame;
	this.amitype.innerHTML = amiObject.amitype;

	this.amiid.focusNode.title = amiObject.description;
	this.amiidContainer.title = amiObject.description;
	this.aminame.title = amiObject.description;
	this.amitype.title = amiObject.description;
},
setAvailzoneCombo : function (event) {
	////console.log("Clusters.setAvailzoneCombo     plugins.cloud.Clusters.setAvailzoneCombo(event)");
	////console.log("Clusters.setAvailzoneCombo     event.target: " + event.target);
	var region = this.getSelectedValue(event.target);
	////console.log("Clusters.setAvailzoneCombo     region: " + region);

	var availzones = Agua.getAvailzonesByRegion(region);	
	////console.log("Clusters.setAvailzoneCombo     availzones: " + dojo.toJson(availzones));
	
	// SET STORE
	var data = {identifier: "name", items: []};
	for ( var i = 0; i < availzones.length; i++ )
	{
		data.items[i] = { name: availzones[i]	};
	}
	////console.log("Clusters.setAvailzoneCombo     data: " + dojo.toJson(data));
	var store = new dojo.data.ItemFileWriteStore({	data: data	});

	//this.availzone.popupClass = "groupsources groupCombo dijitReset dijitMenu";
	//this.availzone.wrapperClass = "groupsources dijitPopup";
	//this.availzone.itemHeight = 30;
	
	// SET COMBO
	this.availzone.store = store;
	this.availzone.startup();
	////console.log("Clusters.setAvailzoneCombo     AFTER this.availzone.startup()");

	// SET COMBO VALUE
	var firstValue = availzones[0];
	this.availzone.setValue(firstValue);
	////console.log("Clusters.setAvailzoneCombo     AFTER this.availzone.setValue(firstValue)");
},
getItemsArray : function () {
	var amis = Agua.getAmis();	
	console.log("Clusters.getItemsArray     amis: " + dojo.toJson(amis));
	return this.hashArrayKeyToArray(amis, ["amiid"]); 	
},
setAmiCombo : function () {
	console.log("Clusters.setAmiCombo     plugins.cloud.Clusters.setAmiCombo()");

	var amis = this.getItemsArray();	
	console.log("Clusters.setAmiCombo     amis: " + dojo.toJson(amis));
	
	// SET STORE
	var data = {identifier: "name", items: []};
	for ( var i = 0; i < amis.length; i++ )
	{
		data.items[i] = { name: amis[i]	};
	}
	console.log("Clusters.setAmiCombo     data: " + dojo.toJson(data));
	var store = new dojo.data.ItemFileWriteStore({	data: data	});

	// SET COMBO
	this.amiid.store = store;
	this.amiid.startup();
	console.log("Clusters.setAmiCombo     AFTER this.amiid.startup()");

	// SET COMBO VALUE
	var firstValue = amis[0];
	this.amiid.setValue(firstValue);
	console.log("Clusters.setAmiCombo     AFTER this.amiid.setValue(firstValue)");
},
getItemArray : function () {
// GET A LIST OF DATA ITEMS - ONE FOR EACH ROW
	return Agua.getClusters();
},
setDragSource : function () {
// SET THE DRAG SOURCE WITH PARAMETER OBJECTS
	console.log("Clusters.setDragSource     plugins.cloud.Clusters.setDragSource()");

	// GENERATE DND GROUP
	if ( this.dragSource == null ) {
		this.initialiseDragSource();
		this.setDragSourceCreator();
	}

	// DELETE EXISTING CONTENT
	this.clearDragSource();

	// INITIALISE USER INFO
	var itemArray = this.getItemArray();
	//console.log("Clusters.setDragSource     itemArray: " + dojo.toJson(itemArray));

	// REMOVE USERNAME FROM BEGINNING OF CLUSTER NAME
	var regex = Agua.cookie('username') + "-";
	for ( var i = 0; i < itemArray.length; i++ )
	{
		itemArray[i].cluster = itemArray[i].cluster.replace(regex, '');
	}

	itemArray = this.sortHasharray(itemArray, 'cluster');
	//console.log("Clusters.setDragSource    itemArray: " + dojo.toJson(itemArray));
	
	// CHECK IF itemArray IS NULL
	if ( itemArray == null )
	{
		//console.log("Clusters.setDragSource     itemArray is null or empty. Returning.");
		return;
	}

	this.loadDragItems(itemArray);
},
newCluster : function (inputs, reload) {
//	SAVE A PARAMETER TO Agua.parameters AND TO REMOTE DATABASE
	////console.log("Clusters.newCluster    plugins.cloud.Clusters.newCluster(inputs, reload)");
	//////console.log("Clusters.newCluster    inputs: " + dojo.toJson(inputs));
	//////console.log("Clusters.newCluster    reload: ");
	//////console.dir(reload);
	
	if ( this.saving == true )	return;
	this.saving = true;

	if ( inputs == null )
	{
		inputs = this.getFormInputs(this);
		////console.log("Clusters.newCluster    inputs: ");
		////console.dir(inputs);
		
		// RETURN IF INPUTS ARE NULL OR INVALID
		
		if ( inputs == null )
		{
			this.saving = false;
			return;
		}
	}
	inputs.cluster = Agua.getClusterLongName(inputs.cluster);
	//////console.log("Clusters.newCluster    inputs: " + dojo.toJson(inputs));
	Agua.newCluster(inputs);
	
	this.saving = false;

	// RELOAD RELEVANT DISPLAYS
	Agua.updater.update("updateClusters", reload);

}, // Clusters.newCluster
saveInputs : function (inputs, reload) {
//	SAVE A PARAMETER TO Agua.parameters AND TO REMOTE DATABASE
	////console.log("Clusters.saveInputs    plugins.cloud.Clusters.saveInputs(inputs, reload)");
	//////console.log("Clusters.saveInputs    inputs: " + dojo.toJson(inputs));
	//////console.log("Clusters.saveInputs    reload: ");
	//////console.dir(reload);
	
	if ( this.saving == true )	return;
	this.saving = true;

	if ( inputs == null )
	{
		inputs = this.getFormInputs(this);
		////console.log("Clusters.saveInputs    inputs: ");
		////console.dir(inputs);
		
		// RETURN IF INPUTS ARE NULL OR INVALID
		
		if ( inputs == null )
		{
			this.saving = false;
			return;
		}
	}
	inputs.cluster = Agua.getClusterLongName(inputs.cluster);
	//////console.log("Clusters.saveInputs    inputs: " + dojo.toJson(inputs));
	Agua.addCluster(inputs);
	
	this.saving = false;

	// RELOAD RELEVANT DISPLAYS
	Agua.updater.update("updateClusters", reload);

}, // Clusters.saveInputs
deleteItem : function (clusterObject) {
	////console.log("Clusters.deleteItem    plugins.cloud.Clusters.deleteItem(name)");
	////console.log("Clusters.deleteItem    clusterObject: " + dojo.toJson(clusterObject));

	// REMOVING PARAMETER FROM Agua.parameters
	clusterObject.cluster = Agua.cookie('username') + "-" + clusterObject.cluster;
	
	Agua.removeCluster(clusterObject);
	
	// RELOAD RELEVANT DISPLAYS
	Agua.updater.update("updateClusters", {originator: this, reload: false});

	// RELOAD RELEVANT DISPLAYS
	Agua.updater.update("updateAmis", {originator: this, reload: false});

}, // Clusters.deleteItem
checkEnter : function (event) {
	////console.log("Cluster.checkEnter    event.keyCode: " + event.keyCode);

	if (event.keyCode == dojo.keys.ENTER)
	{
		this.saveInputs();
		dojo.stopEvent(event);
	}
},
checkEnterNodes : function (event) {
	////console.log("Clusters.checkEnterNodes    event.keyCode: " + event.keyCode);

	if (event.keyCode == dojo.keys.ENTER)
	{
		dojo.stopEvent(event);

		////console.log("Clusters.checkEnterNodes    setting document.body.focus()");
		document.body.focus();

		this.checkNodeNumbers();

		this.saveInputs();
	}
},
checkNodeNumbers : function () {
// SET MIN NODES VALUE TO SENSIBLE NUMBER 
	////console.log("Clusters.checkNodeNumbers     plugins.cloud.Clusters.checkNodeNumbers()");
	//////console.log("Clusters.checkNodeNumbers     this.minnodes.get('value'): " + this.minnodes.get('value'));
	//////console.log("Clusters.checkNodeNumbers     this.maxnodes.get('value'): " + this.maxnodes.get('value'));
	
	if (this.minnodes.value > this.maxnodes.value )
	{
		////console.log("Clusters.checkNodeNumbers     this.minnodes.value > this.maxnodes.value");
		this.minnodes.set('value', this.maxnodes.value);
	}
}

}); // plugins.cloud.Clusters


}

if(!dojo._hasResource["plugins.cloud.Controller"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.cloud.Controller"] = true;
dojo.provide("plugins.cloud.Controller");

// OBJECT:  plugins.cloud.Controller
// PURPOSE: GENERATE AND MANAGE Admin PANES

// CONTAINER


// GLOBAL ADMIN CONTROLLER VARIABLE
var adminController;

// HAS


dojo.declare( "plugins.cloud.Controller",
	[ dijit._Widget, dijit._Templated ],
{
// PANE ID 
paneId : null,

//Path to the template of this widget. 
templateString:"<div dojoAttachPoint=\"containerNode\" class=\"cloud\">\n    <button\n        dojoType=\"dijit.form.Button\"\n        dojoAttachPoint=\"menuButton\"\n        class=\"menuButton\"\n        iconClass=\"cloudIcon\"\n        type=\"button\"\n        label=\"Cloud\"\n        ></button>\n</div>\n        \n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

// TAB PANES
tabPanes : [],

// INPUTS TO PASS TO TAB INSTANCES ON INSTANTIATION
inputs : null,

////}}}

// CONSTRUCTOR	
constructor : function(args) {

	console.log("admin.Controller.constructor    args:");
	console.dir({args:args});

	// SET INPUTS IF PRESENT
	if ( args.inputs )
		this.inputs = args.inputs;
	
	// LOAD CSS FOR BUTTON
	this.loadCSS();		
},
postCreate : function() {
	this.startup();
},
startup : function () {
	////console.log("admin.Controller.startup    plugins.cloud.Controller.startup()");

	this.inherited(arguments);

	// ADD MENU BUTTON TO TOOLBAR
	Agua.toolbar.addChild(this.menuButton);
	
	// SET BUTTON PARENT WIDGET
	this.menuButton.parentWidget = this;
	
	// SET ADMIN BUTTON LISTENER
	var listener = dojo.connect(this.menuButton, "onClick", this, "createTab");
},
createTab : function () {
	
	// GET INPUTS
	var inputs = this.inputs;
	
	// CREATE WIDGET	
	var widget;
	if ( ! inputs )
		widget = new plugins.cloud.Cloud({});
	else
		widget = new plugins.cloud.Cloud({inputs:inputs});
	
	console.log("admin.Controller.createTab    Doing this.tabPanes.push(widget)");
	this.tabPanes.push(widget);

	// ADD TO _supportingWidgets FOR INCLUSION IN DESTROY	
	this._supportingWidgets.push(widget);
},
createMenu : function () {
// ADD PROGRAMMATIC CONTEXT MENU
	var dynamicMenu = new dijit.Menu( { id: "admin" + this.paneId + 'dynamicMenuPopup'} );

	// ADD MENU TITLE
	dynamicMenu.addChild(new dijit.MenuItem( { label:"Application Menu", disabled:false} ));
	dynamicMenu.addChild(new dijit.MenuSeparator());

	//// ONE OF FOUR WAYS TO DO MENU CALLBACK WITH ACCESS TO THE MENU ITEM AND THE CURRENT TARGET 	
	// 4. dojo.connect CALL
	//	REQUIRES:
	//		ADDED menu.currentTarget SLOT TO dijit.menu
	var mItem1 = new dijit.MenuItem(
		{
			id: "admin" + this.paneId + "remove",
			label: "Remove",
			disabled: false
		}
	);
	dynamicMenu.addChild(mItem1);
	dojo.connect(mItem1, "onClick", function()
		{
			//////////console.log("admin.Controller.++++ dojo.connect mItem1, onClick");	
			var parentNode = dynamicMenu.currentTarget.parentNode;
			parentNode.removeChild(dynamicMenu.currentTarget);	
		}
	);

	// SEPARATOR
	dynamicMenu.addChild(new dijit.MenuSeparator());

	//	ADD run MENU ITEM
	var mItem2 = new dijit.MenuItem(
		{
			id: "admin" + this.paneId + "run",
			label: "Run",
			disabled: false
		}
	);
	dynamicMenu.addChild(mItem2);	

	dojo.connect(mItem2, "onClick", function()
		{
			////////console.log("admin.Controller.++++ 'Run' menu item onClick");
			var currentTarget = dynamicMenu.currentTarget; 
			var adminList = currentTarget.parentNode;
		}
	);
		
	return dynamicMenu;
},
loadCSS : function() {
	// LOAD CSS
	var cssFiles = [ "plugins/cloud/css/controller.css" ];
	for ( var i in cssFiles )
	{
		var cssFile = cssFiles[i];
		var cssNode = document.createElement('link');
		cssNode.type = 'text/css';
		cssNode.rel = 'stylesheet';
		cssNode.href = cssFile;
		cssNode.media = 'screen';
		document.getElementsByTagName("head")[0].appendChild(cssNode);
	}
}

}); // end of Controller

dojo.addOnLoad(
	function() {
		//// CREATE TAB
		////console.log("admin.Controller.addOnLoad    BEFORE createTab");
		//Agua.controllers["admin"].createTab();		
		////console.log("admin.Controller.addOnLoad    AFTER createTab");
	}
);


}

if(!dojo._hasResource["plugins.cloud.Hub"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.cloud.Hub"] = true;
dojo.provide("plugins.cloud.Hub");

// ALLOW USER TO MANAGE HUB ACCESS


//
//
//
//
//



dojo.declare("plugins.cloud.Hub",
	[ dijit._Widget, dijit._Templated, plugins.core.Common ], {

//Path to the template of this widget. 
templateString:"<div dojoattachpoint=\"containerNode\">\n\n\t<!-- settings TAB -->\n\t<div\n\t\tdojoAttachPoint=\"mainTab\"\n\t\tclass=\"hub\"\n\t\tdojoType=\"dijit.layout.ContentPane\"\n\t\ttitle=\"Hub\"\n\t\tstyle=\"height: 700px; max-height: auto !important; width: 390px !important; padding: 0 !important;\"\n\t\t>\n\n\t\t<table width=\"100%\">\n\t\t\t<tr valign=\"top\" width=\"100%\">\n\t\t\t\t<td colspan=\"2\" class=\"tabTitle\" align=\"center\"> GitHub </td>\n\t\t\t</tr>\n\t\t\t\n\t\t\t<tr valign=\"top\" width=\"95%\">\n\t\t\t\t<td width=\"95%\">\n\t\t\t\t\t<div class=\"label\"> GitHub Account Info </div>\n\t\t\t\t\t<div\n\t\t\t\t\t\tclass=\"subPane\"\n\t\t\t\t\t>\n\n\t\t\t\t\t<table width=\"100%\">\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td\tdojoAttachPoint=\"addHubButton\"\n\t\t\t\t\t\t\t\tclass=\"addHubButton\"\n\t\t\t\t\t\t\t\tdojoAttachEvent=\"onclick:addHub\"\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\tSave\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td class=\"subLabel\">GitHub User ID</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t<input\n\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"login\"\n\t\t\t\t\t\t\t\t\tclass=\"login\"\n\t\t\t\t\t\t\t\t\tdojoType=\"dijit.form.ValidationTextBox\"\n\t\t\t\t\t\t\t\t\trequired=\"true\"\n\t\t\t\t\t\t\t\t\tmissingMessage=\"Please input your GitHub Login ID\"\n\t\t\t\t\t\t\t\t\tpromptMessage=\"Please input your GitHub Login ID\"\n\t\t\t\t\t\t\t\t\tvalue=\"\"\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td\tdojoAttachPoint=\"addTokenButton\"\n\t\t\t\t\t\t\t\tclass=\"addTokenButton\"\n\t\t\t\t\t\t\t\tdojoAttachEvent=\"onclick:toggleAddToken\"\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\tCreate GitHub Token\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t<tr dojoAttachPoint=\"addToken\"\n\t\t\t\t\t\t\tclass=\"addToken\"\n\t\t\t\t\t\t\twidth=\"100%\"\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<td width=\"10%\">\n\t\t\t\t\t\t\t\t<table class=\"subPane\" width=\"100%\">\n\t\t\t\t\t\t\t\t\t<tr align=\"center\">\n\t\t\t\t\t\t\t\t\t\t<td class=\"subSubLabel\"\n\t\t\t\t\t\t\t\t\t\t\ttitle=\"Enter GitHub password. Password will not be stored on server\">\n\t\t\t\t\t\t\t\t\t\t\tGitHub password\n\t\t\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t\t\t\t<input\n\t\t\t\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"password\"\n\t\t\t\t\t\t\t\t\t\t\t\tclass=\"password\"\n\t\t\t\t\t\t\t\t\t\t\t\ttype=\"password\"\n\t\t\t\t\t\t\t\t\t\t\t\tvalue=\"\"\n\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t\t</tr>\n\n\t\t\t\t\t\t\t\t\t<tr align=\"center\">\n\n\t\t\t\t\t\t\t\t\t\t<td\n\t\t\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"goButton\"\n\t\t\t\t\t\t\t\t\t\t\tclass=\"goButton\"\n\t\t\t\t\t\t\t\t\t\t\tdojoAttachEvent=\"onclick:addHubToken\"\n\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\tGenerate Token\n\t\t\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t</table>\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td class=\"subLabel\">GitHub Token</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t<input\n\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"token\"\n\t\t\t\t\t\t\t\t\tclass=\"token\"\n\t\t\t\t\t\t\t\t\tdojoType=\"dijit.form.ValidationTextBox\"\n\t\t\t\t\t\t\t\t\ttype=\"text\"\n\t\t\t\t\t\t\t\t\tmaxlength=\"40\"\n\t\t\t\t\t\t\t\t\tuppercase=\"false\"\n\t\t\t\t\t\t\t\t\tregExp=\"[a-z0-9]{40}\"\n\t\t\t\t\t\t\t\t\tinvalidMessage=\"GitHub OAuth access token - 40 characters: letters or lowercase numbers\"\n\t\t\t\t\t\t\t\t\tpromptMessage=\"GitHub OAuth access token - 40 characters: letters or lowercase numbers\"\n\t\t\t\t\t\t\t\t\tvalue=\"\"\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td\tdojoAttachPoint=\"addHubCertificateButton\"\n\t\t\t\t\t\t\t\tclass=\"addHubCertificateButton\"\n\t\t\t\t\t\t\t\tdojoAttachEvent=\"onclick:addHubCertificate\"\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\tCreate Public Certificate\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td >\n\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"publiccert\"\n\t\t\t\t\t\t\t\t\tclass=\"publiccert\"\n\t\t\t\t\t\t\t\t></div>\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t</tr>\n\n\t\t\t\t\t</table>\n\n\t\n\t\t\t\t\t</div>\n\t\t\t\t</td>\n\t\t\t</tr>\n\t\t\n\t\t</table>\n\n\t</div>\n\t<!-- END settings TAB -->\n\t\n</div> \n\n\n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

//addingUser STATE
addingUser : false,

// OR USE @import IN HTML TEMPLATE
cssFiles : [
	dojo.moduleUrl("plugins", "cloud/css/hub.css"),
	//dojo.moduleUrl("dojo", "/tests/dnd/dndDefault.css")
],

// PARENT WIDGET
parentWidget : null,

/////}}} 
constructor : function(args)  {
	// GET INFO FROM ARGS
	this.parentWidget = args.parentWidget;
	this.core = args.parentWidget.core;

	// LOAD CSS
	this.loadCSS();		
},
postCreate : function() {
	this.startup();
},
startup : function () {
	//console.log("Hub.startup    plugins.cloud.GroupHub.startup()");

	// COMPLETE CONSTRUCTION OF OBJECT
	this.inherited(arguments);	 

	// ADD ADMIN TAB TO TAB CONTAINER		
	this.tabContainer.addChild(this.mainTab);
	this.tabContainer.selectChild(this.mainTab);

	// SUBSCRIBE TO UPDATES
	Agua.updater.subscribe(this, "updateSyncWorkflows");
	Agua.updater.subscribe(this, "updateSyncApps");

	// SET DRAG SOURCE - LIST OF USERS
	this.initialise();
},
updateSyncApps : function (args) {
	console.warn("Hub.updateSyncApps    args:");
	console.dir({args:args});

	// DO NOTHING
},
updateSyncWorkflows : function (args) {
	console.warn("Hub.updateSyncWorkflows    args:");
	console.dir({args:args});

	// DO NOTHING
},
initialise : function () {
	// INITIALISE AWS SETTINGS
	var hub = Agua.getHub();
	console.log("Hub.initialiseHub     hub: ");
	console.dir({hub:hub});

	hub.login = hub.login || "";
	this.login.set('value', hub.login);
	hub.token = hub.token || "";
	this.token.set('value', hub.token);
	hub.publiccert = hub.publiccert || "";
	this.publiccert.innerHTML = hub.publiccert;
},
// SAVE TO REMOTE
addHub : function (event) {
	console.log("Hub.addHub    plugins.cloud.Hub.addHub(event)");

	if ( this.addingHub == true ) {
		console.log("Hub.addHub    this.addingHub: " + this.addingHub + ". Returning.");
		return;
	}
	this.addingHub = true;
	
	// VALIDATE INPUTS
	var inputs = this.validateInputs(["login", "token"]);
	if ( ! inputs ) {
		this.addingHub = false;
		return;
	}
	
	var hub = {
		login: this.login.value,
		token: this.token.value,
		hubtype: "github"
	};
	
	var query = inputs;
	query.username 			= Agua.cookie('username');
	query.sessionid 		= Agua.cookie('sessionid');
	query.login				= this.login.value;
	query.token				= this.token.value;
	query.hubtype			= "github";
	query.mode 				= "addHub";
	console.log("Hub.addHub    query: ");
	console.dir({query:query});
	
	// SEND TO SERVER
	var url = Agua.cgiUrl + "workflow.cgi?";
	var thisObj = this;
	dojo.xhrPut(
		{
			url: url,
			contentType: "json",
			putData: dojo.toJson(query),
			timeout: 15000,
			load: function(response, ioArgs) {
				console.log("Hub.addHub    OK. response:")
				console.dir({response:response});

				thisObj.addingHub = false;
				
				// SET Agua.data.hub
				Agua.setHub(hub);

				// UPDATE SYNC WORKFLOWS
				Agua.updater.update("updateSyncWorkflows", { originator: thisObj, reload: false });
				Agua.updater.update("updateSyncWorkflows", { originator: thisObj, reload: false });
				
				// TOAST
				Agua.toast(response);
			},
			error: function(response, ioArgs) {
				thisObj.addingHub = false;
				console.log("Hub.addHub    ERROR. response:")
				console.dir({response:response});
				Agua.toast(response);
			}
		}
	);
},
// GENERATE PUBLIC CERTIFICATE FOR PRIVATE KEY USED TO ACCESS HUB
addHubCertificate : function () {
	console.log("Hub.addHubCertificate");
	if ( this.creatingCert ) {
		console.log("Hub.addHubCertificate    this.creatingCert: " + this.creatingCert + ". Returning.");
		return;
	}
	this.creatingCert = true;

	var aws = Agua.getAws();
	console.log("Hub.addHubCertificate    aws:");
	console.dir({aws:aws});
	if ( ! aws || ! aws.ec2privatekey ) {
		Agua.toastError("Please input EC2 Private Key in 'AWS' panel and press 'Save'");
		this.creatingToken = false;
		return;
	}

	var inputs = this.validateInputs(["login"]);
	if ( ! inputs ) {
		this.creatingCert = false;
		return;
	}
	
	var query = inputs;
	query.username 			= Agua.cookie('username');
	query.sessionid 		= Agua.cookie('sessionid');
	query.hubtype			= "github";
	query.mode 				= "addHubCertificate";
	console.log("Hub.addHubCertificate    query: ");
	console.dir({query:query});

	var url = Agua.cgiUrl + "workflow.cgi?";
	
	// SEND TO SERVER
	var thisObj = this;
	dojo.xhrPut(
		{
			url: url,
			contentType: "json",
			putData: dojo.toJson(query),
			handleAs: "json",
			load: function(response, ioArgs) {
				thisObj.creatingCert = false;	

				console.log("Hub.addHubCertificate    response:");
				console.dir({response:response});
				
				var publiccert = response.data.publiccert;
				console.log("Hub.addHubCertificate    publiccert:");
				console.dir({publiccert:publiccert});

				// SET publiccert IN hub DATA
				Agua.setHubCertificate(publiccert);
				
				// DISPLAY publiccert
				thisObj.publiccert.innerHTML = publiccert;
			},
			error: function(response, ioArgs) {

				thisObj.creatingCert = false;	

				console.log("Hub.addHubCertificate    ERROR response:");
				console.dir({response:response});
			}
		}
	);
},
// GENERATE OAUTH TOKEN FOR ACCESSING USER'S HUB ACCOUNT
toggleAddToken : function () {
	console.log("Hub.showCreateToken    this.password:" + this.password)
	console.log("Hub.showCreateToken    dojo.hasClass:" + dojo.hasClass(this.password, "showCreateToken"))

	if ( ! dojo.hasClass(this.addToken, "showAddToken") ) {
		this.addTokenButton.innerHTML = "Hide Panel";
		dojo.addClass(this.addToken, "showAddToken");
	}
	else {
		this.addTokenButton.innerHTML = "Add GitHub Token";
		dojo.removeClass(this.addToken, "showAddToken");
	}
},
// GENERATE OAUTH TOKEN FOR ACCESSING USER'S HUB ACCOUNT
closeAddToken : function () {
	console.log("Hub.closeAddToken    Removing class 'showAddToken'");
	this.addTokenButton.innerHTML = "Add GitHub Token";
	dojo.removeClass(this.addToken, "showAddToken");
},
addHubToken : function () {
	console.log("Hub.addHubToken");

	if ( this.addingToken == true ) {
		console.log("Hub.addHubToken    this.addingToken: " + this.addingToken + ". Returning.");
		return;
	}
	this.addingToken = true;

	var inputs = this.validateInputs(["login", "password"]);
	if ( ! inputs ) {
		this.addingToken = false;
		return;
	}
	
	var query = inputs;
	query.username 			= Agua.cookie('username');
	query.sessionid 		= Agua.cookie('sessionid');
	query.hubtype			= "github";
	query.mode 				= "addHubToken";
	console.log("Hub.addHubToken    query: ");
	console.dir({query:query});

	var url = Agua.cgiUrl + "workflow.cgi?";
	
	// SEND TO SERVER
	var thisObj = this;
	dojo.xhrPut(
		{
			url: url,
			contentType: "json",
			putData: dojo.toJson(query),
			handleAs: "json",
			load: function(response, ioArgs) {
				console.log("Hub.addHubToken    response:");
				console.dir({response:response});

				thisObj.addingToken = false;
				
				if ( response.error ) {
					Agua.toastError(response.error);
					return;
				}
				
				// CLOSE PANEL
				thisObj.closeAddToken();

				// DISPLAY PUBLIC CERT 
				var token = response.data.token;
				console.log("Hub.addHubToken    token:");
				console.dir({token:token});
				thisObj.token.set('value', token);
				
				// RELOAD RELEVANT DISPLAYS
				Agua.updater.update("updateSyncWorkflows");

			},
			error: function(response, ioArgs) {

				thisObj.addingToken = false;
	
				console.log("Hub.addHubToken    ERROR response:");
				console.dir({response:response});
				return response;
			}
		}
	);
},
// UTILS
validateInputs : function (keys) {
	console.log("Hub.validateInputs    keys: ");
	console.dir({keys:keys});
	var inputs = new Object;
	this.isValid = true;
	for ( var i = 0; i < keys.length; i++ ) {
		
		inputs[keys[i]] = this.verifyInput(keys[i]);
	}
	console.log("Hub.validateInputs    inputs: ");
	console.dir({inputs:inputs});

	if ( ! this.isValid ) 	return null;	
	return inputs;
},
verifyInput : function (input) {
	console.log("Hub.verifyInput    input: ");
	console.dir({this_input:this[input]});
	var value = this[input].value;
	value = this.cleanEdges(value);
	console.log("Hub.verifyInput    value: " + value);

	var className = this.getClassName(this[input]);
	console.log("Hub.verifyInput    className: " + className);
	if ( className ) {
		console.log("Hub.verifyInput    this[input].isValid(): " + this[input].isValid());
		if ( ! value || ! this[input].isValid() ) {
			console.log("Hub.verifyInput    input " + input + " value is empty. Adding class 'invalid'");
			dojo.addClass(this[input].domNode, 'invalid');
			this.isValid = false;
		}
		else {
			console.log("Hub.verifyInput    value is NOT empty. Removing class 'invalid'");
			dojo.removeClass(this[input].domNode, 'invalid');
			return value;
		}
	}
	else {
		if ( ! value ) {
			console.log("Hub.verifyInput    input " + input + " value is empty. Adding class 'invalid'");
			dojo.addClass(this[input], 'invalid');
			this.isValid = false;
			return null;
		}
		else {
			console.log("Hub.verifyInput    value is NOT empty. Removing class 'invalid'");
			dojo.removeClass(this[input], 'invalid');
			return value;
		}
	}
	
	return null;
},
clearInvalid : function () {
	var inputs = ["login", "token", ""]
	console.log("Hub.clearInvalid    input: ");
	console.dir({this_input:this[input]});
	var value = this[input].value;
	value = this.cleanEdges(value);
	console.log("Hub.clearInvalid    value: " + value);

	var className = this.getClassName(this[input]);
	console.log("Hub.clearInvalid    className: " + className);
	if ( className ) {
		console.log("Hub.clearInvalid    this[input].isValid(): " + this[input].isValid());
		if ( ! value || ! this[input].isValid() ) {
			console.log("Hub.clearInvalid    input " + input + " value is empty. Adding class 'invalid'");
			dojo.addClass(this[input].domNode, 'invalid');
			this.isValid = false;
		}
		else {
			console.log("Hub.clearInvalid    value is NOT empty. Removing class 'invalid'");
			dojo.removeClass(this[input].domNode, 'invalid');
			return value;
		}
	}
	else {
		if ( ! value ) {
			console.log("Hub.clearInvalid    input " + input + " value is empty. Adding class 'invalid'");
			dojo.addClass(this[input], 'invalid');
			this.isValid = false;
			return null;
		}
		else {
			console.log("Hub.clearInvalid    value is NOT empty. Removing class 'invalid'");
			dojo.removeClass(this[input], 'invalid');
			return value;
		}
	}
	
	return null;
},
cleanEdges : function (string ) {
// REMOVE WHITESPACE FROM EDGES OF TEXT
	string = string.toString();
	if ( string == null || ! string.replace)
		return null;
	string = string.replace(/^\s+/, '');
	string = string.replace(/\s+$/, '');

	return string;
}
}); // plugins.cloud.Hub


}

if(!dojo._hasResource["plugins.dijit.form.ValidationTextBox"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.dijit.form.ValidationTextBox"] = true;
dojo.provide("plugins.dijit.form.ValidationTextBox");



dojo.declare("plugins.dijit.form.ValidationTextBox",
	[ dijit.form.ValidationTextBox ], {

validate: function(/*Boolean*/ isFocused){
	// summary:
	//		Called by oninit, onblur, and onkeypress.
	// description:
	//		Show missing or invalid messages if appropriate, and highlight textbox field.
	// tags:
	//		protected

	//console.log("plugins.dijit.form.ValidationTextBox.validate plugins.dijit.form.ValidationTextBox.validate(isFocused)");
	//console.log("plugins.dijit.form.ValidationTextBox.validate    this.target: " + this.target);
	// SKIP VALIDATE WHEN LOADING WIDGET
	if ( this.parentWidget == null )	return;

	// IF this IS THE newPassword WIDGET, RUN VALIDATE ON
	// ITS TARGET: THE confirmPassword WIDGET
	if ( this.target != null ) {
		var isValid = this.target.validate(isFocused);
		console.log("plugins.dijit.form.ValidationTextBox.validate    TARGET isValid: " + isValid);

		if ( ! isValid)
			this.state = "Error";
		else
			this.state = "Incomplete";
	
		this._setStateClass();
	}
	var message = "";
	var isValid = this.parentWidget.passwordsMatch();
	//console.log("plugins.dijit.form.ValidationTextBox.validate    isValid: " + isValid);

	if(isValid){ this._maskValidSubsetError = true; }
	var isEmpty = this._isEmpty(this.textbox.value);
	var isValidSubset = !isValid && !isEmpty && isFocused && this._isValidSubset();
	this.state = ((isValid || ((!this._hasBeenBlurred || isFocused) && isEmpty) || isValidSubset) && this._maskValidSubsetError) ? "" : "Error";
	
	if ( ! isValid)
		this.state = "Error";
	else
		this.state = "Incomplete";

	if(this.state == "Error"){ this._maskValidSubsetError = isFocused; } // we want the error to show up afer a blur and refocus

	this._setStateClass();

//return isValid;
	
	//console.log("plugins.dijit.form.ValidationTextBox.validate    DOING dijit.setWaiState(this.focusNode, " + this.focusNode, "invalid", isValid ? "false" : "true" + ")");

	dijit.setWaiState(this.focusNode, "invalid", isValid ? "false" : "true");
	if(isFocused){
		if(this.state == "Error"){
			message = this.getErrorMessage(true);
		}else{
			message = this.getPromptMessage(true); // show the prompt whever there's no error
		}
		this._maskValidSubsetError = true; // since we're focused, always mask warnings
	}
	this.displayMessage(message);

	// IF SOURCE EXISTS, SET SOURCE STATE
	if ( this.source ) {
		if ( ! isValid)
			this.source.state = "Error";
		else
			this.source.state = "Incomplete";
	
		this.source._setStateClass();
	}
	
	return isValid;
}	

}); // plugins.dijit.form.ValidationTextBox


}

if(!dojo._hasResource["plugins.cloud.UserRow"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.cloud.UserRow"] = true;
dojo.provide("plugins.cloud.UserRow");


dojo.declare( "plugins.cloud.UserRow",
	[ dijit._Widget, dijit._Templated ],
{
//Path to the template of this widget. 
templateString:"<div dojoAttachPoint=\"containerNode\">\n    <table width=\"100%\">\n        <tr class=\"username\" width=\"100%\">\n            <td\n                width=\"100%\"\n                colspan=\"2\"\n                dojoAttachPoint=\"username\"\n                class=\"username\"\n            >${username}</td>\n        </tr>\n        <tr class='firstname' width=\"100%\">\n            <td \n                dojoAttachPoint=\"firstname\"\n                class='firstname'\n                style=\"display: none;\"\n                width=\"100%\" colspan=\"2\"\n            >${firstname}</td>\n        </tr>\n        <tr class='lastname' width=\"100%\">\n            <td \n                dojoAttachPoint=\"lastname\"\n                class='lastname'\n                style=\"display: none;\"\n                width=\"100%\" colspan=\"2\"\n            >${lastname}</td>\n        </tr>\n        <tr class=\"email\" width=\"100%\">\n            <td \n                dojoAttachPoint=\"email\"\n                class='email'\n                style=\"display: none;\"\n                width=\"100%\" colspan=\"2\"\n            >${email}</td>\n        </tr>\n        <tr class=\"password\" width=\"100%\">\n            <td \n                dojoAttachPoint=\"password\"\n                class='password'\n                style=\"display: none;\"\n                type=\"password\"\n                value=\"its-a-secret\"\n                width=\"100%\" colspan=\"2\"\n            >reset-password</td>\n        </tr>\n    </table>\n</div>\n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

// PARENT plugins.cloud.Users WIDGET
parentWidget : null,

////}}}

constructor : function(args) {
	//////console.log("UserRow.constructor    plugins.workflow.UserRow.constructor()");
	this.parentWidget = args.parentWidget;
},

postCreate : function() {
	////////console.log("UserRow.postCreate    plugins.workflow.UserRow.postCreate()");
	this.formInputs = this.parentWidget.formInputs;
	this.startup();
},

startup : function () {
	//////console.log("UserRow.startup    plugins.workflow.UserRow.startup()");
	//////console.log("UserRow.startup    this.parentWidget: " + this.parentWidget);

	this.inherited(arguments);
	
	var thisObject = this;

	dojo.connect( this.username, "onclick", function(event) {
		thisObject.toggle();
		event.stopPropagation(); //Stop Event Bubbling 			
	});

	// FIRSTNAME
	var thisObject = this;
	dojo.connect(this.firstname, "onclick", function(event)
		{
			//console.log("UserRow.startup    userRow.firstname clicked");
			thisObject.parentWidget.editRow(thisObject, event.target);
			event.stopPropagation(); //Stop Event Bubbling 			
		}
	);

	// LASTNAME
	dojo.connect(this.lastname, "onclick", function(event)
		{
			thisObject.parentWidget.editRow(thisObject, event.target);
			event.stopPropagation(); //Stop Event Bubbling 			
		}
	);

	// EMAIL
	dojo.connect(this.email, "onclick", function(event)
		{
			//////console.log("UserRow.startup    userRow.email clicked");

			thisObject.parentWidget.editRow(thisObject, event.target);
			event.stopPropagation(); //Stop Event Bubbling 			
		}
	);

	// PASSWORD
	dojo.connect(this.password, "onclick", function(event)
		{
			//console.log("UserRow.startup    userRow.password clicked");

			thisObject.clearValue(event.target);
			thisObject.parentWidget.editRow(thisObject, event.target);
			event.stopPropagation(); //Stop Event Bubbling 			
		}
	);
},

toggle : function () {
	//////console.log("UserRow.toggle    plugins.workflow.UserRow.toggle()");

	if ( this.firstname.style.display == 'block' ) this.firstname.style.display='none';
	else this.firstname.style.display = 'block';
	if ( this.lastname.style.display == 'block' ) this.lastname.style.display='none';
	else this.lastname.style.display = 'block';
	if ( this.email.style.display == 'block' ) this.email.style.display='none';
	else this.email.style.display = 'block';
	if ( this.password.style.display == 'block' ) this.password.style.display='none';
	else this.password.style.display = 'block';
},

clearValue : function (element) {
	//console.log("UserRow.clearValue    plugins.cloud.UserRow.clearValue(element)");
	//console.log("UserRow.clearValue    element.value: " + element.value);

	if ( element.clicked == true ) return;
	
	element.clicked = true;
	element.innerHTML = '';
	element.focus();
}


});

}

if(!dojo._hasResource["plugins.cloud.Settings"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.cloud.Settings"] = true;
dojo.provide("plugins.cloud.Settings");

// ALLOW THE ADMIN USER TO ADD, REMOVE AND MODIFY USERS

// NEW USERS MUST HAVE username AND email

// // optimize: load dijit layer











// HAS A


//dojo.declare("plugins.cloud.ValidationTextBox",
//	[ dijit.form.ValidationTextBox ], {
//
//validate: function(/*Boolean*/ isFocused){
//	// summary:
//	//		Called by oninit, onblur, and onkeypress.
//	// description:
//	//		Show missing or invalid messages if appropriate, and highlight textbox field.
//	// tags:
//	//		protected
//
//	console.log("plugins.cloud.ValidationTextBox.validate    plugins.cloud.ValidationTextBox.validate(isFocused)");
//	console.log("plugins.cloud.ValidationTextBox.validate    this.target: " + this.target);
//	// SKIP VALIDATE WHEN LOADING WIDGET
//	if ( this.parentWidget == null )	return;
//
//	// IF this IS THE newPassword WIDGET, RUN VALIDATE ON
//	// ITS TARGET: THE confirmPassword WIDGET
//	if ( this.target != null ) {
//		return this.target.validate(isFocused);
//	}
//	var message = "";
//	var isValid = this.parentWidget.passwordsMatch();
//	console.log("plugins.cloud.ValidationTextBox.validate    isValid: " + isValid);
//
//	if(isValid){ this._maskValidSubsetError = true; }
//	var isEmpty = this._isEmpty(this.textbox.value);
//	var isValidSubset = !isValid && !isEmpty && isFocused && this._isValidSubset();
//	this.state = ((isValid || ((!this._hasBeenBlurred || isFocused) && isEmpty) || isValidSubset) && this._maskValidSubsetError) ? "" : "Error";
//	console.log("plugins.cloud.ValidationTextBox.validate    this.state: " + this.state);
//	if(this.state == "Error"){ this._maskValidSubsetError = isFocused; } // we want the error to show up afer a blur and refocus
//	
//	this._setStateClass();
//	dijit.setWaiState(this.focusNode, "invalid", isValid ? "false" : "true");
//	if(isFocused) {
//		if(this.state == "Error"){
//			message = this.getErrorMessage(true);
//		}else{
//			message = this.getPromptMessage(true); // show the prompt whever there's no error
//		}
//		this._maskValidSubsetError = true; // since we're focused, always mask warnings
//	}
//	this.displayMessage(message);
//
//	return isValid;
//}	
//
//});
//
dojo.declare("plugins.cloud.Settings",
	[ dijit._Widget, dijit._Templated, plugins.core.Common ], {

//Path to the template of this widget. 
templateString:"<div dojoattachpoint=\"containerNode\">\n\n\t\n\t<!-- settings TAB -->\n\t<div\n\t\tdojoAttachPoint=\"mainTab\"\n\t\tclass=\"settings\"\n\t\tdojoType=\"dijit.layout.ContentPane\"\n\t\ttitle=\"Settings\"\n\t\tstyle=\"height: 700px; max-height: auto !important; width: 390px !important; padding: 0 !important;\"\n\t\t>\n\n\t\t<table>\n\t\t\t<tr valign=\"top\" width=\"100%\">\n\t\t\t\t<td colspan=\"2\" class=\"tabTitle\" align=\"center\"> Settings </td>\n\t\t\t</tr>\n\t\t\t\n\t\t\t<tr valign=\"top\" width=\"95%\">\n\t\t\t\t<td width=\"95%\">\n\t\t\t\t\t<div class=\"label\"> Personal Info </div>\n\t\t\t\t\t<div\n\t\t\t\t\t\tclass=\"subPane\"\n\t\t\t\t\t\tstyle=\"height: 195px; width: 95%;\"\n\t\t\t\t\t>\n\n\t\t\t\t\t<table>\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td class=\"sublabel\">Username</td>\n\t\t\t\t\t\t\t<td\tdojoAttachPoint=\"username\"\n\t\t\t\t\t\t\t\t\tclass=\"username\"\n\t\t\t\t\t\t\t></td>\n\t\t\t\t\t\t\t<td\n\t\t\t\t\t\t\t\tdojoAttachPoint=\"updateUserButton\"\n\t\t\t\t\t\t\t\tclass=\"addUserButton\"\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\tSave\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td class=\"sublabel\">Firstname</td>\n\t\t\t\t\t\t\t<td colspan=\"2\">\n\t\t\t\t\t\t\t\t<input\n\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"firstname\"\n\t\t\t\t\t\t\t\t\tclass=\"firstname\"\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td class=\"sublabel\">Lastname</td>\n\t\t\t\t\t\t\t<td colspan=\"2\">\n\t\t\t\t\t\t\t\t<input\n\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"lastname\"\n\t\t\t\t\t\t\t\t\tclass=\"lastname\"\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td class=\"sublabel\">Email</td>\n\t\t\t\t\t\t\t<td colspan=\"2\">\n\t\t\t\t\t\t\t\t<input\n\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"email\"\n\t\t\t\t\t\t\t\t\tclass=\"email\"\n\t\t\t\t\t\t\t\t\tvalue=\"\"\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td class=\"sublabel\">Old Password</td>\n\t\t\t\t\t\t\t<td colspan=\"2\">\n\t\t\t\t\t\t\t\t<input\n\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"oldPassword\"\n\t\t\t\t\t\t\t\t\tclass=\"password\"\n\t\t\t\t\t\t\t\t\ttype=\"password\"\n\t\t\t\t\t\t\t\t\tvalue=\"\"\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t</tr>\n\n\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td class=\"sublabel\">New Password</td>\n\t\t\t\t\t\t\t<td colspan=\"2\">\n\t\t\t\t\t\t\t\t<input\n\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"newPassword\"\n\t\t\t\t\t\t\t\t\tdojoType=\"plugins.dijit.form.ValidationTextBox\"\n\t\t\t\t\t\t\t\t\trequired=\"true\"\n\t\t\t\t\t\t\t\t\tinvalidMessage=\"Passwords don't match\"\n\t\t\t\t\t\t\t\t\tclass=\"newPassword\"\n\t\t\t\t\t\t\t\t\ttype=\"password\"\n\t\t\t\t\t\t\t\t\ttooltipPosition=\"below\"\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td class=\"sublabel\">Confirm Password</td>\n\t\t\t\t\t\t\t<td colspan=\"2\">\n\t\t\t\t\t\t\t\t<input\n\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"confirmPassword\"\n\t\t\t\t\t\t\t\t\tdojoType=\"plugins.dijit.form.ValidationTextBox\"\n\t\t\t\t\t\t\t\t\trequired=\"true\"\n\t\t\t\t\t\t\t\t\tinvalidMessage=\"Passwords don't match\"\n\t\t\t\t\t\t\t\t\tclass=\"confirmPassword\"\n\t\t\t\t\t\t\t\t\ttype=\"password\"\n\t\t\t\t\t\t\t\t\ttooltipPosition=\"below\"\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t</table>\n\t\t\t\t\t\n\t\t\t\t</td>\n\t\t\t</tr>\n\t\t\t\n\t\t</table>\n\n\t</div>\n\t<!-- END settings TAB -->\n\t\n</div> \n\n\n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

//addingUser STATE
addingUser : false,

// OR USE @import IN HTML TEMPLATE
cssFiles : [
	dojo.moduleUrl("plugins", "cloud/css/settings.css"),
	//dojo.moduleUrl("dojo", "/tests/dnd/dndDefault.css")
],

// PARENT WIDGET
parentWidget : null,


/////}}} 
constructor : function(args)  {
	console.log("Settings.constructor     plugins.cloud.Settings.constructor");			
	// GET INFO FROM ARGS
	this.parentWidget = args.parentWidget;
	this.settings = args.parentWidget.settings;

	// LOAD CSS
	this.loadCSS();		
},
postCreate : function() {
	console.log("Controller.postCreate    plugins.cloud.Controller.postCreate()");

	this.startup();
},
startup : function () {
	console.log("Settings.startup    plugins.cloud.GroupSettings.startup()");

	// COMPLETE CONSTRUCTION OF OBJECT
	console.log("Settings.startup    BEFORE inherited(arguments)");
	this.inherited(arguments);	 
	console.log("Settings.startup    AFTER inherited(arguments)");

	// ADD ADMIN TAB TO TAB CONTAINER		
	this.tabContainer.addChild(this.mainTab);
	this.tabContainer.selectChild(this.mainTab);

	// SET ADD SOURCE ONCLICK
	console.log("Settings.startup    BEFORE dojo.connect");
	dojo.connect(this.updateUserButton, "onClick", dojo.hitch(this, "updateUser"));
	console.log("Settings.startup    AFTER dojo.connect");

	//// ADD password CLASS TO PASSWORD INPUTS
	//dojo.addClass(this.newPassword.focusNode, "password");

	console.log("Settings.startup    this.confirmPassword: " + this.confirmPassword);
	this.confirmPassword.parentWidget = this;
	this.newPassword.parentWidget = this;
	this.newPassword.target = this.confirmPassword;
	
	// SET DRAG SOURCE - LIST OF USERS
	this.initialiseSettings();
},
passwordsMatch : function () {
	console.log("Settings.confirmPassword    plugins.cloud.GroupSettings.confirmPassword()");
	var newPassword = this.newPassword.textbox.value;
	console.log("Settings.confirmPassword    newPassword: " + newPassword);
	var confirmPassword = this.confirmPassword.textbox.value;
	console.log("Settings.confirmPassword    confirmPassword: " + confirmPassword);
	
	return newPassword == confirmPassword;
},
getInputValue : function (name) {
	console.log("Settings.getInputValue    name: " + name);
	var widget = this[name];
	var value = widget.get ? widget.get('value') : widget; 
	console.log("Settings.getInputValue    value: " + value);
	value = this.cleanEdges(value);

	//if ( value.match("OMITTED") )	return;
	return value;
},
getTextAreaValue : function (name) {
	console.log("Settings.getTextAreaValue    name: " + name);
	var value = this[name].value;
	value = this.cleanEdges(value);	
	//if ( value.match("OMITTED") )	value = '';
    this[name].value = value;

	return value;
},
// SAVE TO REMOTE
updateUser : function (event) {
	console.log("Settings.updateUser    plugins.cloud.Settings.updateUser(event)");
	console.log("Settings.updateUser    event: " + event);

	console.log("Settings.updateUser    this.savingUser: " + this.savingUser + ". Returning.");
	if ( this.savingUser == true )	return;
	this.savingUser = true;

	// GET PASSWORDS
	var oldPassword = this.cleanEdges(this.oldPassword.value);
	var newPassword = this.cleanEdges(this.newPassword.value);
	var confirmPassword = this.cleanEdges(this.confirmPassword.value);
	
	// RETURN IF ONLY SOME OF THE PASSWORDS ARE FILLED IN
	if ( ! (oldPassword  == '' && newPassword == '' && confirmPassword == '') )
	{
		if ( oldPassword  == '' ) { dojo.addClass(this.oldPassword, 'invalid'); }
		else { dojo.removeClass(this.oldPassword, 'invalid'); }
		if ( newPassword  == '' ) { dojo.addClass(this.newPassword, 'invalid'); }
		else { dojo.removeClass(this.newPassword, 'invalid'); }
		if ( confirmPassword  == '' ) { dojo.addClass(this.confirmPassword, 'invalid'); }
		else { dojo.removeClass(this.confirmPassword, 'invalid'); }		
		if ( oldPassword  == '' || newPassword == '' || confirmPassword == '' ) return;
	}

	// ALERT IF PASSWORDS DO NOT MATCH
	if ( newPassword != confirmPassword ) {
		console.log("Users.updateUser    passwords do not match. Adding class 'invalid'");
		dojo.addClass(this.newPassword, 'invalid');
		dojo.addClass(this.confirmPassword, 'invalid');
		console.log("Users.updateUser    Finished adding class 'invalid'");

		this.savingUser = false;
		return;
	}
	else {
		console.log("Users.updateUser    passwords match. Removing class 'invalid'");
		dojo.removeClass(this.newPassword, 'invalid');
		dojo.removeClass(this.confirmPassword, 'invalid');
	}

	// CLEAN UP WHITESPACE
	var user = new Object;
	user.username = Agua.cookie('username');
	user.firstname = this.cleanEdges(this.firstname.value);
	user.lastname = this.cleanEdges(this.lastname.value);
	user.email = this.cleanEdges(this.email.value);
	user.oldpassword = oldPassword;
	user.newpassword = newPassword;
	console.log("Settings.updateUser    user: " + dojo.toJson(user));
	
	var url = Agua.cgiUrl + "admin.cgi?";

	// CREATE JSON QUERY
	var query = new Object;
	query.username = Agua.cookie('username');
	query.sessionid = Agua.cookie('sessionid');
	query.mode = "updateUser";
	query.data = user;
	
	// SEND TO SERVER
	var thisObj = this;
	dojo.xhrPut(
		{
			url: url,
			contentType: "text",
			handleAs: "json",
			putData: dojo.toJson(query),
			timeout: 15000,
			load: function(response, ioArgs) {
		
				console.log("Settings.updateUser    response: " + response);			
				if ( response.error != null ) {
					dojo.addClass(thisObj.oldPassword, 'invalid');
				}
			},
			error: function(response, ioArgs) {
			}
		}
	);

	this.savingUser = false;

}, // Settings.updateUser
cleanEdges : function (string ) {
// REMOVE WHITESPACE FROM EDGES OF TEXT
	string = string.toString();
	if ( string == null || ! string.replace)
		return null;
	string = string.replace(/^\s+/, '');
	string = string.replace(/\s+$/, '');

	return string;
},
// UTILS
initialiseSettings : function () {
	console.log("Settings.initialiseSettings     plugins.cloud.GroupSettings.initialiseSettings()");
	
	// DISPLAY USERNAME
	var username = Agua.cookie('username');
	console.log("Settings.initialiseSettings     username: " + username);
	this.username.innerHTML = username;

	// INITIALISE USER INFO
	var user = Agua.getUser(username);
	console.log("Settings.initialiseSettings     user: " + dojo.toJson(user));
	this.firstname.value = user["firstname"] || '';
	this.lastname.value = user["lastname"];
	this.email.value = user["email"];
},
reloadSettingsTabs : function () {
// RELOAD RELEVANT DISPLAYS
	console.log("Settings.reloadSettingsTabs    plugins.cloud.Settings.reloadSettingsTabs()");
	console.log("Settings.reloadSettingsTabs    this.parentWidget: " + this.parentWidget);
	console.log("Settings.reloadSettingsTabs    this.parentWidget.paneWidgets: " + this.parentWidget.paneWidgets);

	var tabPaneNames = ["plugins.cloud.GroupSettings"];
	for ( var i in tabPaneNames )
	{
		if ( this.parentWidget.paneWidgets[tabPaneNames[i]] != null )
		{
			console.log("Settings.reloadSettingsTabs    this.parentWidget.paneWidgets['" + tabPaneNames[i] + "']: " + this.parentWidget.paneWidgets[tabPaneNames[i]]);
			this.parentWidget.paneWidgets[tabPaneNames[i]].reload();
		}
	}
},
setTable : function () {
	console.log("Settings.setTable     plugins.cloud.GroupSettings.setTable()");

	// DELETE EXISTING TABLE CONTENT
	while ( this.mainTable.firstChild )
	{
		this.mainTable.removeChild(this.mainTable.firstChild);
	}
},

}); // plugins.cloud.Settings



}

if(!dojo._hasResource["dijit._KeyNavContainer"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._KeyNavContainer"] = true;
dojo.provide("dijit._KeyNavContainer");



dojo.declare("dijit._KeyNavContainer",
	dijit._Container,
	{

		// summary:
		//		A _Container with keyboard navigation of its children.
		// description:
		//		To use this mixin, call connectKeyNavHandlers() in
		//		postCreate() and call startupKeyNavChildren() in startup().
		//		It provides normalized keyboard and focusing code for Container
		//		widgets.
/*=====
		// focusedChild: [protected] Widget
		//		The currently focused child widget, or null if there isn't one
		focusedChild: null,
=====*/

		// tabIndex: Integer
		//		Tab index of the container; same as HTML tabIndex attribute.
		//		Note then when user tabs into the container, focus is immediately
		//		moved to the first item in the container.
		tabIndex: "0",

		_keyNavCodes: {},

		connectKeyNavHandlers: function(/*dojo.keys[]*/ prevKeyCodes, /*dojo.keys[]*/ nextKeyCodes){
			// summary:
			//		Call in postCreate() to attach the keyboard handlers
			//		to the container.
			// preKeyCodes: dojo.keys[]
			//		Key codes for navigating to the previous child.
			// nextKeyCodes: dojo.keys[]
			//		Key codes for navigating to the next child.
			// tags:
			//		protected

			var keyCodes = (this._keyNavCodes = {});
			var prev = dojo.hitch(this, this.focusPrev);
			var next = dojo.hitch(this, this.focusNext);
			dojo.forEach(prevKeyCodes, function(code){ keyCodes[code] = prev; });
			dojo.forEach(nextKeyCodes, function(code){ keyCodes[code] = next; });
			keyCodes[dojo.keys.HOME] = dojo.hitch(this, "focusFirstChild");
			keyCodes[dojo.keys.END] = dojo.hitch(this, "focusLastChild");
			this.connect(this.domNode, "onkeypress", "_onContainerKeypress");
			this.connect(this.domNode, "onfocus", "_onContainerFocus");
		},

		startupKeyNavChildren: function(){
			// summary:
			//		Call in startup() to set child tabindexes to -1
			// tags:
			//		protected
			dojo.forEach(this.getChildren(), dojo.hitch(this, "_startupChild"));
		},

		addChild: function(/*dijit._Widget*/ widget, /*int?*/ insertIndex){
			// summary:
			//		Add a child to our _Container
			dijit._KeyNavContainer.superclass.addChild.apply(this, arguments);
			this._startupChild(widget);
		},

		focus: function(){
			// summary:
			//		Default focus() implementation: focus the first child.
			this.focusFirstChild();
		},

		focusFirstChild: function(){
			// summary:
			//		Focus the first focusable child in the container.
			// tags:
			//		protected
			var child = this._getFirstFocusableChild();
			if(child){ // edge case: Menu could be empty or hidden
				this.focusChild(child);
			}
		},

		focusLastChild: function(){
			// summary:
			//		Focus the last focusable child in the container.
			// tags:
			//		protected
			var child = this._getLastFocusableChild();
			if(child){ // edge case: Menu could be empty or hidden
				this.focusChild(child);
			}
		},

		focusNext: function(){
			// summary:
			//		Focus the next widget
			// tags:
			//		protected
			var child = this._getNextFocusableChild(this.focusedChild, 1);
			this.focusChild(child);
		},

		focusPrev: function(){
			// summary:
			//		Focus the last focusable node in the previous widget
			//		(ex: go to the ComboButton icon section rather than button section)
			// tags:
			//		protected
			var child = this._getNextFocusableChild(this.focusedChild, -1);
			this.focusChild(child, true);
		},

		focusChild: function(/*dijit._Widget*/ widget, /*Boolean*/ last){
			// summary:
			//		Focus widget.
			// widget:
			//		Reference to container's child widget
			// last:
			//		If true and if widget has multiple focusable nodes, focus the
			//		last one instead of the first one
			// tags:
			//		protected
			
			if(this.focusedChild && widget !== this.focusedChild){
				this._onChildBlur(this.focusedChild);
			}
			widget.set("tabIndex", this.tabIndex);	// for IE focus outline to appear, must set tabIndex before focs
			widget.focus(last ? "end" : "start");
			this._set("focusedChild", widget);
		},

		_startupChild: function(/*dijit._Widget*/ widget){
			// summary:
			//		Setup for each child widget
			// description:
			//		Sets tabIndex=-1 on each child, so that the tab key will
			//		leave the container rather than visiting each child.
			// tags:
			//		private
			
			widget.set("tabIndex", "-1");
			
			this.connect(widget, "_onFocus", function(){
				// Set valid tabIndex so tabbing away from widget goes to right place, see #10272
				widget.set("tabIndex", this.tabIndex);
			});
			this.connect(widget, "_onBlur", function(){
				widget.set("tabIndex", "-1");
			});
		},

		_onContainerFocus: function(evt){
			// summary:
			//		Handler for when the container gets focus
			// description:
			//		Initially the container itself has a tabIndex, but when it gets
			//		focus, switch focus to first child...
			// tags:
			//		private

			// Note that we can't use _onFocus() because switching focus from the
			// _onFocus() handler confuses the focus.js code
			// (because it causes _onFocusNode() to be called recursively)

			// focus bubbles on Firefox,
			// so just make sure that focus has really gone to the container
			if(evt.target !== this.domNode){ return; }

			this.focusFirstChild();

			// and then set the container's tabIndex to -1,
			// (don't remove as that breaks Safari 4)
			// so that tab or shift-tab will go to the fields after/before
			// the container, rather than the container itself
			dojo.attr(this.domNode, "tabIndex", "-1");
		},

		_onBlur: function(evt){
			// When focus is moved away the container, and its descendant (popup) widgets,
			// then restore the container's tabIndex so that user can tab to it again.
			// Note that using _onBlur() so that this doesn't happen when focus is shifted
			// to one of my child widgets (typically a popup)
			if(this.tabIndex){
				dojo.attr(this.domNode, "tabIndex", this.tabIndex);
			}
			this.inherited(arguments);
		},

		_onContainerKeypress: function(evt){
			// summary:
			//		When a key is pressed, if it's an arrow key etc. then
			//		it's handled here.
			// tags:
			//		private
			if(evt.ctrlKey || evt.altKey){ return; }
			var func = this._keyNavCodes[evt.charOrCode];
			if(func){
				func();
				dojo.stopEvent(evt);
			}
		},

		_onChildBlur: function(/*dijit._Widget*/ widget){
			// summary:
			//		Called when focus leaves a child widget to go
			//		to a sibling widget.
			// tags:
			//		protected
		},

		_getFirstFocusableChild: function(){
			// summary:
			//		Returns first child that can be focused
			return this._getNextFocusableChild(null, 1);	// dijit._Widget
		},

		_getLastFocusableChild: function(){
			// summary:
			//		Returns last child that can be focused
			return this._getNextFocusableChild(null, -1);	// dijit._Widget
		},

		_getNextFocusableChild: function(child, dir){
			// summary:
			//		Returns the next or previous focusable child, compared
			//		to "child"
			// child: Widget
			//		The current widget
			// dir: Integer
			//		* 1 = after
			//		* -1 = before
			if(child){
				child = this._getSiblingOfChild(child, dir);
			}
			var children = this.getChildren();
			for(var i=0; i < children.length; i++){
				if(!child){
					child = children[(dir>0) ? 0 : (children.length-1)];
				}
				if(child.isFocusable()){
					return child;	// dijit._Widget
				}
				child = this._getSiblingOfChild(child, dir);
			}
			// no focusable child found
			return null;	// dijit._Widget
		}
	}
);

}

if(!dojo._hasResource["dijit.ToolbarSeparator"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.ToolbarSeparator"] = true;
dojo.provide("dijit.ToolbarSeparator");




dojo.declare("dijit.ToolbarSeparator",
		[ dijit._Widget, dijit._Templated ],
		{
		// summary:
		//		A spacer between two `dijit.Toolbar` items
		templateString: '<div class="dijitToolbarSeparator dijitInline" role="presentation"></div>',
		buildRendering: function(){
			this.inherited(arguments);
			dojo.setSelectable(this.domNode, false);
		},
		isFocusable: function(){
			// summary:
			//		This widget isn't focusable, so pass along that fact.
			// tags:
			//		protected
			return false;
		}

	});

}

if(!dojo._hasResource["dijit.Toolbar"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.Toolbar"] = true;
dojo.provide("dijit.Toolbar");






// Note: require of ToolbarSeparator is for back-compat, remove for 2.0

dojo.declare("dijit.Toolbar",
	[dijit._Widget, dijit._Templated, dijit._KeyNavContainer],
	{
	// summary:
	//		A Toolbar widget, used to hold things like `dijit.Editor` buttons

	templateString:
		'<div class="dijit" role="toolbar" tabIndex="${tabIndex}" dojoAttachPoint="containerNode">' +
		//	'<table style="table-layout: fixed" class="dijitReset dijitToolbarTable">' + // factor out style
		//		'<tr class="dijitReset" dojoAttachPoint="containerNode"></tr>'+
		//	'</table>' +
		'</div>',

	baseClass: "dijitToolbar",

	postCreate: function(){
		this.inherited(arguments);

		this.connectKeyNavHandlers(
			this.isLeftToRight() ? [dojo.keys.LEFT_ARROW] : [dojo.keys.RIGHT_ARROW],
			this.isLeftToRight() ? [dojo.keys.RIGHT_ARROW] : [dojo.keys.LEFT_ARROW]
		);
	},

	startup: function(){
		if(this._started){ return; }

		this.startupKeyNavChildren();

		this.inherited(arguments);
	}
}
);

}

if(!dojo._hasResource["dijit.layout.StackController"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.layout.StackController"] = true;
dojo.provide("dijit.layout.StackController");







dojo.declare(
		"dijit.layout.StackController",
		[dijit._Widget, dijit._Templated, dijit._Container],
		{
			// summary:
			//		Set of buttons to select a page in a page list.
			// description:
			//		Monitors the specified StackContainer, and whenever a page is
			//		added, deleted, or selected, updates itself accordingly.

			templateString: "<span role='tablist' dojoAttachEvent='onkeypress' class='dijitStackController'></span>",

			// containerId: [const] String
			//		The id of the page container that I point to
			containerId: "",

			// buttonWidget: [const] String
			//		The name of the button widget to create to correspond to each page
			buttonWidget: "dijit.layout._StackButton",

			constructor: function(){
				this.pane2button = {};		// mapping from pane id to buttons
				this.pane2connects = {};	// mapping from pane id to this.connect() handles
				this.pane2watches = {};		// mapping from pane id to watch() handles
			},

			buildRendering: function(){
				this.inherited(arguments);
				dijit.setWaiRole(this.domNode, "tablist");	// TODO: unneeded?   it's in template above.
			},

			postCreate: function(){
				this.inherited(arguments);

				// Listen to notifications from StackContainer
				this.subscribe(this.containerId+"-startup", "onStartup");
				this.subscribe(this.containerId+"-addChild", "onAddChild");
				this.subscribe(this.containerId+"-removeChild", "onRemoveChild");
				this.subscribe(this.containerId+"-selectChild", "onSelectChild");
				this.subscribe(this.containerId+"-containerKeyPress", "onContainerKeyPress");
			},

			onStartup: function(/*Object*/ info){
				// summary:
				//		Called after StackContainer has finished initializing
				// tags:
				//		private
				dojo.forEach(info.children, this.onAddChild, this);
				if(info.selected){
					// Show button corresponding to selected pane (unless selected
					// is null because there are no panes)
					this.onSelectChild(info.selected);
				}
			},

			destroy: function(){
				for(var pane in this.pane2button){
					this.onRemoveChild(dijit.byId(pane));
				}
				this.inherited(arguments);
			},

			onAddChild: function(/*dijit._Widget*/ page, /*Integer?*/ insertIndex){
				// summary:
				//		Called whenever a page is added to the container.
				//		Create button corresponding to the page.
				// tags:
				//		private

				// create an instance of the button widget
				var cls = dojo.getObject(this.buttonWidget);
				var button = new cls({
					id: this.id + "_" + page.id,
					label: page.title,
					dir: page.dir,
					lang: page.lang,
					showLabel: page.showTitle,
					iconClass: page.iconClass,
					closeButton: page.closable,
					title: page.tooltip
				});
				dijit.setWaiState(button.focusNode,"selected", "false");


				// map from page attribute to corresponding tab button attribute
				var pageAttrList = ["title", "showTitle", "iconClass", "closable", "tooltip"],
					buttonAttrList = ["label", "showLabel", "iconClass", "closeButton", "title"];

				// watch() so events like page title changes are reflected in tab button
				this.pane2watches[page.id] = dojo.map(pageAttrList, function(pageAttr, idx){
					return page.watch(pageAttr, function(name, oldVal, newVal){
						button.set(buttonAttrList[idx], newVal);
					});
				});
					
				// connections so that clicking a tab button selects the corresponding page
				this.pane2connects[page.id] = [
					this.connect(button, 'onClick', dojo.hitch(this,"onButtonClick", page)),
					this.connect(button, 'onClickCloseButton', dojo.hitch(this,"onCloseButtonClick", page))
				];

				this.addChild(button, insertIndex);
				this.pane2button[page.id] = button;
				page.controlButton = button;	// this value might be overwritten if two tabs point to same container
				if(!this._currentChild){ // put the first child into the tab order
					button.focusNode.setAttribute("tabIndex", "0");
					dijit.setWaiState(button.focusNode, "selected", "true");
					this._currentChild = page;
				}
				// make sure all tabs have the same length
				if(!this.isLeftToRight() && dojo.isIE && this._rectifyRtlTabList){
					this._rectifyRtlTabList();
				}
			},

			onRemoveChild: function(/*dijit._Widget*/ page){
				// summary:
				//		Called whenever a page is removed from the container.
				//		Remove the button corresponding to the page.
				// tags:
				//		private

				if(this._currentChild === page){ this._currentChild = null; }

				// disconnect/unwatch connections/watches related to page being removed
				dojo.forEach(this.pane2connects[page.id], dojo.hitch(this, "disconnect"));
				delete this.pane2connects[page.id];
				dojo.forEach(this.pane2watches[page.id], function(w){ w.unwatch(); });
				delete this.pane2watches[page.id];

				var button = this.pane2button[page.id];
				if(button){
					this.removeChild(button);
					delete this.pane2button[page.id];
					button.destroy();
				}
				delete page.controlButton;
			},

			onSelectChild: function(/*dijit._Widget*/ page){
				// summary:
				//		Called when a page has been selected in the StackContainer, either by me or by another StackController
				// tags:
				//		private

				if(!page){ return; }

				if(this._currentChild){
					var oldButton=this.pane2button[this._currentChild.id];
					oldButton.set('checked', false);
					dijit.setWaiState(oldButton.focusNode, "selected", "false");
					oldButton.focusNode.setAttribute("tabIndex", "-1");
				}

				var newButton=this.pane2button[page.id];
				newButton.set('checked', true);
				dijit.setWaiState(newButton.focusNode, "selected", "true");
				this._currentChild = page;
				newButton.focusNode.setAttribute("tabIndex", "0");
				var container = dijit.byId(this.containerId);
				dijit.setWaiState(container.containerNode, "labelledby", newButton.id);
			},

			onButtonClick: function(/*dijit._Widget*/ page){
				// summary:
				//		Called whenever one of my child buttons is pressed in an attempt to select a page
				// tags:
				//		private

				var container = dijit.byId(this.containerId);
				container.selectChild(page);
			},

			onCloseButtonClick: function(/*dijit._Widget*/ page){
				// summary:
				//		Called whenever one of my child buttons [X] is pressed in an attempt to close a page
				// tags:
				//		private

				var container = dijit.byId(this.containerId);
				container.closeChild(page);
				if(this._currentChild){
					var b = this.pane2button[this._currentChild.id];
					if(b){
						dijit.focus(b.focusNode || b.domNode);
					}
				}
			},

			// TODO: this is a bit redundant with forward, back api in StackContainer
			adjacent: function(/*Boolean*/ forward){
				// summary:
				//		Helper for onkeypress to find next/previous button
				// tags:
				//		private

				if(!this.isLeftToRight() && (!this.tabPosition || /top|bottom/.test(this.tabPosition))){ forward = !forward; }
				// find currently focused button in children array
				var children = this.getChildren();
				var current = dojo.indexOf(children, this.pane2button[this._currentChild.id]);
				// pick next button to focus on
				var offset = forward ? 1 : children.length - 1;
				return children[ (current + offset) % children.length ]; // dijit._Widget
			},

			onkeypress: function(/*Event*/ e){
				// summary:
				//		Handle keystrokes on the page list, for advancing to next/previous button
				//		and closing the current page if the page is closable.
				// tags:
				//		private

				if(this.disabled || e.altKey ){ return; }
				var forward = null;
				if(e.ctrlKey || !e._djpage){
					var k = dojo.keys;
					switch(e.charOrCode){
						case k.LEFT_ARROW:
						case k.UP_ARROW:
							if(!e._djpage){ forward = false; }
							break;
						case k.PAGE_UP:
							if(e.ctrlKey){ forward = false; }
							break;
						case k.RIGHT_ARROW:
						case k.DOWN_ARROW:
							if(!e._djpage){ forward = true; }
							break;
						case k.PAGE_DOWN:
							if(e.ctrlKey){ forward = true; }
							break;
						case k.HOME:
						case k.END:
							var children = this.getChildren();
							if(children && children.length){
								children[e.charOrCode == k.HOME ? 0 : children.length-1].onClick();
							}
							dojo.stopEvent(e);
							break;
						case k.DELETE:
							if(this._currentChild.closable){
								this.onCloseButtonClick(this._currentChild);
							}
							dojo.stopEvent(e);
							break;
						default:
							if(e.ctrlKey){
								if(e.charOrCode === k.TAB){
									this.adjacent(!e.shiftKey).onClick();
									dojo.stopEvent(e);
								}else if(e.charOrCode == "w"){
									if(this._currentChild.closable){
										this.onCloseButtonClick(this._currentChild);
									}
									dojo.stopEvent(e); // avoid browser tab closing.
								}
							}
					}
					// handle next/previous page navigation (left/right arrow, etc.)
					if(forward !== null){
						this.adjacent(forward).onClick();
						dojo.stopEvent(e);
					}
				}
			},

			onContainerKeyPress: function(/*Object*/ info){
				// summary:
				//		Called when there was a keypress on the container
				// tags:
				//		private
				info.e._djpage = info.page;
				this.onkeypress(info.e);
			}
	});


dojo.declare("dijit.layout._StackButton",
		dijit.form.ToggleButton,
		{
		// summary:
		//		Internal widget used by StackContainer.
		// description:
		//		The button-like or tab-like object you click to select or delete a page
		// tags:
		//		private

		// Override _FormWidget.tabIndex.
		// StackContainer buttons are not in the tab order by default.
		// Probably we should be calling this.startupKeyNavChildren() instead.
		tabIndex: "-1",

		buildRendering: function(/*Event*/ evt){
			this.inherited(arguments);
			dijit.setWaiRole((this.focusNode || this.domNode), "tab");
		},

		onClick: function(/*Event*/ evt){
			// summary:
			//		This is for TabContainer where the tabs are <span> rather than button,
			//		so need to set focus explicitly (on some browsers)
			//		Note that you shouldn't override this method, but you can connect to it.
			dijit.focus(this.focusNode);

			// ... now let StackController catch the event and tell me what to do
		},

		onClickCloseButton: function(/*Event*/ evt){
			// summary:
			//		StackContainer connects to this function; if your widget contains a close button
			//		then clicking it should call this function.
			//		Note that you shouldn't override this method, but you can connect to it.
			evt.stopPropagation();
		}
	});

}

if(!dojo._hasResource["dijit.layout.StackContainer"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.layout.StackContainer"] = true;
dojo.provide("dijit.layout.StackContainer");







dojo.declare(
	"dijit.layout.StackContainer",
	dijit.layout._LayoutWidget,
	{
	// summary:
	//		A container that has multiple children, but shows only
	//		one child at a time
	//
	// description:
	//		A container for widgets (ContentPanes, for example) That displays
	//		only one Widget at a time.
	//
	//		Publishes topics [widgetId]-addChild, [widgetId]-removeChild, and [widgetId]-selectChild
	//
	//		Can be base class for container, Wizard, Show, etc.

	// doLayout: Boolean
	//		If true, change the size of my currently displayed child to match my size
	doLayout: true,

	// persist: Boolean
	//		Remembers the selected child across sessions
	persist: false,

	baseClass: "dijitStackContainer",

/*=====
	// selectedChildWidget: [readonly] dijit._Widget
	//		References the currently selected child widget, if any.
	//		Adjust selected child with selectChild() method.
	selectedChildWidget: null,
=====*/

	buildRendering: function(){
		this.inherited(arguments);
		dojo.addClass(this.domNode, "dijitLayoutContainer");
		dijit.setWaiRole(this.containerNode, "tabpanel");
	},

	postCreate: function(){
		this.inherited(arguments);
		this.connect(this.domNode, "onkeypress", this._onKeyPress);
	},

	startup: function(){
		if(this._started){ return; }

		var children = this.getChildren();

		// Setup each page panel to be initially hidden
		dojo.forEach(children, this._setupChild, this);

		// Figure out which child to initially display, defaulting to first one
		if(this.persist){
			this.selectedChildWidget = dijit.byId(dojo.cookie(this.id + "_selectedChild"));
		}else{
			dojo.some(children, function(child){
				if(child.selected){
					this.selectedChildWidget = child;
				}
				return child.selected;
			}, this);
		}
		var selected = this.selectedChildWidget;
		if(!selected && children[0]){
			selected = this.selectedChildWidget = children[0];
			selected.selected = true;
		}

		// Publish information about myself so any StackControllers can initialize.
		// This needs to happen before this.inherited(arguments) so that for
		// TabContainer, this._contentBox doesn't include the space for the tab labels.
		dojo.publish(this.id+"-startup", [{children: children, selected: selected}]);

		// Startup each child widget, and do initial layout like setting this._contentBox,
		// then calls this.resize() which does the initial sizing on the selected child.
		this.inherited(arguments);
	},

	resize: function(){
		// Resize is called when we are first made visible (it's called from startup()
		// if we are initially visible).   If this is the first time we've been made
		// visible then show our first child.
		var selected = this.selectedChildWidget;
		if(selected && !this._hasBeenShown){
			this._hasBeenShown = true;
			this._showChild(selected);
		}
		this.inherited(arguments);
	},

	_setupChild: function(/*dijit._Widget*/ child){
		// Overrides _LayoutWidget._setupChild()

		this.inherited(arguments);

		dojo.replaceClass(child.domNode, "dijitHidden", "dijitVisible");

		// remove the title attribute so it doesn't show up when i hover
		// over a node
		child.domNode.title = "";
	},

	addChild: function(/*dijit._Widget*/ child, /*Integer?*/ insertIndex){
		// Overrides _Container.addChild() to do layout and publish events

		this.inherited(arguments);

		if(this._started){
			dojo.publish(this.id+"-addChild", [child, insertIndex]);

			// in case the tab titles have overflowed from one line to two lines
			// (or, if this if first child, from zero lines to one line)
			// TODO: w/ScrollingTabController this is no longer necessary, although
			// ScrollTabController.resize() does need to get called to show/hide
			// the navigation buttons as appropriate, but that's handled in ScrollingTabController.onAddChild()
			this.layout();

			// if this is the first child, then select it
			if(!this.selectedChildWidget){
				this.selectChild(child);
			}
		}
	},

	removeChild: function(/*dijit._Widget*/ page){
		// Overrides _Container.removeChild() to do layout and publish events

		this.inherited(arguments);

		if(this._started){
			// this will notify any tablists to remove a button; do this first because it may affect sizing
			dojo.publish(this.id + "-removeChild", [page]);
		}

		// If we are being destroyed than don't run the code below (to select another page), because we are deleting
		// every page one by one
		if(this._beingDestroyed){ return; }

		// Select new page to display, also updating TabController to show the respective tab.
		// Do this before layout call because it can affect the height of the TabController.
		if(this.selectedChildWidget === page){
			this.selectedChildWidget = undefined;
			if(this._started){
				var children = this.getChildren();
				if(children.length){
					this.selectChild(children[0]);
				}
			}
		}

		if(this._started){
			// In case the tab titles now take up one line instead of two lines
			// (note though that ScrollingTabController never overflows to multiple lines),
			// or the height has changed slightly because of addition/removal of tab which close icon
			this.layout();
		}
	},

	selectChild: function(/*dijit._Widget|String*/ page, /*Boolean*/ animate){
		// summary:
		//		Show the given widget (which must be one of my children)
		// page:
		//		Reference to child widget or id of child widget

		page = dijit.byId(page);

		if(this.selectedChildWidget != page){
			// Deselect old page and select new one
			var d = this._transition(page, this.selectedChildWidget, animate);
			this._set("selectedChildWidget", page);
			dojo.publish(this.id+"-selectChild", [page]);

			if(this.persist){
				dojo.cookie(this.id + "_selectedChild", this.selectedChildWidget.id);
			}
		}

		return d;		// If child has an href, promise that fires when the child's href finishes loading
	},

	_transition: function(/*dijit._Widget*/ newWidget, /*dijit._Widget*/ oldWidget, /*Boolean*/ animate){
		// summary:
		//		Hide the old widget and display the new widget.
		//		Subclasses should override this.
		// tags:
		//		protected extension
		if(oldWidget){
			this._hideChild(oldWidget);
		}
		var d = this._showChild(newWidget);

		// Size the new widget, in case this is the first time it's being shown,
		// or I have been resized since the last time it was shown.
		// Note that page must be visible for resizing to work.
		if(newWidget.resize){
			if(this.doLayout){
				newWidget.resize(this._containerContentBox || this._contentBox);
			}else{
				// the child should pick it's own size but we still need to call resize()
				// (with no arguments) to let the widget lay itself out
				newWidget.resize();
			}
		}

		return d;	// If child has an href, promise that fires when the child's href finishes loading
	},

	_adjacent: function(/*Boolean*/ forward){
		// summary:
		//		Gets the next/previous child widget in this container from the current selection.
		var children = this.getChildren();
		var index = dojo.indexOf(children, this.selectedChildWidget);
		index += forward ? 1 : children.length - 1;
		return children[ index % children.length ]; // dijit._Widget
	},

	forward: function(){
		// summary:
		//		Advance to next page.
		return this.selectChild(this._adjacent(true), true);
	},

	back: function(){
		// summary:
		//		Go back to previous page.
		return this.selectChild(this._adjacent(false), true);
	},

	_onKeyPress: function(e){
		dojo.publish(this.id+"-containerKeyPress", [{ e: e, page: this}]);
	},

	layout: function(){
		// Implement _LayoutWidget.layout() virtual method.
		if(this.doLayout && this.selectedChildWidget && this.selectedChildWidget.resize){
			this.selectedChildWidget.resize(this._containerContentBox || this._contentBox);
		}
	},

	_showChild: function(/*dijit._Widget*/ page){
		// summary:
		//		Show the specified child by changing it's CSS, and call _onShow()/onShow() so
		//		it can do any updates it needs regarding loading href's etc.
		// returns:
		//		Promise that fires when page has finished showing, or true if there's no href
		var children = this.getChildren();
		page.isFirstChild = (page == children[0]);
		page.isLastChild = (page == children[children.length-1]);
		page._set("selected", true);

		dojo.replaceClass(page.domNode, "dijitVisible", "dijitHidden");

		return page._onShow() || true;
	},

	_hideChild: function(/*dijit._Widget*/ page){
		// summary:
		//		Hide the specified child by changing it's CSS, and call _onHide() so
		//		it's notified.
		page._set("selected", false);
		dojo.replaceClass(page.domNode, "dijitHidden", "dijitVisible");

		page.onHide();
	},

	closeChild: function(/*dijit._Widget*/ page){
		// summary:
		//		Callback when user clicks the [X] to remove a page.
		//		If onClose() returns true then remove and destroy the child.
		// tags:
		//		private
		var remove = page.onClose(this, page);
		if(remove){
			this.removeChild(page);
			// makes sure we can clean up executeScripts in ContentPane onUnLoad
			page.destroyRecursive();
		}
	},

	destroyDescendants: function(/*Boolean*/ preserveDom){
		dojo.forEach(this.getChildren(), function(child){
			this.removeChild(child);
			child.destroyRecursive(preserveDom);
		}, this);
	}
});

// For back-compat, remove for 2.0


// These arguments can be specified for the children of a StackContainer.
// Since any widget can be specified as a StackContainer child, mix them
// into the base widget class.  (This is a hack, but it's effective.)
dojo.extend(dijit._Widget, {
	// selected: Boolean
	//		Parameter for children of `dijit.layout.StackContainer` or subclasses.
	//		Specifies that this widget should be the initially displayed pane.
	//		Note: to change the selected child use `dijit.layout.StackContainer.selectChild`
	selected: false,

	// closable: Boolean
	//		Parameter for children of `dijit.layout.StackContainer` or subclasses.
	//		True if user can close (destroy) this child, such as (for example) clicking the X on the tab.
	closable: false,

	// iconClass: String
	//		Parameter for children of `dijit.layout.StackContainer` or subclasses.
	//		CSS Class specifying icon to use in label associated with this pane.
	iconClass: "",

	// showTitle: Boolean
	//		Parameter for children of `dijit.layout.StackContainer` or subclasses.
	//		When true, display title of this widget as tab label etc., rather than just using
	//		icon specified in iconClass
	showTitle: true
});

}

if(!dojo._hasResource["dijit.layout._TabContainerBase"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.layout._TabContainerBase"] = true;
dojo.provide("dijit.layout._TabContainerBase");




dojo.declare("dijit.layout._TabContainerBase",
	[dijit.layout.StackContainer, dijit._Templated],
	{
	// summary:
	//		Abstract base class for TabContainer.   Must define _makeController() to instantiate
	//		and return the widget that displays the tab labels
	// description:
	//		A TabContainer is a container that has multiple panes, but shows only
	//		one pane at a time.  There are a set of tabs corresponding to each pane,
	//		where each tab has the name (aka title) of the pane, and optionally a close button.

	// tabPosition: String
	//		Defines where tabs go relative to tab content.
	//		"top", "bottom", "left-h", "right-h"
	tabPosition: "top",

	baseClass: "dijitTabContainer",

	// tabStrip: [const] Boolean
	//		Defines whether the tablist gets an extra class for layouting, putting a border/shading
	//		around the set of tabs.   Not supported by claro theme.
	tabStrip: false,

	// nested: [const] Boolean
	//		If true, use styling for a TabContainer nested inside another TabContainer.
	//		For tundra etc., makes tabs look like links, and hides the outer
	//		border since the outer TabContainer already has a border.
	nested: false,

	templateString: dojo.cache("dijit.layout", "templates/TabContainer.html", "<div class=\"dijitTabContainer\">\n\t<div class=\"dijitTabListWrapper\" dojoAttachPoint=\"tablistNode\"></div>\n\t<div dojoAttachPoint=\"tablistSpacer\" class=\"dijitTabSpacer ${baseClass}-spacer\"></div>\n\t<div class=\"dijitTabPaneWrapper ${baseClass}-container\" dojoAttachPoint=\"containerNode\"></div>\n</div>\n"),

	postMixInProperties: function(){
		// set class name according to tab position, ex: dijitTabContainerTop
		this.baseClass += this.tabPosition.charAt(0).toUpperCase() + this.tabPosition.substr(1).replace(/-.*/, "");

		this.srcNodeRef && dojo.style(this.srcNodeRef, "visibility", "hidden");

		this.inherited(arguments);
	},

	buildRendering: function(){
		this.inherited(arguments);

		// Create the tab list that will have a tab (a.k.a. tab button) for each tab panel
		this.tablist = this._makeController(this.tablistNode);

		if(!this.doLayout){ dojo.addClass(this.domNode, "dijitTabContainerNoLayout"); }

		if(this.nested){
			/* workaround IE's lack of support for "a > b" selectors by
			 * tagging each node in the template.
			 */
			dojo.addClass(this.domNode, "dijitTabContainerNested");
			dojo.addClass(this.tablist.containerNode, "dijitTabContainerTabListNested");
			dojo.addClass(this.tablistSpacer, "dijitTabContainerSpacerNested");
			dojo.addClass(this.containerNode, "dijitTabPaneWrapperNested");
		}else{
			dojo.addClass(this.domNode, "tabStrip-" + (this.tabStrip ? "enabled" : "disabled"));
		}
	},

	_setupChild: function(/*dijit._Widget*/ tab){
		// Overrides StackContainer._setupChild().
		dojo.addClass(tab.domNode, "dijitTabPane");
		this.inherited(arguments);
	},

	startup: function(){
		if(this._started){ return; }

		// wire up the tablist and its tabs
		this.tablist.startup();

		this.inherited(arguments);
	},

	layout: function(){
		// Overrides StackContainer.layout().
		// Configure the content pane to take up all the space except for where the tabs are

		if(!this._contentBox || typeof(this._contentBox.l) == "undefined"){return;}

		var sc = this.selectedChildWidget;

		if(this.doLayout){
			// position and size the titles and the container node
			var titleAlign = this.tabPosition.replace(/-h/, "");
			this.tablist.layoutAlign = titleAlign;
			var children = [this.tablist, {
				domNode: this.tablistSpacer,
				layoutAlign: titleAlign
			}, {
				domNode: this.containerNode,
				layoutAlign: "client"
			}];
			dijit.layout.layoutChildren(this.domNode, this._contentBox, children);

			// Compute size to make each of my children.
			// children[2] is the margin-box size of this.containerNode, set by layoutChildren() call above
			this._containerContentBox = dijit.layout.marginBox2contentBox(this.containerNode, children[2]);

			if(sc && sc.resize){
				sc.resize(this._containerContentBox);
			}
		}else{
			// just layout the tab controller, so it can position left/right buttons etc.
			if(this.tablist.resize){
				//make the tabs zero width so that they don't interfere with width calc, then reset
				var s = this.tablist.domNode.style;
				s.width="0";
				var width = dojo.contentBox(this.domNode).w;
				s.width="";
				this.tablist.resize({w: width});
			}

			// and call resize() on the selected pane just to tell it that it's been made visible
			if(sc && sc.resize){
				sc.resize();
			}
		}
	},

	destroy: function(){
		if(this.tablist){
			this.tablist.destroy();
		}
		this.inherited(arguments);
	}
});

}

if(!dojo._hasResource["dijit.MenuItem"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.MenuItem"] = true;
dojo.provide("dijit.MenuItem");






dojo.declare("dijit.MenuItem",
		[dijit._Widget, dijit._Templated, dijit._Contained, dijit._CssStateMixin],
		{
		// summary:
		//		A line item in a Menu Widget

		// Make 3 columns
		// icon, label, and expand arrow (BiDi-dependent) indicating sub-menu
		templateString: dojo.cache("dijit", "templates/MenuItem.html", "<tr class=\"dijitReset dijitMenuItem\" dojoAttachPoint=\"focusNode\" role=\"menuitem\" tabIndex=\"-1\"\n\t\tdojoAttachEvent=\"onmouseenter:_onHover,onmouseleave:_onUnhover,ondijitclick:_onClick\">\n\t<td class=\"dijitReset dijitMenuItemIconCell\" role=\"presentation\">\n\t\t<img src=\"${_blankGif}\" alt=\"\" class=\"dijitIcon dijitMenuItemIcon\" dojoAttachPoint=\"iconNode\"/>\n\t</td>\n\t<td class=\"dijitReset dijitMenuItemLabel\" colspan=\"2\" dojoAttachPoint=\"containerNode\"></td>\n\t<td class=\"dijitReset dijitMenuItemAccelKey\" style=\"display: none\" dojoAttachPoint=\"accelKeyNode\"></td>\n\t<td class=\"dijitReset dijitMenuArrowCell\" role=\"presentation\">\n\t\t<div dojoAttachPoint=\"arrowWrapper\" style=\"visibility: hidden\">\n\t\t\t<img src=\"${_blankGif}\" alt=\"\" class=\"dijitMenuExpand\"/>\n\t\t\t<span class=\"dijitMenuExpandA11y\">+</span>\n\t\t</div>\n\t</td>\n</tr>\n"),

		attributeMap: dojo.delegate(dijit._Widget.prototype.attributeMap, {
			label: { node: "containerNode", type: "innerHTML" },
			iconClass: { node: "iconNode", type: "class" }
		}),

		baseClass: "dijitMenuItem",

		// label: String
		//		Menu text
		label: '',

		// iconClass: String
		//		Class to apply to DOMNode to make it display an icon.
		iconClass: "",

		// accelKey: String
		//		Text for the accelerator (shortcut) key combination.
		//		Note that although Menu can display accelerator keys there
		//		is no infrastructure to actually catch and execute these
		//		accelerators.
		accelKey: "",

		// disabled: Boolean
		//		If true, the menu item is disabled.
		//		If false, the menu item is enabled.
		disabled: false,

		_fillContent: function(/*DomNode*/ source){
			// If button label is specified as srcNodeRef.innerHTML rather than
			// this.params.label, handle it here.
			if(source && !("label" in this.params)){
				this.set('label', source.innerHTML);
			}
		},

		buildRendering: function(){
			this.inherited(arguments);
			var label = this.id+"_text";
			dojo.attr(this.containerNode, "id", label);
			if(this.accelKeyNode){
				dojo.attr(this.accelKeyNode, "id", this.id + "_accel");
				label += " " + this.id + "_accel";
			}
			dijit.setWaiState(this.domNode, "labelledby", label);
			dojo.setSelectable(this.domNode, false);
		},

		_onHover: function(){
			// summary:
			//		Handler when mouse is moved onto menu item
			// tags:
			//		protected
			this.getParent().onItemHover(this);
		},

		_onUnhover: function(){
			// summary:
			//		Handler when mouse is moved off of menu item,
			//		possibly to a child menu, or maybe to a sibling
			//		menuitem or somewhere else entirely.
			// tags:
			//		protected

			// if we are unhovering the currently selected item
			// then unselect it
			this.getParent().onItemUnhover(this);

			// When menu is hidden (collapsed) due to clicking a MenuItem and having it execute,
			// FF and IE don't generate an onmouseout event for the MenuItem.
			// So, help out _CssStateMixin in this case.
			this._set("hovering", false);
		},

		_onClick: function(evt){
			// summary:
			//		Internal handler for click events on MenuItem.
			// tags:
			//		private
			this.getParent().onItemClick(this, evt);
			dojo.stopEvent(evt);
		},

		onClick: function(/*Event*/ evt){
			// summary:
			//		User defined function to handle clicks
			// tags:
			//		callback
		},

		focus: function(){
			// summary:
			//		Focus on this MenuItem
			try{
				if(dojo.isIE == 8){
					// needed for IE8 which won't scroll TR tags into view on focus yet calling scrollIntoView creates flicker (#10275)
					this.containerNode.focus();
				}
				dijit.focus(this.focusNode);
			}catch(e){
				// this throws on IE (at least) in some scenarios
			}
		},

		_onFocus: function(){
			// summary:
			//		This is called by the focus manager when focus
			//		goes to this MenuItem or a child menu.
			// tags:
			//		protected
			this._setSelected(true);
			this.getParent()._onItemFocus(this);

			this.inherited(arguments);
		},

		_setSelected: function(selected){
			// summary:
			//		Indicate that this node is the currently selected one
			// tags:
			//		private

			/***
			 * TODO: remove this method and calls to it, when _onBlur() is working for MenuItem.
			 * Currently _onBlur() gets called when focus is moved from the MenuItem to a child menu.
			 * That's not supposed to happen, but the problem is:
			 * In order to allow dijit.popup's getTopPopup() to work,a sub menu's popupParent
			 * points to the parent Menu, bypassing the parent MenuItem... thus the
			 * MenuItem is not in the chain of active widgets and gets a premature call to
			 * _onBlur()
			 */

			dojo.toggleClass(this.domNode, "dijitMenuItemSelected", selected);
		},

		setLabel: function(/*String*/ content){
			// summary:
			//		Deprecated.   Use set('label', ...) instead.
			// tags:
			//		deprecated
			dojo.deprecated("dijit.MenuItem.setLabel() is deprecated.  Use set('label', ...) instead.", "", "2.0");
			this.set("label", content);
		},

		setDisabled: function(/*Boolean*/ disabled){
			// summary:
			//		Deprecated.   Use set('disabled', bool) instead.
			// tags:
			//		deprecated
			dojo.deprecated("dijit.Menu.setDisabled() is deprecated.  Use set('disabled', bool) instead.", "", "2.0");
			this.set('disabled', disabled);
		},
		_setDisabledAttr: function(/*Boolean*/ value){
			// summary:
			//		Hook for attr('disabled', ...) to work.
			//		Enable or disable this menu item.

			dijit.setWaiState(this.focusNode, 'disabled', value ? 'true' : 'false');
			this._set("disabled", value);
		},
		_setAccelKeyAttr: function(/*String*/ value){
			// summary:
			//		Hook for attr('accelKey', ...) to work.
			//		Set accelKey on this menu item.

			this.accelKeyNode.style.display=value?"":"none";
			this.accelKeyNode.innerHTML=value;
			//have to use colSpan to make it work in IE
			dojo.attr(this.containerNode,'colSpan',value?"1":"2");
			
			this._set("accelKey", value);
		}
	});

}

if(!dojo._hasResource["dijit.PopupMenuItem"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.PopupMenuItem"] = true;
dojo.provide("dijit.PopupMenuItem");



dojo.declare("dijit.PopupMenuItem",
		dijit.MenuItem,
		{
		_fillContent: function(){
			// summary:
			//		When Menu is declared in markup, this code gets the menu label and
			//		the popup widget from the srcNodeRef.
			// description:
			//		srcNodeRefinnerHTML contains both the menu item text and a popup widget
			//		The first part holds the menu item text and the second part is the popup
			// example:
			// |	<div dojoType="dijit.PopupMenuItem">
			// |		<span>pick me</span>
			// |		<popup> ... </popup>
			// |	</div>
			// tags:
			//		protected

			if(this.srcNodeRef){
				var nodes = dojo.query("*", this.srcNodeRef);
				dijit.PopupMenuItem.superclass._fillContent.call(this, nodes[0]);

				// save pointer to srcNode so we can grab the drop down widget after it's instantiated
				this.dropDownContainer = this.srcNodeRef;
			}
		},

		startup: function(){
			if(this._started){ return; }
			this.inherited(arguments);

			// we didn't copy the dropdown widget from the this.srcNodeRef, so it's in no-man's
			// land now.  move it to dojo.doc.body.
			if(!this.popup){
				var node = dojo.query("[widgetId]", this.dropDownContainer)[0];
				this.popup = dijit.byNode(node);
			}
			dojo.body().appendChild(this.popup.domNode);
			this.popup.startup();

			this.popup.domNode.style.display="none";
			if(this.arrowWrapper){
				dojo.style(this.arrowWrapper, "visibility", "");
			}
			dijit.setWaiState(this.focusNode, "haspopup", "true");
		},

		destroyDescendants: function(){
			if(this.popup){
				// Destroy the popup, unless it's already been destroyed.  This can happen because
				// the popup is a direct child of <body> even though it's logically my child.
				if(!this.popup._destroyed){
					this.popup.destroyRecursive();
				}
				delete this.popup;
			}
			this.inherited(arguments);
		}
	});

}

if(!dojo._hasResource["dijit.CheckedMenuItem"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.CheckedMenuItem"] = true;
dojo.provide("dijit.CheckedMenuItem");



dojo.declare("dijit.CheckedMenuItem",
		dijit.MenuItem,
		{
		// summary:
		//		A checkbox-like menu item for toggling on and off

		templateString: dojo.cache("dijit", "templates/CheckedMenuItem.html", "<tr class=\"dijitReset dijitMenuItem\" dojoAttachPoint=\"focusNode\" role=\"menuitemcheckbox\" tabIndex=\"-1\"\n\t\tdojoAttachEvent=\"onmouseenter:_onHover,onmouseleave:_onUnhover,ondijitclick:_onClick\">\n\t<td class=\"dijitReset dijitMenuItemIconCell\" role=\"presentation\">\n\t\t<img src=\"${_blankGif}\" alt=\"\" class=\"dijitMenuItemIcon dijitCheckedMenuItemIcon\" dojoAttachPoint=\"iconNode\"/>\n\t\t<span class=\"dijitCheckedMenuItemIconChar\">&#10003;</span>\n\t</td>\n\t<td class=\"dijitReset dijitMenuItemLabel\" colspan=\"2\" dojoAttachPoint=\"containerNode,labelNode\"></td>\n\t<td class=\"dijitReset dijitMenuItemAccelKey\" style=\"display: none\" dojoAttachPoint=\"accelKeyNode\"></td>\n\t<td class=\"dijitReset dijitMenuArrowCell\" role=\"presentation\">&nbsp;</td>\n</tr>\n"),

		// checked: Boolean
		//		Our checked state
		checked: false,
		_setCheckedAttr: function(/*Boolean*/ checked){
			// summary:
			//		Hook so attr('checked', bool) works.
			//		Sets the class and state for the check box.
			dojo.toggleClass(this.domNode, "dijitCheckedMenuItemChecked", checked);
			dijit.setWaiState(this.domNode, "checked", checked);
			this._set("checked", checked);
		},

		onChange: function(/*Boolean*/ checked){
			// summary:
			//		User defined function to handle check/uncheck events
			// tags:
			//		callback
		},

		_onClick: function(/*Event*/ e){
			// summary:
			//		Clicking this item just toggles its state
			// tags:
			//		private
			if(!this.disabled){
				this.set("checked", !this.checked);
				this.onChange(this.checked);
			}
			this.inherited(arguments);
		}
	});

}

if(!dojo._hasResource["dijit.MenuSeparator"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.MenuSeparator"] = true;
dojo.provide("dijit.MenuSeparator");





dojo.declare("dijit.MenuSeparator",
		[dijit._Widget, dijit._Templated, dijit._Contained],
		{
		// summary:
		//		A line between two menu items

		templateString: dojo.cache("dijit", "templates/MenuSeparator.html", "<tr class=\"dijitMenuSeparator\">\n\t<td class=\"dijitMenuSeparatorIconCell\">\n\t\t<div class=\"dijitMenuSeparatorTop\"></div>\n\t\t<div class=\"dijitMenuSeparatorBottom\"></div>\n\t</td>\n\t<td colspan=\"3\" class=\"dijitMenuSeparatorLabelCell\">\n\t\t<div class=\"dijitMenuSeparatorTop dijitMenuSeparatorLabel\"></div>\n\t\t<div class=\"dijitMenuSeparatorBottom\"></div>\n\t</td>\n</tr>\n"),

		buildRendering: function(){
			this.inherited(arguments);
			dojo.setSelectable(this.domNode, false);
		},

		isFocusable: function(){
			// summary:
			//		Override to always return false
			// tags:
			//		protected

			return false; // Boolean
		}
	});

}

if(!dojo._hasResource["dijit.Menu"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.Menu"] = true;
dojo.provide("dijit.Menu");










// "dijit/MenuItem", "dijit/PopupMenuItem", "dijit/CheckedMenuItem", "dijit/MenuSeparator" for Back-compat (TODO: remove in 2.0)

dojo.declare("dijit._MenuBase",
	[dijit._Widget, dijit._Templated, dijit._KeyNavContainer],
{
	// summary:
	//		Base class for Menu and MenuBar

	// parentMenu: [readonly] Widget
	//		pointer to menu that displayed me
	parentMenu: null,

	// popupDelay: Integer
	//		number of milliseconds before hovering (without clicking) causes the popup to automatically open.
	popupDelay: 500,

	startup: function(){
		if(this._started){ return; }

		dojo.forEach(this.getChildren(), function(child){ child.startup(); });
		this.startupKeyNavChildren();

		this.inherited(arguments);
	},

	onExecute: function(){
		// summary:
		//		Attach point for notification about when a menu item has been executed.
		//		This is an internal mechanism used for Menus to signal to their parent to
		//		close them, because they are about to execute the onClick handler.   In
		//		general developers should not attach to or override this method.
		// tags:
		//		protected
	},

	onCancel: function(/*Boolean*/ closeAll){
		// summary:
		//		Attach point for notification about when the user cancels the current menu
		//		This is an internal mechanism used for Menus to signal to their parent to
		//		close them.  In general developers should not attach to or override this method.
		// tags:
		//		protected
	},

	_moveToPopup: function(/*Event*/ evt){
		// summary:
		//		This handles the right arrow key (left arrow key on RTL systems),
		//		which will either open a submenu, or move to the next item in the
		//		ancestor MenuBar
		// tags:
		//		private

		if(this.focusedChild && this.focusedChild.popup && !this.focusedChild.disabled){
			this.focusedChild._onClick(evt);
		}else{
			var topMenu = this._getTopMenu();
			if(topMenu && topMenu._isMenuBar){
				topMenu.focusNext();
			}
		}
	},

	_onPopupHover: function(/*Event*/ evt){
		// summary:
		//		This handler is called when the mouse moves over the popup.
		// tags:
		//		private

		// if the mouse hovers over a menu popup that is in pending-close state,
		// then stop the close operation.
		// This can't be done in onItemHover since some popup targets don't have MenuItems (e.g. ColorPicker)
		if(this.currentPopup && this.currentPopup._pendingClose_timer){
			var parentMenu = this.currentPopup.parentMenu;
			// highlight the parent menu item pointing to this popup
			if(parentMenu.focusedChild){
				parentMenu.focusedChild._setSelected(false);
			}
			parentMenu.focusedChild = this.currentPopup.from_item;
			parentMenu.focusedChild._setSelected(true);
			// cancel the pending close
			this._stopPendingCloseTimer(this.currentPopup);
		}
	},

	onItemHover: function(/*MenuItem*/ item){
		// summary:
		//		Called when cursor is over a MenuItem.
		// tags:
		//		protected

		// Don't do anything unless user has "activated" the menu by:
		//		1) clicking it
		//		2) opening it from a parent menu (which automatically focuses it)
		if(this.isActive){
			this.focusChild(item);
			if(this.focusedChild.popup && !this.focusedChild.disabled && !this.hover_timer){
				this.hover_timer = setTimeout(dojo.hitch(this, "_openPopup"), this.popupDelay);
			}
		}
		// if the user is mixing mouse and keyboard navigation,
		// then the menu may not be active but a menu item has focus,
		// but it's not the item that the mouse just hovered over.
		// To avoid both keyboard and mouse selections, use the latest.
		if(this.focusedChild){
			this.focusChild(item);
		}
		this._hoveredChild = item;
	},

	_onChildBlur: function(item){
		// summary:
		//		Called when a child MenuItem becomes inactive because focus
		//		has been removed from the MenuItem *and* it's descendant menus.
		// tags:
		//		private
		this._stopPopupTimer();
		item._setSelected(false);
		// Close all popups that are open and descendants of this menu
		var itemPopup = item.popup;
		if(itemPopup){
			this._stopPendingCloseTimer(itemPopup);
			itemPopup._pendingClose_timer = setTimeout(function(){
				itemPopup._pendingClose_timer = null;
				if(itemPopup.parentMenu){
					itemPopup.parentMenu.currentPopup = null;
				}
				dijit.popup.close(itemPopup); // this calls onClose
			}, this.popupDelay);
		}
	},

	onItemUnhover: function(/*MenuItem*/ item){
		// summary:
		//		Callback fires when mouse exits a MenuItem
		// tags:
		//		protected

		if(this.isActive){
			this._stopPopupTimer();
		}
		if(this._hoveredChild == item){ this._hoveredChild = null; }
	},

	_stopPopupTimer: function(){
		// summary:
		//		Cancels the popup timer because the user has stop hovering
		//		on the MenuItem, etc.
		// tags:
		//		private
		if(this.hover_timer){
			clearTimeout(this.hover_timer);
			this.hover_timer = null;
		}
	},

	_stopPendingCloseTimer: function(/*dijit._Widget*/ popup){
		// summary:
		//		Cancels the pending-close timer because the close has been preempted
		// tags:
		//		private
		if(popup._pendingClose_timer){
			clearTimeout(popup._pendingClose_timer);
			popup._pendingClose_timer = null;
		}
	},

	_stopFocusTimer: function(){
		// summary:
		//		Cancels the pending-focus timer because the menu was closed before focus occured
		// tags:
		//		private
		if(this._focus_timer){
			clearTimeout(this._focus_timer);
			this._focus_timer = null;
		}
	},

	_getTopMenu: function(){
		// summary:
		//		Returns the top menu in this chain of Menus
		// tags:
		//		private
		for(var top=this; top.parentMenu; top=top.parentMenu);
		return top;
	},

	onItemClick: function(/*dijit._Widget*/ item, /*Event*/ evt){
		// summary:
		//		Handle clicks on an item.
		// tags:
		//		private

		// this can't be done in _onFocus since the _onFocus events occurs asynchronously
		if(typeof this.isShowingNow == 'undefined'){ // non-popup menu
			this._markActive();
		}

		this.focusChild(item);

		if(item.disabled){ return false; }

		if(item.popup){
			this._openPopup();
		}else{
			// before calling user defined handler, close hierarchy of menus
			// and restore focus to place it was when menu was opened
			this.onExecute();

			// user defined handler for click
			item.onClick(evt);
		}
	},

	_openPopup: function(){
		// summary:
		//		Open the popup to the side of/underneath the current menu item
		// tags:
		//		protected

		this._stopPopupTimer();
		var from_item = this.focusedChild;
		if(!from_item){ return; } // the focused child lost focus since the timer was started
		var popup = from_item.popup;
		if(popup.isShowingNow){ return; }
		if(this.currentPopup){
			this._stopPendingCloseTimer(this.currentPopup);
			dijit.popup.close(this.currentPopup);
		}
		popup.parentMenu = this;
		popup.from_item = from_item; // helps finding the parent item that should be focused for this popup
		var self = this;
		dijit.popup.open({
			parent: this,
			popup: popup,
			around: from_item.domNode,
			orient: this._orient || (this.isLeftToRight() ?
									{'TR': 'TL', 'TL': 'TR', 'BR': 'BL', 'BL': 'BR'} :
									{'TL': 'TR', 'TR': 'TL', 'BL': 'BR', 'BR': 'BL'}),
			onCancel: function(){ // called when the child menu is canceled
				// set isActive=false (_closeChild vs _cleanUp) so that subsequent hovering will NOT open child menus
				// which seems aligned with the UX of most applications (e.g. notepad, wordpad, paint shop pro)
				self.focusChild(from_item);	// put focus back on my node
				self._cleanUp();			// close the submenu (be sure this is done _after_ focus is moved)
				from_item._setSelected(true); // oops, _cleanUp() deselected the item
				self.focusedChild = from_item;	// and unset focusedChild
			},
			onExecute: dojo.hitch(this, "_cleanUp")
		});

		this.currentPopup = popup;
		// detect mouseovers to handle lazy mouse movements that temporarily focus other menu items
		popup.connect(popup.domNode, "onmouseenter", dojo.hitch(self, "_onPopupHover")); // cleaned up when the popped-up widget is destroyed on close

		if(popup.focus){
			// If user is opening the popup via keyboard (right arrow, or down arrow for MenuBar),
			// if the cursor happens to collide with the popup, it will generate an onmouseover event
			// even though the mouse wasn't moved.   Use a setTimeout() to call popup.focus so that
			// our focus() call overrides the onmouseover event, rather than vice-versa.  (#8742)
			popup._focus_timer = setTimeout(dojo.hitch(popup, function(){
				this._focus_timer = null;
				this.focus();
			}), 0);
		}
	},

	_markActive: function(){
		// summary:
		//              Mark this menu's state as active.
		//		Called when this Menu gets focus from:
		//			1) clicking it (mouse or via space/arrow key)
		//			2) being opened by a parent menu.
		//		This is not called just from mouse hover.
		//		Focusing a menu via TAB does NOT automatically set isActive
		//		since TAB is a navigation operation and not a selection one.
		//		For Windows apps, pressing the ALT key focuses the menubar
		//		menus (similar to TAB navigation) but the menu is not active
		//		(ie no dropdown) until an item is clicked.
		this.isActive = true;
		dojo.replaceClass(this.domNode, "dijitMenuActive", "dijitMenuPassive");
	},

	onOpen: function(/*Event*/ e){
		// summary:
		//		Callback when this menu is opened.
		//		This is called by the popup manager as notification that the menu
		//		was opened.
		// tags:
		//		private

		console.log("dijit.Menu.onOpen");

		this.isShowingNow = true;
		this._markActive();
	},

	_markInactive: function(){
	
		console.log("dijit.Menu._markInactive");

		// summary:
		//		Mark this menu's state as inactive.
		this.isActive = false; // don't do this in _onBlur since the state is pending-close until we get here
		dojo.replaceClass(this.domNode, "dijitMenuPassive", "dijitMenuActive");
	},

	onClose: function(){
		// summary:
		//		Callback when this menu is closed.
		//		This is called by the popup manager as notification that the menu
		//		was closed.
		// tags:
		//		private

		this._stopFocusTimer();
		this._markInactive();
		this.isShowingNow = false;
		this.parentMenu = null;
	},

	_closeChild: function(){
		// summary:
		//		Called when submenu is clicked or focus is lost.  Close hierarchy of menus.
		// tags:
		//		private
		this._stopPopupTimer();

		var fromItem = this.focusedChild && this.focusedChild.from_item;

		if(this.currentPopup){
			// If focus is on my child menu then move focus to me,
			// because IE doesn't like it when you display:none a node with focus
			if(dijit._curFocus && dojo.isDescendant(dijit._curFocus, this.currentPopup.domNode)){
				this.focusedChild.focusNode.focus();
			}
			// Close all popups that are open and descendants of this menu
			dijit.popup.close(this.currentPopup);
			this.currentPopup = null;
		}

		if(this.focusedChild){ // unhighlight the focused item
			this.focusedChild._setSelected(false);
			this.focusedChild._onUnhover();
			this.focusedChild = null;
		}
	},

	_onItemFocus: function(/*MenuItem*/ item){
		// summary:
		//		Called when child of this Menu gets focus from:
		//			1) clicking it
		//			2) tabbing into it
		//			3) being opened by a parent menu.
		//		This is not called just from mouse hover.
		if(this._hoveredChild && this._hoveredChild != item){
			this._hoveredChild._onUnhover(); // any previous mouse movement is trumped by focus selection
		}
	},

	_onBlur: function(){
		// summary:
		//		Called when focus is moved away from this Menu and it's submenus.
		// tags:
		//		protected
		this._cleanUp();
		this.inherited(arguments);
	},

	_cleanUp: function(){
		// summary:
		//		Called when the user is done with this menu.  Closes hierarchy of menus.
		// tags:
		//		private

		this._closeChild(); // don't call this.onClose since that's incorrect for MenuBar's that never close
		if(typeof this.isShowingNow == 'undefined'){ // non-popup menu doesn't call onClose
			this._markInactive();
		}
	}
});

dojo.declare("dijit.Menu",
	dijit._MenuBase,
	{
	// summary
	//		A context menu you can assign to multiple elements

	// TODO: most of the code in here is just for context menu (right-click menu)
	// support.  In retrospect that should have been a separate class (dijit.ContextMenu).
	// Split them for 2.0

	constructor: function(){
		this._bindings = [];
	},

	templateString: dojo.cache("dijit", "templates/Menu.html", "<table class=\"dijit dijitMenu dijitMenuPassive dijitReset dijitMenuTable\" role=\"menu\" tabIndex=\"${tabIndex}\" dojoAttachEvent=\"onkeypress:_onKeyPress\" cellspacing=\"0\">\n\t<tbody class=\"dijitReset\" dojoAttachPoint=\"containerNode\"></tbody>\n</table>\n"),

	baseClass: "dijitMenu",

	// targetNodeIds: [const] String[]
	//		Array of dom node ids of nodes to attach to.
	//		Fill this with nodeIds upon widget creation and it becomes context menu for those nodes.
	targetNodeIds: [],

	// contextMenuForWindow: [const] Boolean
	//		If true, right clicking anywhere on the window will cause this context menu to open.
	//		If false, must specify targetNodeIds.
	contextMenuForWindow: false,

	// leftClickToOpen: [const] Boolean
	//		If true, menu will open on left click instead of right click, similiar to a file menu.
	leftClickToOpen: false,

	// refocus: Boolean
	// 		When this menu closes, re-focus the element which had focus before it was opened.
	refocus: true,

	postCreate: function(){
		if(this.contextMenuForWindow){
			this.bindDomNode(dojo.body());
		}else{
			// TODO: should have _setTargetNodeIds() method to handle initialization and a possible
			// later set('targetNodeIds', ...) call.   There's also a problem that targetNodeIds[]
			// gets stale after calls to bindDomNode()/unBindDomNode() as it still is just the original list (see #9610)
			dojo.forEach(this.targetNodeIds, this.bindDomNode, this);
		}
		var k = dojo.keys, l = this.isLeftToRight();
		this._openSubMenuKey = l ? k.RIGHT_ARROW : k.LEFT_ARROW;
		this._closeSubMenuKey = l ? k.LEFT_ARROW : k.RIGHT_ARROW;
		this.connectKeyNavHandlers([k.UP_ARROW], [k.DOWN_ARROW]);
	},

	_onKeyPress: function(/*Event*/ evt){
		// summary:
		//		Handle keyboard based menu navigation.
		// tags:
		//		protected

		if(evt.ctrlKey || evt.altKey){ return; }

		switch(evt.charOrCode){
			case this._openSubMenuKey:
				this._moveToPopup(evt);
				dojo.stopEvent(evt);
				break;
			case this._closeSubMenuKey:
				if(this.parentMenu){
					if(this.parentMenu._isMenuBar){
						this.parentMenu.focusPrev();
					}else{
						this.onCancel(false);
					}
				}else{
					dojo.stopEvent(evt);
				}
				break;
		}
	},

	// thanks burstlib!
	_iframeContentWindow: function(/* HTMLIFrameElement */iframe_el){
		// summary:
		//		Returns the window reference of the passed iframe
		// tags:
		//		private
		var win = dojo.window.get(this._iframeContentDocument(iframe_el)) ||
			// Moz. TODO: is this available when defaultView isn't?
			this._iframeContentDocument(iframe_el)['__parent__'] ||
			(iframe_el.name && dojo.doc.frames[iframe_el.name]) || null;
		return win;	//	Window
	},

	_iframeContentDocument: function(/* HTMLIFrameElement */iframe_el){
		// summary:
		//		Returns a reference to the document object inside iframe_el
		// tags:
		//		protected
		var doc = iframe_el.contentDocument // W3
			|| (iframe_el.contentWindow && iframe_el.contentWindow.document) // IE
			|| (iframe_el.name && dojo.doc.frames[iframe_el.name] && dojo.doc.frames[iframe_el.name].document)
			|| null;
		return doc;	//	HTMLDocument
	},

	bindDomNode: function(/*String|DomNode*/ node){
		// summary:
		//		Attach menu to given node
		node = dojo.byId(node);

		var cn;	// Connect node

		// Support context menus on iframes.   Rather than binding to the iframe itself we need
		// to bind to the <body> node inside the iframe.
		if(node.tagName.toLowerCase() == "iframe"){
			var iframe = node,
				win = this._iframeContentWindow(iframe);
			cn = dojo.withGlobal(win, dojo.body);
		}else{
			
			// To capture these events at the top level, attach to <html>, not <body>.
			// Otherwise right-click context menu just doesn't work.
			cn = (node == dojo.body() ? dojo.doc.documentElement : node);
		}


		// "binding" is the object to track our connection to the node (ie, the parameter to bindDomNode())
		var binding = {
			node: node,
			iframe: iframe
		};

		// Save info about binding in _bindings[], and make node itself record index(+1) into
		// _bindings[] array.   Prefix w/_dijitMenu to avoid setting an attribute that may
		// start with a number, which fails on FF/safari.
		dojo.attr(node, "_dijitMenu" + this.id, this._bindings.push(binding));

		// Setup the connections to monitor click etc., unless we are connecting to an iframe which hasn't finished
		// loading yet, in which case we need to wait for the onload event first, and then connect
		// On linux Shift-F10 produces the oncontextmenu event, but on Windows it doesn't, so
		// we need to monitor keyboard events in addition to the oncontextmenu event.
		var doConnects = dojo.hitch(this, function(cn){
			return [
				// TODO: when leftClickToOpen is true then shouldn't space/enter key trigger the menu,
				// rather than shift-F10?
				dojo.connect(cn, this.leftClickToOpen ? "onclick" : "oncontextmenu", this, function(evt){
					// Schedule context menu to be opened unless it's already been scheduled from onkeydown handler
					dojo.stopEvent(evt);
					this._scheduleOpen(evt.target, iframe, {x: evt.pageX, y: evt.pageY});
				}),
				dojo.connect(cn, "onkeydown", this, function(evt){
					if(evt.shiftKey && evt.keyCode == dojo.keys.F10){
						dojo.stopEvent(evt);
						this._scheduleOpen(evt.target, iframe);	// no coords - open near target node
					}
				})
			];
		});
		binding.connects = cn ? doConnects(cn) : [];

		if(iframe){
			// Setup handler to [re]bind to the iframe when the contents are initially loaded,
			// and every time the contents change.
			// Need to do this b/c we are actually binding to the iframe's <body> node.
			// Note: can't use dojo.connect(), see #9609.

			binding.onloadHandler = dojo.hitch(this, function(){
				// want to remove old connections, but IE throws exceptions when trying to
				// access the <body> node because it's already gone, or at least in a state of limbo

				var win = this._iframeContentWindow(iframe);
					cn = dojo.withGlobal(win, dojo.body);
				binding.connects = doConnects(cn);
			});
			if(iframe.addEventListener){
				iframe.addEventListener("load", binding.onloadHandler, false);
			}else{
				iframe.attachEvent("onload", binding.onloadHandler);
			}
		}
	},

	unBindDomNode: function(/*String|DomNode*/ nodeName){
		// summary:
		//		Detach menu from given node

		var node;
		try{
			node = dojo.byId(nodeName);
		}catch(e){
			// On IE the dojo.byId() call will get an exception if the attach point was
			// the <body> node of an <iframe> that has since been reloaded (and thus the
			// <body> node is in a limbo state of destruction.
			return;
		}

		// node["_dijitMenu" + this.id] contains index(+1) into my _bindings[] array
		var attrName = "_dijitMenu" + this.id;
		if(node && dojo.hasAttr(node, attrName)){
			var bid = dojo.attr(node, attrName)-1, b = this._bindings[bid];
			dojo.forEach(b.connects, dojo.disconnect);

			// Remove listener for iframe onload events
			var iframe = b.iframe;
			if(iframe){
				if(iframe.removeEventListener){
					iframe.removeEventListener("load", b.onloadHandler, false);
				}else{
					iframe.detachEvent("onload", b.onloadHandler);
				}
			}

			dojo.removeAttr(node, attrName);
			delete this._bindings[bid];
		}
	},

	_scheduleOpen: function(/*DomNode?*/ target, /*DomNode?*/ iframe, /*Object?*/ coords){
		// summary:
		//		Set timer to display myself.  Using a timer rather than displaying immediately solves
		//		two problems:
		//
		//		1. IE: without the delay, focus work in "open" causes the system
		//		context menu to appear in spite of stopEvent.
		//
		//		2. Avoid double-shows on linux, where shift-F10 generates an oncontextmenu event
		//		even after a dojo.stopEvent(e).  (Shift-F10 on windows doesn't generate the
		//		oncontextmenu event.)

		if(!this._openTimer){
			this._openTimer = setTimeout(dojo.hitch(this, function(){
				delete this._openTimer;
				this._openMyself({
					target: target,
					iframe: iframe,
					coords: coords
				});
			}), 1);
		}
	},

	_openMyself: function(args){
		// summary:
		//		Internal function for opening myself when the user does a right-click or something similar.
		// args:
		//		This is an Object containing:
		//		* target:
		//			The node that is being clicked
		//		* iframe:
		//			If an <iframe> is being clicked, iframe points to that iframe
		//		* coords:
		//			Put menu at specified x/y position in viewport, or if iframe is
		//			specified, then relative to iframe.
		//
		//		_openMyself() formerly took the event object, and since various code references
		//		evt.target (after connecting to _openMyself()), using an Object for parameters
		//		(so that old code still works).

		var target = args.target,
			iframe = args.iframe,
			coords = args.coords;

		// Get coordinates to open menu, either at specified (mouse) position or (if triggered via keyboard)
		// then near the node the menu is assigned to.
		if(coords){
			if(iframe){
				// Specified coordinates are on <body> node of an <iframe>, convert to match main document
				var od = target.ownerDocument,
					ifc = dojo.position(iframe, true),
					win = this._iframeContentWindow(iframe),
					scroll = dojo.withGlobal(win, "_docScroll", dojo);
	
				var cs = dojo.getComputedStyle(iframe),
					tp = dojo._toPixelValue,
					left = (dojo.isIE && dojo.isQuirks ? 0 : tp(iframe, cs.paddingLeft)) + (dojo.isIE && dojo.isQuirks ? tp(iframe, cs.borderLeftWidth) : 0),
					top = (dojo.isIE && dojo.isQuirks ? 0 : tp(iframe, cs.paddingTop)) + (dojo.isIE && dojo.isQuirks ? tp(iframe, cs.borderTopWidth) : 0);

				coords.x += ifc.x + left - scroll.x;
				coords.y += ifc.y + top - scroll.y;
			}
		}else{
			coords = dojo.position(target, true);
			coords.x += 10;
			coords.y += 10;
		}

		var self=this;
		var savedFocus = dijit.getFocus(this);
		function closeAndRestoreFocus(){
			// user has clicked on a menu or popup
			if(self.refocus){
				dijit.focus(savedFocus);
			}
			dijit.popup.close(self);
		}
		dijit.popup.open({
			popup: this,
			x: coords.x,
			y: coords.y,
			onExecute: closeAndRestoreFocus,
			onCancel: closeAndRestoreFocus,
			orient: this.isLeftToRight() ? 'L' : 'R'
		});
		this.focus();

		this._onBlur = function(){
			this.inherited('_onBlur', arguments);
			// Usually the parent closes the child widget but if this is a context
			// menu then there is no parent
			dijit.popup.close(this);
			// don't try to restore focus; user has clicked another part of the screen
			// and set focus there
		};
	},

	uninitialize: function(){
 		dojo.forEach(this._bindings, function(b){ if(b){ this.unBindDomNode(b.node); } }, this);
 		this.inherited(arguments);
	}
}
);

}

if(!dojo._hasResource["dijit.layout.TabController"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.layout.TabController"] = true;
dojo.provide("dijit.layout.TabController");






// Menu is used for an accessible close button, would be nice to have a lighter-weight solution


dojo.declare("dijit.layout.TabController",
	dijit.layout.StackController,
{
	// summary:
	// 		Set of tabs (the things with titles and a close button, that you click to show a tab panel).
	//		Used internally by `dijit.layout.TabContainer`.
	// description:
	//		Lets the user select the currently shown pane in a TabContainer or StackContainer.
	//		TabController also monitors the TabContainer, and whenever a pane is
	//		added or deleted updates itself accordingly.
	// tags:
	//		private

	templateString: "<div role='tablist' dojoAttachEvent='onkeypress:onkeypress'></div>",

	// tabPosition: String
	//		Defines where tabs go relative to the content.
	//		"top", "bottom", "left-h", "right-h"
	tabPosition: "top",

	// buttonWidget: String
	//		The name of the tab widget to create to correspond to each page
	buttonWidget: "dijit.layout._TabButton",

	_rectifyRtlTabList: function(){
		// summary:
		//		For left/right TabContainer when page is RTL mode, rectify the width of all tabs to be equal, otherwise the tab widths are different in IE

		if(0 >= this.tabPosition.indexOf('-h')){ return; }
		if(!this.pane2button){ return; }

		var maxWidth = 0;
		for(var pane in this.pane2button){
			var ow = this.pane2button[pane].innerDiv.scrollWidth;
			maxWidth = Math.max(maxWidth, ow);
		}
		//unify the length of all the tabs
		for(pane in this.pane2button){
			this.pane2button[pane].innerDiv.style.width = maxWidth + 'px';
		}
	}
});

dojo.declare("dijit.layout._TabButton",
	dijit.layout._StackButton,
	{
	// summary:
	//		A tab (the thing you click to select a pane).
	// description:
	//		Contains the title of the pane, and optionally a close-button to destroy the pane.
	//		This is an internal widget and should not be instantiated directly.
	// tags:
	//		private

	// baseClass: String
	//		The CSS class applied to the domNode.
	baseClass: "dijitTab",

	// Apply dijitTabCloseButtonHover when close button is hovered
	cssStateNodes: {
		closeNode: "dijitTabCloseButton"
	},

	templateString: dojo.cache("dijit.layout", "templates/_TabButton.html", "<div role=\"presentation\" dojoAttachPoint=\"titleNode\" dojoAttachEvent='onclick:onClick'>\n    <div role=\"presentation\" class='dijitTabInnerDiv' dojoAttachPoint='innerDiv'>\n        <div role=\"presentation\" class='dijitTabContent' dojoAttachPoint='tabContent'>\n        \t<div role=\"presentation\" dojoAttachPoint='focusNode'>\n\t\t        <img src=\"${_blankGif}\" alt=\"\" class=\"dijitIcon dijitTabButtonIcon\" dojoAttachPoint='iconNode' />\n\t\t        <span dojoAttachPoint='containerNode' class='tabLabel'></span>\n\t\t        <span class=\"dijitInline dijitTabCloseButton dijitTabCloseIcon\" dojoAttachPoint='closeNode'\n\t\t        \t\tdojoAttachEvent='onclick: onClickCloseButton' role=\"presentation\">\n\t\t            <span dojoAttachPoint='closeText' class='dijitTabCloseText'>[x]</span\n\t\t        ></span>\n\t\t\t</div>\n        </div>\n    </div>\n</div>\n"),

	// Override _FormWidget.scrollOnFocus.
	// Don't scroll the whole tab container into view when the button is focused.
	scrollOnFocus: false,

	buildRendering: function(){
		this.inherited(arguments);

		dojo.setSelectable(this.containerNode, false);
	},

	startup: function(){
		this.inherited(arguments);
		var n = this.domNode;

		// Required to give IE6 a kick, as it initially hides the
		// tabs until they are focused on.
		setTimeout(function(){
			n.className = n.className;
		}, 1);
	},

	_setCloseButtonAttr: function(/*Boolean*/ disp){
		// summary:
		//		Hide/show close button
		this._set("closeButton", disp);
		dojo.toggleClass(this.innerDiv, "dijitClosable", disp);
		this.closeNode.style.display = disp ? "" : "none";
		if(disp){
			var _nlsResources = dojo.i18n.getLocalization("dijit", "common");
			if(this.closeNode){
				dojo.attr(this.closeNode,"title", _nlsResources.itemClose);
			}
			// add context menu onto title button
			var _nlsResources = dojo.i18n.getLocalization("dijit", "common");
			this._closeMenu = new dijit.Menu({
				id: this.id+"_Menu",
				dir: this.dir,
				lang: this.lang,
				targetNodeIds: [this.domNode]
			});

			this._closeMenu.addChild(new dijit.MenuItem({
				label: _nlsResources.itemClose,
				dir: this.dir,
				lang: this.lang,
				onClick: dojo.hitch(this, "onClickCloseButton")
			}));
		}else{
			if(this._closeMenu){
				this._closeMenu.destroyRecursive();
				delete this._closeMenu;
			}
		}
	},
	_setLabelAttr: function(/*String*/ content){
		// summary:
		//		Hook for set('label', ...) to work.
		// description:
		//		takes an HTML string.
		//		Inherited ToggleButton implementation will Set the label (text) of the button;
		//		Need to set the alt attribute of icon on tab buttons if no label displayed
		this.inherited(arguments);
		if(this.showLabel == false && !this.params.title){
			this.iconNode.alt = dojo.trim(this.containerNode.innerText || this.containerNode.textContent || '');
		}
	},

	destroy: function(){
		if(this._closeMenu){
			this._closeMenu.destroyRecursive();
			delete this._closeMenu;
		}
		this.inherited(arguments);
	}
});

}

if(!dojo._hasResource["dijit.layout.ScrollingTabController"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.layout.ScrollingTabController"] = true;
dojo.provide("dijit.layout.ScrollingTabController");






dojo.declare("dijit.layout.ScrollingTabController",
	dijit.layout.TabController,
	{
	// summary:
	//		Set of tabs with left/right arrow keys and a menu to switch between tabs not
	//		all fitting on a single row.
	//		Works only for horizontal tabs (either above or below the content, not to the left
	//		or right).
	// tags:
	//		private

	templateString: dojo.cache("dijit.layout", "templates/ScrollingTabController.html", "<div class=\"dijitTabListContainer-${tabPosition}\" style=\"visibility:hidden\">\n\t<div dojoType=\"dijit.layout._ScrollingTabControllerMenuButton\"\n\t\t\tclass=\"tabStripButton-${tabPosition}\"\n\t\t\tid=\"${id}_menuBtn\" containerId=\"${containerId}\" iconClass=\"dijitTabStripMenuIcon\"\n\t\t\tdropDownPosition=\"below-alt, above-alt\"\n\t\t\tdojoAttachPoint=\"_menuBtn\" showLabel=\"false\">&#9660;</div>\n\t<div dojoType=\"dijit.layout._ScrollingTabControllerButton\"\n\t\t\tclass=\"tabStripButton-${tabPosition}\"\n\t\t\tid=\"${id}_leftBtn\" iconClass=\"dijitTabStripSlideLeftIcon\"\n\t\t\tdojoAttachPoint=\"_leftBtn\" dojoAttachEvent=\"onClick: doSlideLeft\" showLabel=\"false\">&#9664;</div>\n\t<div dojoType=\"dijit.layout._ScrollingTabControllerButton\"\n\t\t\tclass=\"tabStripButton-${tabPosition}\"\n\t\t\tid=\"${id}_rightBtn\" iconClass=\"dijitTabStripSlideRightIcon\"\n\t\t\tdojoAttachPoint=\"_rightBtn\" dojoAttachEvent=\"onClick: doSlideRight\" showLabel=\"false\">&#9654;</div>\n\t<div class='dijitTabListWrapper' dojoAttachPoint='tablistWrapper'>\n\t\t<div role='tablist' dojoAttachEvent='onkeypress:onkeypress'\n\t\t\t\tdojoAttachPoint='containerNode' class='nowrapTabStrip'></div>\n\t</div>\n</div>\n"),

	// useMenu: [const] Boolean
	//		True if a menu should be used to select tabs when they are too
	//		wide to fit the TabContainer, false otherwise.
	useMenu: true,

	// useSlider: [const] Boolean
	//		True if a slider should be used to select tabs when they are too
	//		wide to fit the TabContainer, false otherwise.
	useSlider: true,

	// tabStripClass: [const] String
	//		The css class to apply to the tab strip, if it is visible.
	tabStripClass: "",

	widgetsInTemplate: true,

	// _minScroll: Number
	//		The distance in pixels from the edge of the tab strip which,
	//		if a scroll animation is less than, forces the scroll to
	//		go all the way to the left/right.
	_minScroll: 5,

	attributeMap: dojo.delegate(dijit._Widget.prototype.attributeMap, {
		"class": "containerNode"
	}),

	buildRendering: function(){
		this.inherited(arguments);
		var n = this.domNode;

		this.scrollNode = this.tablistWrapper;
		this._initButtons();

		if(!this.tabStripClass){
			this.tabStripClass = "dijitTabContainer" +
				this.tabPosition.charAt(0).toUpperCase() +
				this.tabPosition.substr(1).replace(/-.*/, "") +
				"None";
			dojo.addClass(n, "tabStrip-disabled")
		}

		dojo.addClass(this.tablistWrapper, this.tabStripClass);
	},

	onStartup: function(){
		this.inherited(arguments);

		// Do not show the TabController until the related
		// StackController has added it's children.  This gives
		// a less visually jumpy instantiation.
		dojo.style(this.domNode, "visibility", "visible");
		this._postStartup = true;
	},

	onAddChild: function(page, insertIndex){
		this.inherited(arguments);

		// changes to the tab button label or iconClass will have changed the width of the
		// buttons, so do a resize
		dojo.forEach(["label", "iconClass"], function(attr){
			this.pane2watches[page.id].push(
				this.pane2button[page.id].watch(attr, dojo.hitch(this, function(name, oldValue, newValue){
					if(this._postStartup && this._dim){
						this.resize(this._dim);
					}
				}))
			);
		}, this);

		// Increment the width of the wrapper when a tab is added
		// This makes sure that the buttons never wrap.
		// The value 200 is chosen as it should be bigger than most
		// Tab button widths.
		dojo.style(this.containerNode, "width",
			(dojo.style(this.containerNode, "width") + 200) + "px");
	},

	onRemoveChild: function(page, insertIndex){
		// null out _selectedTab because we are about to delete that dom node
		var button = this.pane2button[page.id];
		if(this._selectedTab === button.domNode){
			this._selectedTab = null;
		}

		this.inherited(arguments);
	},

	_initButtons: function(){
		// summary:
		//		Creates the buttons used to scroll to view tabs that
		//		may not be visible if the TabContainer is too narrow.

		// Make a list of the buttons to display when the tab labels become
		// wider than the TabContainer, and hide the other buttons.
		// Also gets the total width of the displayed buttons.
		this._btnWidth = 0;
		this._buttons = dojo.query("> .tabStripButton", this.domNode).filter(function(btn){
			if((this.useMenu && btn == this._menuBtn.domNode) ||
				(this.useSlider && (btn == this._rightBtn.domNode || btn == this._leftBtn.domNode))){
				this._btnWidth += dojo._getMarginSize(btn).w;
				return true;
			}else{
				dojo.style(btn, "display", "none");
				return false;
			}
		}, this);
	},

	_getTabsWidth: function(){
		var children = this.getChildren();
		if(children.length){
			var leftTab = children[this.isLeftToRight() ? 0 : children.length - 1].domNode,
				rightTab = children[this.isLeftToRight() ? children.length - 1 : 0].domNode;
			return rightTab.offsetLeft + dojo.style(rightTab, "width") - leftTab.offsetLeft;
		}else{
			return 0;
		}
	},

	_enableBtn: function(width){
		// summary:
		//		Determines if the tabs are wider than the width of the TabContainer, and
		//		thus that we need to display left/right/menu navigation buttons.
		var tabsWidth = this._getTabsWidth();
		width = width || dojo.style(this.scrollNode, "width");
		return tabsWidth > 0 && width < tabsWidth;
	},

	resize: function(dim){
		// summary:
		//		Hides or displays the buttons used to scroll the tab list and launch the menu
		//		that selects tabs.

		if(this.domNode.offsetWidth == 0){
			return;
		}

		// Save the dimensions to be used when a child is renamed.
		this._dim = dim;

		// Set my height to be my natural height (tall enough for one row of tab labels),
		// and my content-box width based on margin-box width specified in dim parameter.
		// But first reset scrollNode.height in case it was set by layoutChildren() call
		// in a previous run of this method.
		this.scrollNode.style.height = "auto";
		this._contentBox = dijit.layout.marginBox2contentBox(this.domNode, {h: 0, w: dim.w});
		this._contentBox.h = this.scrollNode.offsetHeight;
		dojo.contentBox(this.domNode, this._contentBox);

		// Show/hide the left/right/menu navigation buttons depending on whether or not they
		// are needed.
		var enable = this._enableBtn(this._contentBox.w);
		this._buttons.style("display", enable ? "" : "none");

		// Position and size the navigation buttons and the tablist
		this._leftBtn.layoutAlign = "left";
		this._rightBtn.layoutAlign = "right";
		this._menuBtn.layoutAlign = this.isLeftToRight() ? "right" : "left";
		dijit.layout.layoutChildren(this.domNode, this._contentBox,
			[this._menuBtn, this._leftBtn, this._rightBtn, {domNode: this.scrollNode, layoutAlign: "client"}]);

		// set proper scroll so that selected tab is visible
		if(this._selectedTab){
			if(this._anim && this._anim.status() == "playing"){
				this._anim.stop();
			}
			var w = this.scrollNode,
				sl = this._convertToScrollLeft(this._getScrollForSelectedTab());
			w.scrollLeft = sl;
		}

		// Enable/disabled left right buttons depending on whether or not user can scroll to left or right
		this._setButtonClass(this._getScroll());
		
		this._postResize = true;

		// Return my size so layoutChildren() can use it.
		// Also avoids IE9 layout glitch on browser resize when scroll buttons present
		return {h: this._contentBox.h, w: dim.w};
	},

	_getScroll: function(){
		// summary:
		//		Returns the current scroll of the tabs where 0 means
		//		"scrolled all the way to the left" and some positive number, based on #
		//		of pixels of possible scroll (ex: 1000) means "scrolled all the way to the right"
		var sl = (this.isLeftToRight() || dojo.isIE < 8 || (dojo.isIE && dojo.isQuirks) || dojo.isWebKit) ? this.scrollNode.scrollLeft :
				dojo.style(this.containerNode, "width") - dojo.style(this.scrollNode, "width")
					 + (dojo.isIE == 8 ? -1 : 1) * this.scrollNode.scrollLeft;
		return sl;
	},

	_convertToScrollLeft: function(val){
		// summary:
		//		Given a scroll value where 0 means "scrolled all the way to the left"
		//		and some positive number, based on # of pixels of possible scroll (ex: 1000)
		//		means "scrolled all the way to the right", return value to set this.scrollNode.scrollLeft
		//		to achieve that scroll.
		//
		//		This method is to adjust for RTL funniness in various browsers and versions.
		if(this.isLeftToRight() || dojo.isIE < 8 || (dojo.isIE && dojo.isQuirks) || dojo.isWebKit){
			return val;
		}else{
			var maxScroll = dojo.style(this.containerNode, "width") - dojo.style(this.scrollNode, "width");
			return (dojo.isIE == 8 ? -1 : 1) * (val - maxScroll);
		}
	},

	onSelectChild: function(/*dijit._Widget*/ page){
		// summary:
		//		Smoothly scrolls to a tab when it is selected.

		var tab = this.pane2button[page.id];
		if(!tab || !page){return;}

		// Scroll to the selected tab, except on startup, when scrolling is handled in resize()
		var node = tab.domNode;
		if(this._postResize && node != this._selectedTab){
			this._selectedTab = node;

			var sl = this._getScroll();

			if(sl > node.offsetLeft ||
					sl + dojo.style(this.scrollNode, "width") <
					node.offsetLeft + dojo.style(node, "width")){
				this.createSmoothScroll().play();
			}
		}

		this.inherited(arguments);
	},

	_getScrollBounds: function(){
		// summary:
		//		Returns the minimum and maximum scroll setting to show the leftmost and rightmost
		//		tabs (respectively)
		var children = this.getChildren(),
			scrollNodeWidth = dojo.style(this.scrollNode, "width"),		// about 500px
			containerWidth = dojo.style(this.containerNode, "width"),	// 50,000px
			maxPossibleScroll = containerWidth - scrollNodeWidth,	// scrolling until right edge of containerNode visible
			tabsWidth = this._getTabsWidth();

		if(children.length && tabsWidth > scrollNodeWidth){
			// Scrolling should happen
			return {
				min: this.isLeftToRight() ? 0 : children[children.length-1].domNode.offsetLeft,
				max: this.isLeftToRight() ?
					(children[children.length-1].domNode.offsetLeft + dojo.style(children[children.length-1].domNode, "width")) - scrollNodeWidth :
					maxPossibleScroll
			};
		}else{
			// No scrolling needed, all tabs visible, we stay either scrolled to far left or far right (depending on dir)
			var onlyScrollPosition = this.isLeftToRight() ? 0 : maxPossibleScroll;
			return {
				min: onlyScrollPosition,
				max: onlyScrollPosition
			};
		}
	},

	_getScrollForSelectedTab: function(){
		// summary:
		//		Returns the scroll value setting so that the selected tab
		//		will appear in the center
		var w = this.scrollNode,
			n = this._selectedTab,
			scrollNodeWidth = dojo.style(this.scrollNode, "width"),
			scrollBounds = this._getScrollBounds();

		// TODO: scroll minimal amount (to either right or left) so that
		// selected tab is fully visible, and just return if it's already visible?
		var pos = (n.offsetLeft + dojo.style(n, "width")/2) - scrollNodeWidth/2;
		pos = Math.min(Math.max(pos, scrollBounds.min), scrollBounds.max);

		// TODO:
		// If scrolling close to the left side or right side, scroll
		// all the way to the left or right.  See this._minScroll.
		// (But need to make sure that doesn't scroll the tab out of view...)
		return pos;
	},

	createSmoothScroll: function(x){
		// summary:
		//		Creates a dojo._Animation object that smoothly scrolls the tab list
		//		either to a fixed horizontal pixel value, or to the selected tab.
		// description:
		//		If an number argument is passed to the function, that horizontal
		//		pixel position is scrolled to.  Otherwise the currently selected
		//		tab is scrolled to.
		// x: Integer?
		//		An optional pixel value to scroll to, indicating distance from left.

		// Calculate position to scroll to
		if(arguments.length > 0){
			// position specified by caller, just make sure it's within bounds
			var scrollBounds = this._getScrollBounds();
			x = Math.min(Math.max(x, scrollBounds.min), scrollBounds.max);
		}else{
			// scroll to center the current tab
			x = this._getScrollForSelectedTab();
		}

		if(this._anim && this._anim.status() == "playing"){
			this._anim.stop();
		}

		var self = this,
			w = this.scrollNode,
			anim = new dojo._Animation({
				beforeBegin: function(){
					if(this.curve){ delete this.curve; }
					var oldS = w.scrollLeft,
						newS = self._convertToScrollLeft(x);
					anim.curve = new dojo._Line(oldS, newS);
				},
				onAnimate: function(val){
					w.scrollLeft = val;
				}
			});
		this._anim = anim;

		// Disable/enable left/right buttons according to new scroll position
		this._setButtonClass(x);

		return anim; // dojo._Animation
	},

	_getBtnNode: function(/*Event*/ e){
		// summary:
		//		Gets a button DOM node from a mouse click event.
		// e:
		//		The mouse click event.
		var n = e.target;
		while(n && !dojo.hasClass(n, "tabStripButton")){
			n = n.parentNode;
		}
		return n;
	},

	doSlideRight: function(/*Event*/ e){
		// summary:
		//		Scrolls the menu to the right.
		// e:
		//		The mouse click event.
		this.doSlide(1, this._getBtnNode(e));
	},

	doSlideLeft: function(/*Event*/ e){
		// summary:
		//		Scrolls the menu to the left.
		// e:
		//		The mouse click event.
		this.doSlide(-1,this._getBtnNode(e));
	},

	doSlide: function(/*Number*/ direction, /*DomNode*/ node){
		// summary:
		//		Scrolls the tab list to the left or right by 75% of the widget width.
		// direction:
		//		If the direction is 1, the widget scrolls to the right, if it is
		//		-1, it scrolls to the left.

		if(node && dojo.hasClass(node, "dijitTabDisabled")){return;}

		var sWidth = dojo.style(this.scrollNode, "width");
		var d = (sWidth * 0.75) * direction;

		var to = this._getScroll() + d;

		this._setButtonClass(to);

		this.createSmoothScroll(to).play();
	},

	_setButtonClass: function(/*Number*/ scroll){
		// summary:
		//		Disables the left scroll button if the tabs are scrolled all the way to the left,
		//		or the right scroll button in the opposite case.
		// scroll: Integer
		//		amount of horizontal scroll

		var scrollBounds = this._getScrollBounds();
		this._leftBtn.set("disabled", scroll <= scrollBounds.min);
		this._rightBtn.set("disabled", scroll >= scrollBounds.max);
	}
});


dojo.declare("dijit.layout._ScrollingTabControllerButtonMixin", null, {
	baseClass: "dijitTab tabStripButton",

	templateString: dojo.cache("dijit.layout", "templates/_ScrollingTabControllerButton.html", "<div dojoAttachEvent=\"onclick:_onButtonClick\">\n\t<div role=\"presentation\" class=\"dijitTabInnerDiv\" dojoattachpoint=\"innerDiv,focusNode\">\n\t\t<div role=\"presentation\" class=\"dijitTabContent dijitButtonContents\" dojoattachpoint=\"tabContent\">\n\t\t\t<img role=\"presentation\" alt=\"\" src=\"${_blankGif}\" class=\"dijitTabStripIcon\" dojoAttachPoint=\"iconNode\"/>\n\t\t\t<span dojoAttachPoint=\"containerNode,titleNode\" class=\"dijitButtonText\"></span>\n\t\t</div>\n\t</div>\n</div>\n"),

		// Override inherited tabIndex: 0 from dijit.form.Button, because user shouldn't be
		// able to tab to the left/right/menu buttons
	tabIndex: "",

	// Similarly, override FormWidget.isFocusable() because clicking a button shouldn't focus it
	// either (this override avoids focus() call in FormWidget.js)
	isFocusable: function(){ return false; }
});

dojo.declare("dijit.layout._ScrollingTabControllerButton",
	[dijit.form.Button, dijit.layout._ScrollingTabControllerButtonMixin]);

dojo.declare(
	"dijit.layout._ScrollingTabControllerMenuButton",
	[dijit.form.Button, dijit._HasDropDown, dijit.layout._ScrollingTabControllerButtonMixin],
{
	// id of the TabContainer itself
	containerId: "",

	// -1 so user can't tab into the button, but so that button can still be focused programatically.
	// Because need to move focus to the button (or somewhere) before the menu is hidden or IE6 will crash.
	tabIndex: "-1",

	isLoaded: function(){
		// recreate menu every time, in case the TabContainer's list of children (or their icons/labels) have changed
		return false;
	},

	loadDropDown: function(callback){
		this.dropDown = new dijit.Menu({
			id: this.containerId + "_menu",
			dir: this.dir,
			lang: this.lang
		});
		var container = dijit.byId(this.containerId);
		dojo.forEach(container.getChildren(), function(page){
			var menuItem = new dijit.MenuItem({
				id: page.id + "_stcMi",
				label: page.title,
				iconClass: page.iconClass,
				dir: page.dir,
				lang: page.lang,
				onClick: function(){
					container.selectChild(page);
				}
			});
			this.dropDown.addChild(menuItem);
		}, this);
		callback();
	},

	closeDropDown: function(/*Boolean*/ focus){
		this.inherited(arguments);
		if(this.dropDown){
			this.dropDown.destroyRecursive();
			delete this.dropDown;
		}
	}
});

}

if(!dojo._hasResource["dijit.layout.TabContainer"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.layout.TabContainer"] = true;
dojo.provide("dijit.layout.TabContainer");





dojo.declare("dijit.layout.TabContainer",
	dijit.layout._TabContainerBase,
	{
		// summary:
		//		A Container with tabs to select each child (only one of which is displayed at a time).
		// description:
		//		A TabContainer is a container that has multiple panes, but shows only
		//		one pane at a time.  There are a set of tabs corresponding to each pane,
		//		where each tab has the name (aka title) of the pane, and optionally a close button.

		// useMenu: [const] Boolean
		//		True if a menu should be used to select tabs when they are too
		//		wide to fit the TabContainer, false otherwise.
		useMenu: true,

		// useSlider: [const] Boolean
		//		True if a slider should be used to select tabs when they are too
		//		wide to fit the TabContainer, false otherwise.
		useSlider: true,

		// controllerWidget: String
		//		An optional parameter to override the widget used to display the tab labels
		controllerWidget: "",

		_makeController: function(/*DomNode*/ srcNode){
			// summary:
			//		Instantiate tablist controller widget and return reference to it.
			//		Callback from _TabContainerBase.postCreate().
			// tags:
			//		protected extension

			var cls = this.baseClass + "-tabs" + (this.doLayout ? "" : " dijitTabNoLayout"),
				TabController = dojo.getObject(this.controllerWidget);

			return new TabController({
				id: this.id + "_tablist",
				dir: this.dir,
				lang: this.lang,
				tabPosition: this.tabPosition,
				doLayout: this.doLayout,
				containerId: this.id,
				"class": cls,
				nested: this.nested,
				useMenu: this.useMenu,
				useSlider: this.useSlider,
				tabStripClass: this.tabStrip ? this.baseClass + (this.tabStrip ? "":"No") + "Strip": null
			}, srcNode);
		},

		postMixInProperties: function(){
			this.inherited(arguments);

			// Scrolling controller only works for horizontal non-nested tabs
			if(!this.controllerWidget){
				this.controllerWidget = (this.tabPosition == "top" || this.tabPosition == "bottom") && !this.nested ?
							"dijit.layout.ScrollingTabController" : "dijit.layout.TabController";
			}
		}
});

}

if(!dojo._hasResource["dojox.widget.Standby"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.widget.Standby"] = true;
dojo.provide("dojox.widget.Standby");






dojo.experimental("dojox.widget.Standby");

dojo.declare("dojox.widget.Standby",[dijit._Widget, dijit._Templated],{
	// summary:
	//		A widget designed to act as a Standby/Busy/Disable/Blocking widget to indicate a
	//		particular DOM node is processing and cannot be clicked on at this time.
	//		This widget uses absolute positioning to apply the overlay and image.
	//
	// image:
	//		A URL to an image to center within the blocking overlay.
	//		The default is a basic spinner.
	//
	// imageText:
	//		Text to set on the ALT tag of the image.
	//		The default is 'Please wait...'
	//
	// text:
	//		Text to display in the center instead of an image.
	//		Defaults to 'Please Wait...'
	//
	// centerIndicator:
	//		Which to use as the center info, the text or the image.
	//		Defaults to image.
	//
	// color:
	//		The color to use for the translucent overlay.
	//		Text string such as: darkblue, #FE02FD, etc.
	//
	// duration:
	//		How long the fade in and out effects should run in milliseconds.
	//		Default is 500ms
	//
	// zIndex:
	//		Control that lets you specify if the zIndex for the overlay
	//		should be auto-computed based off parent zIndex, or should be set
	//		to a particular value.  This is useful when you want to overlay
	//		things in digit.Dialogs, you can specify a base zIndex to append from.
	//		Default is 'auto'.

	// templateString: [protected] String
	//		The template string defining out the basics of the widget.  No need for an external
	//		file.
	templateString:
		"<div>" +
			"<div style=\"display: none; opacity: 0; z-index: 9999; " +
				"position: absolute; cursor:wait;\" dojoAttachPoint=\"_underlayNode\"></div>" +
			"<img src=\"${image}\" style=\"opacity: 0; display: none; z-index: -10000; " +
				"position: absolute; top: 0px; left: 0px; cursor:wait;\" "+
				"dojoAttachPoint=\"_imageNode\">" +
			"<div style=\"opacity: 0; display: none; z-index: -10000; position: absolute; " +
				"top: 0px;\" dojoAttachPoint=\"_textNode\"></div>" +
		"</div>",

	// _underlayNode: [private] DOMNode
	//		The node that is the translucent underlay for the
	//		image that blocks access to the target.
	_underlayNode: null,

	// _imageNode: [private] DOMNode
	//		The image node where we attach and define the image to display.
	_imageNode: null,

	// _textNode: [private] DOMNode
	//		The div to attach text/HTML in the overlay center item.
	_textNode: null,

	// _centerNode: [private] DOMNode
	//		Which node to use as the center node, the image or the text node.
	_centerNode: null,

	// image: String
	//		The URL to the image to center in the overlay.
	image: dojo.moduleUrl("dojox", "widget/Standby/images/loading.gif").toString(),

	// imageText: String
	//		Text for the ALT tag.
	imageText: "Please Wait...",

	// text: String
	//		Text/HTML to display in the center of the overlay
	//		This is used if image center is disabled.
	text: "Please wait...",

	// centerIndicator: String
	//		Property to define if the image and its alt text should be used, or
	//		a simple Text/HTML node should be used.  Allowable values are 'image'
	//		and 'text'.
	//		Default is 'image'.
	centerIndicator: "image",

	// _displayed: [private] Boolean
	//		Flag to indicate if the overlay is displayed or not.
	_displayed: false,

	// _resizeCheck: [private] Object
	//		Handle to interval function that checks the target for changes.
	_resizeCheck: null,
	
	// target: DOMNode||DOMID(String)||WidgetID(String)
	//		The target to overlay when active.  Can be a widget id, a
	//		dom id, or a direct node reference.
	target: "",

	// color:	String
	//		The color to set the overlay.  Should be in #XXXXXX form.
	//		Default color for the translucent overlay is light gray.
	color: "#C0C0C0",

	// duration: integer
	//		Integer defining how long the show and hide effects should take.
	duration: 500,

	// _started: [private] Boolean
	//		Trap flag to ensure startup only processes once.
	_started: false,

	// _parent: [private] DOMNode
	//		Wrapping div for the widget, also used for IE 7 in dealing with the
	//		zoom issue.
	_parent: null,

	// zIndex: String
	//		Control that lets you specify if the zIndex for the overlay
	//		should be auto-computed based off parent zIndex, or should be set
	//		to a particular value.  This is useful when you want to overlay
	//		things in digit.Dialogs, you can specify a base zIndex to append from.
	zIndex: "auto",

	startup: function(args){
		// summary:
		//		Over-ride of the basic widget startup function.
		//		Configures the target node and sets the image to use.
		if(!this._started){
			if(typeof this.target === "string"){
				var w = dijit.byId(this.target);
				if(w){
					this.target = w.domNode;
				}else{
					this.target = dojo.byId(this.target);
				}
			}

			if(this.text){
				this._textNode.innerHTML = this.text;
			}
			if(this.centerIndicator === "image"){
				this._centerNode = this._imageNode;
				dojo.attr(this._imageNode, "src", this.image);
				dojo.attr(this._imageNode, "alt", this.imageText);
			}else{
				this._centerNode = this._textNode;
			}
			dojo.style(this._underlayNode, {
				display: "none",
				backgroundColor: this.color
			});
			dojo.style(this._centerNode, "display", "none");
			this.connect(this._underlayNode, "onclick", "_ignore");

			//Last thing to do is move the widgets parent, if any, to the current document body.
			//Avoids having to deal with parent relative/absolute mess.  Otherwise positioning
			//tends to go goofy.
			if(this.domNode.parentNode && this.domNode.parentNode != dojo.body()){
				dojo.body().appendChild(this.domNode);
			}

			//IE 7 has a horrible bug with zoom, so we have to create this node
			//to cross-check later.  Sigh.
			if(dojo.isIE == 7){
				this._ieFixNode = dojo.doc.createElement("div");
				dojo.style(this._ieFixNode, {
					opacity: "0",
					zIndex: "-1000",
					position: "absolute",
					top: "-1000px"
				});
				dojo.body().appendChild(this._ieFixNode);
			}
		}
	},

	show: function(){
		// summary:
		//		Function to display the blocking overlay and busy/status icon or text.
		if(!this._displayed){
			if(this._anim){
				this._anim.stop();
				delete this._anim;
			}
			this._displayed = true;
			this._size();
			this._disableOverflow();
			this._fadeIn();
		}
	},

	hide: function(){
		// summary:
		//		Function to hide the blocking overlay and status icon or text.
		if(this._displayed){
			if(this._anim){
				this._anim.stop();
				delete this._anim;
			}
			this._size();
			this._fadeOut();
			this._displayed = false;
			if(this._resizeCheck !== null){
				clearInterval(this._resizeCheck);
				this._resizeCheck = null;
			}
		}
	},

	isVisible: function(){
		// summary:
		//		Helper function so you can test if the widget is already visible or not.
		// returns:
		//		boolean indicating if the widget is in 'show' state or not.
		return this._displayed; // boolean
	},

	onShow: function(){
		// summary:
		//		Event that fires when the display of the Standby completes.
	},

	onHide: function(){
		// summary:
		//		Event that fires when the display of the Standby completes.
	},

	uninitialize: function(){
		// summary:
		//		Over-ride to hide the widget, which clears intervals, before cleanup.
		this._displayed = false;
		if(this._resizeCheck){
			clearInterval(this._resizeCheck);
		}
		dojo.style(this._centerNode, "display", "none");
		dojo.style(this._underlayNode, "display", "none");
		if(dojo.isIE == 7){
			dojo.body().removeChild(this._ieFixNode);
			delete this._ieFixNode;
		}
		if(this._anim){
			this._anim.stop();
			delete this._anim;
		}
		this.target = null;
		this._imageNode = null;
		this._textNode = null;
		this._centerNode = null;
		this.inherited(arguments);
	},

	_size: function(){

		// summary:
		//		Internal function that handles resizing the overlay and
		//		centering of the image on window resizing.
		// tags:
		//		private
		if(this._displayed){
			var dir = dojo.attr(dojo.body(), "dir");
			if(dir){dir = dir.toLowerCase();}
			var _ie7zoom;
			var scrollers = this._scrollerWidths();

			var target = this.target;

			//Show the image and make sure the zIndex is set high.
			var curStyle = dojo.style(this._centerNode, "display");
			dojo.style(this._centerNode, "display", "block");
			var box = dojo.position(target, true);
			if(target === dojo.body() || target === dojo.doc){
				// Target is the whole doc, so scale to viewport.
				box = dojo.window.getBox();
				box.x = box.l;
				box.y = box.t;
			}

			var cntrIndicator = dojo.marginBox(this._centerNode);
			dojo.style(this._centerNode, "display", curStyle);

			//IE has a horrible zoom bug.  So, we have to try and account for
			//it and fix up the scaling.
			if(this._ieFixNode){
				_ie7zoom = -this._ieFixNode.offsetTop / 1000;
				box.x = Math.floor((box.x + 0.9) / _ie7zoom);
				box.y = Math.floor((box.y + 0.9) / _ie7zoom);
				box.w = Math.floor((box.w + 0.9) / _ie7zoom);
				box.h = Math.floor((box.h + 0.9) / _ie7zoom);
			}

			//Figure out how to zIndex this thing over the target.
			var zi = dojo.style(target, "zIndex");
			var ziUl = zi;
			var ziIn = zi;

			if(this.zIndex === "auto"){
				if(zi != "auto"){
					ziUl = parseInt(ziUl, 10) + 1;
					ziIn = parseInt(ziIn, 10) + 2;
				}else{
					//We need to search up the chain to see if there
					//are any parent zIndexs to overlay.
					var cNode = target.parentNode;
					var oldZi = -100000;
					while(cNode && cNode !== dojo.body()){
						zi = dojo.style(cNode, "zIndex");
						if(!zi || zi === "auto"){
							cNode = cNode.parentNode;
						}else{
							var newZi = parseInt(zi, 10);
							if(oldZi < newZi){
								oldZi = newZi;
								ziUl = newZi + 1;
								ziIn = newZi + 2;
							}
							// Keep looking until we run out, we want the highest zIndex.
							cNode = cNode.parentNode;
						}
					}
				}
			}else{
				ziUl = parseInt(this.zIndex, 10) + 1;
				ziIn = parseInt(this.zIndex, 10) + 2;
			}

			dojo.style(this._centerNode, "zIndex", ziIn);
			dojo.style(this._underlayNode, "zIndex", ziUl);


			var pn = target.parentNode;
			if(pn && pn !== dojo.body() &&
				target !== dojo.body() &&
				target !== dojo.doc){
				
				// If the parent is the body tag itself,
				// we can avoid all this, the body takes
				// care of overflow for me.  Besides, browser
				// weirdness with height and width on body causes
				// problems with this sort of intersect testing
				// anyway.
				var obh = box.h;
				var obw = box.w;
				var pnBox = dojo.position(pn, true);

				//More IE zoom corrections.  Grr.
				if(this._ieFixNode){
					_ie7zoom = -this._ieFixNode.offsetTop / 1000;
					pnBox.x = Math.floor((pnBox.x + 0.9) / _ie7zoom);
					pnBox.y = Math.floor((pnBox.y + 0.9) / _ie7zoom);
					pnBox.w = Math.floor((pnBox.w + 0.9) / _ie7zoom);
					pnBox.h = Math.floor((pnBox.h + 0.9) / _ie7zoom);
				}
				
				//Shift the parent width/height a bit if scollers are present.
				pnBox.w -= pn.scrollHeight > pn.clientHeight &&
					pn.clientHeight > 0 ? scrollers.v: 0;
				pnBox.h -= pn.scrollWidth > pn.clientWidth &&
					pn.clientWidth > 0 ? scrollers.h: 0;

				//RTL requires a bit of massaging in some cases
				//(and differently depending on browser, ugh!)
				//WebKit and others still need work.
				if(dir === "rtl"){
					if(dojo.isOpera){
						box.x += pn.scrollHeight > pn.clientHeight &&
							pn.clientHeight > 0 ? scrollers.v: 0;
						pnBox.x += pn.scrollHeight > pn.clientHeight &&
							pn.clientHeight > 0 ? scrollers.v: 0;
					}else if(dojo.isIE){
						pnBox.x += pn.scrollHeight > pn.clientHeight &&
							pn.clientHeight > 0 ? scrollers.v: 0;
					}else if(dojo.isWebKit){
						//TODO:  FIX THIS!
					}
				}

				//Figure out if we need to adjust the overlay to fit a viewable
				//area, then resize it, we saved the original height/width above.
				//This is causing issues on IE.  Argh!
				if(pnBox.w < box.w){
					//Scale down the width if necessary.
					box.w = box.w - pnBox.w;
				}
				if(pnBox.h < box.h){
					//Scale down the width if necessary.
					box.h = box.h - pnBox.h;
				}

				//Look at the y positions and see if we intersect with the
				//viewport borders.  Will have to do computations off it.
				var vpTop = pnBox.y;
				var vpBottom = pnBox.y + pnBox.h;
				var bTop = box.y;
				var bBottom = box.y + obh;
				var vpLeft = pnBox.x;
				var vpRight = pnBox.x + pnBox.w;
				var bLeft = box.x;
				var bRight = box.x + obw;
				var delta;
				//Adjust the height now
				if(bBottom > vpTop &&
					bTop < vpTop){
					box.y = pnBox.y;
					//intersecting top, need to do some shifting.
					delta = vpTop - bTop;
					var visHeight = obh - delta;
					//If the visible height < viewport height,
					//We need to shift it.
					if(visHeight < pnBox.h){
						box.h = visHeight;
					}else{
						//Deal with horizontal scrollbars if necessary.
						box.h -= 2*(pn.scrollWidth > pn.clientWidth &&
							pn.clientWidth > 0? scrollers.h: 0);
					}
				}else if(bTop < vpBottom && bBottom > vpBottom){
					//Intersecting bottom, just figure out how much
					//overlay to show.
					box.h = vpBottom - bTop;
				}else if(bBottom <= vpTop || bTop >= vpBottom){
					//Outside view, hide it.
					box.h = 0;
				}

				//adjust width
				if(bRight > vpLeft && bLeft < vpLeft){
					box.x = pnBox.x;
					//intersecting left, need to do some shifting.
					delta = vpLeft - bLeft;
					var visWidth = obw - delta;
					//If the visible width < viewport width,
					//We need to shift it.
					if(visWidth < pnBox.w){
						box.w = visWidth;
					}else{
						//Deal with horizontal scrollbars if necessary.
						box.w -= 2*(pn.scrollHeight > pn.clientHeight &&
							pn.clientHeight > 0? scrollers.w:0);
					}
				}else if(bLeft < vpRight && bRight > vpRight){
					//Intersecting right, just figure out how much
					//overlay to show.
					box.w = vpRight - bLeft;
				}else if(bRight <= vpLeft || bLeft >= vpRight){
					//Outside view, hide it.
					box.w = 0;
				}
			}

			if(box.h > 0 && box.w > 0){
				//Set position and size of the blocking div overlay.
				dojo.style(this._underlayNode, {
					display: "block",
					width: box.w + "px",
					height: box.h + "px",
					top: box.y + "px",
					left: box.x + "px"
				});

				var styles = ["borderRadius", "borderTopLeftRadius",
					"borderTopRightRadius","borderBottomLeftRadius",
					"borderBottomRightRadius"];
				this._cloneStyles(styles);
				if(!dojo.isIE){
					//Browser specific styles to try and clone if non-IE.
					styles = ["MozBorderRadius", "MozBorderRadiusTopleft",
						"MozBorderRadiusTopright","MozBorderRadiusBottomleft",
						"MozBorderRadiusBottomright","WebkitBorderRadius",
						"WebkitBorderTopLeftRadius", "WebkitBorderTopRightRadius",
						"WebkitBorderBottomLeftRadius","WebkitBorderBottomRightRadius"
					];
					this._cloneStyles(styles, this);
				}
				var cntrIndicatorTop = (box.h/2) - (cntrIndicator.h/2);
				var cntrIndicatorLeft = (box.w/2) - (cntrIndicator.w/2);
				//Only show the image if there is height and width room.
				if(box.h >= cntrIndicator.h && box.w >= cntrIndicator.w){
					dojo.style(this._centerNode, {
						top: (cntrIndicatorTop + box.y) + "px",
						left: (cntrIndicatorLeft + box.x) + "px",
						display: "block"
					});
				}else{
					dojo.style(this._centerNode, "display", "none");
				}
			}else{
				//Target has no size, display nothing on it!
				dojo.style(this._underlayNode, "display", "none");
				dojo.style(this._centerNode, "display", "none");
			}
			if(this._resizeCheck === null){
				//Set an interval timer that checks the target size and scales as needed.
				//Checking every 10th of a second seems to generate a fairly smooth update.
				var self = this;
				this._resizeCheck = setInterval(function(){self._size();}, 100);
			}
		}
	},

	_cloneStyles: function(list){
		// summary:
		//		Internal function to clone a set of styles from the target to
		//		the underlay.
		// list: Array
		//		An array of style names to clone.
		//
		// tags:
		//		private
		dojo.forEach(list, function(style){
			dojo.style(this._underlayNode,style,dojo.style(this.target,style));
		}, this);
	},

	_fadeIn: function(){
		// summary:
		//		Internal function that does the opacity style fade in animation.
		// tags:
		//		private
		var self = this;
		var underlayNodeAnim = dojo.animateProperty({
			duration: self.duration,
			node: self._underlayNode,
			properties: {opacity: {start: 0, end: 0.75}}
		});
		var imageAnim = dojo.animateProperty({
			duration: self.duration,
			node: self._centerNode,
			properties: {opacity: {start: 0, end: 1}},
			onEnd: function(){
				self.onShow();
				delete self._anim;
			}
		});
		this._anim = dojo.fx.combine([underlayNodeAnim,imageAnim]);
		this._anim.play();
	},

	_fadeOut: function(){
		// summary:
		//		Internal function that does the opacity style fade out animation.
		// tags:
		//		private
		var self = this;
		var underlayNodeAnim = dojo.animateProperty({
			duration: self.duration,
			node: self._underlayNode,
			properties: {opacity: {start: 0.75, end: 0}},
			onEnd: function(){
				dojo.style(this.node,{"display":"none", "zIndex": "-1000"});
			}
		});
		var imageAnim = dojo.animateProperty({
			duration: self.duration,
			node: self._centerNode,
			properties: {opacity: {start: 1, end: 0}},
			onEnd: function(){
				dojo.style(this.node,{"display":"none", "zIndex": "-1000"});
				self.onHide();
				self._enableOverflow();
				delete self._anim;
			}
		});
		this._anim = dojo.fx.combine([underlayNodeAnim,imageAnim]);
		this._anim.play();
	},

	_ignore: function(event){
		// summary:
		//		Function to ignore events that occur on the overlay.
		// event: Event
		//		The event to halt
		// tags:
		//		private
		if(event){
			dojo.stopEvent(event);
		}
	},

	_scrollerWidths: function(){
		// summary:
		//		This function will calculate the size of the vertical and
		//		horizontaol scrollbars.
		// returns:
		//		Object of form: {v: Number, h: Number} where v is vertical scrollbar width
		//		and h is horizontal scrollbar width.
		// tags:
		//		private
		var div = dojo.doc.createElement("div");
		dojo.style(div, {
			position: "absolute",
			opacity: 0,
			overflow: "hidden",
			width: "50px",
			height: "50px",
			zIndex: "-100",
			top: "-200px",
			left: "-200px",
			padding: "0px",
			margin: "0px"
		});
		var iDiv = dojo.doc.createElement("div");
		dojo.style(iDiv, {
			width: "200px",
			height: "10px"
		});
		div.appendChild(iDiv);
		dojo.body().appendChild(div);

		//Figure out content size before and after
		//scrollbars are there, then just subtract to
		//get width.
		var b = dojo.contentBox(div);
		dojo.style(div, "overflow", "scroll");
		var a = dojo.contentBox(div);
		dojo.body().removeChild(div);
		return { v: b.w - a.w, h: b.h - a.h };
	},

	/* The following are functions that tie into _Widget.attr() */

	_setTextAttr: function(text){
		// summary:
		//		Function to allow widget.attr to set the text displayed in center
		//		if using text display.
		// text: String
		//		The text to set.
		this._textNode.innerHTML = text;
		this.text = text;
	},

	_setColorAttr: function(c){
		// summary:
		//		Function to allow widget.attr to set the color used for the translucent
		//		div overlay.
		// c: String
		//		The color to set the background underlay to in #XXXXXX format..
		dojo.style(this._underlayNode, "backgroundColor", c);
		this.color = c;
	},

	_setImageTextAttr: function(text){
		// summary:
		//		Function to allow widget.attr to set the ALT text text displayed for
		//		the image (if using image center display).
		// text: String
		//		The text to set.
		dojo.attr(this._imageNode, "alt", text);
		this.imageText = text;
	},

	_setImageAttr: function(url){
		// summary:
		//		Function to allow widget.attr to set the url source for the center image
		// text: String
		//		The url to set for the image.
		dojo.attr(this._imageNode, "src", url);
		this.image = url;
	},

	_setCenterIndicatorAttr: function(indicator){
		// summary:
		//		Function to allow widget.attr to set the node used for the center indicator,
		//		either the image or the text.
		// indicator: String
		//		The indicator to use, either 'image' or 'text'.
		this.centerIndicator = indicator;
		if(indicator === "image"){
			this._centerNode = this._imageNode;
			dojo.style(this._textNode, "display", "none");
		}else{
			this._centerNode = this._textNode;
			dojo.style(this._imageNode, "display", "none");
		}
	},

	_disableOverflow: function(){
		 // summary:
		 //		Function to disable scrollbars on the body.  Only used if the overlay
		 //		targets the body or the document.
		 if(this.target === dojo.body() || this.target === dojo.doc){
			 // Store the overflow state we have to restore later.
			 // IE had issues, so have to check that it's defined.  Ugh.
			 this._overflowDisabled = true;
			 var body = dojo.body();
			 if(body.style && body.style.overflow){
				 this._oldOverflow = dojo.style(body, "overflow");
			 }else{
				 this._oldOverflow = "";
			 }
			 if(dojo.isIE && !dojo.isQuirks){
				 // IE will put scrollbars in anyway, html (parent of body)
				 // also controls them in standards mode, so we have to
				 // remove them, argh.
				 if(body.parentNode &&
					body.parentNode.style &&
					body.parentNode.style.overflow){
					 this._oldBodyParentOverflow = body.parentNode.style.overflow;
				 }else{
					 try{
						this._oldBodyParentOverflow = dojo.style(body.parentNode, "overflow");
					 }catch(e){
						 this._oldBodyParentOverflow = "scroll";
					 }
				 }
				 dojo.style(body.parentNode, "overflow", "hidden");
			 }
			 dojo.style(body, "overflow", "hidden");
		 }
	},

	_enableOverflow: function(){
		 // summary:
		 //		Function to restore scrollbars on the body.  Only used if the overlay
		 //		targets the body or the document.
		 if(this._overflowDisabled){
			delete this._overflowDisabled;
			var body = dojo.body();
			// Restore all the overflow.
			if(dojo.isIE && !dojo.isQuirks){
				body.parentNode.style.overflow = this._oldBodyParentOverflow;
				delete this._oldBodyParentOverflow;
			}
			dojo.style(body, "overflow", this._oldOverflow);
			if(dojo.isWebKit){
				//Gotta poke WebKit, or scrollers don't come back. :-(
				var div = dojo.create("div", { style: {
						height: "2px"
					}
				});
				body.appendChild(div);
				setTimeout(function(){
					body.removeChild(div);
				}, 0);
			}
			delete this._oldOverflow;
		}
	}
});

}

if(!dojo._hasResource["plugins.core.Updater"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.core.Updater"] = true;
dojo.provide("plugins.core.Updater");

// UPDATE SUBSCRIBING OBJECTS, E.G., IN RESPONSE TO INFORMATION
// CHANGES THAT AFFECT THE SUBSCRIBING OBJECTS
dojo.declare( "plugins.core.Updater",
    null,
{    
// HASH OF LOADED CSS FILES
loadedCssFiles : null,

updates : null,

constructor : function () {
	//////console.log("core.Updater.constructor    plugins.core.Updater.constructor()");
	this.startup();
},

startup : function () {
	this.updates = new Object;
},

/////}}}
subscribe : function (subscriber, subscription) {
	//console.log("core.Updater.subscribe    plugins.core.Updater.subscribe(subscriber, subscription)");
	//console.log("core.Updater.subscribe    subscriber: " + subscriber);
	//console.log("core.Updater.subscribe    subscription: " + subscription);

	// CHECK SUBSCRIBER IMPLEMENTS SUBSCRIPTION METHOD
	if ( subscriber[subscription] == null )
	{
		//console.error("core.Updater.subscribe    subscriber " + subscriber + " doesn't implement subscription method: " + subscription);
		return;
	}

	if ( this.updates[subscription] == null )
		this.updates[subscription] = new Array;
	
	for ( currentSubscriber in this.updates[subscription] )
	{
		if ( currentSubscriber == subscriber )
		{
			//console.log("core.Updater.subscribe    subscriber " + subscriber + " is already subscribed to subscription: " + subscription);
			return;	
		}
	}

	//console.log("core.Updater.subscribe    subscribers.length BEFORE subscribe: " + this.updates[subscription].length);
	this.updates[subscription].push(subscriber);
	//console.log("core.Updater.subscribe    subscribers.length AFTER subscribe: " + this.updates[subscription].length);
},

update : function (subscription, args) {
	console.log("core.Updater.update    subscription: " + subscription);
	console.log("core.Updater.update    args: ");
	console.dir(args);
	
	var subscribers = this.getSubscribers(subscription);
	console.log("core.Updater.update    subscribers: ");
	console.dir({subscribers:subscribers});
	for ( var i in subscribers )
	{
		var subscriber = subscribers[i];
		console.log("core.Updater.update    subscriber: ");
		console.dir({subscriber:subscriber});
		subscriber[subscription](args);
	}
},

getSubscribers : function (subscription) {
	return this.updates[subscription]
},

unsubscribe : function (subscriber, subscription) {
	////console.log("core.Updater.unsubscribe    plugins.core.Updater.unsubscribe(subscriber, subscription)");
	////console.log("core.Updater.unsubscribe    subscriber: " + subscriber);
	////console.log("core.Updater.unsubscribe    subscription: " + subscription);

	// CHECK SUBSCRIBER IMPLEMENTS SUBSCRIPTION METHOD
	if ( subscriber[subscription] == null )
	{
		////console.error("core.Updater.unsubscribe    subscriber " + subscriber + " doesn't implement subscription method: " + subscription);
		return;
	}

	if ( this.updates[subscription] == null )
		this.updates = new Array;
	
	////console.log("core.Updater.unsubscribe    subscribers.length BEFORE unsubscribe: " + updates[subscription].length);
	for ( var i = 0; i < this.updates[subscription].length; i++ )
	{
		if ( this.updates[subscription][i] == subscriber )
		{
			////console.log("core.Updater.unsubscribe    Removing subscriber " + subscriber);
			this.updates[subscription].splice(i, 1);
			break;	
		}
	}
	////console.log("core.Updater.unsubscribe    subscribers.length AFTER unsubscribe: " + updates[subscription].length);
}



});


}

if(!dojo._hasResource["plugins.core.Agua.Data"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.core.Agua.Data"] = true;
dojo.provide("plugins.core.Agua.Data");

/* SUMMARY: THIS CLASS IS INHERITED BY  Agua.js AND CONTAINS THE MAJORITY
  
  OF THE DATA MANIPULATION METHODS (SUPPLEMENTED BY Common.js WHICH Agua.js
  
  ALSO INHERITS).
  
  THE "MUTATORS AND ACCESSORS" METHODS JUST BELOW ARE PRIVATE - THEY SHOULD
  
  NOT BE CALLED DIRECTLY OR OVERRIDDEN.

*/

dojo.declare( "plugins.core.Agua.Data",	[  ], {

/////}}}

// MUTATORS AND ACCESSORS (GET, SET, CLONE, ETC.)
cloneData : function (name) {
	var caller = this.cloneData.caller.nom;
	////console.log("Data.cloneData    caller: " + caller);
	//console.log("Data.cloneData    this.data:");
	//console.dir({this_data:this.data});
	if ( this.data[name] != null )
	    return dojo.clone(this.data[name]);
	else return [];
},
getData : function(name) {
	////console.log("Data.getData    core.Data.getData()");		
	//console.log("Data.getData    this.data:");
	//console.dir({this_data:this.data});
	if ( this.data[name] == null )
		this.data[name] = [];
	return this.data[name];
},
setData : function(name, value) {
	////console.log("Data.setData    core.Data.setData()");		
	//console.log("Data.setData    this.data:");
	//console.dir({this_data:this.data});
    this.data[name] = value;
},
addData : function(name, object, keys) {
	////console.log("Data.addData    name: " + name);		
	////console.log("Data.addData    object: " + dojo.toJson(object));		
	////console.log("Data.addData    keys: " + dojo.toJson(keys));		
	//console.log("Data.addData    this.data:");
	//console.dir({this_data:this.data});
	return this._addObjectToArray(this.data[name], object, keys);	
},
removeData : function(name, object, keys) {
	////console.log("Data.removeData    name: " + name);		
	//console.log("Data.removeData    this.data:");
	//console.dir({this_data:this.data});
	return this._removeObjectFromArray(this.data[name], object, keys);	
},
removeArrayFromData : function (name, array, keys) {
	//console.log("Data.removeArrayFromData    this.data:");
	//console.dir({this_data:this.data});
	return this._removeArrayFromArray(this.data[name], array, keys);
},
addArrayToData : function (name, array, keys) {
	//console.log("Data.addArrayToData    this.data:");
	//console.dir({this_data:this.data});
	return this._addArrayToArray(this.data[name], array, keys);
},
removeObjectsFromData : function (name, array, keys) {
	console.log("Data.removeObjectsFromData    BEFORE REMOVE, this.data[" + name + "]");
	console.dir({this_data:this.data[name]});
	return this._removeObjectsFromArray(this.data[name], array, keys);
},
sortData : function (name, key) {
	this.sortHasharray(this.getData(name), key);
},
loadData : function (data) {
	////console.log("Data.loadData    Agua.loadData(data)");
	////console.log("Data.loadData    data: " + data);
	Agua.data = dojo.clone(data);	
},
}); // end of Agua

}

if(!dojo._hasResource["plugins.core.Agua.Access"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.core.Agua.Access"] = true;
dojo.provide("plugins.core.Agua.Access");

/* SUMMARY: THIS CLASS IS INHERITED BY Agua.js AND CONTAINS 
	
	ADMIN METHODS  
*/

dojo.declare( "plugins.core.Agua.Access",	[  ], {

///////}}}

getAccess : function () {
	//console.log("Agua.Access.getAccess    plugins.core.Data.getAccess()");
	return this.cloneData("access");
}

});

}

if(!dojo._hasResource["plugins.core.Agua.Ami"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.core.Agua.Ami"] = true;
dojo.provide("plugins.core.Agua.Ami");

/* SUMMARY: THIS CLASS IS INHERITED BY Agua.js AND CONTAINS 
	
	CLUSTER METHODS  
*/

dojo.declare( "plugins.core.Agua.Ami",	[  ], {

/////}}}
getAmis : function () {
// RETURN A COPY OF THE amis ARRAY
	//console.log("Agua.Ami.getAmis    plugins.core.Data.getAmis()");
	return this.cloneData("amis");
},
getAmiObjectById : function (amiid) {
	//console.log("Agua.Ami.getAmiObjectById    plugins.core.Data.getAmiObjectById()");
	var amis = this.getAmis();	
	//console.log("Agua.Ami.getAmiObjectById    amis: " + dojo.toJson(amis));
	return this._getObjectByKeyValue(amis, ["amiid"], amiid);	
},
addAmi : function (amiObject) {
	this._removeAmi(amiObject);
	this._addAmi(amiObject);

	// SAVE ON REMOTE DATABASE
	var url = this.cgiUrl + "workflow.cgi?";
	amiObject.username = this.cookie("username");	
	amiObject.sessionid = this.cookie("sessionid");	
	amiObject.mode = "addAmi";
	console.log("Agua.Ami.addAmi    amiObject: " + dojo.toJson(amiObject));
	
	this.doPut({ url: url, query: amiObject, sync: false, timeout: 15000 });
},
removeAmi : function (amiObject) {
	console.log("Agua.Ami.removeAmi    Agua.removeAmi(amiObject)");
	//console.log("Agua.Ami.removeAmi    amiObject: " + dojo.toJson(amiObject));

	var success = this._removeAmi(amiObject)
	if ( success == false ) {
		console.log("this.removeAmi    this._removeAmi(amiObject) returned false for ami: " + amiObject.ami);
		return;
	}
	
	var url = this.cgiUrl + "sharing.cgi?";
	amiObject.username = this.cookie("username");
	amiObject.sessionid = this.cookie("sessionid");
	amiObject.mode = "removeAmi";
	//console.log("this.removeAmi    amiObject: " + dojo.toJson(amiObject));

	this.doPut({ url: url, query: amiObject, sync: false, timeout: 15000 });	
},
_removeAmi : function (amiObject) {
// REMOVE A CLUSTER OBJECT FROM THE amis ARRAY
	console.log("Agua.Ami._removeAmi    plugins.core.Data._removeAmi(amiObject)");
	//console.log("Agua.Ami._removeAmi    amiObject: " + dojo.toJson(amiObject));
	var requiredKeys = ["amiid"];
	return this.removeData("amis", amiObject, requiredKeys);
},
_addAmi : function (amiObject) {
// ADD A CLUSTER TO amis AND SAVE ON REMOTE SERVER
	console.log("Agua.Ami._addAmi    plugins.core.Data._addAmi(amiObject)");
	//console.log("Agua.Ami._addAmi    amiObject: " + dojo.toJson(amiObject));

	// DO THE ADD
	var requiredKeys = ["amiid"];
	return this.addData("amis", amiObject, requiredKeys);
}


});

}

if(!dojo._hasResource["plugins.core.Agua.App"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.core.Agua.App"] = true;
dojo.provide("plugins.core.Agua.App");

/* SUMMARY: THIS CLASS IS INHERITED BY Agua.js AND CONTAINS 
	
	APP METHODS  
*/

dojo.declare( "plugins.core.Agua.App",	[  ], {

/////}}}

getAppHeadings : function () {
	console.log("Agua.App.getAppHeadings    plugins.core.Data.getAppHeadings()");
	var headings = this.cloneData("appheadings");
	console.log("Agua.App.getAppHeadings    headings: " + dojo.toJson(headings));
	return headings;
},
getApps : function () {
	//console.log("Agua.App.getApps    plugins.core.Data.getApps()");
	return this.cloneData("apps");
},
getAppTypes : function (apps) {
// GET SORTED LIST OF ALL APP TYPES
	var typesHash = new Object;
	for ( var i = 0; i < apps.length; i++ )
	{
		typesHash[apps[i].type] = 1;
	}	
	var types = this.hashkeysToArray(typesHash)
	types = this.sortNoCase(types);
	
	return types;
},
getAppType : function (appName) {
// RETURN THE TYPE OF AN APP OWNED BY THE USER
	console.log("Agua.App.getAppType    plugins.core.Data.getAppType(appName)");
	//console.log("Agua.App.getAppType    appName: *" + appName + "*");
	var apps = this.cloneData("apps");
	for ( var i in apps )
	{
		var app = apps[i];
		if ( app.name.toLowerCase() == appName.toLowerCase() )
			return app.type;
	}
	
	return null;
},
hasApps : function () {
	//console.log("Agua.App.hasApps    plugins.core.Data.hasApps()");
	if ( this.getData("apps").length == 0 )	return false;	
	return true;
},
addApp : function (appObject) {
// ADD AN APP OBJECT TO apps
	console.log("Agua.App.addApp    plugins.core.Data.addApp(appObject)");
	//console.log("Agua.App.addApp    appObject: " + dojo.toJson(appObject));
	var result = this.addData("apps", appObject, [ "name" ]);
	if ( result == true ) this.sortData("apps", "name");
	
	// RETURN TRUE OR FALSE
	return result;
},
removeApp : function (appObject) {
// REMOVE AN APP OBJECT FROM apps
	console.log("Agua.App.removeApp    plugins.core.Data.removeApp(appObject)");
	//console.log("Agua.App.removeApp    appObject: " + dojo.toJson(appObject));
	var result = this.removeData("apps", appObject, ["name"]);
	
	return result;
},
isApp : function (appName) {
// RETURN true IF AN APP EXISTS IN apps
	console.log("Agua.App.isApp    plugins.core.Data.isApp(appName, appObject)");
	console.log("Agua.App.isApp    appName: *" + appName + "*");
	
	var apps = this.getApps();
	for ( var i in apps )
	{
		var app = apps[i];
		console.log("Agua.App.isApp    Checking app.name: *" + app.name + "*");
		if ( app.name.toLowerCase() == appName.toLowerCase() )
		{
			return true;
		}
	}
	
	return false;
}

});

}

if(!dojo._hasResource["plugins.core.Agua.Aws"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.core.Agua.Aws"] = true;
dojo.provide("plugins.core.Agua.Aws");

/* SUMMARY: THIS CLASS IS INHERITED BY Agua.js AND CONTAINS 
	
	AWS METHODS  
*/

dojo.declare( "plugins.core.Agua.Aws",	[  ], {

/////}}}

getAws : function () {
// RETURN CLONE OF this.aws
	//console.log("Agua.Aws.getAws    plugins.core.Data.getAws(username)");
	//console.log("Agua.Aws.getAws    username: " + username);
	return this.cloneData("aws");
},
setAws : function (aws) {
// RETURN ENTRY FOR username IN this.aws
	console.log("Agua.Aws.setAws    plugins.core.Data.setAws(aws)");
	console.log("Agua.Aws.setAws    aws: " + dojo.toJson(aws));
	if ( aws == null )
	{
		console.log("Agua.Aws.setAws    aws is null. Returning");
		return;
	}
	if ( aws.amazonuserid == null )
	{
		console.log("Agua.Aws.setAws    aws.amazonuserid is null. Returning");
		return;
	}
	this.setData("aws", aws);
	
	return aws;
},
getAvailzonesByRegion : function (region) {
	if ( region == null )	return;
	var regionzones = this.cloneData("regionzones");
	if ( regionzones[region] != null )
		return regionzones[region];
	
	return [];
}


});

}

if(!dojo._hasResource["plugins.core.Agua.Cloud"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.core.Agua.Cloud"] = true;
dojo.provide("plugins.core.Agua.Cloud");

/* SUMMARY: THIS CLASS IS INHERITED BY Agua.js AND CONTAINS 
	
	ADMIN METHODS  
*/

dojo.declare( "plugins.core.Agua.Cloud",	[  ], {

///////}}}

getCloudHeadings : function () {
	console.log("Agua.Cloud.getCloudHeadings    plugins.core.Data.getCloudHeadings()");
	var headings = this.cloneData("cloudheadings");
	console.log("Agua.Cloud.getCloudHeadings    headings: " + dojo.toJson(headings));
	return headings;
}

});

}

if(!dojo._hasResource["plugins.core.Agua.Cluster"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.core.Agua.Cluster"] = true;
dojo.provide("plugins.core.Agua.Cluster");

/* SUMMARY: THIS CLASS IS INHERITED BY Agua.js AND CONTAINS 
	
	CLUSTER METHODS  
*/

dojo.declare( "plugins.core.Agua.Cluster",	[  ], {

/////}}}
getClusterObject : function (clusterName) {
	console.log("Agua.Cluster.getClusterObject    plugins.core.Data.getClusterObject(clusterName)");
	console.log("Agua.Cluster.getClusterObject    clusterName: " + clusterName);
	var clusters = this.getClusters();
	console.log("Agua.Cluster.getClusterObject    clusters: " + dojo.toJson(clusters));
	if ( clusters == null )	return [];
	var keyArray = ["cluster"];
	var valueArray = [clusterName];
	clusters = this.filterByKeyValues(clusters, keyArray, valueArray);
	console.log("Agua.Cluster.getClusterObject    FILTERED clusters: " + dojo.toJson(clusters));
	
	if ( clusters != null && clusters.length != 0 )
		return clusters[0];
	return null;
},
getClusters : function () {
// RETURN A COPY OF THE clusters ARRAY
	//console.log("Agua.Cluster.getClusters    plugins.core.Data.getClusters()");
	return this.cloneData("clusters");
},
getClusterByWorkflow : function (projectName, workflowName) {
// RETURN THE CLUSTER FOR THIS WORKFLOW, OR "" IF NO CLUSTER ASSIGNED
	//console.log("Agua.Cluster.getClusterByWorkflow    plugins.core.Data.getClusterByWorkflow(projectName, workflowName)");
	//console.log("Agua.Cluster.getClusterByWorkflow    projectName: " + projectName);
	//console.log("Agua.Cluster.getClusterByWorkflow    workflowName: " + workflowName);

	var clusterworkflows = this.cloneData("clusterworkflows");
	//console.log("Agua.Cluster.getClusterObjectByWorkflow   clusterworkflows: " + dojo.toJson(clusterworkflows));
    clusterworkflows = this.filterByKeyValues(clusterworkflows, ["project", "workflow"], [projectName, workflowName]);
	//console.log("Agua.Cluster.getClusterObjectByWorkflow   clusterworkflows: " + dojo.toJson(clusterworkflows));
    
	if ( clusterworkflows != null && clusterworkflows.length > 0 )
        return clusterworkflows[0].cluster;
		
    return null;
},
isClusterWorkflow : function (clusterObject) {
// RETURN 1 IF THE ENTRY ALREADY EXISTS IN clusterworkflows, 0 OTHERWISE
	//console.log("Agua.Cluster.isClusterWorkflow    plugins.core.Data.isClusterWorkflow(clusterObject)");
	//console.log("Agua.Cluster.isClusterWorkflow    clusterObject: " + dojo.toJson(clusterObject));

	var clusterworkflows = this.cloneData("clusterworkflows");
	//console.log("Agua.Cluster.isClusterWorkflow    BEFORE clusterworkflows: " + dojo.toJson(clusterworkflows));
    clusterworkflows = this.filterByKeyValues(clusterworkflows, ["project", "workflow", "cluster"], [clusterObject.project, clusterObject.workflow, clusterObject.cluster]);
	//console.log("Agua.Cluster.isClusterWorkflow    AFTER clusterworkflows: " + dojo.toJson(clusterworkflows));
    
	if ( clusterworkflows != null && clusterworkflows.length > 0 )
        return 1;
		
    return 0;
},
getClusterObjectByWorkflow : function (projectName, workflowName) {

	var clusterName = this.getClusterByWorkflow(projectName, workflowName);
	if ( clusterName == null || ! clusterName) 	return null;
	console.log("Agua.Cluster.getClusterObjectByWorkflow    clusterName: " + clusterName);
	
	return this.getClusterObject(clusterName);
},
getClusterLongName : function (cluster) {
	var username = this.cookie("username");
	var clusterName = "";
	if ( cluster != null && cluster ) clusterName = username + "-" + cluster;
	
	return clusterName;
},
isCluster : function (clusterName) {
// RETURN true IF A CLUSTER EXISTS
	//console.log("Agua.Cluster.isCluster    plugins.core.Data.isCluster(clusterName)");
	//console.log("Agua.Cluster.isCluster    clusterName: *" + clusterName + "*");

	var clusterObjects = this.getClusters();
	var inArray = this._objectInArray(clusterObjects, { cluster: clusterName }, ["cluster"]);	
	//console.log("Agua.Cluster.isCluster    inArray: " + inArray);
	//console.log("Agua.Cluster.isCluster    clusterObjects: " + dojo.toJson(clusterObjects));

	return inArray;
},
addCluster : function (clusterObject) {
// MODIFIES EXISTING CLUSTER. DOES NOT CREATE NEW CELL DIR
	console.log("Agua.Cluster.newCluster    clusterObject:");
	console.dir({clusterObject:clusterObject});
	
	this._removeCluster(clusterObject);
	this._addCluster(clusterObject);

	// SAVE ON REMOTE DATABASE
	var url = this.cgiUrl + "workflow.cgi?";
	clusterObject.username = this.cookie("username");	
	clusterObject.sessionid = this.cookie("sessionid");	
	clusterObject.mode = "addCluster";
	console.log("Agua.Cluster.addCluster    clusterObject: " + dojo.toJson(clusterObject));
	
	this.doPut({
		url: url,
		query: clusterObject,
		sync: false,
		timeout: 15000,
		callback: null
	});
},
newCluster : function (clusterObject) {
// CREATES NEW CELL DIR
	console.log("Agua.Cluster.newCluster    core.Data.newCluster(clusterObject)");
	console.log("Agua.Cluster.newCluster    clusterObject: " + dojo.toJson(clusterObject));

	this._removeCluster(clusterObject);
	this._addCluster(clusterObject);

	// SAVE ON REMOTE DATABASE
	var url = this.cgiUrl + "workflow.cgi?";
	clusterObject.username = this.cookie("username");	
	clusterObject.sessionid = this.cookie("sessionid");	
	clusterObject.mode = "newCluster";
	console.log("Agua.Cluster.newCluster    clusterObject: " + dojo.toJson(clusterObject));
	
	this.doPut({
		url: url,
		query: clusterObject,
		sync: false,
		timeout: 15000,
		callback: dojo.hitch(this, "toast")
	});
},
removeCluster : function (clusterObject) {
	//console.log("Agua.Cluster.removeCluster    Agua.removeCluster(clusterObject)");
	//console.log("Agua.Cluster.removeCluster    clusterObject: " + dojo.toJson(clusterObject));

	var success = this._removeCluster(clusterObject)
	if ( success == false ) {
		console.log("this.removeCluster    this._removeCluster(clusterObject) returned false for cluster: " + clusterObject.cluster);
		return;
	}
	
	var url = this.cgiUrl + "workflow.cgi?";
	clusterObject.username = this.cookie("username");
	clusterObject.sessionid = this.cookie("sessionid");
	clusterObject.mode = "removeCluster";
	console.log("this.removeCluster    clusterObject: " + dojo.toJson(clusterObject));

	this.doPut({ url: url, query: clusterObject, sync: false, timeout: 15000 });	
},
_removeCluster : function (clusterObject) {
// REMOVE A CLUSTER OBJECT FROM THE clusters ARRAY
	console.log("Agua.Cluster._removeCluster    plugins.core.Data._removeCluster(clusterObject)");
	console.log("Agua.Cluster._removeCluster    clusterObject: " + dojo.toJson(clusterObject));
	var requiredKeys = ["cluster"];
	return this.removeData("clusters", clusterObject, requiredKeys);
},
_addCluster : function (clusterObject) {
// ADD A CLUSTER TO clusters AND SAVE ON REMOTE SERVER
	console.log("Agua.Cluster._addCluster    plugins.core.Data._addCluster(clusterObject)");
	//console.log("Agua.Cluster._addCluster    clusterObject: " + dojo.toJson(clusterObject));

	// DO THE ADD
	var requiredKeys = ["cluster"];
	return this.addData("clusters", clusterObject, requiredKeys);
},
_removeClusterWorkflow : function (clusterObject) {
// REMOVE A CLUSTER OBJECT FROM THE clusters ARRAY
	console.log("Agua.Cluster._removeClusterWorkflow    plugins.core.Data._removeClusterWorkflow(clusterObject)");
	var requiredKeys = ["project", "workflow"];
	return this.removeData("clusterworkflows", clusterObject, requiredKeys);
},
_addClusterWorkflow : function (clusterObject) {
// ADD A CLUSTER TO clusters AND SAVE ON REMOTE SERVER
	console.log("Agua.Cluster._addClusterWorkflow    plugins.core.Data._addClusterWorkflow(clusterObject)");
	console.log("Agua.Cluster._addClusterWorkflow    clusterObject: " + dojo.toJson(clusterObject));

	// DO THE ADD
	var requiredKeys = ["cluster", "project", "workflow"];
	return this.addData("clusterworkflows", clusterObject, requiredKeys);
},
});

}

if(!dojo._hasResource["plugins.core.Agua.Feature"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.core.Agua.Feature"] = true;
dojo.provide("plugins.core.Agua.Feature");

/* SUMMARY: THIS CLASS IS INHERITED BY Agua.js AND CONTAINS 
	
	FEATURE METHODS  
*/
dojo.declare( "plugins.core.Agua.Feature",	[  ], {

/////}}}

getViewFeatures : function (projectName, viewName) {
// GET THE UNIQUE SPECIES (AND BUILD) FOR A GIVEN VIEW
	console.log("Agua.View.getViewFeatures     plugins.core.Data.getViewFeatures(projectName, viewName)");
	console.log("Agua.View.getViewFeatures    projectName: " + projectName);
	console.log("Agua.View.getViewFeatures    viewName: " + viewName);
	if ( projectName == null || ! projectName )
	{
		//console.log("Agua.View.getViewFeatures     projectName is null or empty. Returning");
		return;
	}

	var viewfeatures = this.cloneData("viewfeatures");
	console.log("Agua.View.getViewFeatures    viewfeatures: ");
	console.dir({viewfeatures:viewfeatures});
	var keyArray = ["project", "view"];
	var valueArray = [projectName, viewName];
	viewfeatures = this.filterByKeyValues(viewfeatures, keyArray, valueArray);

	//console.log("Agua.View.getViewFeatures    Returning viewfeatures: " + dojo.toJson(viewfeatures));
	return viewfeatures;
},
hasViewFeature : function (projectName, viewName, featureName) {
	console.log("Agua.View.hasViewFeature    projectName: " + projectName);
	console.log("Agua.View.hasViewFeature    viewName: " + viewName);
	console.log("Agua.View.hasViewFeature    featureName: " + featureName);
	var features = this.getViewFeatures(projectName, viewName);
	console.log("Agua.View.hasViewFeature    features: ");
	console.dir({features:features});

	if ( features == null || features == [] )	return;
	
	var featureObject = {
		project: 	projectName,
		view:		viewName,
		feature:	featureName
	};
	var keys = ["project", "view", "feature"];
	return this._objectInArray(features, featureObject, keys);
},
getFeatureProjects : function () {
	//console.log("Agua.Feature.getFeatureProjects     plugins.core.Data.getFeatureProjects()");
	var features = this.cloneData("features");
	//console.log("Agua.Feature.getFeatureProjects     features: ");
	//console.dir({features:features});
	
	var projects = this.hashArrayKeyToArray(features, "project");
	console.log("Agua.Feature.getFeatureProjects     projects: ");
	console.dir({projects:projects});
	
	projects = this.uniqueValues(projects);
	
	return projects;
},
getViewProjectWorkflows : function (projectName) {
	//console.log("Agua.Feature.getViewProjectWorkflows     plugins.core.Data.getViewProjectWorkflows(projectName)");
	if ( projectName == null || ! projectName )
	{
		console.log("Agua.Feature.getViewProjectWorkflows     projectName is null or empty. Returning");
		return;
	}
	var features = this.cloneData("features");
	//console.log("Agua.Feature.getViewProjectWorkflows    features: " + dojo.toJson(features));
	var keyArray = ["project"];
	var valueArray = [projectName];
	features = this.filterByKeyValues(features, keyArray, valueArray);
	//console.log("Agua.Feature.getViewProjectWorkflows    FILTERED features: " + dojo.toJson(features));
	var workflows = new Array;
	for ( var i = 0; i < features.length; i++ )
		workflows.push(features[i].workflow);
	
	workflows = this.uniqueValues(workflows);
	//console.log("Agua.Feature.getViewProjectWorkflows    Returning workflows: " + dojo.toJson(workflows));
	
	return workflows;
},
getViewWorkflowFeatures : function (projectName, workflowName) {
	//console.log("Agua.Feature.getViewWorkflowFeatures     plugins.core.Data.getViewWorkflowFeatures(projectName, workflowName, speciesName, buildName)");
	//console.log("Agua.Feature.getViewWorkflowFeatures    projectName: " + projectName);
	//console.log("Agua.Feature.getViewWorkflowFeatures    workflowName: " + workflowName);
	var features = this.cloneData("features");
	//console.log("Agua.Feature.getViewWorkflowFeatures    features: " + dojo.toJson(features));
	var keyArray = ["project", "workflow"];
	var valueArray = [projectName, workflowName];
	features = this.filterByKeyValues(features, keyArray, valueArray);
	//console.log("Agua.Feature.getViewWorkflowFeatures    workflow features: " + dojo.toJson(features));

	return features;
},
getViewSpeciesFeatureNames : function (projectName, workflowName, speciesName, buildName) {
	// GET THE FEATURE NAMES FOR A GIVEN PROJECT, WORKFLOW AND SPECIES BUILD
	//console.log("Agua.Feature.getViewSpeciesFeatureNames    projectName: " + projectName);
	//console.log("Agua.Feature.getViewSpeciesFeatureNames    workflowName: " + workflowName);
	//console.log("Agua.Feature.getViewSpeciesFeatureNames    speciesName: " + speciesName);
	//console.log("Agua.Feature.getViewSpeciesFeatureNames    buildName: " + buildName);
	var features = this.getViewSpeciesFeatures(projectName, workflowName, speciesName, buildName);
	//console.log("Agua.Feature.getViewSpeciesFeatureNames    features: ");
	//console.dir({features:features});
	
	var featureNames = new Array;
	for ( var i = 0; i < features.length; i++ )
		featureNames.push(features[i].feature);
	
	featureNames = this.uniqueValues(featureNames);
	//console.log("Agua.Feature.getViewSpeciesFeatureNames    featureNames: ");
	//console.dir({featureNames:featureNames});	
	
	return featureNames;
},
getViewSpeciesFeatures : function (projectName, workflowName, speciesName, buildName) {
	// GET THE FEATURES FOR A GIVEN PROJECT, WORKFLOW AND SPECIES BUILD
	//console.log("Agua.Feature.getViewSpeciesFeatures     plugins.core.Data.getViewSpeciesFeatures(projectName, workflowName, speciesName, buildName)");
	//console.log("Agua.Feature.getViewSpeciesFeatures    projectName: " + projectName);
	//console.log("Agua.Feature.getViewSpeciesFeatures    workflowName: " + workflowName);
	//console.log("Agua.Feature.getViewSpeciesFeatures    speciesName: " + speciesName);
	//console.log("Agua.Feature.getViewSpeciesFeatures    buildName: " + buildName);

	if ( projectName == null || ! projectName
		|| workflowName == null || ! workflowName
		|| speciesName == null || ! speciesName )
	{
		console.log("Agua.Feature.getViewSpeciesFeatures     projectName is null or empty. Returning");
		return;
	}
	var features = this.cloneData("features");
	//console.log("Agua.Feature.getViewSpeciesFeatures    features: " + dojo.toJson(features));
	var keyArray = ["project", "workflow", "species", "build"];
	var valueArray = [projectName, workflowName, speciesName, buildName];
	features = this.filterByKeyValues(features, keyArray, valueArray);
	//console.log("Agua.Feature.getViewSpeciesFeatures    workflow features: " + dojo.toJson(features));

	return features;
},
_removeViewFeature : function (featureObject) {
	//console.log("Agua.Feature.removeViewFeature    plugins.core.Data.removeViewFeature(featureObject)");
	//console.log("Agua.Feature.removeViewFeature    featureObject: " + dojo.toJson(featureObject));

	// REMOVE LOCALLY AND THEN ON THE REMOTE
	var requiredKeys = ["project", "view", "feature"];

	var removeSuccess = Agua.removeData("viewfeatures", featureObject, requiredKeys);
	//console.log("Agua.Feature.removeViewFeature    removeSuccess: " + dojo.toJson(removeSuccess));
	if ( ! removeSuccess ) return;

	var viewObject = Agua.getViewObject(featureObject.project, featureObject.view);
	//console.log("Agua.Feature.removeViewFeature    viewObject: " + dojo.toJson(viewObject));

	// REMOVE TRACK IF PRESENT IN DISPLAYED TRACKS (tracklist)
	var tracklist = viewObject.tracklist;
	console.log("Agua.Feature.removeViewFeature    BEFORE tracklist: " + dojo.toJson(tracklist));
    var array = tracklist.split(/,/);
	//console.dir({array:array});
    for ( var i = 0; i < array.length; i++ ) {
        if ( array[i] == featureObject.feature ) {
            console.log("matched feature in array[" + i + "]: " + array[i]);
            array.splice(i, 1);
        }
    }
	tracklist = array.join(",");
	viewObject.tracklist = tracklist;
	console.log("Agua.Feature.removeViewFeature    AFTER tracklist: " + dojo.toJson(tracklist));

	// REMOVE VIEW OBJECT FROM VIEWS
	Agua.removeData("views", viewObject, ["project", "view"]);
	Agua.addData("views", viewObject, ["project", "view"]);

	views = Agua.getData("views");
	console.dir({views:views});
	
	return true;
},
isFeature : function (featureObject) {
// RETURN true IF THE FEATURE ALREADY EXISTS IN THE VIEW

	//console.log("Agua.Feature.isFeature    plugins.core.Data.isFeature(projectName, viewName)");
	//console.log("Agua.Feature.isFeature    featureObject: " + dojo.toJson(featureObject));
	
	var viewfeatures = this.getViewFeatures(featureObject.project, featureObject.view);
	//console.log("Agua.Feature.isFeature    viewfeatures: " + dojo.toJson(viewfeatures));
	if ( this._objectInArray(viewfeatures, featureObject, ["project", "view", "feature", "species", "build"]))
	{
		//console.log("Agua.Feature.isFeature    feature is in viewfeatures for this project/view. Returning true.");
		return true;
	}
	
	return false;
},
_addViewFeature : function (featureObject) {
	//console.log("Agua.Feature._addViewFeature    plugins.core.Data._addViewFeature(featureObject)");
	//console.log("Agua.Feature._addViewFeature    featureObject: " + dojo.toJson(featureObject));
	
	// RETURN IF FEATURE ALREADY EXISTS
	if ( this.isFeature(featureObject) )	return;

	// ADD LOCALLY 
	var requiredKeys = ["project", "view", "feature", "species", "build"];
	return this.addData("viewfeatures", featureObject, requiredKeys);
}

});

}

if(!dojo._hasResource["plugins.core.Agua.File"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.core.Agua.File"] = true;
dojo.provide("plugins.core.Agua.File");

/* SUMMARY: THIS CLASS IS INHERITED BY Agua.js AND CONTAINS FILE CACHE 
  
	AND FILE MANIPULATION METHODS  
*/

dojo.declare( "plugins.core.Agua.File",	[  ], {

/////}}}

// FILECACHE METHODS
getFoldersUrl : function () {
	return Agua.cgiUrl + "folders.cgi?";
},
setFileCaches : function (url) {
	console.log("Agua.File.setFileCache    url: " + url);
	var callback = dojo.hitch(this, function (data) {
		//console.log("Agua.File.setFileCache    BEFORE setData, data: ");
		//console.dir({data:data});
		this.setData("filecaches", data);
	});

	//console.log("Agua.File.setFileCache    Doing this.fetchJson(url, callback)");
	this.fetchJson(url, callback);
},
fetchJson : function (url, callback) {
	console.log("Agua.File.fetchJson    url: " + url);
    var thisObject = this;
    dojo.xhrGet({
        url: url,
		sync: false,
        handleAs: "json",
        handle: function(data) {
			//console.log("Agua.File.fetchJson    data: ");
			//console.dir({data:data});
			callback(data);
        },
        error: function(response) {
            console.log("Agua.File.fetchJson    Error with JSON Post, response: " + response);
        }
    });
},
getFileCache : function (username, location) {
	console.log("Agua.File.getFileCache    username: " + username);
	console.log("Agua.File.getFileCache    location: " + location);
	
	var fileCaches = this.cloneData("filecaches");
	console.log("Agua.File.getFileCache    fileCaches: ");
	console.dir({fileCaches:fileCaches});
	
	// RETURN IF NO ENTRIES FOR USER
	if ( ! fileCaches[username] )	return null;
	
	return fileCaches[username][location];
},
setFileCache : function (username, location, item) {
	console.log("Agua.File.setFileCache    username: " + username);
	console.log("Agua.File.setFileCache    location: " + location);
	console.log("Agua.File.setFileCache    item: ");
	console.dir({item:item});
	
	var fileCaches = this.getData("filecaches");
	if ( ! fileCaches )	fileCaches = {};
	if ( ! fileCaches[username] )	fileCaches[username] = {};
	fileCaches[username][location] = item;

	var parentDir = this.getParentDir(location);
	console.log("Agua.File.setFileCache    parentDir: " + parentDir);
	if ( ! parentDir )	return;
	
	var parent = fileCaches[username][parentDir];
	if ( ! parent )	return;
	console.log("Agua.File.setFileCache    parent: " + parent);
	this.addItemToParent(parent, item);

	console.log("Agua.File.setFileCache    parent: " + parent);
	console.dir({parent:parent});	
},
addItemToParent : function (parent, item) {
	parent.items.push(item);
},
getFileSystem : function (putData, callback, request) {
	console.log("Agua.File.getFileSystem    caller: " + this.getFileSystem.caller.nom);
	
	console.log("Agua.File.getFileSystem    putData:");
	console.dir({putData:putData});
	console.log("Agua.File.getFileSystem    callback: " + callback);
	console.dir({callback:callback});
	console.log("Agua.File.getFileSystem    request:");
	console.dir({request:request});
	
	// SET DEFAULT ARGS EMPTY ARRAY
	if ( ! request )
		request = new Array;
	
	// SET LOCATION
	var location = '';
	if ( putData.location || putData.query )
		location = putData.query || putData.location;
	console.log("Agua.File.getFileSystem    location: " + location);
	
	var username = putData.username;
	console.log("Agua.File.getFileSystem    username: " + username);
	
	// USE IF CACHED
	var fileCache = this.getFileCache(username, location);
	console.log("Agua.File.getFileSystem    fileCache:");
	console.dir({fileCache:fileCache});
	if ( fileCache ) {
		console.log("Agua.File.getFileSystem    fileCache IS DEFINED. Doing setTimeout callback(fileCache, request)");
		
		// DELAY TO AVOID node is undefined ERROR
		setTimeout( function() {
			callback(fileCache, request);
		},
		10,
		this);

		return;
	}
	else {
		console.log("Agua.File.getFileSystem    fileCache NOT DEFINED. Doing remote query");
		this.queryFileSystem(putData, callback, request);
	}
},
queryFileSystem : function (putData, callback, request) {
	console.log("Agua.File.queryFileSystem    putData:");
	console.dir({putData:putData});
	console.log("Agua.File.queryFileSystem    callback:");
	console.dir({callback:callback});
	console.log("Agua.File.queryFileSystem    request:");
	console.dir({request:request});
	
	// SET LOCATION
	var location = '';
	if ( putData.location || putData.query )
		location = putData.query;
	if ( ! putData.path && location )	putData.path = location;
	console.log("Agua.File.queryFileSystem    location: " + location);

	// SET USERNAME
	var username = putData.username;
	
	var url = this.cgiUrl + "folders.cgi";
	
	// QUERY REMOTE
	var thisObject = this;
	var putArgs = {
		url			: 	url,
		//url			: 	putData.url,
		contentType	: 	"text",
		sync		: 	false,
		preventCache: 	true,
		handleAs	: 	"json-comment-optional",
		putData		: 	dojo.toJson(putData),
		handle		:	function(response) {
			console.log("Agua.File.queryFileSystem    handle response:");
			console.dir({response:response});
			
			thisObject.setFileCache(username, location, dojo.clone(response));
			
			callback(response, request);
		}
	};

	var deferred = dojo.xhrPut(putArgs);
	deferred.addCallback(callback);
	var scope = request.scope || dojo.global;
	deferred.addErrback(function(error){
		if(request.onError){
			request.onError.call(scope, error, request);
		}
	});
},
removeFileTree : function (username, location) {
	console.log("Agua.File.removeFileTree    username: " + username);
	console.log("Agua.File.removeFileTree    location: " + location);

	var fileCaches = this.getData("filecaches");
	console.log("Agua.File.removeFileTree    fileCaches: ");
	console.dir({fileCaches:fileCaches});

	if ( ! fileCaches )	{
		console.log("Agua.File.removeFileTree    fileCaches is null. Returning");
		return;
	}
	
	var rootTree = fileCaches[username];
	console.log("Agua.File.removeFileTree    rootTree: ");
	console.dir({rootTree:rootTree});

	if ( ! rootTree ) {
		console.log("Agua.File.removeFileTree    rootTree is null. Returning");
		return;
	}

	for ( var fileRoot in fileCaches[username] ) {
		if ( fileRoot.match('^' + location +'$')
                    || fileRoot.match('^' + location +'\/') ) {
			console.log("Agua.File.removeFileTree    DELETING fileRoot: " + fileRoot);
//			delete fileCaches[username][fileRoot];
		}		
	}
	
	if ( ! location.match(/^(.+)\/[^\/]+$/) )	{
		console.log("Agua.File.removeFileTree    No parentDir. Returning");
		return;
	}
	var parentDir = location.match(/^(.+)\/[^\/]+$/)[1];
	var child = location.match(/^.+\/([^\/]+)$/)[1];
	console.log("Agua.File.removeFileTree    parentDir: " + parentDir);
	console.log("Agua.File.removeFileTree    child: " + child);
	
	this.removeItemFromParent(fileCaches[username][parentDir], child);
	
	var project1 = fileCaches[username][parentDir];
	console.log("Agua.File.removeFileTree    project1: " + project1);
	console.dir({project1:project1});	

	console.log("Agua.File.removeFileTree    END");
},
removeItemFromParent : function (parent, childName) {
	for ( i = 0; i < parent.items.length; i++ ) {
		var childObject = parent.items[i];
		if ( childObject.name == childName ) {
			parent.items.splice(i, 1);
			break;
		}
	}
},
removeRemoteFile : function (username, location, callback) {
	console.log("Agua.File.removeRemoteFile    username: " + username);
	console.log("Agua.File.removeRemoteFile    location: " + location);
	console.log("Agua.File.removeRemoteFile    callback: " + callback);

	// DELETE ON REMOTE
	var url 			= 	this.getFoldersUrl();
	var putData 		= 	new Object;
	putData.mode		=	"removeFile";
	putData.sessionid	=	Agua.cookie('sessionid');
	putData.username	=	Agua.cookie('username');
	putData.file		=	location;

	var thisObject = this;
	dojo.xhrPut(
		{
			url			: 	url,
			putData		:	dojo.toJson(putData),
			handleAs	: 	"json",
			sync		: 	false,
			handle		: 	function(response) {
				if ( callback )	callback(response);
			}
		}
	);
},
renameFileTree : function (username, oldLocation, newLocation) {
	console.log("Agua.File.renameFileTree    username: " + username);
	console.log("Agua.File.renameFileTree    oldLocation: " + oldLocation);
	console.log("Agua.File.renameFileTree    newLocation: " + newLocation);

	var fileCaches = this.getData("filecaches");
	console.log("Agua.File.renameFileTree    fileCaches: ");
	console.dir({fileCaches:fileCaches});

	if ( ! fileCaches )	{
		console.log("Agua.File.renameFileTree    fileCaches is null. Returning");
		return;
	}
	
	var rootTree = fileCaches[username];
	console.log("Agua.File.renameFileTree    rootTree: ");
	console.dir({rootTree:rootTree});

	if ( ! rootTree ) {
		console.log("Agua.File.renameFileTree    rootTree is null. Returning");
		return;
	}

	for ( var fileRoot in fileCaches[username] ) {
		if ( fileRoot.match('^' + oldLocation +'$')
                    || fileRoot.match('^' + oldLocation +'\/') ) {
			console.log("Agua.File.renameFileTree    DELETING fileRoot: " + fileRoot);
			var value = fileCaches[username][fileRoot];
			var re = new RegExp('^' + oldLocation);
			var newRoot = fileRoot.replace(re, newLocation);
			console.log("Agua.File.renameFileTree    ADDING newRoot: " + newRoot);
			delete fileCaches[username][fileRoot];
			fileCaches[username][newRoot] = value;
		}		
	}

		
	var parentDir = this.getParentDir(oldLocation);
	if ( ! parentDir ) 	return;
	console.log("Agua.File.renameFileTree    Doing this.renameItemInParent()");
	var child = this.getChild(oldLocation);
	var newChild = newLocation.match(/^.+\/([^\/]+)$/)[1];
	console.log("Agua.File.renameFileTree    parentDir: " + parentDir);
	console.log("Agua.File.renameFileTree    child: " + child);
	console.log("Agua.File.renameFileTree    newChild: " + newChild);
	var parent = fileCaches[username][parentDir];
	this.renameItemInParent(parent, child, newChild);
	
	console.log("Agua.File.renameFileTree    parent: " + parent);
	console.dir({parent:parent});	

	console.log("Agua.File.renameFileTree    END");
},
renameItemInParent : function (parent, childName, newChildName) {
	for ( i = 0; i < parent.items.length; i++ ) {
		var childObject = parent.items[i];
		if ( childObject.name == childName ) {
			var re = new RegExp(childName + "$");
			parent.items[i].name= parent.items[i].name.replace(re, newChildName);
			console.log("Agua.File.renameItemInParent    NEW parent.items[" + i + "].name: " + parent.items[i].name);
			parent.items[i].path= parent.items[i].path.replace(re, newChildName);
			console.log("Agua.File.repathItemInParent    NEW parent.items[" + i + "].path: " + parent.items[i].path);
			break;
		}
	}
},
getParentDir : function (location) {
	if ( ! location.match(/^(.+)\/[^\/]+$/) )	return null;
	return location.match(/^(.+)\/[^\/]+$/)[1];
},
getChild : function (location) {
	if ( ! location.match(/^.+\/([^\/]+)$/) )	return null;
	return location.match(/^.+\/([^\/]+)$/)[1];
},
isDirectory : function (username, location) {
	// USE IF CACHED
	var fileCache = this.getFileCache(username, location);
	console.log("Agua.File.isDirectory    username: " + username);
	console.log("Agua.File.isDirectory    location: " + location);
	console.log("Agua.File.isDirectory    fileCache: ");
	console.dir({fileCache:fileCache});

	if ( fileCache )	return fileCache.directory;
	return null;
},
isFileCacheItem : function (username, directory, itemName) {
	console.log("Agua.isFileCacheItem     username: " + username);
	console.log("Agua.isFileCacheItem     directory: " + directory);
	console.log("Agua.isFileCacheItem     itemName: " + itemName);

	var fileCache = this.getFileCache(username, directory);
	console.log("Agua.isFileCacheItem     fileCache: " + fileCache);
	console.dir({fileCache:fileCache});
	
	if ( ! fileCache || ! fileCache.items )	return false;
	
	for ( var i = 0; i < fileCache.items.length; i++ ) {
		if ( fileCache.items[i].name == itemName)	return true;
	}
	
	return false;

},

// FILE METHODS
renameFile : function (oldFilePath, newFilePath) {
// RENAME FILE OR FOLDER ON SERVER	
	var url 			= 	this.getFoldersUrl();
	var query 			= 	new Object;
	query.mode			=	"renameFile";
	query.sessionid		=	Agua.cookie('sessionid');
	query.username		=	Agua.cookie('username');
	query.oldpath		=	oldFilePath;
	query.newpath		=	newFilePath;
	
	this.doPut({ url: url, query: query, sync: false });
},
createFolder : function (folderPath) {
	// CREATE FOLDER ON SERVER	
	var url 		= 	this.getFoldersUrl();
	var query 		= 	new Object;
	query.mode		=	"newFolder";
	query.sessionid	=	Agua.cookie('sessionid');
	query.username	=	Agua.cookie('username');
	query.folderpath=	folderPath;
	
	this.doPut({ url: url, query: query, sync: false });
},
// FILEINFO METHODS
getFileInfo : function (stageParameterObject, fileinfo) {
// GET THE BOOLEAN fileInfo VALUE FOR A STAGE PARAMETER
	if ( fileinfo != null )
	{
		console.log("Agua.File.getFileInfo    fileinfo parameter is present. Should you be using setFileInfo instead?. Returning null.");
		return null;
	}
	
	return this._fileInfo(stageParameterObject, fileinfo);
},
setFileInfo : function (stageParameterObject, fileinfo) {
// SET THE BOOLEAN fileInfo VALUE FOR A STAGE PARAMETER
	if ( ! stageParameterObject	)	return;
	
	if ( fileinfo == null )
	{
		console.log("Agua.File.setFileInfo    fileinfo is null. Returning null.");
		return null;
	}

	return this._fileInfo(stageParameterObject, fileinfo);
},
_fileInfo : function (stageParameterObject, fileinfo) {
// RETURN THE fileInfo BOOLEAN FOR A STAGE PARAMETER
// OR SET IT IF A VALUE IS SUPPLIED: RETURN NULL IF
// UNSUCCESSFUL, TRUE OTHERWISE

	console.log("Agua.File._fileInfo    plugins.core.Data._fileInfo()");
	console.log("Agua.File._fileInfo    stageParameterObject: ");
	console.dir({stageParameterObject:stageParameterObject});
	console.log("Agua.File._fileInfo    fileinfo: ");
	console.dir({fileinfo:fileinfo});

	var uniqueKeys = ["username", "project", "workflow", "appname", "appnumber", "name", "paramtype"];
	var valueArray = new Array;
	for ( var i = 0; i < uniqueKeys.length; i++ ) {
		valueArray.push(stageParameterObject[uniqueKeys[i]]);
	}
	var stageParameter = this.getEntry(this.cloneData("stageparameters"), uniqueKeys, valueArray);
	console.log("Agua.File._fileInfo    stageParameter found: ");
	console.dir({stageParameter:stageParameter});
	if ( stageParameter == null ) {
		console.log("Agua.File._fileInfo    stageParameter is null. Returning null");
		return null;
	}

	// RETURN FOR GETTER	
	if ( fileinfo == null ) {
		console.log("Agua.File._fileInfo    DOING the GETTER. Returning stageParameter.exists: " + stageParameter.fileinfo.exists);
		return stageParameter.fileinfo.exists;
	}

	console.log("Agua.File._fileInfo    DOING the SETTER");

	// ELSE, DO THE SETTER
	stageParameter.fileinfo = fileinfo;
	var success = this._removeStageParameter(stageParameter);
	if ( success == false ) {
		console.log("Agua.File._fileInfo    Could not remove stage parameter. Returning null");
		return null;
	}
	console.log("Agua.File._fileInfo    	BEFORE success = this._addStageParameter(stageParameter)");
		
	success = this._addStageParameter(stageParameter);			
	if ( success == false ) {
		console.log("Agua.File._fileInfo    Could not add stage parameter. Returning null");
		return null;
	}

	return true;
},
// VALIDITY METHODS
getParameterValidity : function (stageParameterObject, booleanValue) {
// GET THE BOOLEAN parameterValidity VALUE FOR A STAGE PARAMETER
	//console.log("Agua.File.getParameterValidity    plugins.core.Data.getParameterValidity()");
	////console.log("Agua.File.getParameterValidity    stageParameterObject: " + dojo.toJson(stageParameterObject));
	////console.log("Agua.File.getParameterValidity    booleanValue: " + booleanValue);

	if ( booleanValue != null )
	{
		//console.log("Agua.File.getParameterValidity    booleanValue parameter is present. Should you be using "setParameterValidity" instead?. Returning null.");
		return null;
	}
	
	var isValid = this._parameterValidity(stageParameterObject, booleanValue);
	//console.log("Agua.File.getParameterValidity   '" + stageParameterObject.name + "' isValid: " + isValid);
	
	return isValid;
},
setParameterValidity : function (stageParameterObject, booleanValue) {
// SET THE BOOLEAN parameterValidity VALUE FOR A STAGE PARAMETER
	////console.log("Agua.File.setParameterValidity    plugins.core.Data.setParameterValidity()");
	////console.log("Agua.File.setParameterValidity    stageParameterObject: " + dojo.toJson(stageParameterObject));
	////console.log("Agua.File.setParameterValidity    " + stageParameterObject.name + " booleanValue: " + booleanValue);
	if ( booleanValue == null )
	{
		//console.log("Agua.File.setParameterValidity    booleanValue is null. Returning null.");
		return null;
	}

	var isValid = this._parameterValidity(stageParameterObject, booleanValue);
	//console.log("Agua.File.setParameterValidity   '" + stageParameterObject.name + "' isValid: " + isValid);

	return isValid;
},
_parameterValidity : function (stageParameterObject, booleanValue) {
// RETURN THE parameterValidity BOOLEAN FOR A STAGE PARAMETER
// OR SET IT IF A VALUE IS SUPPLIED
	////console.log("Agua.File._parameterValidity    plugins.core.Data._parameterValidity()");
	//console.log("Agua.File._parameterValidity    stageParameterObject: " + dojo.toJson(stageParameterObject, true));
	////console.log("Agua.File._parameterValidity    booleanValue: " + booleanValue);

	//////var filtered = this._getStageParameters();
	//////var keys = ["appname"];
	//////var values = ["image2eland.pl"];
	//////filtered = this.filterByKeyValues(filtered, keys, values);
	////////console.log("Agua.File._parameterValidity    filtered: " + dojo.toJson(filtered, true));
	var uniqueKeys = ["project", "workflow", "appname", "appnumber", "name", "paramtype"];
	var valueArray = new Array;
	for ( var i = 0; i < uniqueKeys.length; i++ )
	{
		valueArray.push(stageParameterObject[uniqueKeys[i]]);
	}
	var stageParameter = this.getEntry(this._getStageParameters(), uniqueKeys, valueArray);
	//console.log("Agua.File._parameterValidity    stageParameter found: " + dojo.toJson(stageParameter, true));
	if ( stageParameter == null )
	{
		//console.log("Agua.File._parameterValidity    stageParameter is null. Returning null");
		return null;
	}
	
	if ( booleanValue == null )
		return stageParameter.isValid;

	//console.log("Agua.File._parameterValidity    stageParameter: " + dojo.toJson(stageParameter, true));
	//console.log("Agua.File._parameterValidity    booleanValue: " + booleanValue);
	// SET isValid BOOLEAN VALUE
	stageParameter.isValid = booleanValue;		
	var success = this._removeStageParameter(stageParameter);
	if ( success == false )
	{
		//console.log("Agua.File._parameterValidity    Could not remove stage parameter. Returning null");
		return null;
	}
	////console.log("Agua.File._parameterValidity    	BEFORE success = this._addStageParameter(stageParameter)");
		
	success = this._addStageParameter(stageParameter);			
	if ( success == false )
	{
		//console.log("Agua.File._parameterValidity    Could not add stage parameter. Returning null");
		return null;
	}

	return true;
}

});

}

if(!dojo._hasResource["plugins.core.Agua.Group"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.core.Agua.Group"] = true;
dojo.provide("plugins.core.Agua.Group");

/* SUMMARY: THIS CLASS IS INHERITED BY Agua.js AND CONTAINS 
	
	GROUP METHODS  
*/

dojo.declare( "plugins.core.Agua.Group",	[  ], {

/////}}}

// GROUP METHODS
getGroups : function () {
// RETURN THE groups ARRAY FOR THIS USER
	console.log("Agua.Group.getGroups    plugins.core.Data.getGroups()");

	return this.cloneData("groups");
},
addGroup : function (groupObject) {
// ADD A GROUP OBJECT TO THE groups ARRAY

	console.log("Agua.Group.addGroup    plugins.core.Data.addGroup(groupObject)");
	console.log("Agua.Group.addGroup    groupObject: " + dojo.toJson(groupObject));
	
	this.removeData("groups", groupObject, ["groupname"]);
	if ( ! this.addData("groups", groupObject, [ "groupname" ]) )	return;
	this.sortData("groups", "groupname");

	// CLEAN UP WHITESPACE AND SUBSTITUTE NON-JSON SAFE CHARACTERS
	groupObject.groupname = this.jsonSafe(groupObject.groupname, "toJson");
	groupObject.description = this.jsonSafe(groupObject.description, "toJson");
	groupObject.notes = this.jsonSafe(groupObject.notes, "toJson");
	
	// CREATE JSON QUERY
	var url = Agua.cgiUrl + "sharing.cgi?";
	var query = new Object;
	query.username = this.cookie("username");
	query.sessionid = this.cookie("sessionid");
	query.mode = "addGroup";
	query.data = groupObject;
	////console.log("Groups.addItem    query: " + dojo.toJson(query));
	
	this.doPut({ url: url, query: query });

	if ( Agua.isAccess(groupObject) )	return;
	
	// ADD TO access	
	var accessObject = new Object;
	accessObject.groupname = groupObject.groupname;
	accessObject.owner		=	this.cookie("username");
	accessObject.groupwrite	=	0;
	accessObject.groupcopy	=	1;
	accessObject.groupview	=	1;
	accessObject.worldwrite	=	0;
	accessObject.worldcopy	=	0;
	accessObject.worldview	=	0

	console.log("Agua.Group.addGroup    Adding accessObject: " + dojo.toJson(accessObject));
	this.addData("access", accessObject, ["groupname"]);	
	this.sortData("access", "groupname");
},
removeGroup : function (groupObject) {
// REMOVE A GROUP OBJECT FROM THE groups ARRAY
// AND RELATED: groupmembers, access

	console.log("Agua.Group.removeGroup    plugins.core.Data.removeGroup(groupObject)");
	console.log("Agua.Group.removeGroup    groupObject: " + dojo.toJson(groupObject));

	if ( ! this._removeGroup(groupObject) )	return;
	this.sortData("groups", "groupname");
	
	// REMOVE FROM access
	this._removeAccess(groupObject);

	// REMOVE FROM groupmembers 
	this._removeGroupMembers(groupObject);

	// CREATE JSON QUERY
	var url = Agua.cgiUrl + "sharing.cgi?";
	var query = new Object;
	query.username = this.cookie("username");
	query.sessionid = this.cookie("sessionid");
	query.mode = "removeGroup";
	query.data = groupObject;
	//console.log("Groups.deleteItem    query: " + dojo.toJson(query));
	
	this.doPut({ url: url, query: query, sync: false });	
},
_removeGroup : function ( groupObject) {
	return this.removeData("groups", groupObject, ["groupname"]);
},
_removeGroupMembers : function (groupObject) {
// REMOVE A GROUP OBJECT FROM groupmembers
	console.log("Agua.Group._removeGroupMembers    plugins.core.Data._removeGroupMembers(groupObject)");
	console.log("Agua.Group._removeGroupMembers    groupObject: " + dojo.toJson(groupObject));

	return this._removeObjectsFromData("groupmembers", groupObject, ["groupname"]);
},
_removeAccess : function (groupObject) {
	// REMOVE FROM access
	this.removeData("access", groupObject, ["groupname"]);		
},
isAccess : function (groupObject) {
	var access = this.cloneData(access);
	return this._objectInArray(access, groupObject, ["groupname"]);		
},
isGroup : function (groupObject) {
// RETURN true IF A GROUP EXISTS IN groups
	console.log("Agua.Group.isGroup    plugins.core.Data.isGroup(groupObject, groupObject)");
	console.log("Agua.Group.isGroup    groupObject: " + dojo.toJson(groupObject));
	var groups = this.getGroups();
	if ( this._getIndexInArray(groups, groupObject, ["groupname"]) )	return true;
	
	return false;
},
getGroupNames : function () {
// PARSE NAMES OF ALL GROUPS IN groups INTO AN ARRAY
	console.log("Agua.Group.getGroupNames    plugins.core.Data.getGroupNames()");
	var groups = this.getGroups();	
	var groupNames = new Array;
	var groups = this.getGroups();
	for ( var i in groups  )
	{
		groupNames.push(groups[i].groupname);
	}
	//console.log("Agua.Group.getGroupNames    groupNames: " +  dojo.toJson(groupNames));
	
	return groupNames;
},
getGroupMembers : function (memberType) {
// PARSE groups ENTRIES INTO HASH OF ARRAYS groupName: [ source1, source2 ]
	//console.log("Agua.Group.getGroupMembers    plugins.core.Data.getGroupMembers(memberType)");
	//console.log("Agua.Group.getGroupMembers    memberType: " + memberType);
	
	var groupMembers = this.cloneData("groupmembers");
	var keyArray = ["type"];
	var valueArray = [memberType];
	return this.filterByKeyValues(groupMembers, keyArray, valueArray);
},
getGroupMembersHash : function (memberType) {
// PARSE groups ENTRIES INTO HASH OF ARRAYS { groupName: [ source1, source2 ] }

	console.log("Agua.Group.getGroupMembersHash    plugins.core.Data.getGroupMembersHash(memberType)");
	console.log("Agua.Group.getGroupMembersHash    memberType" + memberType);
	
	var groupMembers = this.cloneData("groupmembers");
	for ( var groupName in groupMembers )
	{
		for ( var j = 0; j < groupMembers[groupName].length; j++ )
		{
			if ( groupMembers[groupName][j].type != memberType )
			{
				groupMembers[groupName].splice(j,1);
				j--;
			}
		} 
	}
	
	return groupMembers;
},
getGroupSources : function () {
// GET ALL SOURCE MEMBERS OF groupmembers

	//console.log("Agua.Group.getGroupUsers    plugins.core.Data.getGroupUsers()");
	return this.getGroupMembers("source");
},
getGroupUsers : function () {
// GET ALL USER MEMBERS OF groupmembers
	//console.log("Agua.Group.getGroupUsers    plugins.core.Data.getGroupUsers()");
	return this.getGroupMembers("user");
},
getGroupProjects : function () {
// GET ALL PROJECT MEMBERS OF groupmembers

	//console.log("Agua.Group.getGroupProjects    plugins.core.Data.getGroupProjects()");
	return this.getGroupMembers("project");
}

});

}

if(!dojo._hasResource["plugins.core.Agua.Hub"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.core.Agua.Hub"] = true;
dojo.provide("plugins.core.Agua.Hub");

/* SUMMARY: THIS CLASS IS INHERITED BY Agua.js AND CONTAINS HUB METHODS */

dojo.declare( "plugins.core.Agua.Hub",	[  ], {

/////}}}

getHub : function () {
// RETURN CLONE OF this.hub
	return this.cloneData("hub");
},

setHub : function (hub) {
// RETURN ENTRY FOR username IN this.hub
	console.log("Agua.Hub.setHub    plugins.core.Data.setHub(hub)");
	console.log("Agua.Hub.setHub    hub: " + dojo.toJson(hub));
	if ( hub == null ) {
		console.log("Agua.Hub.setHub    hub is null. Returning");
		return;
	}
	if ( hub.login == null ) {
		console.log("Agua.Hub.setHub    hub.login is null. Returning");
		return;
	}
	this.setData("hub", hub);
	
	return hub;
},
setHubCertificate : function (publiccert) {
// RETURN ENTRY FOR username IN this.hub
	console.log("Agua.Hub.setHubCertificate    publiccert: " + publiccert);
	if ( ! publiccert ) {
		console.log("Agua.Hub.setHubCertificate    publiccert is null. Returning");
		return;
	}
	var hub = this.getData("hub");
	console.log("Agua.Hub.setHubCertificate    hub: ");
	console.dir({hub:hub});
	if ( ! hub ) {
		console.log("Agua.Hub.setHubCertificate    hub is null. Returning");
		return;
	}
	if ( ! hub.login ) {
		console.log("Agua.Hub.setHubCertificate    hub.login is null. Returning");
		return;
	}

	hub.publiccert = publiccert;	
	this.setData("hub", hub);
	
	return hub;
}



});

}

if(!dojo._hasResource["plugins.core.Agua.Package"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.core.Agua.Package"] = true;
dojo.provide("plugins.core.Agua.Package");

/* SUMMARY: THIS CLASS IS INHERITED BY Agua.js AND CONTAINS 
	
	PACKAGE METHODS  
*/

dojo.declare( "plugins.core.Agua.Package",	[  ], {

/////}}}

// PACKAGE METHODS
getPackages : function () {
	console.log("Agua.Package.getPackages    plugins.core.Data.getPackages()");
	return this.cloneData("packages");
},
getPackageTypes : function (packages) {
// GET SORTED LIST OF ALL PACKAGE TYPES
	var typesHash = new Object;
	for ( var i = 0; i < packages.length; i++ )
	{
		typesHash[packages[i].type] = 1;
	}	
	var types = this.hashkeysToArray(typesHash)
	types = this.sortNoCase(types);
	
	return types;
},
getPackageType : function (packageName) {
// RETURN THE TYPE OF AN PACKAGE OWNED BY THE USER
	console.log("Agua.Package.getPackageType    plugins.core.Data.getPackageType(packageName)");
	//console.log("Agua.Package.getPackageType    packageName: *" + packageName + "*");
	var packages = this.cloneData("packages");
	for ( var i in packages )
	{
		var thisPackage = packages[i];
		if ( thisPackage["package"].toLowerCase() == packageName.toLowerCase() )
			return thisPackage.type;
	}
	
	return null;
},
hasPackages : function () {
	//console.log("Agua.Package.hasPackages    plugins.core.Data.hasPackages()");
	if ( this.getData("packages").length == 0 )	return false;	
	return true;
},
addPackage : function (packageObject) {
// ADD AN PACKAGE OBJECT TO packages
	//console.log("Agua.Package.addPackage    packageObject: " + dojo.toJson(packageObject));

	var packages = this.getData("packages");
	//console.log("Agua.Package.removePackage    packages.length: " + packages.length);
	//console.log("Agua.Package.removePackage    packages: " + dojo.toJson(packages, true));

	var result = this.addData("packages", packageObject, ["package", "owner", "installdir"]);
	if ( result == true ) this.sortData("packages", "package");


	packages = this.getData("packages");
	//console.log("Agua.Package.removePackage    packages.length: " + packages.length);
	//console.log("Agua.Package.removePackage    packages: " + dojo.toJson(packages, true));
	
	// RETURN TRUE OR FALSE
	return result;
},
removePackage : function (packageObject) {
// REMOVE AN PACKAGE OBJECT FROM packages
	//console.log("Agua.Package.removePackage    packageObject: " + dojo.toJson(packageObject));
	var packages = this.getData("packages");
	//console.log("Agua.Package.removePackage    packages: " + dojo.toJson(packages, true));
	//console.log("Agua.Package.removePackage    packages.length: " + packages.length);
	var result = this.removeData("packages", packageObject, ["package", "owner", "installdir"]);
	
	packages = this.getData("packages");
	//console.log("Agua.Package.removePackage    packages.length: " + packages.length);
	
	return result;
},
isPackage : function (packageName) {
// RETURN true IF AN PACKAGE EXISTS IN packages
	console.log("Agua.Package.isPackage    packageName: *" + packageName + "*");
	
	var packages = this.getPackages();
	for ( var i in packages )
	{
		var thisPackage = packages[i];
		console.log("Agua.Package.isPackage    Checking package.package: *" + thisPackage["package"] + "*");
		if ( thisPackage["package"].toLowerCase() == packageName.toLowerCase() )
		{
			return true;
		}
	}
	
	return false;
}

});

}

if(!dojo._hasResource["plugins.core.Agua.Parameter"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.core.Agua.Parameter"] = true;
dojo.provide("plugins.core.Agua.Parameter");

/* SUMMARY: THIS CLASS IS INHERITED BY Agua.js AND CONTAINS 
	
	PARAMETER METHODS  
*/

dojo.declare( "plugins.core.Agua.Parameter",	[  ], {

/////}}}

// PARAMETER METHODS
addParameter : function (parameterObject) {
// ADD A PARAMETER OBJECT TO THE parameters ARRAY

	console.log("Agua.Parameter.addParameter    plugins.core.Data.addParameter(parameterObject)");
	//console.log("Agua.Parameter.addParameter    parameterObject: " + dojo.toJson(parameterObject));

	// REMOVE THE PARAMETER OBJECT IF IT EXISTS ALREADY
	var result = this.removeData("parameters", parameterObject, ["appname", "name", "paramtype"]);

	// DO THE ADD
	var requiredKeys = [ "appname", "name", "paramtype" ];
	return result = this.addData("parameters", parameterObject, requiredKeys);
},
removeParameter : function (parameterObject) {
// REMOVE AN PARAMETER OBJECT FROM THE parameters ARRAY.
// RETURN TRUE OR FALSE.
	console.log("Agua.Parameter.removeParameter    plugins.core.Data.removeParameter(parameterObject)");
	console.log("Agua.Parameter.removeParameter    parameterObject: " + dojo.toJson(parameterObject));

	if ( ! this._removeParameter(parameterObject) ) 	return false;

	// PUT JSON QUERY
	var url = Agua.cgiUrl + "workflow.cgi";
	var query = new Object;
	query.username = this.cookie("username");
	query.sessionid = this.cookie("sessionid");
	query.mode = "deleteParameter";
	query.data = parameterObject;
	//console.log("Parameter.deleteItem    query: " + dojo.toJson(query));
	this.doPut({ url: url, query: query });

	return true;
},
_removeParameter : function (parameterObject) {
	return this.removeData("parameters", parameterObject, ["appname", "name", "paramtype"]);
},
isParameter : function (appName, parameterName) {
// RETURN true IF AN PARAMETER EXISTS IN parameters

	console.log("Agua.Parameter.isParameter    plugins.core.Data.isParameter(parameterName, parameterObject)");
	console.log("Agua.Parameter.isParameter    parameterName: *" + parameterName + "*");
	
	var parameters = getParametersByAppname(appName);
	if ( parameters == null )	return false;

	for ( var i in parameters )
	{
		if ( parameters[i].name.toLowerCase() == parameterName.toLowerCase() )
		{
			return true;
		}
	}
	
	return false;
},
getParametersByAppname : function (appname) {
// RETURN AN ARRAY OF PARAMETERS FOR THE GIVEN APPLICATION
	//console.log("Agua.Parameter.getParametersByAppname    core.Agua.getParametersByAppname(appname)");
	//console.log("Agua.Parameter.getParametersByAppname    appname: " + appname);
	if ( appname == null )	return null;	
	var parameters = new Array;
	var params = this.cloneData("parameters");
	for ( var i = 0; i < params.length; i++ )
	{
		var parameter = params[i];
		//console.log("Agua.Parameter.getParametersByAppname    parameter " + parameter.name + ": " + parameter.value);
		if ( parameter.appname == appname ){
			//console.log("Agua.Parameter.getParametersByAppname    PUSHING parameter " + parameter.name + ": " + dojo.toJson(parameter));

			parameters.push(parameter);
		}
	}
	//console.log("Agua.Parameter.getParametersByAppname    Returning parameters : " + dojo.toJson(parameters));
	
	return parameters;
},
getParameter : function (appName, parameterName) {
// RETURN A NAMED PARAMETER FOR A GIVEN APPLICATION
// E.G., WHEN RETURNING VALUE TO DEFAULT

	//console.log("Agua.Parameter.getParameter    plugins.core.Data.getParameter(appName)");
	//console.log("Agua.Parameter.getParameter    appName: " + appName);
	//console.log("Agua.Parameter.getParameter    parameterName: " + parameterName);

	if ( appName == null )	return null;
	if ( parameterName == null )	return null;
	
	var parameters = getParametersByAppname(appName);
	if ( parameters == null )	return false;

	for ( var i in parameters )
	{
		if ( parameters[i].name.toLowerCase() == parameterName.toLowerCase() )
		{
			return parameters[i];
		}
	}
	
	return null;
}

});

}

if(!dojo._hasResource["plugins.core.Agua.Project"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.core.Agua.Project"] = true;
dojo.provide("plugins.core.Agua.Project");

/* SUMMARY: THIS CLASS IS INHERITED BY Agua.js AND CONTAINS 
	
	PROJECT METHODS  
*/

dojo.declare( "plugins.core.Agua.Project",	[  ], {

/////}}}

// PROJECT METHODS
getProjects : function () {
// RETURN A SORTED COPY OF 
	//console.log("Agua.Project.getProjects    plugins.core.Data.getProjects(projectObject)");
	var projects = this.cloneData("projects");
	return this.sortHasharray(projects, "name");
},
getProjectNames : function (projects) {
// RETURN AN ARRAY OF ALL PROJECT NAMES IN projects
	console.log("Agua.Project.getProjectNames    plugins.core.Data.getProjectNames()");
	if ( projects == null )	projects = this.getProjects();
	return this.hashArrayKeyToArray(projects, "name");
},
addProject : function (projectObject) {
// ADD A PROJECT OBJECT TO THE projects ARRAY

	console.log("Agua.Project.addProject    plugins.core.Data.addProject(projectName)");
	console.log("Agua.Project.addProject    projectObject: " + dojo.toJson(projectObject));
	projectObject.description = projectObject.description || "";
	projectObject.notes = projectObject.notes || "";

	console.log("Agua.Project.addProject    this.addingProject: " + this.addingProject);
	if ( this.addingProject == true )	return;
	this.addingProject == true;
	
	this.removeData("projects", projectObject, ["name"]);
	
	if ( ! this.addData("projects", projectObject, ["name" ]) )
	{
		console.log("Agua.Project.addProject    Could not add project to projects: " + projectName);
		this.addingProject == false;
		return;
	}
	this.sortData("projects", "name");
	this.addingProject == false;
	
	// COMMIT CHANGES IN REMOTE DATABASE
	var url = Agua.cgiUrl + "workflow.cgi";
	
	// SET QUERY
	var query = dojo.clone(projectObject);
	query.username = this.cookie("username");
	query.sessionid = this.cookie("sessionid");
	query.mode = "addProject";
	console.log("Agua.Project.addProject    query: " + dojo.toJson(query, true));
	
	this.doPut({ url: url, query: query, sync: false });
},
copyProject : function (sourceUser, sourceProject, targetUser, targetProject, copyFiles) {
// ADD AN EMPTY NEW WORKFLOW OBJECT TO A PROJECT OBJECT

	console.log("Agua.Project.copyProject    plugins.folders.Agua.copyProject(sourceUser, sourceProject, sourceProject, targetUser, targetProject, targetProject)");
	console.log("Agua.Project.copyProject    sourceUser: " + sourceUser);
	console.log("Agua.Project.copyProject    sourceProject: " + sourceProject);
	console.log("Agua.Project.copyProject    targetUser: " + targetUser);
	console.log("Agua.Project.copyProject    targetProject: " + targetProject);
	console.log("Agua.Project.copyProject    copyFiles: " + copyFiles);

	if ( this.isProject(targetProject) == true )
	{
		console.log("Agua.Project.copyProject    Project '" + targetProject + "' already exists. Returning.");
		return;
	}

	// GET PROJECT
	var projects = this.getSharedProjectsByUsername(sourceUser);
	console.log("Agua.Project.copyProject    projects: " + dojo.toJson(projects));
	projects = this.filterByKeyValues(projects, ["project"], [sourceProject]);
	if ( ! projects || projects.length == 0 ) {
		console.log("Agua.Project.copyProject    Returning becacuse  projects is null or empty: " + dojo.toJson(projects));
	}
	var projectObject = projects[0];
	
	// SET PROVENANCE
	var date = this.currentMysqlDate();
	projectObject = this.setProvenance(projectObject, date);
	
	// SET TARGET VARIABLES
	projectObject.name = targetProject;
	projectObject.project  = targetProject;
	projectObject.username = targetUser;
	console.dir({projectObject:projectObject});
	var keys = ["name"];
	var copied = this.addData("projects", projectObject, keys);
	if ( copied == false )
	{
		console.log("Agua.Project.copyProject    Could not copy project " + projectObject.name + " to projects");
		return;
	}
	
	// COPY WORKFLOWS
	var workflows = this.getSharedWorkflowsByProject(sourceUser, sourceProject);
	for ( var i = 0; i < workflows.length; i++ ) {
		var sourceWorkflow = workflows[i].name;
		console.log("Agua.Project.copyProject    workflows[" + i + "]: " + dojo.toJson(workflows[i]));
		this._copyWorkflow(workflows[i], targetUser, targetProject, sourceWorkflow, date);
	}

	// COMMIT CHANGES TO REMOTE DATABASE
	var url = Agua.cgiUrl + "workflow.cgi";
	var query = new Object;
	query.sourceuser 	= sourceUser;
	query.targetuser 	= targetUser;
	query.sourceproject = sourceProject;
	query.targetproject = targetProject;
	query.copyfiles 	= copyFiles;
	query.date			= date;
	query.provenance 	= projectObject.provenance;
	query.username 		= this.cookie("username");
	query.sessionid 	= this.cookie("sessionid");
	query.mode 			= "copyProject";
	console.log("Agua.Project.copyProject    query: " + dojo.toJson(query, true));

	this.doPut({ url: url, query: query, sync: false });
},
removeProject : function (projectObject) {
// REMOVE A PROJECT OBJECT FROM: projects, workflows, groupmembers
// stages AND stageparameters
	console.log("Agua.Project.removeProject    plugins.core.Data.removeProject(projectObject)");
	console.log("Agua.Project.removeProject    projectObject: " + dojo.toJson(projectObject));
	
	// SET ADDITIONAL FIELDS
	projectObject.project = projectObject.name;
	projectObject.owner = this.cookie("username");
	projectObject.type = "project";

	// REMOVE PROJECT FROM projects
	var success = this.removeData("projects", projectObject, ["name"]);
	if ( success == true )	console.log("Agua.Project.removeProject    Removed project from projects: " + projectObject.name);
	else	console.log("Agua.Project.removeProject    Could not remove project from projects: " + projectObject.name);
	
	// REMOVE FROM workflows
	this.removeData("workflows", projectObject, ["project"]);

	// REMOVE FROM groupmembers 
	var keys = ["owner", "name", "type"];
	this.removeData("groupmembers", projectObject, keys);

	// REMOVE FROM stages AND stageparameters
	var keys = ["project"];
	this.removeData("stages", projectObject, keys);

	// REMOVE FROM stageparameters
	var keys = ["project"];
	this.removeData("stageparameters", projectObject, keys);
	
	// COMMIT CHANGES IN REMOTE DATABASE
	var url = Agua.cgiUrl + "workflow.cgi";
	var query = projectObject;
	query.username = this.cookie("username");
	query.sessionid = this.cookie("sessionid");
	query.mode = "removeProject";
	console.log("Agua.Project.removeProject    query: " + dojo.toJson(query, true));
	
	this.doPut({ url: url, query: query, sync: false });
},
isProject : function (projectName) {
// RETURN true IF A PROJECT EXISTS IN projects
	//console.log("Agua.Project.isProject    core.Data.isProject(projectName)");
	//console.log("Agua.Project.isProject    projectName: " + projectName);

	var projects = this.getProjects();
	for ( var i in projects )
	{
		var project = projects[i];
		if ( project.name.toLowerCase() == projectName.toLowerCase() )
		{
			return true;
		}
	}
	
	return false;
},
isGroupProject : function (groupName, projectObject) {
// RETURN true IF A PROJECT BELONGS TO THE SPECIFIED GROUP

	console.log("Agua.Project.isGroupProject    plugins.core.Data.isGroupProject(groupName, projectObject)");
	console.log("Agua.Project.isGroupProject    groupName: " + groupName);
	console.log("Agua.Project.isGroupProject    projectObject: " + dojo.toJson(projectObject));
	
	var groupProjects = this.getGroupProjects();
	if ( groupProjects == null )	return false;
	
	groupProjects = this.filterByKeyValues(groupProjects, ["groupname"], [groupName]);
	
	return this._objectInArray(groupProjects, projectObject, ["groupname", "name"]);
},
addProjectToGroup : function (groupName, projectObject) {
// ADD A PROJECT OBJECT TO A GROUP ARRAY IF IT DOESN"T EXIST THERE ALREADY 

	console.log("Agua.Project.addProjectToGroup    caller: " + this.addProjectToGroup.caller.nom);
	console.log("Agua.Project.addProjectToGroup    groupName: " + groupName);
	console.log("Agua.Project.addProjectToGroup    projectObject: " + dojo.toJson(projectObject));

	if ( this.isGroupProject(groupName, projectObject) == true )
	{
		console.log("Agua.Project.addProjectToGroup     project already exists in projects: " + projectObject.name + ". Returning.");
		return false;
	}
	
	projectObject.owner = projectObject.username;
	projectObject.groupname = groupName;
	projectObject.type = "project";

	var groups = this.getGroups();
	console.log("Agua.Project.addProjectToGroup    groups: " + dojo.toJson(groups));
	var group = this._getObjectByKeyValue(groups, "groupname", groupName);
	if ( group == null )	return false;
	console.log("Agua.Project.addProjectToGroup    group: " + dojo.toJson(group));
	projectObject.groupdesc = group.description;

	console.log("Agua.Project.addProjectToGroup    New projectObject: " + dojo.toJson(projectObject));

	var requiredKeys = ["owner", "groupname", "name", "type"];
	return this.addData("groupmembers", projectObject, requiredKeys);
},
removeProjectFromGroup : function (groupName, projectObject) {
// REMOVE A PROJECT OBJECT FROM A GROUP ARRAY, IDENTIFY OBJECT BY "name" KEY VALUE

	console.log("Agua.Project.removeProjectFromGroup     caller: " + this.removeProjectFromGroup.caller.nom);
	console.log("Agua.Project.removeProjectFromGroup     groupName: " + groupName);
	console.log("Agua.Project.removeProjectFromGroup     projectObject: " + dojo.toJson(projectObject));
	
	projectObject.owner = projectObject.username;
	projectObject.groupname = groupName;
	projectObject.type = "project";

	// REMOVE THIS LATER		
	var groups = this.getGroups();
	console.log("Agua.Project.removeProjectFromGroup    groups: " + dojo.toJson(groups));
	var group = this._getObjectByKeyValue(groups, "groupname", groupName);
	if ( group == null )	return false;
	console.log("Agua.Project.removeProjectFromGroup    group: " + dojo.toJson(group));
	projectObject.groupdesc = group.description;

	var requiredKeys = [ "owner", "groupname", "name", "type"];
	return this.removeData("groupmembers", projectObject, requiredKeys);
},
getProjectsByGroup : function (groupName) {
// RETURN THE ARRAY OF PROJECTS THAT BELONG TO A GROUP

	var groupProjects = this.getGroupProjects();
	if ( groupProjects == null )	return null;

	var keyArray = ["groupname"];
	var valueArray = [groupName];
	var projects = this.filterByKeyValues(groupProjects, keyArray, valueArray);

	return this.sortHasharray(projects, "name");
},
getGroupsByProject : function (projectName) {
// RETURN THE ARRAY OF PROJECTS THAT BELONG TO A GROUP

	var groupProjects = this.getGroupProjects();
	if ( groupProjects == null )	return null;

	var keyArray = ["type", "name"];
	var valueArray = ["project", projectName];
	return this.filterByKeyValues(groupProjects, keyArray, valueArray);
}

});

}

if(!dojo._hasResource["plugins.core.Agua.Report"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.core.Agua.Report"] = true;
dojo.provide("plugins.core.Agua.Report");

/* SUMMARY: THIS CLASS IS INHERITED BY Agua.js AND CONTAINS 
	
	REPORT METHODS  
*/

dojo.declare( "plugins.core.Agua.Report",	[  ], {

/////}}}

getReports : function () {
// RETURN A COPY OF THE this.reports ARRAY

	console.log("Agua.Report.getReports    plugins.core.Data.getReports()");

	var stages = this.getStages();
	if ( stages == null )	return;
	//console.log("Agua.Report.getReports    stages: " + dojo.toJson(stages, true));

	var keys = [ "type" ];
	var values = [ "report" ];
	var reports = this.filterByKeyValues(stages, keys, values);
	//console.log("Agua.Report.getReports    reports: " + dojo.toJson(reports, true));

	return reports;
},
getReportsByWorkflow : function (projectName, workflowName) {
// RETURN AN ARRAY OF REPORT HASHES FOR THE SPECIFIED PROJECT AND WORKFLOW

	var reports = this.getReports();
	if ( reports == null )	return null;

	var keyArray = ["project", "workflow"];
	var valueArray = [projectName, workflowName];
	return this.filterByKeyValues(reports, keyArray, valueArray);
},
removeReport : function (reportObject) {
// REMOVE A REPORT OBJECT FROM THE this.reports ARRAY

	console.log("Agua.Report.removeReport    plugins.core.Data.removeReport(reportObject)");
	console.log("Agua.Report.removeReport    reportObject: " + dojo.toJson(reportObject));

	// REMOVE REPORT FROM this.reports
	var requiredKeys = ["project", "workflow", "name"];
	var success = this.removeData("reports", reportObject, requiredKeys);
	if ( success == true )	console.log("Agua.Report.removeReport    Removed report from this.reports: " + reportObject.name);
	else	console.log("Agua.Report.removeReport    Could not remove report from this.reports: " + reportObject.name);
	
	// REMOVE REPORT FROM groupmembers IF PRESENT
	var groupNames = this.getGroupsByReport(reportObject.name);
	console.log("Agua.Report.removeReport    groupNames: " + dojo.toJson(groupNames));
	for ( var i = 0; i < groupNames.length; i++ )
	{
		if ( this.removeReportFromGroup(groupNames[i], reportObject) == false )
			success = false;
	}

	return success;
},
isReport : function (reportName) {
// RETURN true IF A REPORT EXISTS IN this.reports
	console.log("Agua.Report.isReport    plugins.core.Data.isReport(reportName)");
	console.log("Agua.Report.isReport    reportName: *" + reportName + "*");
	//console.log("Agua.Report.isReport    this.reports: " + dojo.toJson(this.reports));

	var reports = this.getReports();	
	for ( var i in reports )
	{
		var report = reports[i];
		if ( report.name.toLowerCase() == reportName.toLowerCase() )
		{
			console.log("Agua.Report.isReport    report.name is a report: *" + report.name + "*");
			return true;
		}
	}
	
	return false;
},
addReport : function (reportObject) {
// ADD A REPORT 
	console.log("Agua.Report.addReport+     plugins.core.Data.addReport(projectName)");
	console.log("Agua.Report.addReport    reportObject: " + dojo.toJson(reportObject));

	// DO THE ADD
	var requiredKeys = ["project", "workflow", "name"];
	var success = this.addData("reports", reportObject, requiredKeys);
	
	if ( success == true ) console.log("Agua.Report.addReport    Added report to this.reports[" + reportObject.name);
	else console.log("Agua.Report.addReport    Could not add report to this.reports[" + reportObject.name);
	return success;
}

});

}

if(!dojo._hasResource["plugins.core.Agua.Shared"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.core.Agua.Shared"] = true;
dojo.provide("plugins.core.Agua.Shared");

/* SUMMARY: THIS CLASS IS INHERITED BY Agua.js AND CONTAINS 
	
	SHARED METHODS  
*/

dojo.declare( "plugins.core.Agua.Shared",	[  ], {

/////}}}

getSharedSources : function () {
// RETURN A COPY OF sharedsources
	//console.log("Agua.Shared.getSharedSources    plugins.core.Data.getSharedSources()");
	return this.cloneData("sharedsources");
},
getSharedSourcesByUsername : function(username) {
/// RETURN ALL SHARED PROJECTS PROVIDED BY THE SPECIFIED USER
	//console.log("Agua.Shared.getSharedSourcesByUsername    username: " + username);
	
	var sharedSources = this.cloneData("sharedsources");
	//console.log("Agua.Shared.getSharedSourcesByUsername    BEFORE sharedSources: " + dojo.toJson(sharedSources));

	if ( ! sharedSources || ! sharedSources[username] )	return [];
	else return sharedSources[username];
},
getSharedUsernames : function() {
// RETURN AN ARRAY OF ALL OF THE NAMES OF USERS WHO HAVE SHARED PROJECTS
// WITH THE LOGGED ON USER
	console.log("Agua.Shared.getSharedUsernames    plugins.core.Data.getSharedUsernames()");

	var sharedProjects = this.getSharedProjects();	
	var usernames = new Array;
	for ( var name in sharedProjects ) {
		usernames.push(name);
	}
	usernames = usernames.sort();
	console.log("Agua.Shared.getSharedUsernames    usernames: " + dojo.toJson(usernames));

	return usernames;
},
getSharedProjects : function() {
	console.log("Agua.Shared.getSharedProjects    plugins.core.Data.getSharedProjects()");	
	var sharedProjects = this.cloneData("sharedprojects");
	console.log("Agua.Shared.getSharedProjects    sharedProjects: ");
	console.dir({sharedProjects:sharedProjects});

	return sharedProjects;
},
getSharedProjectsByUsername : function(username) {
/// RETURN ALL SHARED PROJECTS PROVIDED BY THE SPECIFIED USER
	//console.log("Agua.Shared.getSharedProjectsByUsername    username: " + username);
	
	var sharedProjects = this.cloneData("sharedprojects");
	//console.log("Agua.Shared.getSharedProjectsByUsername    BEFORE sharedProjects: " + dojo.toJson(sharedProjects));

	if ( ! sharedProjects || ! sharedProjects[username] )	return [];
	else return sharedProjects[username];
},
getSharedStagesByUsername : function(username) {
// RETURN AN ARRAY OF STAGES SHARED BY THE USER
	var sharedStages = this.cloneData("sharedstages");
	if ( sharedStages == null || sharedStages[username] == null )	return [];
	else return sharedStages[username];
},
getSharedWorkflowsByProject : function(username, project) {
// RETURN AN ARRAY OF ALL OF THE NAMES OF USERS WHO HAVE SHARED PROJECTS
// WITH THE LOGGED ON USER

	console.log("Agua.Shared.getSharedWorkflowsByProject    plugins.core.Data.getSharedWorkflowsByProject(username, project)");		
	console.log("Agua.Shared.getSharedWorkflowsByProject    username: " + username);
	console.log("Agua.Shared.getSharedWorkflowsByProject    project: " + project);

	var sharedWorkflows = this.cloneData("sharedworkflows") || [];
	sharedWorkflows = sharedWorkflows[username] || [];
	console.dir({sharedWorkflows:sharedWorkflows});
	sharedWorkflows = this.filterByKeyValues(sharedWorkflows, ["project"], [project]);
	console.log("Agua.Shared.getSharedWorkflowsByProject    sharedWorkflows: ");
	console.dir({sharedWorkflows:sharedWorkflows});

	return sharedWorkflows;
},
getSharedStagesByWorkflow : function(username, project, workflow) {
// RETURN AN ARRAY OF ALL OF THE NAMES OF USERS WHO HAVE SHARED PROJECTS
// WITH THE LOGGED ON USER

	console.log("Agua.Shared.getSharedStagesByWorkflow    plugins.core.Data.getSharedStagesByWorkflow(username, project, workflow)");		
	console.log("Agua.Shared.getSharedStagesByWorkflow    username: " + username);
	console.log("Agua.Shared.getSharedStagesByWorkflow    project: " + project);
	console.log("Agua.Shared.getSharedStagesByWorkflow    workflow: " + workflow);
	
	var sharedStages = this.getSharedStagesByUsername(username);
	console.log("Agua.Shared.getSharedStagesByWorkflow    BEFORE FILTER PROJECT, sharedStages: ");
	console.dir({sharedStages:sharedStages});
	sharedStages = this.filterByKeyValues(sharedStages, ["project"], [project]);

	console.log("Agua.Shared.getSharedStagesByWorkflow    BEFORE FILTER WORKFLOW, sharedStages: ");
	console.dir({sharedStages:sharedStages});

	sharedStages = this.filterByKeyValues(sharedStages, ["workflow"], [workflow]);
	console.log("Agua.Shared.getSharedStagesByWorkflow    AFTER sharedStages: ");
	console.dir({sharedStages:sharedStages});

	return sharedStages;
},
getSharedParametersByAppname : function (appname, owner) {
// RETURN AN ARRAY OF PARAMETERS FOR THE GIVEN APPLICATION
// OWNED BY ANOTHER USER
	//console.log("Agua.Shared.getSharedParametersByAppname    plugins.core.Data.getSharedParametersByAppname(appname,)");
	//console.log("Agua.Shared.getSharedParametersByAppname    owner: " + owner);
	//console.log("Agua.Shared.getSharedParametersByAppname    appname: " + appname);
	if ( appname == null )	return null;	
	var params = this.cloneData("sharedparameters");
	////console.log("Agua.Shared.getSharedParametersByAppname    params : " + dojo.toJson(params));
	var keys = [ "owner", "appname" ];
	var values = [ owner, appname ];
	var parameters = this.filterByKeyValues(params, keys, values);
	////console.log("Agua.Shared.getSharedParametersByAppname    Returning parameters : " + dojo.toJson(parameters));
	
	return parameters;
},
getSharedStageParameters : function (stageObject) {
// RETURN AN ARRAY OF STAGE PARAMETER HASHARRAYS FOR A STAGE
	//console.log("Agua.Shared.getSharedStageParameters    plugins.core.Data.getSharedStageParameters(stageObject)");
	//console.log("Agua.Shared.getSharedStageParameters    stageObject: " + dojo.toJson(stageObject));
	
	var keys = ["username", "project", "workflow", "name", "number"];
	var notDefined = this.notDefined (stageObject, keys);
	console.log("Agua.Shared.getSharedStageParameters    notDefined: " + dojo.toJson(notDefined));
	if ( notDefined.length != 0 )
	{
		console.log("Agua.Shared.getSharedStageParameters    not defined: " + dojo.toJson(notDefined));
		return;
	}
	var username = stageObject.username;
	var sharedStageParameters = this.cloneData("sharedstageparameters");
	if ( sharedStageParameters == null || sharedStageParameters[username] == null )	return [];
	var stageParameters = sharedStageParameters[username];
	//console.log("Agua.Shared.getSharedStageParameters    BEFORE stageParameters: " + dojo.toJson(stageParameters, true));
	
	// ADD appname AND appnumber FOR STAGE PARAMETER IDENTIFICATION
	stageObject.appname = stageObject.name;
	stageObject.appnumber = stageObject.number;
	
	var keyArray = ["username", "project", "workflow", "appname", "appnumber"];
	var valueArray = [stageObject.username, stageObject.project, stageObject.workflow, stageObject.name, stageObject.number];
	stageParameters = this.filterByKeyValues(stageParameters, keyArray, valueArray);
	
	//console.log("Agua.Shared.getSharedStageParameters    AFTER  stageParameters: " + dojo.toJson(stageParameters));

	return stageParameters;
},
getSharedViews : function (viewObject) {
// RETURN AN ARRAY OF VIEWS IN THE SHARED PROJECT
	console.log("Agua.Shared.getSharedViews    plugins.core.Data.getSharedViews(viewObject)");
	console.log("Agua.Shared.getSharedViews    viewObject: " + dojo.toJson(viewObject));
	
	var keys = ["project", "username"];
	var notDefined = this.notDefined (viewObject, keys);
	console.log("Agua.Shared.getSharedViews    notDefined: " + dojo.toJson(notDefined));
	if ( notDefined.length != 0 )
	{
		console.log("Agua.Shared.getSharedViews    not defined: " + dojo.toJson(notDefined));
		return;
	}

	var username = viewObject.username;
	var sharedViews = this.cloneData("sharedsharedViews");
	if ( sharedViews == null || sharedViews[username] == null )	return [];
	var views = sharedViews[username];
	console.log("Agua.Shared.getSharedViews    BEFORE views: " + dojo.toJson(views, true));	
	
	var keyArray = ["project", "username"];
	var valueArray = [viewObject.username, viewObject.project, viewObject.workflow, viewObject.name, viewObject.number];
	views = this.filterByKeyValues(views, keyArray, valueArray);
	
	console.log("Agua.Shared.getSharedViews    AFTER  views: " + dojo.toJson(views));

	return views;
},
getSharedApps : function () {
	//console.log("Agua.Shared.getSharedApps    plugins.core.Data.getSharedApps()");
	return this.cloneData("sharedapps");
}

});

}

if(!dojo._hasResource["plugins.core.Agua.Sharing"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.core.Agua.Sharing"] = true;
dojo.provide("plugins.core.Agua.Sharing");

/* SUMMARY: THIS CLASS IS INHERITED BY Agua.js AND CONTAINS 
	
	ADMIN METHODS  
*/

dojo.declare( "plugins.core.Agua.Sharing",	[  ], {

///////}}}

// ADMIN METHODS
getSharingHeadings : function () {
	console.log("Agua.Sharing.getSharingHeadings    plugins.core.Data.getSharingHeadings()");
	var headings = this.cloneData("sharingheadings");
	console.log("Agua.Sharing.getSharingHeadings    headings: " + dojo.toJson(headings));
	return headings;
},
getAccess : function () {
	//console.log("Agua.Sharing.getAccess    plugins.core.Data.getAccess()");
	return this.cloneData("access");
}

});

}

if(!dojo._hasResource["plugins.core.Agua.Source"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.core.Agua.Source"] = true;
dojo.provide("plugins.core.Agua.Source");

/* SUMMARY: THIS CLASS IS INHERITED BY Agua.js AND CONTAINS 
	
	SOURCE METHODS  
*/

dojo.declare( "plugins.core.Agua.Source",	[  ], {

/////}}}

getSources : function () {
// RETURN A SORTED COPY OF sources
	//console.log("Agua.Source.getSources    plugins.core.Data.getSources()");

	var sources = this.cloneData("sources");
	return this.sortHasharray(sources, "name");
},
isSource : function (sourceObject) {
// RETURN TRUE IF SOURCE NAME ALREADY EXISTS

	console.log("Agua.Source.isSource    plugins.core.Data.isSource(sourceObject)");
	console.log("Agua.Source.isSource    sourceObject: " + dojo.toJson(sourceObject));
	
	var sources = this.getSources();
	if ( sources == null )	return false;
	
	return this._objectInArray(sources, sourceObject, ["name"]);
},
addSource : function (sourceObject) {
// ADD A SOURCE OBJECT TO THE sources ARRAY
	console.log("Agua.Source.addSource    plugins.core.Data.addSource(sourceObject)");
	console.log("Agua.Source.addSource    sourceObject: " + dojo.toJson(sourceObject));	

	this._removeSource(sourceObject);
	if ( ! this._addSource(sourceObject) )	return false;
	
	var url = Agua.cgiUrl + "sharing.cgi?";
	var query = new Object;
	query.username = this.cookie("username");
	query.sessionid = this.cookie("sessionid");
	query.mode = "addSource";
	query.data = sourceObject;
	////console.log("Sources.addItem    query: " + dojo.toJson(query));
	this.doPut({ url: url, query: query, sync: false });
},
_addSource : function (sourceObject) {
// ADD A SOURCE OBJECT TO THE sources ARRAY
	console.log("Agua.Source._addSource    plugins.core.Data._addSource(sourceObject)");
	console.log("Agua.Source._addSource    sourceObject: " + dojo.toJson(sourceObject));
	return this.addData("sources", sourceObject, [ "name", "description", "location" ]);
},
removeSource : function (sourceObject) {
// REMOVE A SOURCE OBJECT FROM sources AND groupmembers
	//console.log("Agua.Source.removeSource    plugins.core.Data.removeSource(sourceObject)");
	//console.log("Agua.Source.removeSource    sourceObject: " + dojo.toJson(sourceObject));	
	if ( ! this._removeSource(sourceObject) )
	{
		console.log("Agua.Source.removeSource    FAILED TO REMOVE sourceObject: " + dojo.toJson(sourceObject));
		return false;
	}

	// REMOVE FROM GROUPMEMBER
	sourceObject.username = this.cookie("username");
	sourceObject.type = "source";
	var requiredKeys = [ "username", "name", "type"];
	this.removeData("groupmembers", sourceObject, requiredKeys);

	// SEND TO SERVER
	var url = Agua.cgiUrl + "sharing.cgi?";
	var query = new Object;
	query.username = this.cookie("username");
	query.sessionid = this.cookie("sessionid");
	query.mode = "removeSource";
	query.data = sourceObject;
	
	////console.log("Sources.deleteItem    sourceObject: " + dojo.toJson(sourceObject));
	this.doPut({ url: url, query: query, sync: false });
},
_removeSource : function (sourceObject) {
// _remove A SOURCE OBJECT FROM sources AND groupmembers
	//console.log("Agua.Source._removeSource    plugins.core.Data._removeSource(sourceObject)");
	//console.log("Agua.Source._removeSource    sourceObject: " + dojo.toJson(sourceObject));
	return this.removeData("sources", sourceObject, ["name"]);
},
isGroupSource : function (groupName, sourceObject) {
// RETURN true IF A SOURCE ALREADY BELONGS TO A GROUP
	console.log("Agua.Source.isGroupSource    plugins.core.Data.isGroupSource(groupName, sourceObject)");
	//console.log("Agua.Source.isGroupSource    groupName: " + groupName);
	//console.log("Agua.Source.isGroupSource    sourceObject: " + dojo.toJson(sourceObject));
	
	var groupSources = this.getGroupSources();
	if ( groupSources == null )	return false;

	groupSources = this.filterByKeyValues(groupSources, ["groupname"], [groupName]);
	
	return this._objectInArray(groupSources, sourceObject, ["name"]);
},
addSourceToGroup : function (groupName, sourceObject) {
// ADD A SOURCE OBJECT TO A GROUP ARRAY IF IT DOESN"T EXIST THERE ALREADY 
	console.log("Agua.Source.addSourceToGroup     plugins.core.Data.addSourceToGroup");

	if ( this.isGroupSource(groupName, sourceObject) == true )
	{
		console.log("Agua.Source.addSourceToGroup     source already exists in sources: " + sourceObject.name + ". Returning.");
		return false;
	}

	var groups = this.getGroups();
	var group = this._getObjectByKeyValue(groups, "groupname", groupName);
	if ( group == null )	return null;
	
	sourceObject.username = group.username;
	sourceObject.groupname = groupName;
	sourceObject.groupdesc = group.description;
	sourceObject.type = "source";

	var requiredKeys = [ "username", "groupname", "name", "type"];
	return this.addData("groupmembers", sourceObject, requiredKeys);
},
removeSourceFromGroup : function (groupName, sourceObject) {
// REMOVE A SOURCE OBJECT FROM A GROUP ARRAY, IDENTIFY OBJECT BY "name" KEY VALUE
	console.log("Agua.Source.removeSourceFromGroup     groupName: " + groupName);
	console.log("Agua.Source.removeSourceFromGroup     sourceObject: ");
	console.dir({sourceObject:sourceObject});

	var groups = this.getGroups();
	console.log("Agua.Source.removeSourceFromGroup     groups: ");
	console.dir({groups:groups});
	var group = this._getObjectByKeyValue(groups, "groupname", groupName);
	console.log("Agua.Source.removeSourceFromGroup     group: ");
	console.dir({group:group});

	if ( group == null )	{
		console.log("Agua.Source.removeSourceFromGroup     group is null. Returning.");
		return null;
	}
	
	sourceObject.owner 		= group.username;
	sourceObject.groupname 	= groupName;
	sourceObject.groupdesc	= group.description;
	sourceObject.type 		= "source";
	console.log("Agua.Source.removeSourceFromGroup     BEFORE removeData, sourceObject: ");
	console.dir({sourceObject:sourceObject});

	var requiredKeys = [ "username", "groupname", "name", "type"];
	return this.removeData("groupmembers", sourceObject, requiredKeys);
},
getSourcesByGroup : function (groupName) {
// RETURN THE ARRAY OF SOURCES THAT BELONG TO A GROUP

	var groupSources = this.getGroupSources();
	var keyArray = ["groupname"];
	var valueArray = [groupName];
	return this.filterByKeyValues(groupSources, keyArray, valueArray);
}

});

}

if(!dojo._hasResource["plugins.core.Agua.Stage"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.core.Agua.Stage"] = true;
dojo.provide("plugins.core.Agua.Stage");

/* SUMMARY: THIS CLASS IS INHERITED BY Agua.js AND CONTAINS 
	
	STAGE METHODS  
*/

dojo.declare( "plugins.core.Agua.Stage",	[  ], {

/////}}}

// STAGE METHODS
addStage : function (stageObject) {
// ADD AN APP OBJECT TO stages AND COPY ITS PARAMETERS
// INTO parameters. RETURN TRUE OR FALSE.
// ALSO UPDATE THE REMOTE DATABASE.
	console.log("Agua.Stage.addStage    stageObject: ");
	console.dir({stageObject:stageObject});
	
	var result = this._addStage(stageObject);
	
	// ADD PARAMETERS FOR THIS STAGE TO stageparameters
	if ( result == true )	result = this.addStageParametersForStage(stageObject);
	if ( result == false )
	{
		//console.log("Agua.Stage.removeStage    Problem adding stage or stageparameters. Returning.");
		return;
	}
	
	// ADD STAGE ON REMOTE DATABASE
	var url = Agua.cgiUrl + "workflow.cgi";
	var query = stageObject;
	query.username = this.cookie("username");
	query.sessionid = this.cookie("sessionid");
	query.mode = "addStage";
	//console.log("Agua.Stage.addStage    query: " + dojo.toJson(query));

	this.doPut({ url: url, query: query });
	
	return result;
},
_addStage : function (stageObject) {
// ADD A STAGE TO stages 
	//console.log("Agua.Stage._addStage    plugins.core.Data._addStage(stageObject)");
	//console.log("Agua.Stage._addStage    stageObject: " + dojo.toJson(stageObject));	
	var requiredKeys = ["project", "workflow", "name", "number"];
	var result = this.addData("stages", stageObject, requiredKeys);
	if ( result == false )
	{
		//console.log("Agua.Stage._addStage    Failed to add stage to stages");
		return false;
	}

	return result;
},
insertStage : function (stageObject) {
// INSERT AN APP OBJECT INTO THE stages ARRAY,
// INCREMENTING THE number OF ALL DOWNSTREAM STAGES
// BEFOREHAND. DO THE SAME FOR THE stageparameters
// ENTRIES FOR THIS APP.
// THEN, MIRROR ON THE REMOTE DATABASE.

	console.log("Agua.Stage.insertStage    plugins.core.Data.insertStage(stageObject)");
	delete stageObject.avatarType;
	console.log("Agua.Stage.insertStage    stageObject: ");
	console.dir({stageObject:stageObject});
	
    // SET THE WORKFLOW NUMBER IN THE STAGE OBJECT
    var workflowNumber = Agua.getWorkflowNumber(stageObject.project, stageObject.workflow);
    stageObject.workflownumber = workflowNumber;    

	// SANITY CHECK
	if ( stageObject == null )	return;
	
	// GET THE STAGES FOR THIS PROJECT AND WORKFLOW
	// ORDERED BY number
	var stages = this.getStagesByWorkflow(stageObject.project, stageObject.workflow);
	//console.log("Agua.Stage.insertStage    pre-insert unsorted stages: " + dojo.toJson(stages, true));
	stages = this.sortHasharray(stages, "number");
	//console.log("Agua.Stage.insertStage    pre-insert sorted stages: ");
	//console.dir({pre_insert_sorted_stages:stages});

	// GET THE INSERTION INDEX OF THE STAGE
	var index = stageObject.number - 1;
	
	var sourceUser = stageObject.owner;
	var targetUser = stageObject.username;
	
	// INCREMENT THE appnumber IN ALL DOWNSTREAM STAGES IN stageparameters
	var result = true;
	for ( var i = stages.length - 1; i > index - 1; i-- )
	{
		// GET THE STAGE PARAMETERS FOR THIS STAGE
		var stageParameters = this.getStageParameters(stages[i]);

		//console.log("Agua.Stage.insertStage    Stage parameters for stages[" + i + "]: ");
		//console.dir({stageParameters:stageParameters});

		if ( stageParameters == null )
		{
			console.log("Agua.Stage.insertStage    Result = false because no stage parameters for stage: " + dojo.toJson(stages[i], true));
			result = false;
		}

		// REMOVE EACH STAGE PARAMETER AND RE-ADD ITS UPDATED VERSION
		var thisObject = this;
		for ( var j = 0; j < stageParameters.length; j++ )
		{
			// REMOVE EXISTING STAGE
			if ( thisObject._removeStageParameter(stageParameters[j]) == false )
			{
				console.log("Agua.Stage.insertStage    Result = false because there was a problem removing stageParameter: " + dojo.toJson(stageParameters[j], true));
				result = false;
			}

			// INCREMENT STAGE NUMBER
			stageParameters[j].appnumber = (i + 2).toString();

			// ADD BACK STAGE
			if ( thisObject._addStageParameter(stageParameters[j]) == false )
			{
				console.log("Agua.Stage.insertStage    Result = false because there was a problem adding stageParameter: " + dojo.toJson(stageParameters[j], true));
				result = false;
			}				
		}

		//  ******** DEBUG ONLY ************
		//  ******** DEBUG ONLY ************
		//var updatedStageParameters = this.getStageParameters(stages[i]);
		////console.log("Agua.Stage.insertStage    updatedStageParameters for stages[" + i + "]: " + dojo.toJson(updatedStageParameters));
		//  ******** DEBUG ONLY ************
		//  ******** DEBUG ONLY ************
	}
	if ( result == false )
	{
		console.log("Agua.Stage.insertStage    Returning because there was a problem updating the stage parameters");
		return false;
	}

	// INCREMENT THE number OF ALL DOWNSTREAM STAGES IN stages
	// NB: THE SERVER SIDE UPDATES ARE DONE AUTOMATICALLY
	for ( var i = stages.length - 1; i > index - 1; i-- )
	{
		// REMOVE FROM stages
		if ( this._removeStage(stages[i]) == false )
		{
			console.log("Agua.Stage.spliceStage    Returning because there was a problem removing stages[" + i + "]: " + dojo.toJson(stages[i]));
			return false;
		}

		// INCREMENT STAGE NUMBER
		stages[i].number = (i + 2).toString();

		// ADD BACK TO stages
		if ( this._addStage(stages[i]) == false )
		{
			console.log("Agua.Stage.spliceStage    Returning because there was a problem adding back stages[" + i + "]: " + dojo.toJson(stages[i]));
			return false;
		}
	}
	
	// INSERT THE NEW STAGE (NO EXISTING STAGES WILL HAVE ITS number)
	// (NB: this._addStage CHECKS FOR REQUIRED FIELDS)
	result = this._addStage(stageObject);
	if ( result == false )
	{
		console.log("Agua.Stage.insertStage    Returning FALSE because there was a problem adding the stage to stages: " + dojo.toJson(stageObject));
		return false;
	}
	//console.log("Agua.Stage.insertStage    this._addStage(...) result: " + result);
	
	// ADD PARAMETERS FOR THIS STAGE TO stageparameters
	if ( result == true ) result = this.addStageParametersForStage(stageObject);
	if ( result == false )
	{
		console.log("Agua.Stage.insertStage    Returning because there was a problem copying parameters for the stage:" + dojo.toJson(stageObject));
		return false;
	}

	// ADD STAGE IN REMOTE DATABASE
	var url = Agua.cgiUrl + "workflow.cgi";
	var query = stageObject;
	query.username = this.cookie("username");
	query.sessionid = this.cookie("sessionid");
	query.mode = "insertStage";
	this.doPut({ url: url, query: query });
	
	// RETURN TRUE OR FALSE
	return true;
},
removeStage : function (stageObject) {
// REMOVE AN APP OBJECT FROM THE stages ARRAY
// AND SIMULTANEOUSLY REMOVE CORRESPONDING ENTRIES IN
// parameters FOR THIS STAGE.
// ALSO, MAKE removeStage CALL TO REMOTE DATABASE.

	console.log("Agua.Stage.removeStage    plugins.core.Data.removeStage(stageObject)");
	console.log("Agua.Stage.removeStage    stageObject: " + stageObject);
	
	// DO THE ADD
	var result = this._removeStage(stageObject);

	// ADD PARAMETERS FOR THIS STAGE TO stageparameters
	console.log("Agua.Stage.removeStage    Doing this.removeStageParameters(stageObject)");
	if( result == true ) 	result = this.removeStageParameters(stageObject);

	if ( result == false )
	{
		console.log("Agua.Stage.removeStage    Problem removing stage or stageparameters. Returning.");
		return;
	}
	
	// ADD STAGE TO stage TABLE IN REMOTE DATABASE
	var url = Agua.cgiUrl + "workflow.cgi";
	var query = stageObject;
	query.username = this.cookie("username");
	query.sessionid = this.cookie("sessionid");
	query.mode = "removeStage";
	//console.log("Agua.Stage.removeStage    query: " + dojo.toJson(query));

	this.doPut({ url: url, query: query });
	
	// RETURN TRUE OR FALSE
	return result;
},
_removeStage : function (stageObject) {
// REMOVE AN APP OBJECT FROM THE stages ARRAY
// AND SIMULTANEOUSLY REMOVE CORRESPONDING ENTRIES IN
// parameters FOR THIS STAGE
	//console.log("Agua.Stage._removeStage    plugins.core.Data._removeStage(stageObject)");
	//console.log("Agua.Stage._removeStage    stageObject: " + dojo.toJson(stageObject));

	var uniqueKeys = ["project", "workflow", "name", "number"];
	var result = this.removeData("stages", stageObject, uniqueKeys);
	if ( result == false )
	{
		//console.log("Agua.Stage._removeStage    Failed to remove stage from stages");
		return false;
	}
	return result;
},
updateStagesStatus : function (stageList) {
// UPDATE STAGE status, started AND completed
	//console.log("Agua.Stage.updateStagesStatus    stageList: " + dojo.toJson(stageList, true));	
	if ( stageList == null || stageList.length == 0 )	return;
	//console.log("Agua.Stage.updateStagesStatus     stageList.length: " + stageList.length);
	
	// GET ACTUAL stages DATA
	var stages = this.getData("stages");
	
	// ORDER BY STAGE NUMBER -- NB: REMOVES ENTRIES WITH NO NUMBER
	stages = this.sortNumericHasharray(stages, "number");
	//console.log("Agua.Stage.updateStagesStatus     stages.length: " + stages.length);

	var projectName = stages[0].project;
	var workflowName = stages[0].workflow;
	var counter = 0;
	for ( var i = 0; i < stages.length; i++ )
	{
		if ( stages[i].project != projectName )	continue;
		if ( stages[i].workflow != workflowName )	continue;
		counter++;
		//console.log("Agua.Stage.updateStagesStatus     stage " + counter + ": " + dojo.toJson(stages[i], true));
		//console.log("Agua.Stage.updateStagesStatus     stages " + counter + " number: " + stages[i].number + ", status: " + stages[i].status + ", started: " + stages[i].started + ", completed: " + stages[i].completed);
	}
	
	// UPDATE STAGES
	for ( var i = 0; i < stages.length; i++ )
	{
		if ( stages[i].project != projectName )	continue;
		if ( stages[i].workflow != workflowName )	continue;

		for ( var k = 0; k < stageList.length; k++ )
		{
			//console.log("Agua.Stage.updateStagesStatus     stageList " + k);
			if ( stages[i].number == stageList[k].number )
			{
				stages[i].status = stageList[k].status;
				stages[i].started = stageList[k].started;
				stages[i].completed = stageList[k].completed;
				continue;
			}
		}
	}
	
	// DEBUG -- CONFIRM CHANGES
	stages = this.getData("stages");
	stages = this.sortNumericHasharray(stages, "number");
	counter = 0;
	for ( var i = 0; i < stages.length; i++ )
	{
		if ( stages[i].project != projectName )	continue;
		if ( stages[i].workflow != workflowName )	continue;
		counter++;
		//console.log("Agua.Stage.updateStagesStatus     stage " + counter + ": " + dojo.toJson(stages[i], true));
		//console.log("Agua.Stage.updateStagesStatus     stage " + counter + " number: " + stages[i].number + ", status: " + stages[i].status + ", started: " + stages[i].started + ", completed: " + stages[i].completed);
	}
},	
updateStageSubmit : function (stageObject) {
// ADD AN APP OBJECT TO stages AND COPY ITS PARAMETERS
// INTO parameters. RETURN TRUE OR FALSE.
// ALSO UPDATE THE REMOTE DATABASE.
	//console.log("Agua.Stage.updateStageSubmit    plugins.core.Data.updateStageSubmit(stageObject)");
	//console.log("Agua.Stage.updateStageSubmit    stageObject: " + dojo.toJson(stageObject));

	var stages = this.getData("stages");
	var index = this._getIndexInArray(stages, stageObject, ["project", "workflow", "number"]);
	//console.log("Agua.Stage.updateStageSubmit    index: " + index);	
	if ( index == null )	return 0;
	
	//console.log("Agua.Stage.updateStageSubmit    stages[index]: " + dojo.toJson(stages[index]));
	stages[index].submit = stageObject.submit;

	// ADD STAGE ON REMOTE DATABASE
	var url = Agua.cgiUrl + "workflow.cgi";
	stageObject.username = this.cookie("username");
	stageObject.sessionid = this.cookie("sessionid");
	stageObject.mode = "updateStageSubmit";
	//console.log("Agua.Stage.updateStageSubmit    stageObject: " + dojo.toJson(stageObject, true));
	this.doPut({ url: url, query: stageObject });

	return 1;
},
spliceStage : function (stageObject) {
// SPLICE OUT A STAGE FROM stages AND DECREMENT THE
// number OF ALL DOWNSTREAM STAGES.
// DO THE SAME FOR THE CORRESPONDING ENTRIES IN stageparameters
	//console.log("Agua.Stage.spliceStage    plugins.core.Data.updateStage(stageObject)");
	//console.log("Agua.Stage.spliceStage    stageObject: " + dojo.toJson(stageObject, true));
	
	// SANITY CHECK
	if ( stageObject == null )	return;
	
	// GET THE STAGES FOR THIS PROJECT AND WORKFLOW
	var stages = this.getStagesByWorkflow(stageObject.project, stageObject.workflow);
	//////console.log("Agua.Stage.spliceStage    pre-splice unsorted stages: " + dojo.toJson(stages, true));

	// ORDER BY number AND SPLICE OUT THE STAGE 
	stages = this.sortHasharray(stages, "number");
	//////console.log("Agua.Stage.spliceStage    pre-splice sorted stages: " + dojo.toJson(stages, true));
	var index = stageObject.number - 1;
	stages.splice(index, 1);
	
	
	// REMOVE THE STAGE FROM THE stages
	var result = this._removeStage(stageObject);
	if ( result == false )
	{
		////console.log("Agua.Stage.spliceStage    Returning because there was a problem removing the stage from stages: " + dojo.toJson(stageObject));
		return false;
	}

	// REMOVE THE STAGE FROM stageparameters
	//console.log("Agua.Stage.spliceStage    Doing this.removeStageParameters(stageObject)");
	result = this.removeStageParameters(stageObject);
	if ( result == false )
	{
		console.log("Agua.Stage.spliceStage    Returning because there was a problem removing parameters for the stage:" + dojo.toJson(stageObject));
		return false;
	}

	// DECREMENT THE number OF ALL DOWNSTREAM STAGES IN stages
	// NB: THE SERVER SIDE UPDATES ARE DONE AUTOMATICALLY
	for ( var i = index; i < stages.length; i++ )
	{
		// REMOVE IT FROM THE stages ARRAY
		////console.log("Agua.Stage.spliceStage    Replacing stage " + i + " to decrement number to " + (i + 1) );
		this._removeStage(stages[i]);
		stages[i].number = (i + 1).toString();
		this._addStage(stages[i]);
	}

	//  ******** DEBUG ONLY ************
	//  ******** DEBUG ONLY ************
	var newStages = this.getStagesByWorkflow(stageObject.project, stageObject.workflow);
	//////console.log("Agua.Stage.spliceStage    post-splice stages: " + dojo.toJson(newStages, true));
	for ( var i = 0; i < newStages.length; i++ )
	{
		////console.log("Agua.Stage.spliceStage    newStages[" + i + "]:" + newStages[i].name + "\t" + newStages[i].number);
	}
	
	//  ******** DEBUG ONLY ************
	//  ******** DEBUG ONLY ************


	// DECREMENT THE appnumber IN ALL DOWNSTREAM STAGES IN stageparameters
	////console.log("Agua.Stage.spliceStage    Doing from " + (stages.length - 1) + " to " + index);
	for ( var i = stages.length - 1; i > index - 1; i-- )
	{
		// REINCREMENT STAGE NUMBER TO GET ITS STAGE
		// PARAMETERS, WHICH HAVE NOT BEEN DECREMENTED YET
		stages[i].number = (i + 2).toString();
		////console.log("Agua.Stage.spliceStage    Reincremented stage[" + i + "].number to: " + stages[i].number);

		// GET THE STAGE PARAMETERS FOR THIS STAGE
		var stageParameters = this.getStageParameters(stages[i]);
		//////console.log("Agua.Stage.spliceStage    stages[" + i + "]: " + dojo.toJson(stages[i], true));
		//////console.log("Agua.Stage.spliceStage    Stage parameters for stages[" + i + "]: " + dojo.toJson(stageParameters, true));
		if ( stageParameters == null )
		{
			////console.log("Agua.Stage.spliceStage    Returning because no stage parameters for stage: " + dojo.toJson(stages[i], true));
			return false;
		}

		// REMOVE EACH STAGE PARAMETER AND RE-ADD ITS UPDATED VERSION
		var thisObject = this;
		//dojo.forEach( stageParameters, function(stageParameter, i)
		for ( var j = 0; j < stageParameters.length; j++ )
		{
			// REMOVE EXISTING STAGE
			if ( thisObject._removeStageParameter(stageParameters[j]) == false )
			{
				////console.log("Agua.Stage.spliceStage    Result = false because there was a problem removing stageParameter: " + dojo.toJson(stageParameters[j], true));
				result = false;
			}

			// DECREMENT STAGE NUMBER
			stageParameters[j].appnumber = (i + 1).toString();

			// ADD BACK STAGE
			if ( thisObject._addStageParameter(stageParameters[j]) == false )
			{
				////console.log("Agua.Stage.spliceStage    Result = false because there was a problem adding stageParameter: " + dojo.toJson(stageParameters[j], true));
				result = false;
			}
		}

		// REDECREMENT STAGE NUMBER
		stages[i].number = (i + 1).toString();
		////console.log("Agua.Stage.spliceStage    Redecremented stage[" + i + "].number to: " + stages[i].number);
	}
	if ( result == false )	return false;

	// REMOVE FROM REMOTE DATABASE DATABASE:
	var url = Agua.cgiUrl + "workflow.cgi";

	// GENERATE QUERY JSON FOR THIS WORKFLOW IN THIS PROJECT
	var query = stageObject;
	query.username = this.cookie("username");
	query.sessionid = this.cookie("sessionid");
	query.mode = "removeStage";
	////console.log("Agua.Stage.spliceStage    query: " + dojo.toJson(query));

	this.doPut({ url: url, query: query});
},
isStage : function (stageName) {
// RETURN true IF AN APP EXISTS IN stages
	//console.log("Agua.Stage.isStage    plugins.core.Data.isStage(stageName, stageObject)");
	//console.log("Agua.Stage.isStage    stageName: *" + stageName + "*");
	var stages = this.getStages();
	for ( var i in stages )
	{
		var stage = stages[i];
		//console.log("Agua.Stage.isStage    Checking stage.name: *" + stage.name + "*");
		if ( stage.name.toLowerCase() == stageName.toLowerCase() )
		{
			return true;
		}
	}
	
	return false;
},
getStageType : function (stageName) {
// RETURN true IF AN APP EXISTS IN stages
	//console.log("Agua.Stage.getStageType    plugins.core.Data.getStageType(stageName, stageObject)");
	////console.log("Agua.Stage.getStageType    stageName: *" + stageName + "*");
	var stages = this.getStages();
	for ( var i in stages )
	{
		var stage = stages[i];
		////console.log("Agua.Stage.getStageType    Checking stage.name: *" + stage.name + "*");
		if ( stage.name.toLowerCase() == stageName.toLowerCase() )
		{
			return stage.type;
		}
	}
	
	return null;
},
getStages : function () {
	//console.log("Agua.Stage.getStages    plugins.core.Data.getStages()");
	
	return this.cloneData("stages");
},
getStagesByWorkflow : function (project, workflow) {
// RETURN AN ARRAY OF STAGE HASHES FOR THIS PROJECT AND WORKFLOW

	////console.log("Agua.Stage.getStagesByWorkflow    plugins.core.Data.getStagesByWorkflow(project, workflow)");
	////console.log("Agua.Stage.getStagesByWorkflow    project: " + project);
	////console.log("Agua.Stage.getStagesByWorkflow    workflow: " + workflow);
	if ( project == null )	return;
	if ( workflow == null )	return;
	var stages = this.cloneData("stages");
	var keyArray = ["project", "workflow"];
	var valueArray = [project, workflow];
	stages = this.filterByKeyValues(stages, keyArray, valueArray);
	
	////console.log("Agua.Stage.getStagesByWorkflow    Returning stages: " + dojo.toJson(stages));

	return stages;
}

});

}

if(!dojo._hasResource["plugins.core.Agua.StageParameter"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.core.Agua.StageParameter"] = true;
dojo.provide("plugins.core.Agua.StageParameter");

/* SUMMARY: THIS CLASS IS INHERITED BY Agua.js AND CONTAINS 
	
	STAGEPARAMETER METHODS  
*/

dojo.declare( "plugins.core.Agua.StageParameter",	[  ], {

/////}}}

// STAGEPARAMETER METHODS
addStageParameter : function (stageParameterObject) {
// 1. REMOVE ANY EXISTING STAGE PARAMETER (UNIQUE KEYS: appname, appnumber, name)
// 		(I.E., THE SAME AS UPDATING AN EXISTING STAGE PARAMETER)
// 2. ADD A STAGE PARAMETER OBJECT TO THE stageparameters ARRAY
//   
// 3. ADD TO stageparameter TABLE IN REMOTE DATABASE

	//console.log("Agua.StageParameteraddStageParameter    plugins.core.Data.addStageParameter(stageParameterObject)");
	//console.log("Agua.StageParameteraddStageParameter    stageParameterObject: " + dojo.toJson(stageParameterObject));

	// DO THE REMOVE
	this._removeStageParameter(stageParameterObject);
	
	// DO THE ADD
	var result = this._addStageParameter(stageParameterObject);
	if ( result == false )
    {
        console.log("Agua.StageParameteraddStageParameter    result of _addStageParameter is " + result + ". Returning");
        return result;
    }
    
	// REMOVE FROM REMOTE DATABASE DATABASE:
	// SET URL, ADD RANDOM NUMBER TO DISAMBIGUATE BETWEEN CALLS BY DIFFERENT
	// METHODS TO THE SERVER
	var url = this.cgiUrl + "workflow.cgi";

	// GENERATE QUERY JSON FOR THIS WORKFLOW IN THIS PROJECT
	var query = stageParameterObject;
	query.username = this.cookie("username");
	query.sessionid = this.cookie("sessionid");
	query.mode = "addStageParameter";
	//console.log("Agua.StageParameteraddStageParameter     query: " + dojo.toJson(query));

	this.doPut({ url: url, query: query});

	// RETURN TRUE OR FALSE
	return result;
},
_addStageParameter : function (stageParameterObject) {
// ADD A STAGE PARAMETER OBJECT TO THE stageparameters ARRAY,
// REQUIRE THAT UNIQUE KEYS ARE DEFINED

	if ( stageParameterObject.chained == null )
		stageParameterObject.chained = "0";
	//console.log("Agua.StageParameter_addStageParameter    plugins.core.Data._addStageParameter(stageParameterObject)");
	//console.log("Agua.StageParameter_addStageParameter    stageParameterObject: " + dojo.toJson(stageParameterObject));

	// DO THE ADD
	var uniqueKeys = ["project", "workflow", "appname", "appnumber", "name", "paramtype"];
	return this.addData("stageparameters", stageParameterObject, uniqueKeys);
},
removeStageParameter : function (stageParameterObject) {
// 1. REMOVE A stage PARAMETER OBJECT FROM THE stageparameters ARRAY
// 2. REMOVE FROM stageparameter TABLE IN REMOTE DATABASE

	////console.log("Agua.StageParameterremoveStageParameter    plugins.core.Data.removeStageParameter(stageParameterObject)");
	////console.log("Agua.StageParameterremoveStageParameter    stageParameterObject: " + dojo.toJson(stageParameterObject));

	var result = this._removeStageParameter(stageParameterObject);
	if ( result == false )	return result;

	// REMOVE FROM REMOTE DATABASE:
	// SET URL, ADD RANDOM NUMBER TO DISAMBIGUATE BETWEEN CALLS BY DIFFERENT
	// METHODS TO THE SERVER
	var url = this.cgiUrl + "workflow.cgi";
	
	// GENERATE QUERY JSON FOR THIS WORKFLOW IN THIS PROJECT
	var query = stageParameterObject;
	query.username = this.cookie("username");
	query.sessionid = this.cookie("sessionid");
	query.mode = "addStageParameter";
	//console.log("Agua.StageParameteraddStageParameter     query: " + dojo.toJson(query));

	this.doPut({ url: url, query: query, timeout : 15000 });

	// RETURN TRUE OR FALSE
	return result;
},
_removeStageParameter : function (stageParameterObject) {
// REMOVE A stage PARAMETER OBJECT FROM THE stageparameters ARRAY,
// IDENTIFY OBJECT USING UNIQUE KEYS
	////console.log("Agua.StageParameter_removeStageParameter    plugins.core.Data._removeStageParameter(stageParameterObject)");
	////console.log("Agua.StageParameter_removeStageParameter    stageParameterObject: " + dojo.toJson(stageParameterObject));

	var uniqueKeys = ["project", "workflow", "appname", "appnumber", "name", "paramtype"];
	return this.removeData("stageparameters", stageParameterObject, uniqueKeys);
},
getStageParameters : function (stageObject) {
// RETURN AN ARRAY OF STAGE PARAMETER HASHARRAYS FOR THE GIVEN STAGE
	//console.log("Agua.StageParametergetStageParameters    plugins.core.Data.getStageParameters(stageObject)");
	//console.log("Agua.StageParametergetStageParameters    stageObject: " + dojo.toJson(stageObject));
	if ( stageObject == null )	return;
	
	var keys = ["project", "workflow", "name", "number"];
	var notDefined = this.notDefined (stageObject, keys);
	//console.log("Agua.StageParametergetStageParameters    notDefined: " + dojo.toJson(notDefined));
	if ( notDefined.length != 0 )
	{
		console.log("Agua.StageParametergetStageParameters    not defined: " + dojo.toJson(notDefined));
		return;
	}
	
	// CONVERT STAGE number TO appnumber
	stageObject.appnumber = stageObject.number;
	stageObject.appname = stageObject.name;

	var stageParameters = this._getStageParameters();
	//console.log("Agua.StageParametergetStageParameters    INITIAL stageParameters.length: " + stageParameters.length);	
	var keyArray = ["project", "workflow", "appname", "appnumber"];
	var valueArray = [stageObject.project, stageObject.workflow, stageObject.name, stageObject.number];
	stageParameters = this.filterByKeyValues(stageParameters, keyArray, valueArray);
	//console.log("Agua.StageParametergetStageParameters    Returning stageParameters.length: " + stageParameters.length);	

	return stageParameters;
},
_getStageParameters : function () {
    return this.cloneData("stageparameters");
},
addStageParametersForStage : function (stageObject) {
// ADD parameters ENTRIES FOR A STAGE TO stageparameters
	//console.log("Agua.StageParameteraddStageParametersForStage    plugins.core.Data.addStageParametersForStage(stageObject)");
	//console.log("Agua.StageParameteraddStageParametersForStage    stageObject: " + dojo.toJson(stageObject));
	if ( stageObject.name == null )	return null;
	if ( stageObject.number == null )	return null;

	// GET APP PARAMETERS	
	var parameters;
	//console.log("Agua.StageParameteraddStageParametersForStage    this.cookie("username"): " + this.cookie("username"));
	if ( stageObject.owner == this.cookie("username") )
	{
		//console.log("Agua.StageParameteraddStageParametersForStage    Doing this.getParametersByAppname(stageObject.name)");
		parameters = dojo.clone(this.getParametersByAppname(stageObject.name));
	}
	else {
		//console.log("Agua.StageParameteraddStageParametersForStage    Doing this.getSHAREDParametersByAppname(stageObject.name)");
		parameters = dojo.clone(this.getSharedParametersByAppname(stageObject.name, stageObject.owner));
	}
	//console.log("Agua.StageParameteraddStageParametersForStage    parameters.length: " + parameters.length);	
	//console.log("Agua.StageParameteraddStageParametersForStage    BEFORE parameters: " + dojo.toJson(parameters, true));

	// ADD STAGE project, workflow, AND number TO PARAMETERS
	dojo.forEach(parameters, function(parameter)
	{
		parameter.project = stageObject.project;
		parameter.workflow = stageObject.workflow;
		parameter.appnumber = stageObject.number;
		parameter.appname = stageObject.name;
	});
	//console.log("Agua.StageParameteraddStageParametersForStage    AFTER parameters: " + dojo.toJson(parameters));
	//console.log("Agua.StageParameteraddStageParametersForStage    parameters.length: " + parameters.length);

	var stageParameters = Agua.cloneData("stageparameters");
	//console.log("Agua.StageParameteraddStageParametersForStage    stageParameters.length: " + stageParameters.length);


	// ADD PARAMETERS TO stageparameters ARRAY
	var uniqueKeys = ["owner", "project", "workflow", "appname", "appnumber", "name", "paramtype"];
	var addOk = true;
	var thisObject = this;
	dojo.forEach(parameters, function(parameter)
	{
		//console.log("Agua.StageParameteraddStageParametersForStage    Adding parameter: " + dojo.toJson(parameter));

		if ( thisObject.addData("stageparameters", parameter, uniqueKeys) == false)
		{
			addOk = false;
		}

		stageParameters = Agua.cloneData("stageparameters");
		//console.log("Agua.StageParameteraddStageParametersForStage    stageParameters.length: " + stageParameters.length);

	});
	//console.log("Agua.StageParameteraddStageParametersForStage    addOk: " + addOk);
	if ( ! addOk )
	{
		//console.log("Agua.StageParameteraddStageParametersForStage    Could not add one or more parameters to stageparameters");
		return;
	}

	return addOk;
},
removeStageParameters : function (stageObject) {
// REMOVE STAGE PARAMETERS FOR A STAGE FROM stageparameters 
	//console.log("Agua.StageParameterremoveStageParameters    plugins.core.Data.removeStageParameters(stageObject)");
	//console.log("Agua.StageParameterremoveStageParameters    stageObject: " + dojo.toJson(stageObject, true));

	if ( stageObject.name == null )
	{
		console.log("Agua.StageParameterremoveStageParameters    stageObject.name is null. Returning.");
		return null;
	}
	if ( stageObject.number == null )
	{
		console.log("Agua.StageParameterremoveStageParameters    stageObject.number is null. Returning.");
		return null;
	}

	// GET STAGE PARAMETERS BELONGING TO THIS STAGE
	var keys = [ "owner", "project", "workflow", "appname", "appnumber" ];
	var values = [ stageObject.owner, stageObject.project, stageObject.workflow, stageObject.name, stageObject.number ];
	var removeTheseStageParameters = this.filterByKeyValues(this._getStageParameters(), keys, values);
	//console.log("Agua.StageParameterremoveStageParameters    removeTheseStageParameters.length: " + removeTheseStageParameters.length);

	// REMOVE PARAMETERS FROM stageparameters
	var uniqueKeys = [ "project", "workflow", "appname", "appnumber", "name"];
	var removeOk = this.removeArrayFromData("stageparameters", removeTheseStageParameters, uniqueKeys);
	console.log("Agua.StageParameterremoveStageParameters    removeOk: " + removeOk);
	if ( removeOk == false )
	{
		console.log("Agua.StageParameterremoveStageParameters    Could not remove one or more parameters from stageparameters");
		return false;
	}

	return true;
},
getStageParametersByApp : function (appname) {
// RETURN AN ARRAY OF PARAMETER HASHARRAYS FOR THE GIVEN APPLICATION
	//console.log("Agua.StageParametergetStageParametersByApp    plugins.core.Data.getStageParametersByApp(appname)");
	//console.log("Agua.StageParametergetStageParametersByApp    appname: " + appname);

	var stageParameters = new Array;
	dojo.forEach(this.getStageParameters(), function(stageparameter)
	{
		if ( stageparameter.appname == appname )	stageParameters.push(stageparameter);
	});
	
	//console.log("Agua.StageParametergetStageParametersByApp    Returning stageParameters: " + dojo.toJson(stageParameters));

	return stageParameters;
}

});

}

if(!dojo._hasResource["plugins.core.Agua.User"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.core.Agua.User"] = true;
dojo.provide("plugins.core.Agua.User");

/* SUMMARY: THIS CLASS IS INHERITED BY Agua.js AND CONTAINS 
	
	USER METHODS  
*/

dojo.declare( "plugins.core.Agua.User",	[  ], {

/////}}}

getUser : function (username) {
// RETURN ENTRY FOR username IN users
	console.log("Agua.User.getUser    plugins.core.Data.getUser(username)");
	console.log("Agua.User.getUser    username: " + username);
	var users = this.getUsers();
	console.log("Agua.User.getUser    users: " + dojo.toJson(users));
	var index = this._getIndexInArray(users, {"username":username}, ["username"]);
	console.log("Agua.User.getUser    index: " + index);
	if ( index != null )
	{
		return users[index];
	}
	
	return null;
},
getUsers : function () {
// RETURN A SORTED COPY OF users
	console.log("Agua.User.getUsers    plugins.core.Data.getUsers(userObject)");
	this.sortData("users", "username");
	return this.cloneData("users");
},
addUser : function (userObject) {
	console.log("Agua.User.addUser    plugins.core.Data.addUser(userObject)");
	//console.log("Agua.User.addUser    userObject: " + dojo.toJson(userObject));

	this._removeUser(userObject);
	if ( ! Agua._addUser(userObject) )	return;
	
	// CREATE JSON QUERY
	var url = Agua.cgiUrl + "workflow.cgi?";
	var query = new Object;
	query.username = this.cookie("username");
	query.sessionid = this.cookie("sessionid");
	query.mode = "addUser";
	query.data = userObject;
	console.log("query: ");
	console.dir(query);
	console.log("Users.saveUser    query: " + dojo.toJson(query));

	this.doPut({ url: url, query: query, sync: false });
},
_addUser : function (userObject) {
// ADD A USER OBJECT TO THE users ARRAY
	console.log("Agua.User._addUser    plugins.core.Data._addUser(userObject)");
	//console.log("Agua.User._addUser    userObject: " + dojo.toJson(userObject));
	if ( ! this.addData("users", userObject, ["username"]) )	return false;
	this.sortData("users", "username");
	
	return true;
},
isUser : function (userObject) {
// ADD A USER OBJECT TO THE users ARRAY
	//console.log("Agua.User.isUser    plugins.core.Data.isUser(userObject)");
	//console.log("Agua.User.isUser    userObject: " + dojo.toJson(userObject));
	var users = this.getUsers();
	if ( this._getIndexInArray(users, userObject, ["username"]) )	return true;
	
	return false;
},
removeUser : function (userObject) {
	console.log("Agua.User.removeUser    plugins.core.Data.removeUser(userObject)");
	//console.log("Agua.User.removeUser    userObject: " + dojo.toJson(userObject));

	// REMOVING SOURCE FROM Agua.users
	if ( ! this._removeUser(userObject) )	return;

	// CREATE JSON QUERY
	var url = Agua.cgiUrl + "sharing.cgi?";
	var query = new Object;
	query.username = this.cookie("username");
	query.sessionid = this.cookie("sessionid");
	query.mode = "removeUser";
	query.data = userObject;
	////console.log("Users.deleteItem    query: " + dojo.toJson(query));

	this.doPut({ url: url, query: query, sync: false });	
},
_removeUser : function (userObject) {
// REMOVE A USER OBJECT FROM THE users ARRAY
	console.log("Agua.User._removeUser    plugins.core.Data._removeUser(userObject)");
	//console.log("Agua.User._removeUser    userObject: " + dojo.toJson(userObject));

	// MOTHBALLED TWO-D ARRAYS
	//// ARRAY FORMAT:
	//// userArray[0]: ["aabate","a","abate","aabate@med.miami.edu",""]
	//var userArray = new Array;
	//userArray[0] = userObject.username;
	//userArray[1] = userObject.firstname || "";
	//userArray[2] = userObject.lastname || "";
	//userArray[3] = userObject.email || "";
	//
	//// DELETED USER MUST HAVE username
	if ( ! this.removeData("users", userObject, ["username"]) ) return false;

	// REMOVE USER FROM groupmember TABLE
	this._removeUserFromGroups(userObject);

	return true;
},
_removeUserFromGroups : function (userObject) {
// REMOVE USER FROM ALL GROUPS CREATED BY THIS (ADMIN) USER

	console.log("Agua.User._removeUserFromGroups    plugins.core.Data._removeUserFromGroups");
	userObject.type = "user";
	userObject.name = userObject.username;
	return this._removeObjectsFromData("groupmembers", userObject, ["name", "type"]);
},
isGroupUser : function (groupName, userObject) {
// RETURN true IF A USER ALREADY BELONGS TO A GROUP

	//console.log("Agua.User.isGroupUser    plugins.core.Data.isGroupUser(groupName, userObject)");
	//console.log("Agua.User.isGroupUser    groupName: " + groupName);
	//console.log("Agua.User.isGroupUser    userObject: " + dojo.toJson(userObject));
	
	var groupUsers = this.getGroupUsers();
	if ( groupUsers == null )	return false;
	//console.log("Agua.User.isGroupUser    groupUsers: " + dojo.toJson(groupUsers));

	groupUsers = this.filterByKeyValues(groupUsers, ["groupname"], [groupName]);
	//console.log("Agua.User.isGroupUser    AFTER filter groupUsers: " + dojo.toJson(groupUsers));
	
	return this._objectInArray(groupUsers, userObject, ["name"]);
},
addUserToGroup : function (groupName, userObject) {
// ADD A USER OBJECT TO A GROUP ARRAY IF IT DOESN"T EXIST THERE ALREADY 
	//console.log("Agua.User.addUserToGroup     Agua.addUserToGroup(groupName, userObject)");
	//console.log("Agua.User.addUserToGroup     groupName: " + groupName);
	//console.log("Agua.User.addUserToGroup     userObject: " + dojo.toJson(userObject));
	
	if ( this.isGroupUser(groupName, userObject) == true )
	{
		//console.log("Agua.User.addUserToGroup     user already exists in group: " + userObject.name + ". Returning.");
		return false;
	}

	var groups = this.getGroups();
	var group = this._getObjectByKeyValue(groups, "groupname", groupName);
	if ( group == null )	return false;
	
	userObject.username = group.username;
	userObject.groupname = groupName;
	userObject.groupdesc = group.description;
	userObject.type = "user";

	var requiredKeys = [ "username", "groupname", "name", "type"];
	return this.addData("groupmembers", userObject, requiredKeys);
},
removeUserFromGroup : function (groupName, userObject) {
// REMOVE A USER FROM A GROUP, IDENTIFY USER OBJECT BY "name" KEY VALUE
	//console.log("Agua.User.removeUserFromGroup    plugins.core.Data.addUserToGroup");
	var groups = this.getGroups();
	//console.log("Agua.User.removeUserFromGroup    groups: " + groups);
	var group = this._getObjectByKeyValue(groups, "groupname", groupName);
	if ( group == null )	return false;
	//console.log("Agua.User.removeUserFromGroup    group: " + dojo.toJson(group));

	userObject.owner = group.username;
	userObject.groupname = groupName;
	userObject.groupdesc = group.description;
	userObject.type = "user";

	var requiredKeys = [ "username", "groupname", "name", "type"];
	return this.removeData("groupmembers", userObject, requiredKeys);
}

});

}

if(!dojo._hasResource["plugins.core.Agua.View"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.core.Agua.View"] = true;
dojo.provide("plugins.core.Agua.View");

/* SUMMARY: THIS CLASS IS INHERITED BY Agua.js AND CONTAINS 
	
	VIEW METHODS  
*/

dojo.declare( "plugins.core.Agua.View",	[  ], {

/////}}}}
getViewObject : function (projectName, viewName) {
// RETURN AN ARRAY OF VIEW HASHES FOR THE SPECIFIED PROJECT AND WORKFLOW
	//console.log("Agua.View.getViewObject    plugins.core.Data.getViewObject(projectName, viewName)");
	//console.log("Agua.View.getViewObject    projectName: " + projectName);
	//console.log("Agua.View.getViewObject    viewName: " + viewName);

	var views = this.getViews();
	//console.log("Agua.View.getViewObject    views: " + dojo.toJson(views, true));
	if ( views == null )	return [];
	var keyArray = ["project", "view"];
	var valueArray = [projectName, viewName];
	var views = this.filterByKeyValues(views, keyArray, valueArray);
	//console.log("Agua.View.getViewObject    AFTER Agua.getViewObject");
	//console.dir({views:Agua.data.views})

	if ( views == null || views.length == 0 )	return null;
	return views[0];
},
getViews : function () {
// RETURN A COPY OF THE views ARRAY
	//console.log("Agua.View.getViews    plugins.core.Data.getViews()");	
	return this.cloneData("views");
},
getPreviousView : function (viewObject) {
	//console.log("Agua.View.getPreviousView    viewObject XXX: ");
	//console.dir({viewObject:viewObject});	

	var views = this.getViews();
	if ( ! views || views.length == 0 ) {
		//console.log("Agua.View.getPreviousView    views is null or empty. Returning");
		return;
	}

	var viewsCopy = dojo.clone(views);
	var projectViews = this.filterByKeyValues(viewsCopy, ["project"], [viewObject.project]);
	//console.log("Agua.View.getPreviousView    projectViews: ");
	//console.dir({projectViews:projectViews});	

	// GET PREVIOUS OR NEXT PROJECT IF NO VIEWS LEFT IN PROJECT
	if ( ! projectViews || projectViews.length == 0 ) {
	
		// ADD VIEW OBJECT BACK TO VIEWS AND SORT BY PROJECT
		views.push(viewObject);
		var thisObject = this;
		views.sort(
			function(a,b) {
				return thisObject.sortObjectsNaturally(a, b, "project");
			}
		);
		
		var projectNames = this.hashArrayKeyToArray(dojo.clone(views), "project");
		projectNames = this.uniqueValues(projectNames);
		if ( projectNames.length == 1 ) {
			//console.log("Agua.View.getPreviousView    projectNames.length == 1. Returning");
			return;
		}
		//console.log("Agua.View.getPreviousView    projectNames: ");
		//console.dir({projectNames:projectNames});
		
		var index = this._getIndex(projectNames, viewObject.project);
		//console.log("Agua.View.getPreviousView    index: " + index);
		
		var previousProject;
		if ( index == 0 )	{
			previousProject = projectNames[1];
			//console.log("Agua.View.getPreviousView    previousProject: " + previousProject);
			var projectViews = this.filterByKeyValues(views, ["project"], [previousProject]);

			projectViews.sort(
				function(a,b) {
					return thisObject.sortObjectsNaturally(a, b, "view");
				}
			);
			//console.log("Agua.View.getPreviousView    FINAL projectViews: ");
			//console.dir({projectViews:projectViews});
			//console.log("Agua.View.getPreviousView    RETURNING projectViews[0]");
		
			
			return projectViews[0];
		}
		else {
			previousProject = projectNames[index - 1];
			//console.log("Agua.View.getPreviousView    previousProject: " + previousProject);
			var projectViews = this.filterByKeyValues(views, ["project"], [previousProject]);
			projectViews.sort(
				function(a,b) {
					return thisObject.sortObjectsNaturally(a, b, "view");
				}
			);
			//console.log("Agua.View.getPreviousView    FINAL projectViews: ");
			//console.dir({projectViews:projectViews});
			//console.log("Agua.View.getPreviousView    RETURNING projectViews[(projectViews.length - 1)]");
		
			return projectViews[(projectViews.length - 1)];
		}		
	}
	else {
		// ADD VIEW OBJECT BACK TO VIEWS AND SORT
		views.push(viewObject);
		var thisObject = this;
		views.sort(
			function(a,b) {
				return thisObject.sortObjectsNaturally(a, b, "view");
			}
		);

		var index = this._getIndexInArray(views, viewObject, ["project", "view"]);
		//console.log("Agua.View.getPreviousView    index: " + index);
		
		if ( index == 0 )	return views[1];
		else return views[index - 1];
	}
},
removeView : function (viewObject) {
// REMOVE A VIEW OBJECT FROM THE views ARRAY
	//console.log("Agua.View.removeView    viewObject: " + dojo.toJson(viewObject));

	// REMOVE VIEW FROM views
	this._removeView(viewObject);
	
	// REMOVE ANY EXISTING FEATURES
	this._removeViewFeatures(viewObject);
	
	return true;
},
_removeView : function (viewObject) {
// REMOVE A VIEW OBJECT FROM THE views ARRAY
	console.log("Agua.View._removeView    viewObject: " + dojo.toJson(viewObject));

	// REMOVE VIEW FROM views
	var requiredKeys = ["project", "view"];
	if ( ! this.removeData("views", viewObject, requiredKeys) ) {
		console.log("Agua.View.removeView    Could not remove view from views table: " + viewObject.name);
		return false;
	}

	return true;
},
_removeViewFeatures : function (viewObject) {
// REMOVE A VIEW OBJECT FROM THE views ARRAY
	//console.log("Agua.View.removeView    viewObject: " + dojo.toJson(viewObject));

	// REMOVE ANY EXISTING FEATURES
	var requiredKeys = ["project", "view"];
	this.removeObjectsFromData("viewfeatures", viewObject, requiredKeys);
	
	return true;	
},
isView : function (projectName, viewName) {
// RETURN true IF A VIEW EXISTS FOR THE PARTICULAR PROJECT AND WORKFLOW
	//console.log("Agua.View.isView    projectName: *" + projectName + "*");
	//console.log("Agua.View.isView    viewName: *" + viewName + "*");
	
	var viewObjects = this.getViewsByProject(projectName);
	//console.log("Agua.View.isView    viewObjects: ");
	//console.dir({viewObjects:viewObjects});
	
	for ( var i in viewObjects )
	{
		var viewObject = viewObjects[i];
		if ( viewObject.view.toLowerCase() == viewName.toLowerCase() )
		{
			console.log("Agua.View.isView    Match found for view: *" + viewObject.view + "*");
			return true;
		}
	}
	
	return false;
},
_addView : function (viewObject) {
// ADD A VIEW TO views AND SAVE ON REMOTE SERVER
	//console.log("Agua.View.addView    plugins.core.Data._addView(viewObject)");
	//console.log("Agua.View.addView    viewObject: " + dojo.toJson(viewObject));

	// DO THE ADD
	var requiredKeys = ["project", "view"];
	return this.addData("views", viewObject, requiredKeys);
},
getViewNames : function (projectName) {
// RETURN AN ARRAY OF ALL VIEW NAMES IN views
	//console.log("Agua.View.viewNames    projectName: " + projectName);

	var views = this.getViewsByProject(projectName);
	//console.log("Agua.View.viewNames views: ");
	//console.dir({views:views});

	return this.hashArrayKeyToArray(views, "view");
},
getViewsByProject : function (projectName) {
// RETURN AN ARRAY OF VIEW HASHES FOR THE SPECIFIED PROJECT AND WORKFLOW
	//console.log("Agua.View.getViewsByProject    projectName: " + projectName);
	var views = this.getViews();
	if ( views == null )	return [];

	var keyArray = ["project"];
	var valueArray = [projectName];
	var views = this.filterByKeyValues(views, keyArray, valueArray);
	//console.log("Agua.View.getViewsByProject    AFTER FILTER views: " + dojo.toJson(views));

	return views;
},
getViewSpecies : function (projectName, viewName) {
// GET THE UNIQUE SPECIES (AND BUILD) FOR A GIVEN VIEW
	////console.log("Agua.View.getViewSpecies     plugins.core.Data.getViewSpecies(projectName, viewName)");
	////console.log("Agua.View.getViewSpecies    projectName: " + projectName);
	////console.log("Agua.View.getViewSpecies    viewName: " + viewName);
	if ( projectName == null || ! projectName )
	{
		//console.log("Agua.View.getViewSpecies     projectName is null or empty. Returning");
		return;
	}

	var viewfeatures = this.getViewFeatures(projectName, viewName);
	if ( viewfeatures == null || viewfeatures.length == 0 )	return new Array;

	var speciesHash = new Object;
	speciesHash.species = viewfeatures[0].species;
	speciesHash.build = viewfeatures[0].build;

	return speciesHash;
},
getViewProjects : function () {
	//console.log("Agua.View.getViewProjects     plugins.core.Data.getViewProjects()");
	//console.log("Agua.View.getViewProjects     CAUTION -- ONLY PROJECTS WITH FEATURES");
	var viewfeatures = this.cloneData("viewfeatures");
	var projects = this.hashArrayKeyToArray(viewfeatures, "project");
	projects = this.uniqueValues(projects);
	
	return projects;
},
getSpeciesBuilds : function () {
// GET THE UNIQUE SPECIES/BUILD COMBINATIONS FOR ALL FEATURES
	//console.log("Agua.View.getSpeciesBuilds     plugins.core.Data.getSpeciesBuilds()");
	var features = this.cloneData("features");
	var speciesBuilds = new Array;
	for ( var i = 1; i < features.length; i++ )
	{
		speciesBuilds.push(	features[i].species + "(" + features[i].build + ")");
	}
	speciesBuilds = this.uniqueValues(speciesBuilds);
	//console.log("Agua.View.getSpeciesBuilds     speciesBuilds: " + dojo.toJson(speciesBuilds));
	
	return speciesBuilds;
},
getSpecies : function (projectName, viewName) {
	//console.log("Agua.View.getSpecies     plugins.core.Data.getSpecies(projectName, viewName)");
	//console.log("Agua.View.getSpecies     projectName: " + projectName);
	//console.log("Agua.View.getSpecies     viewName: " + viewName);
	var views = this.cloneData("views");
	views = this.filterByKeyValues(views, ["project", "view"], [projectName, viewName]);
	//console.log("Agua.View.getSpeciesBuilds     views: " + dojo.toJson(views));
	
	if ( views == null || views.length == 0 )	return;
	return views[0].species;
},
getBuild : function (projectName, viewName) {
	//console.log("Agua.View.getBuild     plugins.core.Data.getBuild(projectName, viewName)");
	//console.log("Agua.View.getBuild     projectName: " + projectName);
	//console.log("Agua.View.getBuild     viewName: " + viewName);
	var views = this.cloneData("views");	
	views = this.filterByKeyValues(views, ["project", "view"], [projectName, viewName]);
	//console.log("Agua.View.getBuildBuilds     views: " + dojo.toJson(views));
	
	if ( views == null || views.length == 0 )	return;
	return views[0].build;
}

});

}

if(!dojo._hasResource["plugins.core.Agua.Workflow"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.core.Agua.Workflow"] = true;
dojo.provide("plugins.core.Agua.Workflow");

/* SUMMARY: THIS CLASS IS INHERITED BY Agua.js AND CONTAINS 
	
	WORKFLOW METHODS  
*/

dojo.declare( "plugins.core.Agua.Workflow",	[  ], {

/////}}}

// 	WORKFLOW METHODS
getWorkflows : function () {
// RETURN A SORTED COPY OF workflows
	//console.log("Agua.Workflow.getWorkflows    plugins.core.Data.getWorkflows(workflowObject)");
	var workflows = this.cloneData("workflows");
	return this.sortHasharray(workflows, "name");
},
getWorkflowNamesByProject : function (projectName) {
// RETURN AN ARRAY OF NAMES OF WORKFLOWS IN THE SPECIFIED PROJECT
	//console.log("Agua.Workflow.getWorkflowNamesByProject    plugins.core.Data.getWorkflowNamesByProject(projectName)");
	//console.log("Agua.Workflow.getWorkflowNamesByProject    projectName: " + projectName);
	var workflows = this.getWorkflowsByProject(projectName);
	//console.log("Agua.Workflow.getWorkflowNamesByProject    workflows: " + dojo.toJson(workflows));

	// ORDER BY WORKFLOW NUMBER -- NB: REMOVES ENTRIES WITH NO WORKFLOW NUMBER
	workflows = this.sortNumericHasharray(workflows, "number");	

	return this.hashArrayKeyToArray(workflows, "name");
},
getWorkflowsByProject : function (projectName) {
// RETURN AN ARRAY OF WORKFLOWS IN THE SPECIFIED PROJECT
	//console.log("Agua.Workflow.getWorkflowsByProject    plugins.core.Data.getWorkflowsByProject(projectName)");
	//console.log("Agua.Workflow.getWorkflowsByProject    projectName: " + projectName);
	var workflows = this.cloneData("workflows");
	return this.filterByKeyValues(workflows, ["project"], [projectName]);
},
getWorkflow : function (workflowObject) {
// RETURN FULL workflow OBJECT IF WORKFLOW IN PROJECT
	console.log("Agua.Workflow.getWorkflow     plugins.core.Data.getWorkflow(workflowObject)");
	console.log("Agua.Workflow.getWorkflow     workflowObject: ");
	console.dir({workflowObject:workflowObject});
	
	var object = this._getWorkflow(workflowObject);
	if ( ! object )
	{
		console.log("Agua.Workflow.getWorkflow     No workflowObject.name " + workflowObject.name + " found. Returning");
		return null;
	}
	console.log("Agua.Workflow.getWorkflow     object.name: " + object.name);
	console.log("Agua.Workflow.getWorkflow     object: ");
	console.dir({object:object});

	return object;
},
_getWorkflow : function (workflowObject) {
// RETURN WORKFLOW IN workflows IDENTIFIED BY PROJECT AND WORKFLOW NAMES
	console.log("Agua.Workflow._getWorkflow     plugins.core.Data._getWorkflow(workflowObject)");
	console.log("Agua.Workflow._getWorkflow     workflowObject: " + dojo.toJson(workflowObject));
	
	if ( ! this.isProject(workflowObject.project) )
	{
		console.log("Agua.Workflow._getWorkflow     No project found in workflowObject. Returning false.");
		return false;
	}
	
	// GET ALL WORKFLOWS
	var workflows = this.getWorkflows();
	//console.log("Agua.Workflow._getWorkflow     workflows: " + dojo.toJson(workflows));		
	if ( workflows == null ) 
	{
		console.log("Agua.Workflow._getWorkflow     workflows is null. Returning false.");
		return false;
	}
	
	// CHECK FOR OUR PROJECT AND WORKFLOW NAME AMONG WORKFLOWS
	var keyArray = ["project", "name"];
	var valueArray = [ workflowObject.project, workflowObject.name ];
	var workflows = this.filterByKeyValues(workflows, keyArray, valueArray);
	
	if ( ! workflows || workflows.length == 0 )	return;

	return workflows[0];
},
isWorkflow : function (workflowObject) {
// RETURN TRUE IF WORKFLOW NAME IS FOUND IN PROJECT IN workflows
	console.log("Agua.Workflow.isWorkflow     caller: " + this.isWorkflow.caller.nom);
	//console.log("Agua.Workflow.isWorkflow     workflowObject: ");
	//console.dir({workflowObject:workflowObject});
	var object = this._getWorkflow(workflowObject);
	if ( ! object ) {
		console.log("Agua.Workflow.isWorkflow     Returning false");
		return false;
	}
	
	console.log("Agua.Workflow.isWorkflow     Returning true");
	return true;		
},
getWorkflowNumber : function (projectName, workflowName) {
// WORKFLOW NUMBER GIVEN PROJECT AND WORKFLOW IN workflows
	//console.log("Agua.Workflow.getWorkflowNumber     plugins.core.Data.getWorkflowNumber(projectName, workflowName)");
	//console.log("Agua.Workflow.getWorkflowNumber     projectName: " + projectName);
	//console.log("Agua.Workflow.getWorkflowNumber     workflowName: " + workflowName);
	var workflowObject = this._getWorkflow({ project: projectName, name: workflowName });
	if ( ! workflowObject ) return null;
	console.log("Agua.Workflow.getWorkflowNumber    workflowObject:");
	console.dir({workflowObject:workflowObject});

	return workflowObject.number;
},
getMaxWorkflowNumber : function (projectName) {
// WORKFLOW NUMBER GIVEN PROJECT AND WORKFLOW IN workflows
	console.log("Agua.Workflow.getMaxWorkflowNumber     plugins.core.Data.getMaxWorkflowNumber(projectName)");
	console.log("Agua.Workflow.getMaxWorkflowNumber     projectName: " + projectName);
	
	var workflowObjects = this.getWorkflowsByProject(projectName);
	//console.log("Agua.Workflow.getMaxWorkflowNumber     workflowObject: " + dojo.toJson(workflowObjects));		
	if ( workflowObjects == null ) return null;
	if ( workflowObjects.length == 0 ) return null;

	console.log("Agua.Workflow.getMaxWorkflowNumber     Returning workflowObjects.length: " + workflowObjects.length);
	return workflowObjects.length;
},
moveWorkflow : function (workflowObject, newNumber) {
// MOVE A WORKFLOW WITHIN A PROJECT
	console.log("Agua.Workflow.moveWorkflow    workflowObject: " + dojo.toJson(workflowObject, true));	
	//console.log("Agua.Workflow.moveWorkflow    newNumber: " + newNumber);

	var oldNumber = workflowObject.number;
	if ( oldNumber == null )	return false;
	if ( oldNumber == newNumber )	return false;
	//console.log("Agua.Workflow.moveWorkflow    oldNumber: " + oldNumber);
	
	// GET ACTUAL WORKFLOWS DATA
	var workflows = this.getData("workflows");
	//console.log("Agua.Workflow.moveWorkflow     UNSORTED workflows: " + dojo.toJson(workflows));

	// ORDER BY WORKFLOW NUMBER -- NB: REMOVES ENTRIES WITH NO WORKFLOW NUMBER
	workflows = this.sortNumericHasharray(workflows, "number");	
	for ( var i = 0; i < workflows.length; i++ )
	{
		if ( workflows[i].project != projectName )	continue;
		counter++;
	}

	// DO RENUMBER
	var projectName = workflowObject.project;
	var counter = 0;
	for ( var i = 0; i < workflows.length; i++ )
	{
		if ( workflows[i].project != projectName )	continue;
		counter++;

		// SKIP IF BEFORE REORDERED WORKFLOWS
		if ( counter < oldNumber && counter < newNumber )
		{
			workflows[i].number = counter;
		}
		// IF WORKFLOW HAS BEEN MOVED DOWNWARDS, GIVE IT THE NEW INDEX
		// AND DECREMENT COUNTER FOR SUBSEQUENT WORKFLOWS
		else if ( oldNumber < newNumber ) {
			if ( counter == oldNumber ) {
				workflows[i].number = newNumber;
			}
			else if ( counter <= newNumber ) {
				workflows[i].number = counter - 1;
			}
			else {
				workflows[i].number = counter;
			}
		}
		// OTHERWISE, THE WORKFLOW HAS BEEN MOVED UPWARDS SO GIVE IT
		// THE NEW INDEX AND INCREMENT COUNTER FOR SUBSEQUENT WORKFLOWS
		else {
			if ( counter < oldNumber ) {
				workflows[i].number = counter + 1;
			}
			else if ( oldNumber == counter ) {
				workflows[i].number = newNumber;
			}
			else {
				workflows[i].number = counter;
			}
		}
	}
	
	var query = workflowObject;
	query.newnumber = newNumber;
	query.mode = "moveWorkflow";
	query.username = Agua.cookie("username");
	query.sessionid = Agua.cookie("sessionid");
	var url = Agua.cgiUrl + "workflow.cgi";
	this.doPut({ url: url, query: query, sync: false });
},
renumberWorkflows : function(projectName) {
	console.log("Agua.Workflow.renumberWorkflows     plugins.core.Data.renumberWorkflows(projectName)");
	console.log("Agua.Workflow.renumberWorkflows     projectName: " + projectName);
	var workflows = this.getWorkflowsByProject(projectName);
	console.log("Agua.Workflow.renumberWorkflows     workflows.length: " + workflows.length);

	this.printObjectKeys(workflows, "number", "UNSORTED workflows");
	console.log("Agua.Workflow.renumberWorkflows     workflows.length: " + workflows.length);
	this.printObjectKeys(workflows, "name", "UNSORTED workflows");
	console.log("Agua.Workflow.renumberWorkflows     workflows.length: " + workflows.length);

	workflows = this.sortHasharrayByKeys(workflows, ["number"]);
	console.log("Agua.Workflow.renumberWorkflows     workflows.length: " + workflows.length);		

	this.printObjectKeys(workflows, "number", "SORTED workflows");
	console.log("Agua.Workflow.renumberWorkflows     workflows.length: " + workflows.length);
	this.printObjectKeys(workflows, "name", "SORTED workflows");
	console.log("Agua.Workflow.renumberWorkflows     workflows.length: " + workflows.length);

	// DO RENUMBER
	console.log("Agua.Workflow.renumberWorkflows     RENUMBERING workflows");
	var number = 0;
	for ( var i = 0; i < workflows.length; i++ )
	{
		console.log("Agua.Workflow.renumberWorkflows     REMOVING workflow [" + i + "].number: " + workflows[i].number);
		this._removeWorkflow(workflows[i]);
		number++;
		workflows[i].number = number;
		console.log("Agua.Workflow.renumberWorkflows     ADDING workflows [" + i + "].number: " + workflows[i].number);
		this._addWorkflow(workflows[i]);
	}

	workflows = this.getWorkflowsByProject(projectName);
	console.log("Agua.Workflow.renumberWorkflows     BEFORE FILTER workflows.length: " + workflows.length);
	workflows = this.filterByKeyValues(workflows, ["project"], [projectName]);
	console.log("Agua.Workflow.renumberWorkflows     AFTER FILTER workflows.length: " + workflows.length);

},
addWorkflow : function (workflowObject) {
// ADD AN EMPTY NEW WORKFLOW OBJECT TO A PROJECT OBJECT
	console.log("Agua.Workflow.addWorkflow    plugins.workflow.Agua.addWorkflow(workflowObject)");
	console.log("Agua.Workflow.addWorkflow    workflowObject: " + dojo.toJson(workflowObject));
	
	var projectName = workflowObject.project;
	var workflowName = workflowObject.name;
	if ( this.isWorkflow(workflowObject)== true )
	{
		console.log("Agua.Workflow.addWorkflow    Workflow '" + workflowName + "' already exists in project '" + projectName + "'. Returning.");
		return;
	}

    // SET THE WORKFLOW NUMBER
	var maxNumber = this.getMaxWorkflowNumber(projectName);
    console.log("Agua.Workflow.addWorkflow    maxNumber: " + maxNumber);

	var number;
	if ( maxNumber == null )
		number = 1;
	else
		number = maxNumber + 1;
	workflowObject.number = number;
    console.log("Agua.Workflow.addWorkflow    workflowObject.number: " + workflowObject.number);

	var added = this._addWorkflow(workflowObject);
	if ( added == false )
	{
		console.log("Agua.Workflow.addWorkflow    Could not add workflow " + workflowName + " to workflows");
		return;
	}
	
	// COMMIT CHANGES IN REMOTE DATABASE
	var url = Agua.cgiUrl + "workflow.cgi";
	var query = new Object;
	query.project = projectName;
	query.name = workflowName;
	query.number = number;
	query.username = this.cookie("username");
	query.sessionid = this.cookie("sessionid");
	query.mode = "addWorkflow";
	console.log("Agua.Workflow.addWorkflow    query: " + dojo.toJson(query, true));

	this.doPut({ url: url, query: query, sync: false });
},
_addWorkflow : function(workflowObject) {
	var keys = ["project", "name", "number"];
	var added = this.addData("workflows", workflowObject, keys);
},
removeWorkflow : function (workflowObject) {
// REMOVE A WORKFLOW FROM workflows, stages AND stageparameters

	console.log("Agua.Workflow.removeWorkflow    caller: " + this.removeWorkflow.caller.nom);
	console.log("Agua.Workflow.removeWorkflow    workflowObject: " + dojo.toJson(workflowObject));

	// REMOVE WORKFLOW
	this._removeWorkflow(workflowObject);
	
	// RENUMBER WORKFLOWS
	this.renumberWorkflows(workflowObject.project);
	
	// COMMIT CHANGES IN REMOTE DATABASE
	var url 		= Agua.cgiUrl + "workflow.cgi";
	var query 		= new Object;
	query.project 	= workflowObject.project;
	query.name 		= workflowObject.name;
	query.number 	= workflowObject.number;
	query.username 	= this.cookie("username");
	query.sessionid = this.cookie("sessionid");
	query.mode 		= "removeWorkflow";
	console.log("Agua.Workflow.removeWorkflow    query: " + dojo.toJson(query, true));

	this.doPut({ url: url, query: query, sync: false });
},
_removeWorkflow : function(workflowObject) {
// REMOVE FROM workflows, stages, ETC.
	console.log("Agua.Workflow._removeWorkflow    BEFORE delete workflows.length: " + this.getWorkflows().length);

	var keys = ["project", "number", "name"];
	var result = this.removeData("workflows", workflowObject, keys);

	console.log("Agua.Workflow._removeWorkflow    delete result: " + result);
	console.log("Agua.Workflow._removeWorkflow    AFTER delete workflows.length: " + this.getWorkflows().length);
	
	// REMOVE FROM stages, stageparameters AND views
	workflowObject.workflow = workflowObject.name;
	keys = ["project", "workflow"];
	this.removeObjectsFromData("stages", workflowObject, keys);
	this.removeObjectsFromData("stageparameters", workflowObject, keys);

},
renameWorkflow : function (workflowObject, newName, callback, standby) {
// RENAME A WORKFLOW FROM workflows, stages AND stageparameters
	console.log("Agua.Workflow.renameWorkflow    plugins.core.Data.renameWorkflow(workflowObject, newName)");
	console.log("Agua.Workflow.renameWorkflow    workflowObject: " + dojo.toJson(workflowObject));
	console.log("Agua.Workflow.renameWorkflow    newName: " + newName);
	console.log("Agua.Workflow.renameWorkflow    callback: " + callback);

	if ( workflowObject.name == null )	return;
	if ( workflowObject.project == null )	return;
	if ( newName == null )	return;

	// COPY WORKFLOW DATA TO NEW WORKFLOW NAMES
	var username = this.cookie("username");
	var date = this.currentMysqlDate();
	this._copyWorkflow(workflowObject, username, workflowObject.project, newName, date, workflowObject.number);
	
	// DELETE OLD WORKFLOW
	this._removeWorkflow(workflowObject);

	// COMMIT CHANGES IN REMOTE DATABASE
	var url = Agua.cgiUrl + "workflow.cgi";
	var query = new Object;
	query.project = workflowObject.project;
	query.name = workflowObject.name;
	query.newname = newName;
	query.username = this.cookie("username");
	query.sessionid = this.cookie("sessionid");
	query.mode = "renameWorkflow";
	console.log("Agua.Workflow.renameWorkflow    query: " + dojo.toJson(query, true));

	this.doPut({ url: url, query: query, sync: false, callback: callback });
},
copyWorkflow : function (sourceUser, sourceProject, sourceWorkflow, targetUser, targetProject, targetWorkflow, copyFiles) {
// ADD AN EMPTY NEW WORKFLOW OBJECT TO A PROJECT OBJECT
	console.log("Agua.Workflow.copyWorkflow    plugins.workflow.Agua.copyWorkflow(sourceUser, sourceProject, sourceWorkflow, targetUser, targetProject, targetWorkflow)");
	console.log("Agua.Workflow.copyWorkflow    sourceUser: " + sourceUser);
	console.log("Agua.Workflow.copyWorkflow    sourceProject: " + sourceProject);
	console.log("Agua.Workflow.copyWorkflow    sourceWorkflow: " + sourceWorkflow);
	console.log("Agua.Workflow.copyWorkflow    targetUser: " + targetUser);
	console.log("Agua.Workflow.copyWorkflow    targetProject: " + targetProject);
	console.log("Agua.Workflow.copyWorkflow    targetWorkflow: " + targetWorkflow);
	console.log("Agua.Workflow.copyWorkflow    copyFiles: " + copyFiles);

	if ( this.isWorkflow({ project: targetProject, name: targetWorkflow })== true )
	{
		console.log("Agua.Workflow.copyWorkflow    Workflow " + targetWorkflow + " already exists in project " + targetProject + ". Returning FALSE.");
		return false;
	}

	var workflows = this.getSharedWorkflowsByProject(sourceUser, sourceProject);
	workflows = this.filterByKeyValues(workflows, ["name"], [sourceWorkflow]);
	if ( ! workflows || workflows.length == 0 ) {
		console.log("Agua.Workflow.copyWorkflow    Returning because workflows is not defined or empty");
		return;
	}
	var workflowObject = workflows[0];
	
	// ADD STAGES, STAGEPARAMETERS, REPORTS AND VIEWS	
	var date = this.currentMysqlDate();
	var success = this._copyWorkflow(workflowObject, targetUser, targetProject, targetWorkflow, date);
	if ( success == false )	{
		console.log("Agua.Workflow.copyWorkflow    Failed to copy workflow: " + dojo.toJson(workflowObject));
		return false;
	}	

	// SET PROVENANCE
	workflowObject = this.setProvenance(workflowObject, date);

	// COMMIT CHANGES TO REMOTE DATABASE
	var url = Agua.cgiUrl + "workflow.cgi";
	var query = new Object;
	query.sourceuser 		= sourceUser;
	query.targetuser 		= targetUser;
	query.sourceworkflow 	= sourceWorkflow;
	query.sourceproject 	= sourceProject;
	query.targetworkflow 	= targetWorkflow;
	query.targetproject 	= targetProject;
	query.copyfiles 		= copyFiles;
	query.date				= date;
	query.provenance 		= workflowObject.provenance;
	query.username 			= this.cookie("username");
	query.sessionid 		= this.cookie("sessionid");
	query.mode 				= "copyWorkflow";
	console.log("Agua.Workflow.copyWorkflow    query: " + dojo.toJson(query, true));

	this.doPut({ url: url, query: query, sync: false });

	return success;
},
_copyWorkflow : function (workflowObject, targetUser, targetProject, targetWorkflow, date, workflowNumber) {
// COPY WORKFLOW AND THEN ADD STAGES, STAGEPARAMETERS, REPORTS AND VIEWS	
	console.log("XXXXXXXXXXXX Data._copyWorkflow    Data._copyWorkflow(sourceUser, sourceProject, sourceWorkflow, targetUser, targetProject, targetWorkflow, copyFiles, workflowNumber)");
	console.log("Agua.Workflow._copyWorkflow    BEFORE workflowObject: " + dojo.toJson(workflowObject));
	console.dir({workflowObject:workflowObject});
	console.log("Agua.Workflow._copyWorkflow    BEFORE workflowObject.name: " + workflowObject.name);
	console.log("Agua.Workflow._copyWorkflow    targetUser: " + targetUser);
	console.log("Agua.Workflow._copyWorkflow    targetProject: " + targetProject);
	console.log("Agua.Workflow._copyWorkflow    targetWorkflow: " + targetWorkflow);
	console.log("Agua.Workflow._copyWorkflow    date: " + date);

	// GET SOURCE DATA
	var sourceUser = workflowObject.username;
	var sourceWorkflow = workflowObject.name;
	var sourceProject = workflowObject.project;
	console.log("Agua.Workflow._copyWorkflow    sourceWorkflow: " + sourceWorkflow);
	
	// SET PROVENANCE
	workflowObject = this.setProvenance(workflowObject, date);
	
	// SET TARGET DATA
	var maxNumber = this.getMaxWorkflowNumber(targetProject);
	var number;
	if ( workflowNumber ) {
		number = workflowNumber;
	}
	else {
		if ( ! maxNumber )
			number = 1;
		else
			number = maxNumber + 1;
	}
	
	var newObject = dojo.clone(workflowObject);
	newObject.name = targetWorkflow;
	newObject.project = targetProject;
	newObject.username = targetUser;
	newObject.number = number;
	console.log("Agua.Workflow._copyWorkflow    AFTER newObject: ");
	console.dir({newObject:newObject});
	console.dir({workflowObject:workflowObject});
	
	// COPY WORKFLOW
	var keys = ["project", "name", "number"];
	var copied = this.addData("workflows", newObject, keys);
	if ( copied == false ) {
		console.log("Agua.Workflow._copyWorkflow    Could not copy workflow to targetWorkflow: " + targetWorkflow);
		return false;
	}

	// COPY STAGES AND STAGE PARAMETERS
	var stages;
	if ( sourceUser != targetUser )
		stages = this.getSharedStagesByWorkflow(sourceUser, sourceProject, sourceWorkflow);
	else stages = this.getStagesByWorkflow(sourceProject, sourceWorkflow);
	console.log("Agua.Workflow._copyWorkflow    stages.length: " + stages.length);

	for ( var i = 0; i < stages.length; i++ )
	{
	 	console.log("Agua.Workflow._copyWorkflow    stages[" + i + "]: " + stages[i]);
		var newStage = dojo.clone(stages[i]);
		newStage.project = targetProject;
		newStage.workflow = targetWorkflow;
		
		this._addStage(newStage);

		// ADD STAGE PARAMETERS
		var stageparams;
		if ( sourceUser != targetUser )
			stageparams = this.getSharedStageParameters(stages[i]);
		else stageparams = this.getStageParameters(stages[i]);
		
		console.log("Agua.Workflow._copyWorkflow    stageparams.length: " + stageparams.length);
		var thisObject = this;
		var oldPath = sourceProject + "/" + sourceWorkflow;
		var newPath = targetProject + "/" + targetWorkflow;
		dojo.forEach(stageparams, function(stageparam, j){
			stageparams[j].project = targetProject;
			stageparams[j].workflow = targetWorkflow;
		
			// REPLACE FILE PATH WITH NEW Project/Workflow
			if ( stageparams[j].value != null
				&& stageparams[j].value.replace )
				stageparams[j].value = stageparams[j].value.replace(oldPath, newPath);
			
			thisObject._addStageParameter(stageparams[j]);
		})
	}

	// COPY VIEWS
	var views = this.getSharedViews({ username: sourceUser, project: sourceProject } );
    if ( views == null )
        views = [];
	//console.log("Agua.Workflow._copyWorkflow    view: " + dojo.toJson(views));
	for ( var i = 0; i < views.length; i++ )
	{
		this._addStage(views[i]);
	}

	//console.log("Agua.Workflow._copyWorkflow    views: " + dojo.toJson(views));
	return true;
},
getWorkflowSubmit : function (workflowObject) {
	if ( ! workflowObject )	return;

	var submit = 0;	
	var stages = this.getStagesByWorkflow(workflowObject.project, workflowObject.workflow);
	if ( ! stages )	return 1;
	
	for ( var i = 0; i < stages.length; i++ ) {
		if ( stages[i].submit == 1 )	return 1;
	}
	
	return 0;
},
// PROVENANCE METHODS
setProvenance : function (object, date) {
	var provenanceString = object.provenance;
	var provenance;
	if ( ! provenanceString )
		provenance = [];
	else
		provenance = dojo.fromJson(provenanceString);
	
	if ( ! date ) date = this.currentMysqlDate();
	var item = {
		copiedby : Agua.cookie("username"),
		original: dojo.clone(object),
		date: date
	};
	
	provenance.push(item);
	provenanceString = dojo.toJson(provenance);
	
	object.provenance = provenanceString;
	
	return object;
}

});

}

if(!dojo._hasResource["plugins.core.Plugin"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.core.Plugin"] = true;
dojo.provide("plugins.core.Plugin");

/**
 * PLUGIN FRAMEWORK, Version 0.1
 * Copyright (c) 2012 Stuart Young youngstuart@hotmail.com
 * This code is freely distributable under the terms of an MIT-style license.
 * 
 *  This code provides the following functions
 *
 *    Plugin.isInstalled(String name)           // RETURN Boolean PLUGIN INSTALL STATUS
 *    Plugin.getVersion(String name)            // RETURN PLUGIN VERSION
 *    Plugin.getDescription(String name)        // RETURN PLUGIN DESCRIPTION
 *    Plugin.getPluginPage(String name)         // RETURN PLUGIN URL
 *    Plugin.getInfo(String name)               // RETURN PLUGIN INFO (NAME, VERSION, DESCRIPTION, IS INSTALLED)
 *
 *        Boolean isInstalled
 *        String  version
 *        String  description
 *        String  pluginPage   URL to download the plugin
 *
 * CHANGELOG:
 * Sat 18th October 2008: Version 0.1
 *   load plugins
 *   load plugins
 *   added license
 * 
 * you may remove the comments section, but please leave the copyright
/*--------------------------------------------------------------------*/

// OBJECT:  Plugin
// PURPOSE: ATTEMPT TO LOAD A PLUGIN USING dojo.require AND STORE
//			WHETHER THE LOAD WAS SUCCESSFUL OR NOT AS installed=BOOLEAN

dojo.declare( "plugins.core.Plugin", null, {

installed : false,

////}}}}

setInstalled : function () {
	if ( this.installed != false && installed != true )
		return 0;
	this.installed = true;

	return 1;
},

getInstalled : function () {
	return this.installed;    
},

getVersion : function () {
	return this.version;
},

getDescription : function () {
	return this.description;
},

getPluginUrl : function () {
	return this.pluginUrl;
},

getInfo : function () {
	var info = '';
	info += 'Status: ';
	info += this.getInstalled();
	info += '\n';
	info += 'Version: ';
	info += this.version();
	info += '\n';
	info += 'Description: ';
	info += this.description();
	info += '\n';
	info += 'Plugin Url: ';
	info += this.pluginUrl();
	info += '\n';
	
	return info;
}

});    
    

}

if(!dojo._hasResource["plugins.core.PluginManager"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.core.PluginManager"] = true;
/**
 * CLASS  	PluginManager
 * Version 	0.01
 * PURPOSE 	MANAGE EXTERNAL PLUGINS ON TOP OF dojo FRAMEWORK
 * LICENCE 	Copyright (c) 2012 Stuart Young youngstuart@hotmail.com
 *          This code is freely distributable under the terms of an MIT-style license.
*/

dojo.provide("plugins.core.PluginManager");



// OBJECT:  PluginManager
// PURPOSE: LOAD ALL PLUGINS

dojo.declare( "plugins.core.PluginManager", null,
{
// HASH OF INSTALLED PLUGINS
_installedPlugins : {},
plugins : [],

parentWidget : null,

// PLUGINS TO BE LOADED
pluginsList : null,

// ARGUMENTS FOR PLUGINS TO BE LOADED
pluginsArgs : null,

////}}}}
	
constructor : function(args) {
	//console.log("PluginManager.constructor      plugins.core.PluginManager.constructor(args)");
	
	// SET INPUT PLUGINS LIST IF PROVIDED
	if ( args.pluginsList != null && args.pluginsList )
		this.pluginsList = args.pluginsList;

	// SET INPUT PLUGINS LIST IF PROVIDED
	if ( args.pluginsArgs != null && args.pluginsArgs )
		this.pluginsArgs = args.pluginsArgs;

	// SET PARENT WIDGET IF PROVIDED
	if ( args.parentWidget != null && args.parentWidget )
		this.parentWidget = args.parentWidget;
	
	// SAVE TO controllers
	Agua.controllers["core"] = Agua;

	// LOAD PLUGINS
	this.loadPlugins();
},
loadPlugins : function ()   {
	console.group("PluginManager.loadPlugins    this.pluginsList: ");
	console.dir({this_pluginsList:this.pluginsList});
	
	var length = this.pluginsList.length;
	if ( ! length )	return;
	var doubleLength = 2 * length;
	
	for ( var i = 0; i < this.pluginsList.length; i++ )
	{
		var number = parseInt( (i * 2) + 1);
		this.percentProgress(doubleLength, number);
		console.log("PluginManager.loadPlugins    ******* plugin number" + number);
	
		var pluginName = this.pluginsList[i];
		console.log("PluginManager.loadPlugins     this.pluginsList[" + i + "]:  " + pluginName);

		var moduleName = pluginName.match(/^plugins\.([^\.]+)\./)[1];
		//console.log("PluginManager.loadPlugins    moduleName: " + dojo.toJson(moduleName));
		//console.log("PluginManager.loadPlugins    pluginName: " + dojo.toJson(pluginName));
 
		// LOAD MODULE
		dojo["require"](pluginName);
		
		// INSTANTIATE WIDGET
		
		var args = "";
		if ( this.pluginsArgs && this.pluginsArgs[i] )
			args = this.pluginsArgs[i];
		console.log("PluginManager.loadPlugins    args: ");
		console.dir({args:args});
			
		var command= "new " + pluginName + "({ inputs: '" + args + "'})";
		console.log("PluginManager.loadPlugins    command: " + command);
		var newPlugin = eval (command);

		// SAVE TO controllers
		Agua.controllers[moduleName] = newPlugin;
		
		// DO postLoad IF PRESENT
		console.log("PluginManager.loadPlugins    DOING newPlugin.postLoad: " + newPlugin.postLoad);
		if ( newPlugin.postLoad )	newPlugin.postLoad();
	
		//// CHECK DEPENDENCIES
		var verified = this.checkDependencies(newPlugin.dependencies);
		//console.log("PluginManager.loadPlugins    verified: " + verified);
		
		var number = parseInt( (i * 2) + 2);
		//console.log("PluginManager.loadPlugins    ooooooooooooooooo plugin number" + number);
		this.percentProgress(doubleLength, number);
	}

	console.log("PluginManager.loadPlugins    	FINAL Agua.data: " + Agua.data);
},
percentProgress : function (total, current) {
	//console.log("PluginManager.percentProgress    	" + current + " out of " + total);
	
	var percent = 0;
	if ( total == current )
		percent = 100;
	else
		percent = parseInt((current/total) * 100);

	console.log("PluginManager.percentProgress    percent: " + percent);
	//console.log("PluginManager.percentProgress    Agua.login:");
	//console.dir({agua_loginController:Agua.login});
	if ( ! Agua.login )	return;
	
	Agua.login.progressBar.set({value:percent, progress:percent})
},
checkDependencies : function (dependencies) {
	// CHECK DEPENDENCIES ARE ALREADY LOADED AND CORRECT VERSION
	//console.log("PluginManager.checkDependencies    plugins.core.PluginManager.checkDependencies");
	//console.dir({installedPlugins:this._installedPlugins});
	//console.log("PluginManager.checkDependencies    this._installedPlugins: " + dojo.toJson(this._installedPlugins));
	
	// DEBUG
	return 1;
	
	if ( ! dependencies )	{	return 1;	}
	
	//console.log("PluginManager.checkDependencies     dependencies is defined");
	//console.log("PluginManager.checkDependencies     dependencies: " + dojo.toJson(dependencies));	
	
	for ( var i = 0; i < dependencies.length; i++ )
	{
		//console.log("PluginManager.checking dependencies[" + i + "]: " + dojo.toJson(dependencies[i]));
		var requiredName = dependencies[i].name;
		var requiredVersion = dependencies[i].version;
		//console.log("PluginManager.requiredName: " + requiredName);

		// CHECK DEPENDENCY CLASS IS LOADED
		if ( requiredName )
		{
			////console.log("PluginManager.Dependency is loaded: " + requiredName);                
			////console.log("PluginManager.this._installedPlugins.length: " + this._installedPlugins.length);
			//console.dir({installedPlugins:this.installedPlugins});


			var dependency = Agua.controllers[requiredName];


			//var dependency = this._installedPlugins[requiredName];

			////console.log("PluginManager.dependency: " + dojo.toJson(dependency));
			
			// CHECK VERSION IS MINIMUM OR GREATER
			if ( dependency.version >= requiredVersion  )    
			{        
				// CHECK THAT THE DEPENDENCY ACTUALLY INSTALLED OKAY
				if ( ! dependency.installed )
				{
					//console.log("PluginManager.checkDependencies     Required dependency is not installed: " + requiredName + ". Dependency is present but dependency.installed is false");
					return 0;
				}
				else
				{
					////console.log("PluginManager.Required dependency is installed: " + requiredName);
				}
			}
			else
			{
				//console.log("PluginManager.checkDependencies     Actual dependency '" + requiredName + "' version (" + dependency.version + ") < required version (" + requiredVersion + ")");
				return 0;
			}
		}
		else
		{
			//console.log("PluginManager.checkDependencies     Required dependency is not loaded:" + requiredName);
			return 0;
		}
	}
	
	//console.log("PluginManager.checkDependencies     Dependencies satisfied"); 
	return 1;        
},

getInstalledPlugins : function ()   {
// RETURN HASH OF INSTALLED PLUGINS
	return this._installedPlugins;
}

});

// end of PluginManager


}

if(!dojo._hasResource["plugins.core.Agua"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.core.Agua"] = true;
dojo.provide("plugins.core.Agua");

/*	PURPOSE

		1. PROVIDE INTERFACE WITH Agua DATA OBJECT REPRESENTATION
	
			OF THE DATA MODEL ON THE REMOTE SERVER

		2. PROVIDE METHODS TO CHANGE/INTERROGATE THE DATA OBJECT

		3. CALLS TO REMOTE SERVER TO REFLECT CHANGES ARE MOSTLY THE

			RESPONSIBILITY OF THE OBJECT USING THE Agua CLASS
	
	NOTES
	
		LOAD DATA WITH getData()
			
		LOAD PLUGINS WITH loadPlugins()
			- new pluginsManager
				- new Plugin PER MODULE
					- Plugin.loadPlugin CHECKS DEPENDENCIES AND LOADS MODULE
	
*/
if ( 1 ) {
// EXTERNAL MODULES





// INTERNAL MODULES
// INHERITS


//dojo.require("plugins.core.loadAgua");























	
}
dojo.declare( "plugins.core.Agua",
[
	dijit._Widget,
	dijit._Templated,
	plugins.core.Common,
	plugins.core.Agua.Data,
	plugins.core.Agua.Access,
	plugins.core.Agua.App,
	plugins.core.Agua.Ami,
	plugins.core.Agua.Aws,
	plugins.core.Agua.Cloud,
	plugins.core.Agua.Cluster,
	plugins.core.Agua.Feature,
	plugins.core.Agua.File,
	plugins.core.Agua.Group,
	plugins.core.Agua.Hub,
	plugins.core.Agua.Package,
	plugins.core.Agua.Parameter,
	plugins.core.Agua.Project,
	plugins.core.Agua.Report,
	plugins.core.Agua.Shared,
	plugins.core.Agua.Sharing,
	plugins.core.Agua.Source,
	plugins.core.Agua.Stage,
	plugins.core.Agua.StageParameter,
	plugins.core.Agua.User,
	plugins.core.Agua.View,
	plugins.core.Agua.Workflow
], {
name : "plugins.core.Agua",
version : "0.01",
description : "Create widget for positioning Plugin buttons and tab container for displaying Plugin tabs",
url : '',
dependencies : [],

// PLUGINS TO LOAD (NB: ORDER IS IMPORTANT FOR CORRECT LAYOUT)
pluginsList : [
	"plugins.data.Controller"
	, "plugins.files.Controller"
	, "plugins.cloud.Controller"
	, "plugins.apps.Controller"
	, "plugins.sharing.Controller"
	, "plugins.folders.Controller"
	, "plugins.workflow.Controller"
	, "plugins.view.Controller"
	, "plugins.home.Controller"
],

//Path to the template of this widget. 
templateString:"<div dojoAttachPoint=\"containerNode\">\n\n\t<div\n\t\tdojoAttachPoint=\"controls\"\n\t\tclass=\"controls\"\n\t\tstyle=\"min-height: 100% !important; min-width: 100% !important;\"\t\t\n\t>\n\n\t\t<div\n            dojoAttachPoint=\"toolbar\"\n            dojoType=\"dijit.Toolbar\"\n            class=\"toolbar\"\n        >\n        </div>\n\n\t\t<div\n\t\t\tdojoAttachPoint=\"tabs\"\n\t\t\tdojoType=\"dijit.layout.TabContainer\"\n\t\t\tclass=\"tabs\"\n\t\t\tuseSlider=\"false\"\n\t\t\ttabPosition=\"top\"\n\t\t\ttabStrip=\"false\"\n\t\t\tstyle=\"position: relative; top: 0px; left: 0px; height: 100% !important; min-height: 850px !important; width: 1200px !important; min-width: 100% !important; right: auto; bottom: auto;\"\n\t\t>\n\t\t</div>\n\t\n<!--\t\t<div\n\t\t\tdojoAttachPoint=\"toaster\"\n\t\t\tdojoType=\"dojox.widget.Toaster\"\n\t\t\tclass=\"toaster\" \n\t\t\tpositionDirection=\"bl-right\"\n\t\t\tduration=\"500\" \n\t\t\tmessageTopic=\"toastTopic\"\n\t\t></div> \n-->\t\t\n\t</div>\n\t\n\t<div dojoAttachPoint=\"fileManagerNode\"></div>\n\n</div>\n",	

// CSS files
cssFiles : [
	dojo.moduleUrl("plugins", "core/css/agua.css"),
	dojo.moduleUrl("plugins", "core/css/controls.css"),
	//dojo.moduleUrl("plugins", "core/css/toolbar.css")
],

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

// CONTROLLERS
controllers : new Object(),

// DIV FOR PRELOAD SCREEN
splashNode : null,

// DIV TO DISPLAY PRELOAD MESSAGE BEFORE MODULES ARE LOADED
messageNode : null,

// PLUGIN MANAGER LOADS THE PLUGINS
pluginManager: null,

// COOKIES CONTAINS STORED USER ID AND SESSION ID
cookies : new Object,

// CONTAINS ALL LOADED CSS FILES
css : new Object,

// WEB URLs
cgiUrl : null,
htmlUrl : null,

// CHILD WIDGETS
widgets : new Object,

// TESTING - DON'T getData IF TRUE
testing: false,

////}}}}}}
// CONSTRUCTOR
constructor : function(args) {
	console.log("Agua.constructor     plugins.core.Agua.constructor    args:");
	console.dir({args:args});

	this.cgiUrl = args.cgiUrl;
	this.htmlUrl = args.htmlUrl;
	if ( args.pluginsList != null )	this.pluginsList = args.pluginsList;
    this.database = args.database;
    this.dataUrl = args.dataUrl;
	console.log("Agua.constructor     this.database: " + this.database);
	console.log("Agua.constructor     this.testing: " + this.testing);
	console.log("Agua.constructor     this.dataUrl: " + this.dataUrl); 
},
postCreate : function() {
	this.startup();
},
startup : function () {
// CHECK IF DEBUGGING AND LOAD PLUGINS
	console.log("Agua.startup    plugins.core.Agua.startup()");

	console.log("Agua.startup    BEFORE loadCSS()");
	this.loadCSS();
	console.log("Agua.startup    AFTER loadCSS()");
	
	// ATTACH THIS TEMPLATE TO attachPoint DIV ON HTML PAGE
	var attachPoint = dojo.byId("attachPoint");
	attachPoint.appendChild(this.containerNode);

	// SET BUTTON LISTENER
	var listener = dojo.connect(this.aguaButton, "onClick", this, "reload");

	// SET UP THE ELEMENT OBJECTS AND THEIR VALUE FUNCTIONS
	this.inherited(arguments);

	// INITIALISE ELECTIVE UPDATER
	this.updater = new plugins.core.Updater();

	// SET LOADING PROGRESS STANDBY
	this.setStandby();

	// SET POPUP MESSAGE TOASTER
	this.setToaster();
	
	console.log("Agua.startup    AFTER this.setToaster()");
/*
	 GET DATA
	if ( this.dataUrl != null )	{
		console.log("Agua.startup   Doing this.fetchJsonData()");
		this.fetchJsonData();
	}
	else if ( Data != null && Data.data != null ) {
		console.log("Agua.startup   Doing this.loadData(Data.data)");
		this.loadData(Data.data);
	}
*/

},
displayVersion : function () {
	console.log("Agua.displayVersion     plugins.core.Agua.displayVersion()");
	
	// GET AGUA PACKAGE
	var packages = this.getPackages();
	console.log("Agua.displayVersion    packages: ");
	console.dir({packages:packages});
	var packageObject = this._getObjectByKeyValue(packages, "package", "agua");
	console.log("Agua.displayVersion    packageObject:");
	console.dir({packageObject:packageObject});
	if ( ! packageObject )	return;
	
	// DISPLAY VERSION
	var version = packageObject.version;
	console.log("Agua.displayVersion     version: " + version);
	
	console.log("this.login.statusBar:");
	console.dir({statusBar:this.login.statusBar});

	//this.login.statusBar.aguaVersion.innerHTML = version;

	var aguaVersion = dojo.byId("aguaVersion");
	aguaVersion.innerHTML = version;
		
},
// START PLUGINS
startPlugins : function () {
	console.log("Agua.startPlugins     plugins.core.Agua.startPlugins()");
	return this.loadPlugins(this.pluginsList);
},
loadPlugins : function (pluginsList, pluginsArgs) {
	console.log("Agua.loadPlugins    pluginsList: " + dojo.toJson(pluginsList));
	console.log("Agua.loadPlugins    pluginsArgs: " + dojo.toJson(pluginsArgs));

	

	if ( pluginsList == null )	pluginsList = this.pluginsList;
	if ( pluginsArgs == null )	pluginsArgs = this.pluginsArgs;
	
	this.setStandby();
	console.dir({standby:this.standby});

	console.log("DOING this.standby.show()");
	this.standby.show();
	
	// LOAD PLUGINS
	console.log("Agua.loadPlugins    Creating pluginsManager...");
	this.pluginManager = new plugins.core.PluginManager({
		parentWidget : this,
		pluginsList : pluginsList,
		pluginsArgs : pluginsArgs
	})
	console.log("Agua.loadPlugins    After load PluginManager");

	if ( this.controllers["home"] )	{
		console.log("Agua.loadPlugins    this.controllers[home].createTab()");
		this.controllers["home"].createTab();
	}
},
setStandby : function () {
	console.log("Agua.setStandby    _GroupDragPane.setStandby()");
	if ( this.standby != null )	return this.standby;
	
	var id = dijit.getUniqueId("dojox_widget_Standby");
	this.standby = new dojox.widget.Standby (
		{
			target: this.containerNode,
			//onClick: "reload",
			centerIndicator : "text",
			text: "Waiting for remote featureName",
			id : id,
			url: "plugins/core/images/agua-biwave-24.png"
		}
	);
	document.body.appendChild(this.standby.domNode);
	dojo.addClass(this.standby.domNode, "view");
	dojo.addClass(this.standby.domNode, "standby");
	console.log("Agua.setStandby    this.standby: " + this.standby);

	return this.standby;
},
addWidget : function (type, widget) {
    //console.log("Agua.addWidget    core.Agua.addWidget(type, widget)");
    //console.log("Agua.addWidget    type: " + type);
    //console.log("Agua.addWidget    widget: " + widget);
    if ( Agua.widgets[type] == null ) {
        Agua.widgets[type] = new Array;
    }
    //console.log("Agua.addWidget    BEFORE Agua.widgets[type].length: " + Agua.widgets[type].length);
    Agua.widgets[type].push(widget);
    //console.log("Agua.addWidget    AFTER Agua.widgets[type].length: " + Agua.widgets[type].length);
},
removeWidget : function (type, widget) {
    console.log("Agua.removeWidget    core.Agua.removeWidget(type, widget)");
    console.log("Agua.removeWidget    type: " + type);
    console.log("Agua.removeWidget    widget: " + widget);
        
    if ( Agua.widgets[type] == null )
    {
        console.log("Agua.removeWidget    No widgets of type: " + type);
        return;
    }

    console.log("Agua.removeWidget    BEFORE Agua.widgets[type].length: " + Agua.widgets[type].length);
    for ( var i = 0; i < Agua.widgets[type].length; i++ )
    {
        if ( Agua.widgets[type][i].id == widget.id )
        {
            Agua.widgets[type].splice(i, 1);
        }
    }
    console.log("Agua.removeWidget    AFTER Agua.widgets[type].length: " + Agua.widgets[type].length);
},
addToolbarButton: function (label) {
// ADD MODULE BUTTON TO TOOLBAR
	//console.log("Agua.addToolbarButton    plugins.core.Agua.addToolbarButton(label)");
	console.log("Agua.addToolbarButton    label: " + label);
	console.log("Agua.addToolbarButton    this.toolbar: " + this.toolbar);
	
	if ( this.toolbar == null )
	{
		//console.log("Agua.addToolbarButton    this.toolbar is null. Returning");
		return;
	}
	
	var button = new dijit.form.Button({
		
		label: label,
		showLabel: true,
		//className: label,
		iconClass: "dijitEditorIcon dijitEditorIcon" + label
	});
	//console.log("Agua.addToolbarButton    button: " + button);
	this.toolbar.addChild(button);
	
	return button;
},
cookie : function (name, value) {
// SET OR GET COOKIE-CONTAINED USER ID AND SESSION ID

	//console.log("Agua.cookie     plugins.core.Agua.cookie(name, value)");
	//console.log("Agua.cookie     name: " + name);
	//console.log("Agua.cookie     value: " + value);		

	if ( value != null )
	{
		this.cookies[name] = value;
	}
	else if ( name != null )
	{
		return this.cookies[name];
	}

	//console.log("Agua.cookie     this.cookies: " + dojo.toJson(this.cookies));

	return 0;
},
loadCSSFile : function (cssFile) {
// LOAD A CSS FILE IF NOT ALREADY LOADED, REGISTER IN this.loadedCssFiles
	//console.log("Agua.loadCSSFile    cssFile: " + cssFile);
	//console.log("Agua.loadCSSFile    this.loadedCssFiles: " + dojo.toJson(this.loadedCssFiles));
	if ( this.loadedCssFiles == null || ! this.loadedCssFiles )
	{
		//console.log("Agua.loadCSSFile    Creating this.loadedCssFiles = new Object");
		this.loadedCssFiles = new Object;
	}
	
	if ( ! this.loadedCssFiles[cssFile] )
	{
		console.log("Agua.loadCSSFile    Loading cssFile: " + cssFile);
		
		var cssNode = document.createElement('link');
		cssNode.type = 'text/css';
		cssNode.rel = 'stylesheet';
		cssNode.href = cssFile;
		document.getElementsByTagName("head")[0].appendChild(cssNode);

		this.loadedCssFiles[cssFile] = 1;
	}
	else
	{
		//console.log("Agua.loadCSSFile    No load. cssFile already exists: " + cssFile);
	}
	//console.log("Agua.loadCSSFile    Returning this.loadedCssFiles: " + dojo.toJson(this.loadedCssFiles));
	
	return this.loadedCssFiles;
},
// DATA METHODS
fetchJsonData : function() {
	console.log("Agua.fetchJsonData    plugins.core.Agua.fetchJsonData()")	
	// GET URL 
    var url = this.dataUrl 
	console.log("Agua.fetchJsonData    url: " + url);

    var thisObject = this;
    dojo.xhrGet({
        // The URL of the request
        url: url,
		sync: true,
        // Handle as JSON Data
        handleAs: "json",
        // The success callback with result from server
        handle: function(data) {
			console.log("Agua.fetchJsonData    Setting this.data: " + data);
			thisObject.data = data;
        },
        // The error handler
        error: function() {
            console.log("Agua.Error with JSON Post, response: " + response);
        }
    });
},
reload : function () {
// RELOAD AGUA
	//console.log("Agua.constructor    plugins.core.Controls.reload()");
	var url = window.location;
	window.open(location, '_blank', 'toolbar=1,location=0,directories=0,status=0,menubar=1,scrollbars=1,resizable=1,navigation=0'); 

	//window.location.reload();
},
// LOGOUT
logout : function () {
	console.clear();
	var buttons = Agua.toolbar.getChildren();
	if ( ! buttons )	return;
	for ( var i = 0; i < buttons.length; i++ ) {
		var button = buttons[i];
		controller = button.parentWidget;
		console.log("Agua.logout    controller " + i);
		console.dir({controller:controller});

		var name = controller.id.match(/plugins_([^_]+)/)[1]; 
		console.log("Agua.logout    Doing delete Agua.controllers[" + name + "]");
		delete Agua.controllers[name];
		
		console.log("Agua.logout    Doing controllers.destroyRecursive()");
		controller.destroyRecursive();
	}
	
	delete this.data;
}

}); // end of Agua

}

if(!dojo._hasResource["plugins.core.Agua.Admin"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.core.Agua.Admin"] = true;
dojo.provide("plugins.core.Agua.Admin");

/* SUMMARY: THIS CLASS IS INHERITED BY Agua.js AND CONTAINS 
	
	ADMIN METHODS  
*/

dojo.declare( "plugins.core.Agua.Admin",	[  ], {

///////}}}

// ADMIN METHODS
getAdminHeadings : function () {
	console.log("Agua.Admin.getAdminHeadings    plugins.core.Data.getAdminHeadings()");
	var headings = this.cloneData("adminheadings");
	console.log("Agua.Admin.getAdminHeadings    headings: " + dojo.toJson(headings));
	return headings;
},
getAccess : function () {
	//console.log("Agua.Admin.getAccess    plugins.core.Data.getAccess()");
	return this.cloneData("access");
}

});

}

if(!dojo._hasResource["plugins.core.PluginController"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.core.PluginController"] = true;
dojo.provide("plugins.core.PluginController");

/* 	OBJECT:  plugins.core.PluginController

	PURPOSE: GENERIC PLUGIN CONTROLLER
*/

// INHERITS


dojo.declare( "plugins.core.PluginController",
	[ dijit._Widget, dijit._Templated, plugins.core.Common ], {
// PANE ID 
paneId : null,

//Path to the template of this widget. 
templatePath: null,

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

// CSS FILES
cssFiles : [],

// ARRAY OF TAB PANES
tabPanes : [],

// moduleName : String
// Name of tab pane class, e.g., "plugins.folders.Folders"
tabClass : null,

////}}}}

// CONSTRUCTOR	
constructor : function(args) {
	this.loadCSS();
},
postCreate : function() {
	this.startup();
},
startup : function () {
	//console.log("core.Controller.startup    plugins.core.Controller.startup()");
	this.inherited(arguments);

	// ADD MENU BUTTON TO TOOLBAR
	Agua.toolbar.addChild(this.menuButton);
	
	// SET BUTTON PARENT WIDGET
	this.menuButton.parentWidget = this;
	
	// SET ADMIN BUTTON LISTENER
	var listener = dojo.connect(this.menuButton, "onClick", this, "createTab", {});
},
createTab : function (args) {
	console.log("core.Controller.createTab    args: ");
	console.dir({args:args});

	// CLEAR ANNOYING ALL-SELECTED
	window.getSelection().removeAllRanges();

	// SET DEFAULT ARGS
	if ( ! args )	args = {};

	// CREATE TAB WIDGET
	var module = dojo.getObject(this.tabClass);
	var widget = new module(args);
	this.tabPanes.push(widget);

	// ADD TO _supportingWidgets FOR INCLUSION IN DESTROY	
	this._supportingWidgets.push(widget);
}

}); // end of Controller

dojo.addOnLoad(
function()
{
	// CREATE TAB
	//Agua.controllers["folders"].createTab();		
}
);

}

if(!dojo._hasResource["plugins.data.Controller"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.data.Controller"] = true;
dojo.provide("plugins.data.Controller");

// OBJECT:  plugins.data.Controller
// PURPOSE: LOAD, STORE AND PROVIDE ACCESS TO DATA

// CONTAINER


// GLOBAL VARIABLE
//var Data = new Object;

// HAS
//dojo.require("plugins.data.Data");

dojo.declare( "plugins.data.Controller",
	[ plugins.core.Common ],
{

name : "plugins.data.Controller",
version : "0.01",
description : "Load data from remote host",
url : '',
dependencies : [],

// data : object
// Hash for all data tables
data: null,

////}}}
// CONSTRUCTOR	
constructor : function(args) {
	console.log("data.Controller.constructor     plugins.data.Controller.constructor");
	this.startup();
},
startup : function () {
	console.log("data.Controller.startup    plugins.data.Controller.startup()");
	console.log("data.Controller.startup    Data: " + Data);
	//console.dir({data:Data.data});
	
	if ( Data != null )
	{
		if ( Data.data != null )
		{
			console.log("data.Controller.startup    Data.data: ");
			console.dir({data:Data.data});

			this.data = Data.data;
			Agua.data = Data.data;
		}
		else
			this.getData();
	}
	else
		this.getData();

	Data = this;	
},
getData : function() {
// LOAD ALL DATA, INCLUDING SHARED PROJECT DATA
	console.log("data.Controller.getData    plugins.data.Controller.getData()");		
	console.log("data.Controller.getData    Agua.dataUrl: " + Agua.dataUrl);
	
    if ( Agua.dataUrl != null )	return this.fetchJsonData();

	// GENERATE QUERY JSON FOR THIS WORKFLOW IN THIS PROJECT
	var url = Agua.cgiUrl + "workflow.cgi";
	var query = new Object;
	query.username = Agua.cookie('username');
	query.sessionid = Agua.cookie('sessionid');
    if ( Agua.database )
        query.database = Agua.database;

	query.mode = "getData";
	
	console.log("data.Controller.getData    query: ");
	console.dir({query:query});

	if ( Data == null )
		Data = new Object;

	var thisObject = this;
	dojo.xhrPut(
		{
			url: url,
			putData: dojo.toJson(query),
			handleAs: "json",
			//handleAs: "json-comment-optional",
			preventCache : true,
			sync: true,
			load: function(response, ioArgs) {

				//console.log("data.Controller.getData    response: ", dojo.toJson(response));

				if ( response.error )
				{
					Agua.error(response.error);
				}
				else
				{
					Data.data = response;
					thisObject.data = response;
					Agua.data = response;
					console.log("data.Controller.getData    BEFORE thisObject.responseToData(response)");
					//thisObject.responseToData(response);

					// DISPLAY VERSION
					Agua.displayVersion();
				}
			},
			error: function(response, ioArgs) {
				console.log("Error with JSON Post, response: " + dojo.toJson(response) + ", ioArgs: " + dojo.toJson(ioArgs));
			}
		}
	);

	// DISABLE 
	if ( this.testing )
	{
		Agua.cgiUrl = "../";
	}

	return null;
},
fetchJsonData : function() {
	console.log("data.Controller.fetchJsonData    plugins.data.Controller.fetchJsonData()");		

	// GET URL 
    var url = Agua.dataUrl 
	console.log("data.Controller.fetchJsonData    url: " + url);

	console.log("data.Controller.fetchJsonData    DOING dojo.xhrGet");
	
    var thisObject = this;
    dojo.xhrGet({
        // The URL of the request
        url: url,
        sync: true,
		// Handle as JSON Data
		// chrome: handle as text, convert to JSON
        handleAs: "json",
        // The success callback with result from server
//        load: function(text) {
//			var response = dojo.fromJson(response)
        load: function(response) {

			console.log("data.Controller.fetchJsonData    response: ", dojo.toJson(response));
			if ( Data != null )
				Data.data = response;
			Agua.data = response;
			//thisObject.responseToData(response);
        },
        // The error handler
        error: function() {
			Agua.error("Failed to fetch data");
        }
    });
},
getTable : function(table) {
// LOAD ALL AGUA DATA FOR THIS USER, INCLUDING SHARED PROJECT DATA

	console.log("data.Controller.getTable    plugins.data.Controller.getTable(table)");		
	console.log("data.Controller.getTable    table: " + table);

    if ( Agua.dataUrl != null )
    {
		console.log("data.Controller.getTable    Agua.dataUrl: " + Agua.dataUrl);
		console.log("data.Controller.getTable    Agua.dataUrl not null. Doing return this.fetchJsonData()");
        return this.fetchJsonData();
    }

	// GET URL 
	var url = Agua.cgiUrl + "workflow.cgi";
	//console.log("data.Controller.getTable    url: " + url);		

	// GENERATE QUERY JSON FOR THIS WORKFLOW IN THIS PROJECT
	var query = new Object;
	query.username = Agua.cookie('username');
	query.sessionid = Agua.cookie('sessionid');
    if ( this.database != null )
        query.database = this.database;
	query.mode = "getTable";
	query.table = table;
	console.log("data.Controller.getTable    query: " + dojo.toJson(query, true));

	var thisObject = this;
	dojo.xhrPut(
		{
			url: url,
			putData: dojo.toJson(query),
			handleAs: "json",
			//handleAs: "json-comment-optional",
			sync: true,
			load: function(response, ioArgs) {
				console.log("data.Controller.JSON Post worked.");
				if ( response.error )
				{
					console.log("data.Controller.getTable    xhrPut error: " + response.error);
				}
				else
				{
					thisObject.responseToData(response);
					//for ( var key in response )
					//{
					//	console.log("data.Controller.getTable    storing key: " + key);
					//	thisObject[key] = response[key];
					//}
				}
			},
			error: function(response, ioArgs) {
				console.log("data.Controller.Error with JSON Post, response: " + response + ", ioArgs: " + ioArgs);
			}
		}
	);
	//console.log("data.Controller.getTable    this.headings: " + dojo.toJson(this.headings));
},
responseToData : function (response) {
	console.log("data.Controller.responseToData    response: " + response);
	console.log("data.Controller.responseToData    response: " + dojo.toJson(response));
	var keys = this.hashkeysToArray(response);
	keys.sort();
	var thisObject = this;
	dojo.forEach(keys, function(key){
		console.log("data.Controller.getData    storing key: " + key);
		Agua.data[key] = response[key];
	});
},
destroyRecursive : function () {
	dojo.destroy(this);
}


}); // end of Controller


}

if(!dojo._hasResource["dojox.data.FileStore"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.data.FileStore"] = true;
dojo.provide("dojox.data.FileStore");


dojo.declare("dojox.data.FileStore", null, {
	constructor: function(/*Object*/args){
		//	summary:
		//		A simple store that provides a datastore interface to a filesystem.
		//	description:
		//		A simple store that provides a datastore interface to a filesystem.  It takes a few parameters
		//		for initialization:
		//			url:	The URL of the service which provides the file store serverside implementation.
		//			label:	The attribute of the file to use as the huma-readable text.  Default is 'name'.
		//		The purpose of this store is to represent a file as a datastore item.  The
		//		datastore item by default has the following attributes that can be examined on it.
		//			directory:	Boolean indicating if the file item represents a directory.
		//			name:	The filename with no path informatiom.
		//			path:	The file complete file path including name, relative to the location the
		//					file service scans from
		//			size:	The size of the file, in bytes.
		//			parentDir:	The parent directory path.
		//			children:	Any child files contained by a directory file item.
		//
		//		Note that the store's server call pattern is RESTlike.
		//
		//		The store also supports the passing of configurable options to the back end service, such as
		//		expanding all child files (no lazy load), displaying hidden files, displaying only directories, and so on.
		//		These are defined through a comma-separated list in declarative, or through setting the options array in programmatic.
		//		example:	options="expand,dirsOnly,showHiddenFiles"
		if(args && args.label){
			this.label = args.label;
		}
		if(args && args.url){
			this.url = args.url;
		}
		if(args && args.options){
			if(dojo.isArray(args.options)){
				this.options = args.options;
			}else{
				if(dojo.isString(args.options)){
					this.options = args.options.split(",");
				}
			}
		}
		if(args && args.pathAsQueryParam){
			this.pathAsQueryParam = true;
		}
		if(args && "urlPreventCache" in args){
			this.urlPreventCache = args.urlPreventCache?true:false;
		}
	},

	// url: [public] string
	//		The URL to the file path service.
	url: "",
	
	// _storeRef: [private] string
	//		Internal variable used to denote an item came from this store instance.
	_storeRef: "_S",

	// label: [public] string
	//		Default attribute to use to represent the item as a user-readable
	//		string.  Public, so users can change it.
	label: "name",

	// _identifier: [private] string
	//		Default attribute to use to represent the item's identifier.
	//		Path should always be unique in the store instance.
	_identifier: "path",

	// _attributes: [private] string
	//		Internal variable of attributes all file items should have.
	_attributes: ["children", "directory", "name", "path", "modified", "size", "parentDir"], //
	
	// pathSeparator: [public] string
	//		The path separator to use when chaining requests for children
	//		Can be overriden by the server on initial load
	pathSeparator: "/",

	// options: [public] array
	//		Array of options to always send when doing requests.
	//		Back end service controls this, like 'dirsOnly', 'showHiddenFiles', 'expandChildren', etc.
	options: [],

	// failOk: [public] boolean
	//		Flag to pass on to xhr functions to check if we are OK to fail the call silently
	failOk: false,

	// urlPreventCache: [public] string
	//		Flag to dennote if preventCache should be passed to xhrGet.
	urlPreventCache: true,

	_assertIsItem: function(/* item */ item){
		// summary:
		//      This function tests whether the item passed in is indeed an item in the store.
		// item:
		//		The item to test for being contained by the store.

		if(!this.isItem(item)){
			throw new Error("dojox.data.FileStore: a function was passed an item argument that was not an item");
		}
	},

	_assertIsAttribute: function(/* attribute-name-string */ attribute){
		// summary:
		//		This function tests whether the item passed in is indeed a valid 'attribute' like type for the store.
		// attribute:
		//		The attribute to test for being contained by the store.
		if(typeof attribute !== "string"){
			throw new Error("dojox.data.FileStore: a function was passed an attribute argument that was not an attribute name string");
		}
	},

	pathAsQueryParam: false, //Function to switch between REST style URL lookups and passing the path to specific items as a query param: 'path'.

	getFeatures: function(){
		// summary:
		//      See dojo.data.api.Read.getFeatures()
		return {
			'dojo.data.api.Read': true, 'dojo.data.api.Identity':true
		};
	},

	getValue: function(item, attribute, defaultValue){
		// summary:
		//      See dojo.data.api.Read.getValue()
		var values = this.getValues(item, attribute);
		if(values && values.length > 0){
			return values[0];
		}
		return defaultValue;
	},

	getAttributes: function(item){
		// summary:
		//      See dojo.data.api.Read.getAttributes()
		return this._attributes;
	},

	hasAttribute: function(item, attribute){
		// summary:
		//      See dojo.data.api.Read.hasAttribute()
		this._assertIsItem(item);
		this._assertIsAttribute(attribute);
		return (attribute in item);
	},
	
	getIdentity: function(/* item */ item){
		// summary:
		//		See dojo.data.api.Identity.getIdentity()

		console.log("dojox.data.FileStore.getIdentity    caller: " + this.isItem.caller.nom);
		console.log("dojox.data.FileStore.getIdentity    item: " + dojo.toJson(item));

		return this.getValue(item, this._identifier);
	},
	
	getIdentityAttributes: function(item){
		// summary:
		//      See dojo.data.api.Read.getLabelAttributes()
		return [this._identifier];
	},


	isItemLoaded: function(item){
		 //	summary:
		 //      See dojo.data.api.Read.isItemLoaded()
		 var loaded = this.isItem(item);
		 if(loaded && typeof item._loaded == "boolean" && !item._loaded){
		 	loaded = false;
		 }
		 return loaded;
	},

	loadItem: function(keywordArgs){
		// summary:
		//      See dojo.data.api.Read.loadItem()
		var item = keywordArgs.item;
		var self = this;
		var scope = keywordArgs.scope || dojo.global;

		var content = {};

		if(this.options.length > 0){
			content.options = dojo.toJson(this.options);
		}

		if(this.pathAsQueryParam){
			content.path = item.parentPath + this.pathSeparator + item.name;
		}
		var xhrData = {
			url: this.pathAsQueryParam? this.url : this.url + "/" + item.parentPath + "/" + item.name,
			handleAs: "json-comment-optional",
			content: content,
			preventCache: this.urlPreventCache,
			failOk: this.failOk
		};

		var deferred = dojo.xhrGet(xhrData);
		deferred.addErrback(function(error){
				if(keywordArgs.onError){
					keywordArgs.onError.call(scope, error);
				}
		});
		
		deferred.addCallback(function(data){
			delete item.parentPath;
			delete item._loaded;
			dojo.mixin(item, data);
			self._processItem(item);
			if(keywordArgs.onItem){
				keywordArgs.onItem.call(scope, item);
			}
		});
	},

	getLabel: function(item){
		// summary:
		//      See dojo.data.api.Read.getLabel()
		return this.getValue(item,this.label);
	},
	
	getLabelAttributes: function(item){
		// summary:
		//      See dojo.data.api.Read.getLabelAttributes()
		return [this.label];
	},
	
	containsValue: function(item, attribute, value){
		// summary:
		//      See dojo.data.api.Read.containsValue()
		var values = this.getValues(item,attribute);
		for(var i = 0; i < values.length; i++){
			if(values[i] == value){
				return true;
			}
		}
		return false;
	},

	getValues: function(item, attribute){
		// summary:
		//      See dojo.data.api.Read.getValue()
		this._assertIsItem(item);
		this._assertIsAttribute(attribute);
		
		var value = item[attribute];
		if(typeof value !== "undefined" && !dojo.isArray(value)){
			value = [value];
		}else if(typeof value === "undefined"){
			value = [];
		}
		return value;
	},

	isItem: function(item){
		// summary:
		//      See dojo.data.api.Read.isItem()
		console.log("dojox.data.FileStore.isItem    caller: " + this.isItem.caller.nom);
		console.log("dojox.data.FileStore.isItem    item: ");
		console.dir({item:item});
		console.log("dojox.data.FileStore.isItem    this._storeRef: " + this._storeRef);
		console.log("dojox.data.FileStore.isItem    item[this._storeRef]: " + item[this._storeRef]);
		
		if(item && item[this._storeRef] === this){
			return true;
		}
		return false;
	},
	
	close: function(request){
		// summary:
		//      See dojo.data.api.Read.close()
	},

	fetch: function(request){

console.log("dojox.data.FileStore.fetch    caller: " + this.fetch.caller.nom);
console.log("dojox.data.FileStore.fetch    request: " );
console.dir({request:request});

		// summary:
		//		Fetch  items that match to a query
		// request:
		//		A request object

		request = request || {};
		if(!request.store){
			request.store = this;
		}
		var self = this;
		var scope = request.scope || dojo.global;

		//Generate what will be sent over.
		var reqParams = {};
		if(request.query){
			reqParams.query = dojo.toJson(request.query);
		}

		if(request.sort){
			reqParams.sort = dojo.toJson(request.sort);
		}

		if(request.queryOptions){
			reqParams.queryOptions = dojo.toJson(request.queryOptions);
		}

		if(typeof request.start == "number"){
			reqParams.start = "" + request.start;
		}
		if(typeof request.count == "number"){
			reqParams.count = "" + request.count;
		}

		if(this.options.length > 0){
			reqParams.options = dojo.toJson(this.options);
		}

console.log("dojox.data.FileStore.fetch    reqParams:");
console.dir({reqParams:reqParams});

		var getArgs = {
			url: this.url,
			preventCache: this.urlPreventCache,
			failOk: this.failOk,
			handleAs: "json-comment-optional",
			content: reqParams
		};


		var deferred = dojo.xhrGet(getArgs);

		deferred.addCallback(function(data){self._processResult(data, request);});
		deferred.addErrback(function(error){
			if(request.onError){
				request.onError.call(scope, error, request);
			}
		});
	},

	fetchItemByIdentity: function(keywordArgs){
		// summary:
		//      See dojo.data.api.Read.loadItem()
		var path = keywordArgs.identity;
		var self = this;
		var scope = keywordArgs.scope || dojo.global;

		var content = {};

		if(this.options.length > 0){
			content.options = dojo.toJson(this.options);
		}

		if(this.pathAsQueryParam){
			content.path = path;
		}
		var xhrData = {
			url: this.pathAsQueryParam? this.url : this.url + "/" + path,
			handleAs: "json-comment-optional",
			content: content,
			preventCache: this.urlPreventCache,
			failOk: this.failOk
		};

		var deferred = dojo.xhrGet(xhrData);
		deferred.addErrback(function(error){
				if(keywordArgs.onError){
					keywordArgs.onError.call(scope, error);
				}
		});
		
		deferred.addCallback(function(data){
			var item = self._processItem(data);
			if(keywordArgs.onItem){
				keywordArgs.onItem.call(scope, item);
			}
		});
	},

	_processResult: function(data, request){
		 var scope = request.scope || dojo.global;
		 try{
			 //If the data contains a path separator, set ours
			 if(data.pathSeparator){
				 this.pathSeparator = data.pathSeparator;
			 }
			 //Invoke the onBegin handler, if any, to return the
			 //size of the dataset as indicated by the service.
			 if(request.onBegin){
				 request.onBegin.call(scope, data.total, request);
			 }
			 //Now process all the returned items thro
			 var items = this._processItemArray(data.items);
			 if(request.onItem){
				var i;
				for(i = 0; i < items.length; i++){
					request.onItem.call(scope, items[i], request);
				}
				items = null;
			 }
			 if(request.onComplete){
				 request.onComplete.call(scope, items, request);
			 }
		 }catch (e){
			 if(request.onError){
				 request.onError.call(scope, e, request);
			 }else{
				 console.log(e);
			 }
		 }
	},
	
	_processItemArray: function(itemArray){
		 //	summary:
		 //		Internal function for processing an array of items for return.
		 var i;
		 for(i = 0; i < itemArray.length; i++){
		 	this._processItem(itemArray[i]);
		 }
		 return itemArray;
	},
	
	_processItem: function(item){
		//	summary:
		//		Internal function for processing an item returned from the store.
		//		It sets up the store ref as well as sets up the attributes necessary
		//		to invoke a lazy load on a child, if there are any.
		if(!item){return null;}
		item[this._storeRef] = this;
		if(item.children && item.directory){
			if(dojo.isArray(item.children)){
				var children = item.children;
				var i;
				for(i = 0; i < children.length; i++ ){
					var name = children[i];
					if(dojo.isObject(name)){
						children[i] = this._processItem(name);
					}else{
						children[i] = {name: name, _loaded: false, parentPath: item.path};
						children[i][this._storeRef] = this;
					}
				}
			}else{
				delete item.children;
			}
		}
		return item;
	}
});

}

if(!dojo._hasResource["plugins.data.FileStore"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.data.FileStore"] = true;
dojo.provide("plugins.data.FileStore");

// EXTERNAL MODULES


// INTERNAL MODULES


dojo.declare("plugins.data.FileStore",
	[ dojox.data.FileStore ],
{

// OVERRIDE _processItemArray TO RETURN [] IF itemArray IS NULL to AVOID ERROR

_processItemArray: function(itemArray){
	// summary:
	// Internal function for processing an array of items for return.
	if ( itemArray == null )	return [];
	var i;
	for(i = 0; i < itemArray.length; i++){
		this._processItem(itemArray[i]);
	}
	return itemArray;
},

// OVERRIDE _assertIsItem TO AVOID ERROR:
// Error: dojox.data.FileStore: a function was passed an item argument that was not an item

_assertIsItem: function(/* item */ item){

	if ( item == null )	return false;
	// summary:
	// This function tests whether the item passed in is indeed an item in the store.
	// item:
	// The item to test for being contained by the store.
	if(!this.isItem(item)){
		throw new Error("dojox.data.FileStore: a function was passed an item argument that was not an item");
	}
},



}); // plugins.data.FileStore


}

if(!dojo._hasResource["plugins.dnd.Target"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.dnd.Target"] = true;
dojo.provide("plugins.dnd.Target");

// SUMMARY: A Target DnD object that accepts dropped apps and converts them to stages



dojo.declare("plugins.dnd.Target", [ dojo.dnd.Target ], {

// contextMenu: dijit.Menu OBJECT. CONTEXT MENU FOR ALL NODES
contextMenu : null,

// parentWidget: plugins.workflow.Workflows OBJECT.	
parentWidget : null,

// droppingApp : string
// Flag to prevent multiple drops
droppingApp : null,

// dragType: array
// List of permitted dragged items allowed to be dropped
dragTypes : ["draggableItem"],

/////}}}

constructor: function(node, params) {
	console.log("Target.constructor    params: " + params);
	console.log("Target.constructor    params.contextMenu: " + params.contextMenu);
	console.log("Target.constructor    params.this.parentWidget: " + params.parentWidget);

	this.contextMenu = params.contextMenu;
	this.parentWidget = params.parentWidget;
	this.core = params.core;
	if ( params && params.dragTypes )
		this.dragTypes = params.dragTypes
	
	// summary:
	//		a constructor of the Target --- see the `dojo.dnd.Source.constructor` for details
	this.isSource = false;
	dojo.removeClass(this.node, "dojoDndSource");
},

resetDropping : function () {
// RESET this.droppingApp TO FALSE
	this.droppingApp = false;
},

onDndDrop : function(source, nodes, copy) {
// USE dojo.connect TO ADD EVENT TO NEW ITEM
// NB: DROPPED NODES MUST HAVE AN application SLOT

	// RETURN IF DROP FLAG IS SET
	console.log("Target.onDndDrop    XXXXXXXXXXXXXXXXXXXXXXXX this.droppingApp: " + this.droppingApp);
	var acceptance = this.checkAcceptance(source, nodes);
	console.log("Target.onDndDrop    XXXXXXXXXXXXXXXXXXXXXXXX acceptance: " + acceptance);
	if ( ! acceptance ) {
		console.log("Target.onDndDrop    acceptance is FALSE. Returning");
		return;
	}
	
	


	if ( ! this.accept || this.accept.length < 1 ) {
		console.log("Target.onDndDrop    this.accept is empty. Returning");
		return;
	}
	
	if ( this.droppingApp ) {
		console.log("Target.onDndDrop    this.droppingApp is true. Returning");
		return;
	}
	else {
		this.droppingApp = true;
	}

	// SET DROP FLAG
	console.log("Target.onDndDrop    Set this.droppingApp: " + this.droppingApp);
	
	console.log("Target.onDndDrop    this: " + this);
	console.log("Target.onDndDrop    source: ");
	console.dir({source:source});
	console.log("Target.onDndDrop    nodes.length: " + nodes.length);
	console.log("Target.onDndDrop    nodes[0].data: " + nodes[0].data);
	console.dir({nodes_0:nodes[0]});

	
	var thisObject = this;


	// SANITY
	if ( nodes[0].data == null )	return;
	
	// summary: topic event processor for /dnd/drop,
	// called to finish the DnD operation break box
	var newNode;
	do
	{ 
		if ( this.containerState != "Over" )
		{
			break;
		}

		var oldCreator = this._normalizedCreator;

		// transferring nodes from the source to the target
		if ( this != source )
		{
			// CLONE THE DROPPED NODE AND ADD THE
			// CLONE TO THE DROP TARGET
			this._normalizedCreator = function(node, hint)
			{
				var t = source.getItem(node.id);
				var n = node.cloneNode(true);
				n.parentWidget = node.parentWidget;
				n.id = dojo.dnd.getUniqueId();
				return {node: n, data: t.data, type: t.type};
			};
		}  
		
		// CLEAN UP - REMOVE SELECTION AND ANCHOR STYLE
		this._removeSelection();
		if ( this != source )
		{
			this._removeAnchor();
		}

		if ( this != source && !copy && !this.creator )
		{
			source.selectNone();
		}

		// INSERT DROPPED NODE INTO DROP TARGET
		this.insertNodes(true, nodes, this.before, this.current);
		this.sync();

		// COMPLETE THE NODE COPY:
		//
		// 1. TRANSFER THE METADATA FROM THE DROPPED NODE TO
		// THE CLONED NODE.
		// 
		// 2. INCREMENT BY ONE THE number OF THE NODES AFTER
		// THE INSERTION POINT OF THE NEW NODE.
		var belowInsertedNode = false;
		var allNodes = this.getAllNodes();
		console.log("Target.onDndDrop    allNodes: " + allNodes);
		console.log("Target.onDndDrop    allNodes.length: " + allNodes.length);

		dojo.forEach(allNodes, function(node, i)
		{
			if ( node.application == null )
			{
				// CLONE THIS OTHERWISE GET AN INTERESTING ERROR
				// WHEN DUPLICATE COPIES OF THE SAME APPLICATION
				// ARE DROPPED (SHARING THE SAME application OBJECT)
				node.application = dojo.clone(nodes[0].data);
				console.log("Target.onDndDrop    Setting node.application: ");
				console.dir({node_application:node.application});

				// ADD appname TO APPLICATION
				node.application.appname = node.application.name;
				
				// ADD NUMBER TO APPLICATION
				// CAST number TO STRING FOR LATER SORTING
				node.application.appnumber = (i + 1).toString();
				node.application.number = (i + 1).toString();
				node.number = (i + 1).toString();

				// SET DEFAULT CLUSTER IS EMPTY
				if ( node.application["cluster"] == null )	node.application["cluster"] = '';
				
				// ADD PROJECT AND WORKFLOW TO node's APPLICATION
				var project = thisObject.core.userWorkflows.getProject();
				var workflow = thisObject.core.userWorkflows.getWorkflow();
				node.application.project = project;
				node.application.workflow = workflow;
				
				// SET WORKFLOWNUMBER
				var workflowobject = Agua._getWorkflow({name:workflow,project:project});
				console.log("Target.onDndDrop    workflowobject: ");
				console.dir({workflowobject:workflowobject});
				var workflownumber = workflowobject.number;
				console.log("Target.onDndDrop    workflownumber: " + workflownumber);
				node.application.workflownumber = dojo.clone(workflownumber);
				
				// SET USERNAME
				node.application.username = Agua.cookie('username');
				console.log("Target.onDndDrop    node.application: ");
				console.dir({application:node.application});
				
				// INSTANTIATE SOURCE ROW 
				var stageRow = new plugins.workflow.StageRow(node.application);
				console.log("Target.onDndDrop    stageRow: " + stageRow);
				console.log("Target.onDndDrop    stageRow.domNode: " + stageRow.domNode);
				console.log("Target.onDndDrop    stageRow.application: " + dojo.toJson(stageRow.application));

				// SET CORE WORKFLOW OBJECTS
				stageRow.core = thisObject.core;
	
				stageRow.workflowWidget = thisObject.core.userWorkflows.parentWidget;
	
				// CLEAR NODE CONTENT
				node.innerHTML = '';
	
				// APPEND stageRow WIDGET TO NODE
				node.appendChild(stageRow.domNode);
				
				// ADD CONTEXT MENU TO NODE
				thisObject.contextMenu.bind(node);

				// SET stageRow AS node.parentWidget ATTRIBUTE FOR ACCESS LATER:
				// --- (ALSO ADDED this.name.parentWidget = this IN StageRow.startup())
				//
				// 1. WHEN CALLING Workflow.loadParametersPane SO THAT THE CORRECT
				// StageRow HAS ITS validInputs SET ACCORDING TO THE OUTCOME
				// OF Workflow.loadParametersPane
				//
				// 2. FOR RESETTING OF number ON REMOVAL OR INSERTION OF NODES
				//
				// REM: remove ONCLICK BUBBLES ON stageRow.name NODE RATHER THAN ON node. 
				// I.E., CONTRARY TO DESIRED, thisObject.name IS THE TARGET INSTEAD OF THE node.
				node.parentWidget = stageRow;

				//NB: NOT THIS: node.parentWidget = dojo.clone(nodes[0].parentWidget);
				console.log("Target.onDndDrop    node.id: " + node.id);
				console.log("Target.onDndDrop    Set node.parentWidget: " + node.parentWidget);	

				// INSERT STAGE INTO thisObject.stage AND ITS STAGE PARAMETERS
				// INTO Agua.stages AND Agua.stageparameters
				console.log("Target.onDndDrop    BEFORE    Agua.insertStage(node.application)");
				var insertOk = Agua.insertStage(node.application);
				if ( ! insertOk )
				{
					console.log("Target.onDndDrop    Failed to add stage to Agua data");
					// UNSET droppingApp FLAG
					console.log("Target.onDndDrop    Setting thisObject.droppingApp to false and returning");
					//thisObject.droppingApp = false;
					setTimeout(thisObject.resetDropping, 1000);
					return;
				}
				console.log("Target.onDndDrop    AFTER    Agua.insertStage(node.application)");

				// ADD ONCLICK TO LOAD APPLICATION INFO
				node.onclick = function(e)
				{
					console.log("Target.onDndDrop    node.onclick fired, calling thisObject.core.userWorkflows.loadParametersPane(node, null)");
					console.log("Target.onDndDrop    node: " + node);
					thisObject.core.userWorkflows.loadParametersPane(node, null);
				}

				// ADD CONTEXT MENU
				thisObject.contextMenu.bind(node);
				
				// SET THE DEFAULT CHAINED VALUES FOR INPUTS AND OUTPUTS FOR THE
				// APPLICATION BASED ON THOSE OF THE PREVIOUS APPLICATIONS
				thisObject.core.userWorkflows.getChainedValues(node);

				// SET belowInsertedNode FLAG TO TRUE
				belowInsertedNode = true;
				
				// UNSET droppingApp FLAG
				console.log("Target.onDndDrop    Setting thisObject.droppingApp = false");
				thisObject.droppingApp = false;

				// SET NEW NODE FOR LOAD INFO PANE LATER
				newNode = node;
				

				return;
			}
			console.log("Target.onDndDrop    belowInsertedNode: " + belowInsertedNode); 
							
			// IF WE ARE BELOW THE INSERTED NODE, CHAIN THE STAGE
			if ( belowInsertedNode == true )
			{
				console.log("Target.onDndDrop    node " + i + " is belowInsertedNode");
				console.log("Target.onDndDrop    DOING thisObject.core.io.chainStage(node.application, force)");
				console.log("Target.onDndDrop    thisObject.core.userWorkflows: " + thisObject.core.userWorkflows);
				
				var force = true;
				console.log("Target.onDndDrop    Doing thisObject.core.io.chainStage(node.application, force)");
				thisObject.core.io.chainStage(node.application, force);
			}
		});

		// UNSET droppingApp FLAG
		console.log("Target.onDndDrop    BEFORE thisObject.droppingApp = false");
		console.log("Target.onDndDrop    thisObject.core.userWorkflows: " + thisObject.core.userWorkflows);
		thisObject.droppingApp = false;

		thisObject._normalizedCreator = oldCreator;
	}
	while(false);
	// end of 'do'

	// SET THE APPLICATION.NUMBER AND .APPNUMBER FOR EACH NODE AND ITS WIDGET
	setTimeout(function() {
		console.log("Target.onDndDrop    Doing this.core.userWorkflows.resetNumbers()");
		thisObject.core.userWorkflows.resetNumbers();

		console.log("Target.onDndDrop    Setting this.core.runStatus.polling TO FALSE");
		if ( thisObject.core.runStatus )
			thisObject.core.runStatus.polling = false;

		// SET INFO PANE FOR DROPPED NODE
		console.log("Target.onDndDrop    Doing this.core.userWorkflows.loadParametersPane(newNode)");
		console.dir({thisObject:thisObject});
		thisObject.core.userWorkflows.loadParametersPane(newNode);
	}, 100);


// ******************* DISABLED FOR DEBUGGING ***********************
// ******************* DISABLED FOR DEBUGGING ***********************


	console.log("Target.onDndDrop    BEFORE this.onDndCancel");
	this.onDndCancel();

	console.log("Target.onDndDrop    END OF this.onDndCancel");
}	// OVERRIDE onDndDrop TO USE dojo.connect TO ADD EVENT TO NEW ITEM







});

}

if(!dojo._hasResource["dojox.html.metrics"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.html.metrics"] = true;
dojo.provide("dojox.html.metrics");

(function(){
	var dhm = dojox.html.metrics;

	//	derived from Morris John's emResized measurer
	dhm.getFontMeasurements = function(){
		//	summary
		//	Returns an object that has pixel equivilents of standard font size values.
		var heights = {
			'1em':0, '1ex':0, '100%':0, '12pt':0, '16px':0, 'xx-small':0, 'x-small':0,
			'small':0, 'medium':0, 'large':0, 'x-large':0, 'xx-large':0
		};
	
		if(dojo.isIE){
			//	we do a font-size fix if and only if one isn't applied already.
			//	NOTE: If someone set the fontSize on the HTML Element, this will kill it.
			dojo.doc.documentElement.style.fontSize="100%";
		}
	
		//	set up the measuring node.
		var div=dojo.doc.createElement("div");
		var ds = div.style;
		ds.position="absolute";
		ds.left="-100px";
		ds.top="0";
		ds.width="30px";
		ds.height="1000em";
		ds.borderWidth="0";
		ds.margin="0";
		ds.padding="0";
		ds.outline="0";
		ds.lineHeight="1";
		ds.overflow="hidden";
		dojo.body().appendChild(div);
	
		//	do the measurements.
		for(var p in heights){
			ds.fontSize = p;
			heights[p] = Math.round(div.offsetHeight * 12/16) * 16/12 / 1000;
		}
		
		dojo.body().removeChild(div);
		div = null;
		return heights; 	//	object
	};

	var fontMeasurements = null;
	
	dhm.getCachedFontMeasurements = function(recalculate){
		if(recalculate || !fontMeasurements){
			fontMeasurements = dhm.getFontMeasurements();
		}
		return fontMeasurements;
	};

	var measuringNode = null, empty = {};
	dhm.getTextBox = function(/* String */ text, /* Object */ style, /* String? */ className){
		var m, s;
		if(!measuringNode){
			m = measuringNode = dojo.doc.createElement("div");
			// Container that we can set contraints on so that it doesn't
			// trigger a scrollbar.
			var c = dojo.doc.createElement("div");
			c.appendChild(m);
			s = c.style;
			s.overflow='scroll';
			s.position = "absolute";
			s.left = "0px";
			s.top = "-10000px";
			s.width = "1px";
			s.height = "1px";
			s.visibility = "hidden";
			s.borderWidth = "0";
			s.margin = "0";
			s.padding = "0";
			s.outline = "0";
			dojo.body().appendChild(c);
		}else{
			m = measuringNode;
		}
		// reset styles
		m.className = "";
		s = m.style;
		s.borderWidth = "0";
		s.margin = "0";
		s.padding = "0";
		s.outline = "0";
		// set new style
		if(arguments.length > 1 && style){
			for(var i in style){
				if(i in empty){ continue; }
				s[i] = style[i];
			}
		}
		// set classes
		if(arguments.length > 2 && className){
			m.className = className;
		}
		// take a measure
		m.innerHTML = text;
		var box = dojo.position(m);
		// position doesn't report right (reports 1, since parent is 1)
		// So we have to look at the scrollWidth to get the real width
		// Height is right.
		box.w = m.parentNode.scrollWidth;
		return box;
	};

	//	determine the scrollbar sizes on load.
	var scroll={ w:16, h:16 };
	dhm.getScrollbar=function(){ return { w:scroll.w, h:scroll.h }; };

	dhm._fontResizeNode = null;

	dhm.initOnFontResize = function(interval){
		var f = dhm._fontResizeNode = dojo.doc.createElement("iframe");
		var fs = f.style;
		fs.position = "absolute";
		fs.width = "5em";
		fs.height = "10em";
		fs.top = "-10000px";
		if(dojo.isIE){
			f.onreadystatechange = function(){
				if(f.contentWindow.document.readyState == "complete"){
					f.onresize = f.contentWindow.parent[dojox._scopeName].html.metrics._fontresize;
				}
			};
		}else{
			f.onload = function(){
				f.contentWindow.onresize = f.contentWindow.parent[dojox._scopeName].html.metrics._fontresize;
			};
		}
		//The script tag is to work around a known firebug race condition.  See comments in bug #9046
		f.setAttribute("src", "javascript:'<html><head><script>if(\"loadFirebugConsole\" in window){window.loadFirebugConsole();}</script></head><body></body></html>'");
		dojo.body().appendChild(f);
		dhm.initOnFontResize = function(){};
	};

	dhm.onFontResize = function(){};
	dhm._fontresize = function(){
		dhm.onFontResize();
	}

	dojo.addOnUnload(function(){
		// destroy our font resize iframe if we have one
		var f = dhm._fontResizeNode;
		if(f){
			if(dojo.isIE && f.onresize){
				f.onresize = null;
			}else if(f.contentWindow && f.contentWindow.onresize){
				f.contentWindow.onresize = null;
			}
			dhm._fontResizeNode = null;
		}
	});

	dojo.addOnLoad(function(){
		// getScrollbar metrics node
		try{
			var n=dojo.doc.createElement("div");
			n.style.cssText = "top:0;left:0;width:100px;height:100px;overflow:scroll;position:absolute;visibility:hidden;";
			dojo.body().appendChild(n);
			scroll.w = n.offsetWidth - n.clientWidth;
			scroll.h = n.offsetHeight - n.clientHeight;
			dojo.body().removeChild(n);
			//console.log("Scroll bar dimensions: ", scroll);
			delete n;
		}catch(e){}

		// text size poll setup
		if("fontSizeWatch" in dojo.config && !!dojo.config.fontSizeWatch){
			dhm.initOnFontResize();
		}
	});
})();

}

if(!dojo._hasResource["dojox.widget.RollingList"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.widget.RollingList"] = true;
dojo.provide("dojox.widget.RollingList");
dojo.experimental("dojox.widget.RollingList");















dojo.declare("dojox.widget._RollingListPane",
	[dijit.layout.ContentPane, dijit._Templated, dijit._Contained], {
	// summary: a core pane that can be attached to a RollingList.  All panes
	//  should extend this one

	// templateString: string
	//	our template
	templateString: '<div class="dojoxRollingListPane"><table><tbody><tr><td dojoAttachPoint="containerNode"></td></tr></tbody></div>',

	// parentWidget: dojox.widget.RollingList
	//  Our rolling list widget
	parentWidget: null,
	
	// parentPane: dojox.widget._RollingListPane
	//  The pane that immediately precedes ours
	parentPane: null,
			
	// store: store
	//  the store we must use
	store: null,

	// items: item[]
	//  an array of (possibly not-yet-loaded) items to display in this.
	//  If this array is null, then the query and query options are used to
	//  get the top-level items to use.  This array is also used to watch and
	//  see if the pane needs to be reloaded (store notifications are handled)
	//  by the pane
	items: null,
	
	// query: object
	//  a query to pass to the datastore.  This is only used if items are null
	query: null,
	
	// queryOptions: object
	//  query options to be passed to the datastore
	queryOptions: null,
	
	// focusByNode: boolean
	//  set to false if the subclass will handle its own node focusing
	_focusByNode: true,
	
	// minWidth: integer
	//	the width (in px) for this pane
	minWidth: 0,
	
	_setContentAndScroll: function(/*String|DomNode|Nodelist*/cont, /*Boolean?*/isFakeContent){
		// summary: sets the value of the content and scrolls it into view
		this._setContent(cont, isFakeContent);
		this.parentWidget.scrollIntoView(this);
	},

	_updateNodeWidth: function(n, min){
		// summary: updates the min width of the pane to be minPaneWidth
		n.style.width = "";
		var nWidth = dojo.marginBox(n).w;
		if(nWidth < min){
			dojo.marginBox(n, {w: min});
		}
	},
	
	_onMinWidthChange: function(v){
		// Called when the min width of a pane has changed
		this._updateNodeWidth(this.domNode, v);
	},
	
	_setMinWidthAttr: function(v){
		if(v !== this.minWidth){
			this.minWidth = v;
			this._onMinWidthChange(v);
		}
	},
	
	startup: function(){
		if(this._started){ return; }
		if(this.store && this.store.getFeatures()["dojo.data.api.Notification"]){
			window.setTimeout(dojo.hitch(this, function(){
				// Set connections after a slight timeout to avoid getting in the
				// condition where we are setting them while events are still
				// being fired
				this.connect(this.store, "onSet", "_onSetItem");
				this.connect(this.store, "onNew", "_onNewItem");
				this.connect(this.store, "onDelete", "_onDeleteItem");
			}), 1);
		}
		this.connect(this.focusNode||this.domNode, "onkeypress", "_focusKey");
		this.parentWidget._updateClass(this.domNode, "Pane");
		this.inherited(arguments);
		this._onMinWidthChange(this.minWidth);
	},

	_focusKey: function(/*Event*/e){
		// summary: called when a keypress happens on the widget
		if(e.charOrCode == dojo.keys.BACKSPACE){
			dojo.stopEvent(e);
			return;
		}else if(e.charOrCode == dojo.keys.LEFT_ARROW && this.parentPane){
			this.parentPane.focus();
			this.parentWidget.scrollIntoView(this.parentPane);
		}else if(e.charOrCode == dojo.keys.ENTER){
			this.parentWidget._onExecute();
		}
	},
	
	focus: function(/*boolean*/force){
		// summary: sets the focus to this current widget
		if(this.parentWidget._focusedPane != this){
			this.parentWidget._focusedPane = this;
			this.parentWidget.scrollIntoView(this);
			if(this._focusByNode && (!this.parentWidget._savedFocus || force)){
				try{(this.focusNode||this.domNode).focus();}catch(e){}
			}
		}
	},
	
	_onShow: function(){
			//console.log("dojox.widget.RollingListPane._onShow    caller: " + this._onShow.caller.nom);
		
		// summary: checks that the store is loaded
		if((this.store || this.items) && ((this.refreshOnShow && this.domNode) || (!this.isLoaded && this.domNode))){
			console.log("dojox.widget.RollingListPane._onShow    Doing this.refresh()");
			this.refresh();
		}
	},
	
	_load: function(){
		// summary: sets the "loading" message and then kicks off a query asyncronously
		console.log("dojox.widget.RollingListPane._load    caller: " + this._load.caller.nom);
		
		this.isLoaded = false;
		if(this.items){
			this._setContentAndScroll(this.onLoadStart(), true);
			window.setTimeout(dojo.hitch(this, "_doQuery"), 1);
		}else{

			console.log("dojox.widget.RollingListPane._load    Doing this._doQuery()");
			this._doQuery();
		}
	},
	
	_doLoadItems: function(/*item[]*/items, /*function*/callback){
		// summary: loads the given items, and then calls the callback when they
		//		are finished.
		var _waitCount = 0, store = this.store;
		dojo.forEach(items, function(item){
			if(!store.isItemLoaded(item)){ _waitCount++; }
		});
		if(_waitCount === 0){
			callback();
		}else{
			var onItem = function(item){
				_waitCount--;
				if((_waitCount) === 0){
					callback();
				}
			};
			dojo.forEach(items, function(item){
				if(!store.isItemLoaded(item)){
					store.loadItem({item: item, onItem: onItem});
				}
			});
		}
	},
	
	_doQuery: function(){
		// summary: either runs the query or loads potentially not-yet-loaded items.
		if(!this.domNode){return;}
		var preload = this.parentWidget.preloadItems;
		preload = (preload === true || (this.items && this.items.length <= Number(preload)));
		if(this.items && preload){
			this._doLoadItems(this.items, dojo.hitch(this, "onItems"));
		}else if(this.items){
			this.onItems();
		}else{
			this._setContentAndScroll(this.onFetchStart(), true);
			
			console.log("dojox.widget.RollingList._doQuery    this.query: " + this.query);
			this.store.fetch({query: this.query,
				onComplete: function(items){
					this.items = items;
					this.onItems();
				},
				onError: function(e){
					this._onError("Fetch", e);
				},
				scope: this});
		}
	},

	_hasItem: function(/* item */ item){
		// summary: returns whether or not the given item is handled by this
		//  pane
		var items = this.items || [];
		for(var i = 0, myItem; (myItem = items[i]); i++){
			if(this.parentWidget._itemsMatch(myItem, item)){
				return true;
			}
		}
		return false;
	},
	
	_onSetItem: function(/* item */ item,
					/* attribute-name-string */ attribute,
					/* object | array */ oldValue,
					/* object | array */ newValue){
		// Summary: called when an item in the store has changed
		if(this._hasItem(item)){
			this.refresh();
		}
	},
	
	_onNewItem: function(/* item */ newItem, /*object?*/ parentInfo){
		// Summary: called when an item is added to the store
		var sel;
		if((!parentInfo && !this.parentPane) ||
			(parentInfo && this.parentPane && this.parentPane._hasItem(parentInfo.item) &&
			(sel = this.parentPane._getSelected()) && this.parentWidget._itemsMatch(sel.item, parentInfo.item))){
			this.items.push(newItem);
			this.refresh();
		}else if(parentInfo && this.parentPane && this._hasItem(parentInfo.item)){
			this.refresh();
		}
	},
	
	_onDeleteItem: function(/* item */ deletedItem){
		// Summary: called when an item is removed from the store
		if(this._hasItem(deletedItem)){
			this.items = dojo.filter(this.items, function(i){
				return (i != deletedItem);
			});
			this.refresh();
		}
	},
	
	onFetchStart: function(){
		// summary:
		//		called before a fetch starts
		return this.loadingMessage;
	},
	
	onFetchError: function(/*Error*/ error){
		// summary:
		//	called when a fetch error occurs.
		return this.errorMessage;
	},

	onLoadStart: function(){
		// summary:
		//		called before a load starts
		return this.loadingMessage;
	},
	
	onLoadError: function(/*Error*/ error){
		// summary:
		//	called when a load error occurs.
		return this.errorMessage;
	},
	
	onItems: function(){
		// summary:
		//	called after a fetch or load - at this point, this.items should be
		//  set and loaded.  Override this function to "do your stuff"
		if(!this.onLoadDeferred){
			this.cancel();
			this.onLoadDeferred = new dojo.Deferred(dojo.hitch(this, "cancel"));
		}
		
		console.log("RollingList.onItems    Doing this._onLoadHandler()");
		
		this._onLoadHandler();
	}
			
});

dojo.declare("dojox.widget._RollingListGroupPane",
	[dojox.widget._RollingListPane], {
	// summary: a pane that will handle groups (treats them as menu items)
	
	// templateString: string
	//	our template
	templateString: '<div><div dojoAttachPoint="containerNode"></div>' +
					'<div dojoAttachPoint="menuContainer">' +
						'<div dojoAttachPoint="menuNode"></div>' +
					'</div></div>',

	// _menu: dijit.Menu
	//  The menu that we will call addChild() on for adding items
	_menu: null,
	
	_setContent: function(/*String|DomNode|Nodelist*/cont){
		if(!this._menu){
			// Only set the content if we don't already have a menu
			this.inherited(arguments);
		}
	},

	_onMinWidthChange: function(v){
		// override and resize the menu instead
		if(!this._menu){ return; }
		var dWidth = dojo.marginBox(this.domNode).w;
		var mWidth = dojo.marginBox(this._menu.domNode).w;
		this._updateNodeWidth(this._menu.domNode, v - (dWidth - mWidth));
	},

	onItems: function(){
		// summary:
		//	called after a fetch or load
		var selectItem, hadChildren = false;
		if(this._menu){
			selectItem = this._getSelected();
			this._menu.destroyRecursive();
		}
		this._menu = this._getMenu();
		var child, selectMenuItem;
		if(this.items.length){
			dojo.forEach(this.items, function(item){
				child = this.parentWidget._getMenuItemForItem(item, this);
				if(child){
					if(selectItem && this.parentWidget._itemsMatch(child.item, selectItem.item)){
						selectMenuItem = child;
					}
					this._menu.addChild(child);
				}
			}, this);
		}else{
			child = this.parentWidget._getMenuItemForItem(null, this);
			if(child){
				this._menu.addChild(child);
			}
		}
		if(selectMenuItem){
			this._setSelected(selectMenuItem);
			if((selectItem && !selectItem.children && selectMenuItem.children) ||
				(selectItem && selectItem.children && !selectMenuItem.children)){
				var itemPane = this.parentWidget._getPaneForItem(selectMenuItem.item, this, selectMenuItem.children);
				if(itemPane){
					this.parentWidget.addChild(itemPane, this.getIndexInParent() + 1);
				}else{
					this.parentWidget._removeAfter(this);
					this.parentWidget._onItemClick(null, this, selectMenuItem.item, selectMenuItem.children);
				}
			}
		}else if(selectItem){
			this.parentWidget._removeAfter(this);
		}
		this.containerNode.innerHTML = "";
		this.containerNode.appendChild(this._menu.domNode);
		this.parentWidget.scrollIntoView(this);
		this._checkScrollConnection(true);
		this.inherited(arguments);
		this._onMinWidthChange(this.minWidth);
	},
	
	_checkScrollConnection: function(doLoad){
		// summary: checks whether or not we need to connect to our onscroll
		//		function
		var store = this.store
		if(this._scrollConn){
			this.disconnect(this._scrollConn);
		}
		delete this._scrollConn;
		if(!dojo.every(this.items, function(i){return store.isItemLoaded(i);})){
			if(doLoad){
				this._loadVisibleItems();
			}
			this._scrollConn = this.connect(this.domNode, "onscroll", "_onScrollPane");
		}
	},
	
	startup: function(){
		this.inherited(arguments);
		this.parentWidget._updateClass(this.domNode, "GroupPane");
	},
	
	focus: function(/*boolean*/force){
		// summary: sets the focus to this current widget
		if(this._menu){
			if(this._pendingFocus){
				this.disconnect(this._pendingFocus);
			}
			delete this._pendingFocus;
			
			// We focus the right widget - either the focusedChild, the
			//   selected node, the first menu item, or the menu itself
			var focusWidget = this._menu.focusedChild;
			if(!focusWidget){
				var focusNode = dojo.query(".dojoxRollingListItemSelected", this.domNode)[0];
				if(focusNode){
					focusWidget = dijit.byNode(focusNode);
				}
			}
			if(!focusWidget){
				focusWidget = this._menu.getChildren()[0] || this._menu;
			}
			this._focusByNode = false;
			if(focusWidget.focusNode){
				if(!this.parentWidget._savedFocus || force){
					try{focusWidget.focusNode.focus();}catch(e){}
				}
				window.setTimeout(function(){
					try{
						dojo.window.scrollIntoView(focusWidget.focusNode);
					}catch(e){}
				}, 1);
			}else if(focusWidget.focus){
				if(!this.parentWidget._savedFocus || force){
					focusWidget.focus();
				}
			}else{
				this._focusByNode = true;
			}
			this.inherited(arguments);
		}else if(!this._pendingFocus){
			this._pendingFocus = this.connect(this, "onItems", "focus");
		}
	},
	
	_getMenu: function(){
		// summary: returns a widget to be used for the container widget.
		var self = this;
		var menu = new dijit.Menu({
			parentMenu: this.parentPane ? this.parentPane._menu : null,
			onCancel: function(/*Boolean*/ closeAll){
				if(self.parentPane){
					self.parentPane.focus(true);
				}
			},
			_moveToPopup: function(/*Event*/ evt){
				if(this.focusedChild && !this.focusedChild.disabled){
					this.focusedChild._onClick(evt);
				}
			}
		}, this.menuNode);
		this.connect(menu, "onItemClick", function(/*dijit.MenuItem*/ item, /*Event*/ evt){
			if(item.disabled){ return; }
			evt.alreadySelected = dojo.hasClass(item.domNode, "dojoxRollingListItemSelected");
			if(evt.alreadySelected &&
				((evt.type == "keypress" && evt.charOrCode != dojo.keys.ENTER) ||
				(evt.type == "internal"))){
				var p = this.parentWidget.getChildren()[this.getIndexInParent() + 1];
				if(p){
					p.focus(true);
					this.parentWidget.scrollIntoView(p);
				}
			}else{
				this._setSelected(item, menu);
				this.parentWidget._onItemClick(evt, this, item.item, item.children);
				if(evt.type == "keypress" && evt.charOrCode == dojo.keys.ENTER){
					this.parentWidget._onExecute();
				}
			}
		});
		if(!menu._started){
			menu.startup();
		}
		return menu;
	},
	
	_onScrollPane: function(){
		// summary: called when the pane has been scrolled - it sets a timeout
		//		so that we don't try and load our visible items too often during
		//		a scroll
		if(this._visibleLoadPending){
			window.clearTimeout(this._visibleLoadPending);
		}
		this._visibleLoadPending = window.setTimeout(dojo.hitch(this, "_loadVisibleItems"), 500);
	},
	
	_loadVisibleItems: function(){
		// summary: loads the items that are currently visible in the pane
		delete this._visibleLoadPending
		var menu = this._menu;
		if(!menu){ return; }
		var children = menu.getChildren();
		if(!children || !children.length){ return; }
		var gpbme = function(n, m, pb){
			var s = dojo.getComputedStyle(n);
			var r = 0;
			if(m){ r += dojo._getMarginExtents(n, s).t; }
			if(pb){ r += dojo._getPadBorderExtents(n, s).t; }
			return r;
		};
		var topOffset = gpbme(this.domNode, false, true) +
						gpbme(this.containerNode, true, true) +
						gpbme(menu.domNode, true, true) +
						gpbme(children[0].domNode, true, false);
		var h = dojo.contentBox(this.domNode).h;
		var minOffset = this.domNode.scrollTop - topOffset - (h/2);
		var maxOffset = minOffset + (3*h/2);
		var menuItemsToLoad = dojo.filter(children, function(c){
			var cnt = c.domNode.offsetTop;
			var s = c.store;
			var i = c.item;
			return (cnt >= minOffset && cnt <= maxOffset && !s.isItemLoaded(i));
		})
		var itemsToLoad = dojo.map(menuItemsToLoad, function(c){
			return c.item;
		});
		var onItems = dojo.hitch(this, function(){
			var selectItem = this._getSelected();
			var selectMenuItem;
			dojo.forEach(itemsToLoad, function(item, idx){
				var newItem = this.parentWidget._getMenuItemForItem(item, this);
				var oItem = menuItemsToLoad[idx];
				var oIdx = oItem.getIndexInParent();
				menu.removeChild(oItem);
				if(newItem){
					if(selectItem && this.parentWidget._itemsMatch(newItem.item, selectItem.item)){
						selectMenuItem = newItem;
					}
					menu.addChild(newItem, oIdx);
					if(menu.focusedChild == oItem){
						menu.focusChild(newItem);
					}
				}
				oItem.destroy();
			}, this);
			this._checkScrollConnection(false);
		});
		this._doLoadItems(itemsToLoad, onItems);
	},
	
	_getSelected: function(/*dijit.Menu?*/ menu){
		// summary:
		//	returns the selected menu item - or null if none are selected
		if(!menu){ menu = this._menu; }
		if(menu){
			var children = this._menu.getChildren();
			for(var i = 0, item; (item = children[i]); i++){
				if(dojo.hasClass(item.domNode, "dojoxRollingListItemSelected")){
					return item;
				}
			}
		}
		return null;
	},
	
	_setSelected: function(/*dijit.MenuItem?*/ item, /*dijit.Menu?*/ menu){
		// summary:
		//	selectes the given item in the given menu (defaults to pane's menu)
		if(!menu){ menu = this._menu;}
		if(menu){
			dojo.forEach(menu.getChildren(), function(i){
				this.parentWidget._updateClass(i.domNode, "Item", {"Selected": (item && (i == item && !i.disabled))});
			}, this);
		}
	}
});

dojo.declare("dojox.widget.RollingList",
	[dijit._Widget, dijit._Templated, dijit._Container], {
	// summary: a rolling list that can be tied to a data store with children
		
	// templateString: String
	//		The template to be used to construct the widget.
	templateString: dojo.cache("dojox.widget", "RollingList/RollingList.html", "<div class=\"dojoxRollingList ${className}\"\n\t><div class=\"dojoxRollingListContainer\" dojoAttachPoint=\"containerNode\" dojoAttachEvent=\"onkeypress:_onKey\"\n\t></div\n\t><div class=\"dojoxRollingListButtons\" dojoAttachPoint=\"buttonsNode\"\n        ><button dojoType=\"dijit.form.Button\" dojoAttachPoint=\"okButton\"\n\t\t\t\tdojoAttachEvent=\"onClick:_onExecute\">${okButtonLabel}</button\n        ><button dojoType=\"dijit.form.Button\" dojoAttachPoint=\"cancelButton\"\n\t\t\t\tdojoAttachEvent=\"onClick:_onCancel\">${cancelButtonLabel}</button\n\t></div\n></div>\n"),
	widgetsInTemplate: true,
	
	// className: string
	//  an additional class (or space-separated classes) to add for our widget
	className: "",
	
	// store: store
	//  the store we must use
	store: null,
	
	// query: object
	//  a query to pass to the datastore.  This is only used if items are null
	query: null,
	
	// queryOptions: object
	//  query options to be passed to the datastore
	queryOptions: null,
	
	// childrenAttrs: String[]
	//		one ore more attributes that holds children of a node
	childrenAttrs: ["children"],

	// parentAttr: string
	//	the attribute to read for finding our parent item (if any)
	parentAttr: "",
	
	// value: item
	//		The value that has been selected
	value: null,
	
	// executeOnDblClick: boolean
	//		Set to true if you want to call onExecute when an item is
	//		double-clicked, false if you want to call onExecute yourself. (mainly
	//		used for popups to control how they want to be handled)
	executeOnDblClick: true,
	
	// preloadItems: boolean or int
	//		if set to true, then onItems will be called only *after* all items have
	//		been loaded (ie store.isLoaded will return true for all of them).  If
	//		false, then no preloading will occur.  If set to an integer, preloading
	//		will occur if the number of items is less than or equal to the value
	//		of the integer.  The onItems function will need to be aware of handling
	//		items that may not be loaded
	preloadItems: false,
	
	// showButtons: boolean
	//		if set to true, then buttons for "OK" and "Cancel" will be provided
	showButtons: false,
	
	// okButtonLabel: string
	//		The string to use for the OK button - will use dijit's common "OK" string
	//		if not set
	okButtonLabel: "",
	
	// cancelButtonLabel: string
	//		The string to use for the Cancel button - will use dijit's common
	//		"Cancel" string if not set
	cancelButtonLabel: "",

	// minPaneWidth: integer
	//	the minimum pane width (in px) for all child panes.  If they are narrower,
	//  the width will be increased to this value.
	minPaneWidth: 0,
	
	postMixInProperties: function(){
		// summary: Mix in our labels, if they are not set
		this.inherited(arguments);
		var loc = dojo.i18n.getLocalization("dijit", "common");
		this.okButtonLabel = this.okButtonLabel || loc.buttonOk;
		this.cancelButtonLabel = this.cancelButtonLabel || loc.buttonCancel;
	},
	
	_setShowButtonsAttr: function(doShow){
		// summary: Sets the visibility of the buttons for the widget
		var needsLayout = false;
		if((this.showButtons != doShow && this._started) ||
			(this.showButtons == doShow && !this.started)){
			needsLayout = true;
		}
		dojo.toggleClass(this.domNode, "dojoxRollingListButtonsHidden", !doShow);
		this.showButtons = doShow;
		if(needsLayout){
			if(this._started){
				this.layout();
			}else{
				window.setTimeout(dojo.hitch(this, "layout"), 0);
			}
		}
	},
	
	_itemsMatch: function(/*item*/ item1, /*item*/ item2){
		// Summary: returns whether or not the two items match - checks ID if
		//  they aren't the exact same object
		if(!item1 && !item2){
			return true;
		}else if(!item1 || !item2){
			return false;
		}
		return (item1 == item2 ||
			(this._isIdentity && this.store.getIdentity(item1) == this.store.getIdentity(item2)));
	},
	
	_removeAfter: function(/*Widget or int*/ idx){
		// summary: removes all widgets after the given widget (or index)
		if(typeof idx != "number"){
			idx = this.getIndexOfChild(idx);
		}
		if(idx >= 0){
			dojo.forEach(this.getChildren(), function(c, i){
				if(i > idx){
					this.removeChild(c);
					c.destroyRecursive();
				}
			}, this);
		}
		var children = this.getChildren(), child = children[children.length - 1];
		var selItem = null;
		while(child && !selItem){
			var val = child._getSelected ? child._getSelected() : null;
			if(val){
				selItem = val.item;
			}
			child = child.parentPane;
		}
		if(!this._setInProgress){
			this._setValue(selItem);
		}
	},
	
	addChild: function(/*dijit._Widget*/ widget, /*int?*/ insertIndex){
		// summary: adds a child to this rolling list - if passed an insertIndex,
		//  then all children from that index on will be removed and destroyed
		//  before adding the child.
		if(insertIndex > 0){
			this._removeAfter(insertIndex - 1);
		}
		this.inherited(arguments);
		if(!widget._started){
			widget.startup();
		}
		widget.attr("minWidth", this.minPaneWidth);
		this.layout();
		if(!this._savedFocus){
			widget.focus();
		}
	},
	
	_setMinPaneWidthAttr: function(value){
		// summary:
		//		Sets the min pane width of all children
		if(value !== this.minPaneWidth){
			this.minPaneWidth = value;
			dojo.forEach(this.getChildren(), function(c){
				c.attr("minWidth", value);
			});
		}
	},
	
	_updateClass: function(/* Node */ node, /* String */ type, /* Object? */ options){
		// summary:
		//		sets the state of the given node with the given type and options
		// options:
		//		an object with key-value-pairs.  The values are boolean, if true,
		//		the key is added as a class, if false, it is removed.
		if(!this._declaredClasses){
			this._declaredClasses = ("dojoxRollingList " + this.className).split(" ");
		}
		dojo.forEach(this._declaredClasses, function(c){
			if(c){
				dojo.addClass(node, c + type);
				for(var k in options||{}){
					dojo.toggleClass(node, c + type + k, options[k]);
				}
				dojo.toggleClass(node, c + type + "FocusSelected",
					(dojo.hasClass(node, c + type + "Focus") && dojo.hasClass(node, c + type + "Selected")));
				dojo.toggleClass(node, c + type + "HoverSelected",
					(dojo.hasClass(node, c + type + "Hover") && dojo.hasClass(node, c + type + "Selected")));
			}
		});
	},
	
	scrollIntoView: function(/*dijit._Widget*/ childWidget){
		// summary: scrolls the given widget into view
		if(this._scrollingTimeout){
			window.clearTimeout(this._scrollingTimeout);
		}
		delete this._scrollingTimeout;
		this._scrollingTimeout = window.setTimeout(dojo.hitch(this, function(){
			if(childWidget.domNode){
				dojo.window.scrollIntoView(childWidget.domNode);
			}
			delete this._scrollingTimeout;
			return;
		}), 1);
	},
	
	resize: function(args){
		dijit.layout._LayoutWidget.prototype.resize.call(this, args);
	},
	
	layout: function(){
		var children = this.getChildren();
		if(this._contentBox){
			var bn = this.buttonsNode;
			var height = this._contentBox.h - dojo.marginBox(bn).h -
								dojox.html.metrics.getScrollbar().h;
			dojo.forEach(children, function(c){
				dojo.marginBox(c.domNode, {h: height});
			});
		}
		if(this._focusedPane){
			var foc = this._focusedPane;
			delete this._focusedPane;
			if(!this._savedFocus){
				foc.focus();
			}
		}else if(children && children.length){
			if(!this._savedFocus){
				children[0].focus();
			}
		}
	},
	
	_onChange: function(/*item*/ value){
		this.onChange(value);
	},

	_setValue: function(/* item */ value){
		// summary: internally sets the value and fires onchange
		delete this._setInProgress;
		if(!this._itemsMatch(this.value, value)){
			this.value = value;
			this._onChange(value);
		}
	},
	
	_setValueAttr: function(/* item */ value){
		// summary: sets the value of this widget to the given store item
		if(this._itemsMatch(this.value, value) && !value){ return; }
		if(this._setInProgress && this._setInProgress === value){ return; }
		this._setInProgress = value;
		if(!value || !this.store.isItem(value)){
			var pane = this.getChildren()[0];
			pane._setSelected(null);
			this._onItemClick(null, pane, null, null);
			return;
		}
		
		var fetchParentItems = dojo.hitch(this, function(/*item*/ item, /*function*/callback){
			// Summary: Fetchs the parent items for the given item
			var store = this.store, id;
			if(this.parentAttr && store.getFeatures()["dojo.data.api.Identity"] &&
				((id = this.store.getValue(item, this.parentAttr)) || id === "")){
				// Fetch by parent attribute
				var cb = function(i){
					if(store.getIdentity(i) == store.getIdentity(item)){
						callback(null);
					}else{
						callback([i]);
					}
				};
				if(id === ""){
					callback(null);
				}else if(typeof id == "string"){
					store.fetchItemByIdentity({identity: id, onItem: cb});
				}else if(store.isItem(id)){
					cb(id);
				}
			}else{
				// Fetch by finding children
				var numCheck = this.childrenAttrs.length;
				var parents = [];
				dojo.forEach(this.childrenAttrs, function(attr){
					var q = {};
					q[attr] = item;
					store.fetch({query: q, scope: this,
						onComplete: function(items){
							if(this._setInProgress !== value){
								return;
							}
							parents = parents.concat(items);
							numCheck--;
							if(numCheck === 0){
								callback(parents);
							}
						}
					});
				}, this);
			}
		});
		
		var setFromChain = dojo.hitch(this, function(/*item[]*/itemChain, /*integer*/idx){
			// Summary: Sets the value of the widget at the given index in the chain - onchanges are not
			// fired here
			var set = itemChain[idx];
			var child = this.getChildren()[idx];
			var conn;
			if(set && child){
				var fx = dojo.hitch(this, function(){
					if(conn){
						this.disconnect(conn);
					}
					delete conn;
					if(this._setInProgress !== value){
						return;
					}
					var selOpt = dojo.filter(child._menu.getChildren(), function(i){
						return this._itemsMatch(i.item, set);
					}, this)[0];
					if(selOpt){
						idx++;
						child._menu.onItemClick(selOpt, {type: "internal",
													stopPropagation: function(){},
													preventDefault: function(){}});
						if(itemChain[idx]){
							setFromChain(itemChain, idx);
						}else{
							this._setValue(set);
							this.onItemClick(set, child, this.getChildItems(set));
						}
					}
				});
				if(!child.isLoaded){
					conn = this.connect(child, "onLoad", fx);
				}else{
					fx();
				}
			}else if(idx === 0){
				this.set("value", null);
			}
		});
		
		var parentChain = [];
		var onParents = dojo.hitch(this, function(/*item[]*/ parents){
			// Summary: recursively grabs the parents - only the first one is followed
			if(parents && parents.length){
				parentChain.push(parents[0]);
				fetchParentItems(parents[0], onParents);
			}else{
				if(!parents){
					parentChain.pop();
				}
				parentChain.reverse();
				setFromChain(parentChain, 0);
			}
		});
		
		// Only set the value in display if we are shown - if we are in a dropdown,
		// and are hidden, don't actually do the scrolling in the display (it can
		// mess up layouts)
		var ns = this.domNode.style;
		if(ns.display == "none" || ns.visibility == "hidden"){
			this._setValue(value);
		}else if(!this._itemsMatch(value, this._visibleItem)){
			onParents([value]);
		}
	},
	
	_onItemClick: function(/* Event */ evt, /* dijit._Contained */ pane, /* item */ item, /* item[]? */ children){
		// summary: internally called when a widget should pop up its child
		
		if(evt){
			var itemPane = this._getPaneForItem(item, pane, children);
			var alreadySelected = (evt.type == "click" && evt.alreadySelected);

			if(alreadySelected && itemPane){
				this._removeAfter(pane.getIndexInParent() + 1);
				var next = pane.getNextSibling();
				if(next && next._setSelected){
					next._setSelected(null);
				}
				this.scrollIntoView(next);
			}else if(itemPane){
				this.addChild(itemPane, pane.getIndexInParent() + 1);
				if(this._savedFocus){
					itemPane.focus(true);
				}
			}else{
				this._removeAfter(pane);
				this.scrollIntoView(pane);
			}
		}else if(pane){
			this._removeAfter(pane);
			this.scrollIntoView(pane);
		}
		if(!evt || evt.type != "internal"){
			this._setValue(item);
			this.onItemClick(item, pane, children);
		}
		this._visibleItem = item;
	},
	
	_getPaneForItem: function(/* item? */ item, /* dijit._Contained? */ parentPane, /* item[]? */ children){		// summary: gets the pane for the given item, and mixes in our needed parts
		// Returns the pane for the given item (null if the root pane) - after mixing in
		// its stuff.

		var ret = this.getPaneForItem(item, parentPane, children);
		ret.store = this.store;
		ret.parentWidget = this;
		ret.parentPane = parentPane||null;
		if(!item){
			ret.query = this.query;
			ret.queryOptions = this.queryOptions;
		}else if(children){
			ret.items = children;
		}else{
			ret.items = [item];
		}
		return ret;
	},
	
	_getMenuItemForItem: function(/*item*/ item, /* dijit._Contained */ parentPane){
		// summary: returns a widget for the given store item.  The returned
		//  item will be added to this widget's container widget.  null will
		//  be passed in for an "empty" item.
		var store = this.store;
		if(!item || !store || !store.isItem(item)){
			var i = new dijit.MenuItem({
				label: "---",
				disabled: true,
				iconClass: "dojoxEmpty",
				focus: function(){
					// Do nothing on focus of this guy...
				}
			});
			this._updateClass(i.domNode, "Item");
			return i;
		}else{
			var itemLoaded = store.isItemLoaded(item);
			var childItems = itemLoaded ? this.getChildItems(item) : undefined;
			var widgetItem;
			if(childItems){
				widgetItem = this.getMenuItemForItem(item, parentPane, childItems);
				widgetItem.children = childItems;
				this._updateClass(widgetItem.domNode, "Item", {"Expanding": true});
				if(!widgetItem._started){
					var c = widgetItem.connect(widgetItem, "startup", function(){
						this.disconnect(c);
						dojo.style(this.arrowWrapper, "display", "");
					});
				}else{
					dojo.style(widgetItem.arrowWrapper, "display", "");
				}
			}else{
				widgetItem = this.getMenuItemForItem(item, parentPane, null);
				if(itemLoaded){
					this._updateClass(widgetItem.domNode, "Item", {"Single": true});
				}else{
					this._updateClass(widgetItem.domNode, "Item", {"Unloaded": true});
					widgetItem.attr("disabled", true);
				}
			}
			widgetItem.store = this.store;
			widgetItem.item = item;
			if(!widgetItem.label){
				widgetItem.attr("label", this.store.getLabel(item).replace(/</,"&lt;"));
			}
			if(widgetItem.focusNode){
				var self = this;
				widgetItem.focus = function(){
					// Don't set our class
					if(!this.disabled){try{this.focusNode.focus();}catch(e){}}
				};
				widgetItem.connect(widgetItem.focusNode, "onmouseenter", function(){
					if(!this.disabled){
						self._updateClass(this.domNode, "Item", {"Hover": true});
					}
				});
				widgetItem.connect(widgetItem.focusNode, "onmouseleave", function(){
					if(!this.disabled){
						self._updateClass(this.domNode, "Item", {"Hover": false});
					}
				});
				widgetItem.connect(widgetItem.focusNode, "blur", function(){
					self._updateClass(this.domNode, "Item", {"Focus": false, "Hover": false});
				});
				widgetItem.connect(widgetItem.focusNode, "focus", function(){
					self._updateClass(this.domNode, "Item", {"Focus": true});
					self._focusedPane = parentPane;
				});
				if(this.executeOnDblClick){
					widgetItem.connect(widgetItem.focusNode, "ondblclick", function(){
						self._onExecute();
					});
				}
			}
			return widgetItem;
		}
	},
	
	_setStore: function(/* dojo.data.api.Read */ store){
		// summary: sets the store for this widget */
		if(store === this.store && this._started){ return; }
		this.store = store;
		this._isIdentity = store.getFeatures()["dojo.data.api.Identity"];
		var rootPane = this._getPaneForItem();
		this.addChild(rootPane, 0);
	},
	
	_onKey: function(/*Event*/ e){
		// summary: called when a keypress event happens on this widget
		if(e.charOrCode == dojo.keys.BACKSPACE){
			dojo.stopEvent(e);
			return;
		}else if(e.charOrCode == dojo.keys.ESCAPE && this._savedFocus){
			try{dijit.focus(this._savedFocus);}catch(e){}
			dojo.stopEvent(e);
			return;
		}else if(e.charOrCode == dojo.keys.LEFT_ARROW ||
			e.charOrCode == dojo.keys.RIGHT_ARROW){
			dojo.stopEvent(e);
			return;
		}
	},
	
	_resetValue: function(){
		// Summary: function called when the value is reset.
		this.set("value", this._lastExecutedValue);
	},
	
	_onCancel: function(){
		// Summary: function called when the cancel button is clicked.  It
		//		resets its value to whatever was last executed and then cancels
		this._resetValue();
		this.onCancel();
	},
	
	_onExecute: function(){
		// Summary: function called when the OK button is clicked or when an
		//		item is selected (double-clicked or "enter" pressed on it)
		this._lastExecutedValue = this.get("value");
		this.onExecute();
	},
	
	focus: function(){
		// summary: sets the focus state of this widget
		var wasSaved = this._savedFocus;
		this._savedFocus = dijit.getFocus(this);
		if(!this._savedFocus.node){
			delete this._savedFocus;
		}
		if(!this._focusedPane){
			var child = this.getChildren()[0];
			if(child && !wasSaved){
				child.focus(true);
			}
		}else{
			this._savedFocus = dijit.getFocus(this);
			var foc = this._focusedPane;
			delete this._focusedPane;
			if(!wasSaved){
				foc.focus(true);
			}
		}
	},
	
	handleKey:function(/*Event*/e){
		// summary: handle the key for the given event - called by dropdown
		//	widgets
		if(e.charOrCode == dojo.keys.DOWN_ARROW){
			delete this._savedFocus;
			this.focus();
			return false;
		}else if(e.charOrCode == dojo.keys.ESCAPE){
			this._onCancel();
			return false;
		}
		return true;
	},
	
	_updateChildClasses: function(){
		// summary: Called when a child is added or removed - so that we can
		//	update the classes for styling the "current" one differently than
		//	the others
		var children = this.getChildren();
		var length = children.length;
		dojo.forEach(children, function(c, idx){
			dojo.toggleClass(c.domNode, "dojoxRollingListPaneCurrentChild", (idx == (length - 1)));
			dojo.toggleClass(c.domNode, "dojoxRollingListPaneCurrentSelected", (idx == (length - 2)));
		});
	},

	startup: function(){
		if(this._started){ return; }
		if(!this.getParent || !this.getParent()){
			this.resize();
			this.connect(dojo.global, "onresize", "resize");
		}
		this.connect(this, "addChild", "_updateChildClasses");
		this.connect(this, "removeChild", "_updateChildClasses");
		this._setStore(this.store);
		this.set("showButtons", this.showButtons);
		this.inherited(arguments);
		this._lastExecutedValue = this.get("value");
	},
	
	getChildItems: function(/*item*/ item){
		// summary: Returns the child items for the given store item
		var childItems, store = this.store;
		dojo.forEach(this.childrenAttrs, function(attr){
			var vals = store.getValues(item, attr);
			if(vals && vals.length){
				childItems = (childItems||[]).concat(vals);
			}
		});
		return childItems;
	},
	
	getMenuItemForItem: function(/*item*/ item, /* dijit._Contained */ parentPane, /* item[]? */ children){
		// summary: user overridable function to return a widget for the given item
		//  and its children.
		return new dijit.MenuItem({});
	},

	getPaneForItem: function(/* item? */ item, /* dijit._Contained? */ parentPane, /* item[]? */ children){
		// summary: user-overridable function to return a pane that corresponds
		//  to the given item in the store.  It can return null to not add a new pane
		//  (ie, you are planning on doing something else with it in onItemClick)
		//
		//  Item is undefined for the root pane, children is undefined for non-group panes
		if(!item || children){
			return new dojox.widget._RollingListGroupPane({});
		}else{
			return null;
		}
	},

	onItemClick: function(/* item */ item, /* dijit._Contained */ pane, /* item[]? */ children){
		// summary: called when an item is clicked - it receives the store item
	},
	
	onExecute: function(){
		// summary: exists so that popups don't disappear too soon
	},
	
	onCancel: function(){
		// summary: exists so that we can close ourselves if we wish
	},
	
	onChange: function(/* item */ value){
		// summary: called when the value of this widget has changed
	}
	
});

}

if(!dojo._hasResource["dojox.html._base"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.html._base"] = true;
/*
	Status: dont know where this will all live exactly
	Need to pull in the implementation of the various helper methods
	Some can be static method, others maybe methods of the ContentSetter (?)
	
	Gut the ContentPane, replace its _setContent with our own call to dojox.html.set()
	

*/

dojo.provide("dojox.html._base");



(function() {

	if(dojo.isIE){
		var alphaImageLoader = /(AlphaImageLoader\([^)]*?src=(['"]))(?![a-z]+:|\/)([^\r\n;}]+?)(\2[^)]*\)\s*[;}]?)/g;
	}

	// css at-rules must be set before any css declarations according to CSS spec
	// match:
	// @import 'http://dojotoolkit.org/dojo.css';
	// @import 'you/never/thought/' print;
	// @import url("it/would/work") tv, screen;
	// @import url(/did/you/now.css);
	// but not:
	// @namespace dojo "http://dojotoolkit.org/dojo.css"; /* namespace URL should always be a absolute URI */
	// @charset 'utf-8';
	// @media print{ #menuRoot {display:none;} }
		
	// we adjust all paths that dont start on '/' or contains ':'
	//(?![a-z]+:|\/)

	var cssPaths = /(?:(?:@import\s*(['"])(?![a-z]+:|\/)([^\r\n;{]+?)\1)|url\(\s*(['"]?)(?![a-z]+:|\/)([^\r\n;]+?)\3\s*\))([a-z, \s]*[;}]?)/g;

	var adjustCssPaths = dojox.html._adjustCssPaths = function(cssUrl, cssText){
		//	summary:
		//		adjusts relative paths in cssText to be relative to cssUrl
		//		a path is considered relative if it doesn't start with '/' and not contains ':'
		//	description:
		//		Say we fetch a HTML page from level1/page.html
		//		It has some inline CSS:
		//			@import "css/page.css" tv, screen;
		//			...
		//			background-image: url(images/aplhaimage.png);
		//
		//		as we fetched this HTML and therefore this CSS
		//		from level1/page.html, these paths needs to be adjusted to:
		//			@import 'level1/css/page.css' tv, screen;
		//			...
		//			background-image: url(level1/images/alphaimage.png);
		//
		//		In IE it will also adjust relative paths in AlphaImageLoader()
		//			filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src='images/alphaimage.png');
		//		will be adjusted to:
		//			filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src='level1/images/alphaimage.png');
		//
		//		Please note that any relative paths in AlphaImageLoader in external css files wont work, as
		//		the paths in AlphaImageLoader is MUST be declared relative to the HTML page,
		//		not relative to the CSS file that declares it

		if(!cssText || !cssUrl){ return; }

		// support the ImageAlphaFilter if it exists, most people use it in IE 6 for transparent PNGs
		// We are NOT going to kill it in IE 7 just because the PNGs work there. Somebody might have
		// other uses for it.
		// If user want to disable css filter in IE6  he/she should
		// unset filter in a declaration that just IE 6 doesn't understands
		// like * > .myselector { filter:none; }
		if(alphaImageLoader){
			cssText = cssText.replace(alphaImageLoader, function(ignore, pre, delim, url, post){
				return pre + (new dojo._Url(cssUrl, './'+url).toString()) + post;
			});
		}

		return cssText.replace(cssPaths, function(ignore, delimStr, strUrl, delimUrl, urlUrl, media){
			if(strUrl){
				return '@import "' + (new dojo._Url(cssUrl, './'+strUrl).toString()) + '"' + media;
			}else{
				return 'url(' + (new dojo._Url(cssUrl, './'+urlUrl).toString()) + ')' + media;
			}
		});
	};

	// attributepaths one tag can have multiple paths, example:
	// <input src="..." style="url(..)"/> or <a style="url(..)" href="..">
	// <img style='filter:progid...AlphaImageLoader(src="noticeTheSrcHereRunsThroughHtmlSrc")' src="img">
	var htmlAttrPaths = /(<[a-z][a-z0-9]*\s[^>]*)(?:(href|src)=(['"]?)([^>]*?)\3|style=(['"]?)([^>]*?)\5)([^>]*>)/gi;

	var adjustHtmlPaths = dojox.html._adjustHtmlPaths = function(htmlUrl, cont){
		var url = htmlUrl || "./";

		return cont.replace(htmlAttrPaths,
			function(tag, start, name, delim, relUrl, delim2, cssText, end){
				return start + (name ?
							(name + '=' + delim + (new dojo._Url(url, relUrl).toString()) + delim)
						: ('style=' + delim2 + adjustCssPaths(url, cssText) + delim2)
				) + end;
			}
		);
	};
	
	var snarfStyles = dojox.html._snarfStyles = function	(/*String*/cssUrl, /*String*/cont, /*Array*/styles){
		/****************  cut out all <style> and <link rel="stylesheet" href=".."> **************/
		// also return any attributes from this tag (might be a media attribute)
		// if cssUrl is set it will adjust paths accordingly
		styles.attributes = [];

		return cont.replace(/(?:<style([^>]*)>([\s\S]*?)<\/style>|<link\s+(?=[^>]*rel=['"]?stylesheet)([^>]*?href=(['"])([^>]*?)\4[^>\/]*)\/?>)/gi,
			function(ignore, styleAttr, cssText, linkAttr, delim, href){
				// trim attribute
				var i, attr = (styleAttr||linkAttr||"").replace(/^\s*([\s\S]*?)\s*$/i, "$1");
				if(cssText){
					i = styles.push(cssUrl ? adjustCssPaths(cssUrl, cssText) : cssText);
				}else{
					i = styles.push('@import "' + href + '";');
					attr = attr.replace(/\s*(?:rel|href)=(['"])?[^\s]*\1\s*/gi, ""); // remove rel=... and href=...
				}
				if(attr){
					attr = attr.split(/\s+/);// split on both "\n", "\t", " " etc
					var atObj = {}, tmp;
					for(var j = 0, e = attr.length; j < e; j++){
						tmp = attr[j].split('='); // split name='value'
						atObj[tmp[0]] = tmp[1].replace(/^\s*['"]?([\s\S]*?)['"]?\s*$/, "$1"); // trim and remove ''
					}
					styles.attributes[i - 1] = atObj;
				}
				return "";
			}
		);
	};

	var snarfScripts = dojox.html._snarfScripts = function(cont, byRef){
		// summary
		//		strips out script tags from cont
		// invoke with
		//	byRef = {errBack:function(){/*add your download error code here*/, downloadRemote: true(default false)}}
		//	byRef will have {code: 'jscode'} when this scope leaves
		byRef.code = "";

		//Update script tags nested in comments so that the script tag collector doesn't pick
		//them up.
		cont = cont.replace(/<[!][-][-](.|\s)*?[-][-]>/g,
			function(comment){
				return comment.replace(/<(\/?)script\b/ig,"&lt;$1Script");
			}
		);

		function download(src){
			if(byRef.downloadRemote){
				// console.debug('downloading',src);
				//Fix up src, in case there were entity character encodings in it.
				//Probably only need to worry about a subset.
				src = src.replace(/&([a-z0-9#]+);/g, function(m, name) {
					switch(name) {
						case "amp"	: return "&";
						case "gt"	: return ">";
						case "lt"	: return "<";
						default:
							return name.charAt(0)=="#" ? String.fromCharCode(name.substring(1)) : "&"+name+";";
					}
				});
				dojo.xhrGet({
					url: src,
					sync: true,
					load: function(code){
						byRef.code += code+";";
					},
					error: byRef.errBack
				});
			}
		}
		
		// match <script>, <script type="text/..., but not <script type="dojo(/method)...
		return cont.replace(/<script\s*(?![^>]*type=['"]?(?:dojo\/|text\/html\b))(?:[^>]*?(?:src=(['"]?)([^>]*?)\1[^>]*)?)*>([\s\S]*?)<\/script>/gi,
			function(ignore, delim, src, code){
				if(src){
					download(src);
				}else{
					byRef.code += code;
				}
				return "";
			}
		);
	};
	
	var evalInGlobal = dojox.html.evalInGlobal = function(code, appendNode){
		// we do our own eval here as dojo.eval doesn't eval in global crossbrowser
		// This work X browser but but it relies on a DOM
		// plus it doesn't return anything, thats unrelevant here but not for dojo core
		appendNode = appendNode || dojo.doc.body;
		var n = appendNode.ownerDocument.createElement('script');
		n.type = "text/javascript";
		appendNode.appendChild(n);
		n.text = code; // DOM 1 says this should work
	};

	dojo.declare("dojox.html._ContentSetter", [dojo.html._ContentSetter], {
		// adjustPaths: Boolean
		//		Adjust relative paths in html string content to point to this page
		//		Only useful if you grab content from a another folder than the current one
		adjustPaths: false,
		referencePath: ".",
		renderStyles: false,

		executeScripts: false,
		scriptHasHooks: false,
		scriptHookReplacement: null,
		
		_renderStyles: function(styles){
			// insert css from content into document head
			this._styleNodes = [];
			var st, att, cssText, doc = this.node.ownerDocument;
			var head = doc.getElementsByTagName('head')[0];

			for(var i = 0, e = styles.length; i < e; i++){
				cssText = styles[i]; att = styles.attributes[i];
				st = doc.createElement('style');
				st.setAttribute("type", "text/css"); // this is required in CSS spec!

				for(var x in att){
					st.setAttribute(x, att[x]);
				}

				this._styleNodes.push(st);
				head.appendChild(st); // must insert into DOM before setting cssText

				if(st.styleSheet){ // IE
					st.styleSheet.cssText = cssText;
				}else{ // w3c
					st.appendChild(doc.createTextNode(cssText));
				}
			}
		},

		empty: function() {
			this.inherited("empty", arguments);
			
			// empty out the styles array from any previous use
			this._styles = [];
		},
		
		onBegin: function() {
			// summary
			//		Called after instantiation, but before set();
			//		It allows modification of any of the object properties - including the node and content
			//		provided - before the set operation actually takes place
			//		This implementation extends that of dojo.html._ContentSetter
			//		to add handling for adjustPaths, renderStyles on the html string content before it is set
			this.inherited("onBegin", arguments);
			
			var cont = this.content,
				node = this.node;
				
			var styles = this._styles;// init vars

			if(dojo.isString(cont)){
				if(this.adjustPaths && this.referencePath){
					cont = adjustHtmlPaths(this.referencePath, cont);
				}

				if(this.renderStyles || this.cleanContent){
					cont = snarfStyles(this.referencePath, cont, styles);
				}

				// because of a bug in IE, script tags that is first in html hierarchy doesnt make it into the DOM
				//	when content is innerHTML'ed, so we can't use dojo.query to retrieve scripts from DOM
				if(this.executeScripts){
					var _t = this;
					var byRef = {
						downloadRemote: true,
						errBack:function(e){
							_t._onError.call(_t, 'Exec', 'Error downloading remote script in "'+_t.id+'"', e);
						}
					};
					cont = snarfScripts(cont, byRef);
					this._code = byRef.code;
				}
			}
			this.content = cont;
		},
		
		onEnd: function() {
			// summary
			//		Called after set(), when the new content has been pushed into the node
			//		It provides an opportunity for post-processing before handing back the node to the caller
			//		This implementation extends that of dojo.html._ContentSetter
			
			var code = this._code,
				styles = this._styles;
				
			// clear old stylenodes from the DOM
			// these were added by the last set call
			// (in other words, if you dont keep and reuse the ContentSetter for a particular node
			// .. you'll have no practical way to do this)
			if(this._styleNodes && this._styleNodes.length){
				while(this._styleNodes.length){
					dojo.destroy(this._styleNodes.pop());
				}
			}
			// render new style nodes
			if(this.renderStyles && styles && styles.length){
				this._renderStyles(styles);
			}

			if(this.executeScripts && code){
				if(this.cleanContent){
					// clean JS from html comments and other crap that browser
					// parser takes care of in a normal page load
					code = code.replace(/(<!--|(?:\/\/)?-->|<!\[CDATA\[|\]\]>)/g, '');
				}
				if(this.scriptHasHooks){
					// replace _container_ with this.scriptHookReplace()
					// the scriptHookReplacement can be a string
					// or a function, which when invoked returns the string you want to substitute in
					code = code.replace(/_container_(?!\s*=[^=])/g, this.scriptHookReplacement);
				}
				try{
					evalInGlobal(code, this.node);
				}catch(e){
					this._onError('Exec', 'Error eval script in '+this.id+', '+e.message, e);
				}
			}
			this.inherited("onEnd", arguments);
		},
		tearDown: function() {
			this.inherited(arguments);
			delete this._styles;
			// only tear down -or another set() - will explicitly throw away the
			// references to the style nodes we added
			if(this._styleNodes && this._styleNodes.length){
				while(this._styleNodes.length){
					dojo.destroy(this._styleNodes.pop());
				}
			}
			delete this._styleNodes;
			// reset the defaults from the prototype
			dojo.mixin(this, dojo.getObject(this.declaredClass).prototype);
		}
		
	});
	
	dojox.html.set = function(/* DomNode */ node, /* String|DomNode|NodeList */ cont, /* Object? */ params){
		// TODO: add all the other options
			// summary:
			//		inserts (replaces) the given content into the given node
			//	node:
			//		the parent element that will receive the content
			//	cont:
			//		the content to be set on the parent element.
			//		This can be an html string, a node reference or a NodeList, dojo.NodeList, Array or other enumerable list of nodes
			//	params:
			//		Optional flags/properties to configure the content-setting. See dojo.html._ContentSetter
			//	example:
			//		A safe string/node/nodelist content replacement/injection with hooks for extension
			//		Example Usage:
			//		dojo.html.set(node, "some string");
			//		dojo.html.set(node, contentNode, {options});
			//		dojo.html.set(node, myNode.childNodes, {options});
	 
		if(!params){
			// simple and fast
			return dojo.html._setNodeContent(node, cont, true);
		}else{
			// more options but slower
			var op = new dojox.html._ContentSetter(dojo.mixin(
					params,
					{ content: cont, node: node }
			));
			return op.set();
		}
	};
	
})();

}

if(!dojo._hasResource["dojox.layout.ContentPane"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.layout.ContentPane"] = true;
dojo.provide("dojox.layout.ContentPane");




dojo.declare("dojox.layout.ContentPane", dijit.layout.ContentPane, {
	// summary:
	//		An extended version of dijit.layout.ContentPane.
	//		Supports infile scripts and external ones declared by <script src=''
	//		relative path adjustments (content fetched from a different folder)
	//		<style> and <link rel='stylesheet' href='..'> tags,
	//		css paths inside cssText is adjusted (if you set adjustPaths = true)
	//
	//		NOTE that dojo.require in script in the fetched file isn't recommended
	//		Many widgets need to be required at page load to work properly

	// adjustPaths: Boolean
	//		Adjust relative paths in html string content to point to this page.
	//		Only useful if you grab content from a another folder then the current one
	adjustPaths: false,

	// cleanContent: Boolean
	//	summary:
	//		cleans content to make it less likely to generate DOM/JS errors.
	//	description:
	//		useful if you send ContentPane a complete page, instead of a html fragment
	//		scans for
	//
	//			* title Node, remove
	//			* DOCTYPE tag, remove
	cleanContent: false,

	// renderStyles: Boolean
	//		trigger/load styles in the content
	renderStyles: false,

	// executeScripts: Boolean
	//		Execute (eval) scripts that is found in the content
	executeScripts: true,

	// scriptHasHooks: Boolean
	//		replace keyword '_container_' in scripts with 'dijit.byId(this.id)'
	// NOTE this name might change in the near future
	scriptHasHooks: false,

	/*======
	// ioMethod: dojo.xhrGet|dojo.xhrPost
	//		reference to the method that should grab the content
	ioMethod: dojo.xhrGet,
	
	// ioArgs: Object
	//		makes it possible to add custom args to xhrGet, like ioArgs.headers['X-myHeader'] = 'true'
	ioArgs: {},
	======*/

	constructor: function(){
		// init per instance properties, initializer doesn't work here because how things is hooked up in dijit._Widget
		this.ioArgs = {};
		this.ioMethod = dojo.xhrGet;
	},

	onExecError: function(e){
		// summary:
		//		event callback, called on script error or on java handler error
		//		overide and return your own html string if you want a some text
		//		displayed within the ContentPane
	},

	_setContent: function(cont){
		// override dijit.layout.ContentPane._setContent, to enable path adjustments
		
		var setter = this._contentSetter;
		if(! (setter && setter instanceof dojox.html._ContentSetter)) {
			setter = this._contentSetter = new dojox.html._ContentSetter({
				node: this.containerNode,
				_onError: dojo.hitch(this, this._onError),
				onContentError: dojo.hitch(this, function(e){
					// fires if a domfault occurs when we are appending this.errorMessage
					// like for instance if domNode is a UL and we try append a DIV
					var errMess = this.onContentError(e);
					try{
						this.containerNode.innerHTML = errMess;
					}catch(e){
						console.error('Fatal '+this.id+' could not change content due to '+e.message, e);
					}
				})/*,
				_onError */
			});
		};

		// stash the params for the contentSetter to allow inheritance to work for _setContent
		this._contentSetterParams = {
			adjustPaths: Boolean(this.adjustPaths && (this.href||this.referencePath)),
			referencePath: this.href || this.referencePath,
			renderStyles: this.renderStyles,
			executeScripts: this.executeScripts,
			scriptHasHooks: this.scriptHasHooks,
			scriptHookReplacement: "dijit.byId('"+this.id+"')"
		};

		this.inherited("_setContent", arguments);
	}
	// could put back _renderStyles by wrapping/aliasing dojox.html._ContentSetter.prototype._renderStyles
});

}

if(!dojo._hasResource["dojox.layout.ResizeHandle"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.layout.ResizeHandle"] = true;
dojo.provide("dojox.layout.ResizeHandle");
dojo.experimental("dojox.layout.ResizeHandle");






dojo.declare("dojox.layout.ResizeHandle",
	[dijit._Widget, dijit._Templated],
	{
	// summary: A dragable handle used to resize an attached node.
	//
	// description:
	//	The handle on the bottom-right corner of FloatingPane or other widgets that allows
	//	the widget to be resized.
	//	Typically not used directly.
	//
	// targetId: String
	//	id of the Widget OR DomNode that I will size
	targetId: "",
	
	// targetContainer: DomNode
	//	over-ride targetId and attch this handle directly to a reference of a DomNode
	targetContainer: null,
	
	// resizeAxis: String
	//	one of: x|y|xy limit resizing to a single axis, default to xy ...
	resizeAxis: "xy",
	
	// activeResize: Boolean
	// 	if true, node will size realtime with mouse movement,
	//	if false, node will create virtual node, and only resize target on mouseUp
	activeResize: false,
	
	// activeResizeClass: String
	//	css class applied to virtual resize node.
	activeResizeClass: "dojoxResizeHandleClone",
	
	// animateSizing: Boolean
	//	only applicable if activeResize = false. onMouseup, animate the node to the
	//	new size
	animateSizing: true,
	
	// animateMethod: String
	// 	one of "chain" or "combine" ... visual effect only. combine will "scale"
	// 	node to size, "chain" will alter width, then height
	animateMethod: "chain",

	// animateDuration: Integer
	//	time in MS to run sizing animation. if animateMethod="chain", total animation
	//	playtime is 2*animateDuration
	animateDuration: 225,

	// minHeight: Integer
	//	smallest height in px resized node can be
	minHeight: 100,

	// minWidth: Integer
	//	smallest width in px resize node can be
	minWidth: 100,

	// constrainMax: Boolean
	//	Toggle if this widget cares about the maxHeight and maxWidth
	//	parameters.
	constrainMax: false,

	// maxHeight: Integer
	//	Largest height size in px the resize node can become.
	maxHeight:0,
	
	// maxWidth: Integer
	//	Largest width size in px the reize node can become.
	maxWidth:0,

	// fixedAspect: Boolean
	//		Toggle to enable this widget to maintain the aspect
	//		ratio of the attached node.
	fixedAspect: false,

	// intermediateChanges: Boolean
	//		Toggle to enable/disable this widget from firing onResize
	//		events at every step of a resize. If `activeResize` is true,
	//		and this is false, onResize only fires _after_ the drop
	//		operation. Animated resizing is not affected by this setting.
	intermediateChanges: false,

	// startTopic: String
	//		The name of the topic this resizehandle publishes when resize is starting
	startTopic: "/dojo/resize/start",
	
	// endTopic: String
	//		The name of the topic this resizehandle publishes when resize is complete
	endTopic:"/dojo/resize/stop",

	templateString: '<div dojoAttachPoint="resizeHandle" class="dojoxResizeHandle"><div></div></div>',

	postCreate: function(){
		// summary: setup our one major listener upon creation
		this.connect(this.resizeHandle, "onmousedown", "_beginSizing");
		if(!this.activeResize){
			// there shall be only a single resize rubberbox that at the top
			// level so that we can overlay it on anything whenever the user
			// resizes something. Since there is only one mouse pointer he
			// can't at once resize multiple things interactively.
			this._resizeHelper = dijit.byId('dojoxGlobalResizeHelper');
			if(!this._resizeHelper){
				this._resizeHelper = new dojox.layout._ResizeHelper({
						id: 'dojoxGlobalResizeHelper'
				}).placeAt(dojo.body());
				dojo.addClass(this._resizeHelper.domNode, this.activeResizeClass);
			}
		}else{ this.animateSizing = false; }

		if(!this.minSize){
			this.minSize = { w: this.minWidth, h: this.minHeight };
		}
		
		if(this.constrainMax){
			this.maxSize = { w: this.maxWidth, h: this.maxHeight }
		}
		
		// should we modify the css for the cursor hover to n-resize nw-resize and w-resize?
		this._resizeX = this._resizeY = false;
		var addClass = dojo.partial(dojo.addClass, this.resizeHandle);
		switch(this.resizeAxis.toLowerCase()){
			case "xy" :
				this._resizeX = this._resizeY = true;
				// FIXME: need logic to determine NW or NE class to see
				// based on which [todo] corner is clicked
				addClass("dojoxResizeNW");
				break;
			case "x" :
				this._resizeX = true;
				addClass("dojoxResizeW");
				break;
			case "y" :
				this._resizeY = true;
				addClass("dojoxResizeN");
				break;
		}
	},

	_beginSizing: function(/*Event*/ e){
		// summary: setup movement listeners and calculate initial size
		
		if(this._isSizing){ return false; }

		dojo.publish(this.startTopic, [ this ]);
		this.targetWidget = dijit.byId(this.targetId);

		this.targetDomNode = this.targetWidget ? this.targetWidget.domNode : dojo.byId(this.targetId);
		if(this.targetContainer){ this.targetDomNode = this.targetContainer; }
		if(!this.targetDomNode){ return false; }

		if(!this.activeResize){
			var c = dojo.position(this.targetDomNode, true);
			console.log(c);
			console.log(dojo.window.getBox());
			this._resizeHelper.resize({l: c.x, t: c.y, w: c.w, h: c.h});
			this._resizeHelper.show();
		}

		this._isSizing = true;
		this.startPoint  = { x:e.clientX, y:e.clientY};

		// FIXME: this is funky: marginBox adds height, contentBox ignores padding (expected, but foo!)
		var mb = this.targetWidget ? dojo.marginBox(this.targetDomNode) : dojo.contentBox(this.targetDomNode);
		this.startSize  = { w:mb.w, h:mb.h };
		
		if(this.fixedAspect){
			var max, val;
			if(mb.w > mb.h){
				max = "w";
				val = mb.w / mb.h
			}else{
				max = "h";
				val = mb.h / mb.w
			}
			this._aspect = { prop: max };
			this._aspect[max] = val;
		}

		this._pconnects = [];
		this._pconnects.push(dojo.connect(dojo.doc,"onmousemove",this,"_updateSizing"));
		this._pconnects.push(dojo.connect(dojo.doc,"onmouseup", this, "_endSizing"));
		
		dojo.stopEvent(e);
	},

	_updateSizing: function(/*Event*/ e){
		// summary: called when moving the ResizeHandle ... determines
		//	new size based on settings/position and sets styles.

		if(this.activeResize){
			this._changeSizing(e);
		}else{
			var tmp = this._getNewCoords(e);
			if(tmp === false){ return; }
			this._resizeHelper.resize(tmp);
		}
		e.preventDefault();
	},

	_getNewCoords: function(/* Event */ e){
		
		// On IE, if you move the mouse above/to the left of the object being resized,
		// sometimes clientX/Y aren't set, apparently.  Just ignore the event.
		try{
			if(!e.clientX  || !e.clientY){ return false; }
		}catch(e){
			// sometimes you get an exception accessing above fields...
			return false;
		}
		this._activeResizeLastEvent = e;

		var dx = (this.isLeftToRight()? this.startPoint.x - e.clientX: e.clientX - this.startPoint.x),
			dy = this.startPoint.y - e.clientY,
			newW = this.startSize.w - (this._resizeX ? dx : 0),
			newH = this.startSize.h - (this._resizeY ? dy : 0)
		;
			
		return this._checkConstraints(newW, newH); // Object
	},
	
	_checkConstraints: function(newW, newH){
		// summary: filter through the various possible constaint possibilities.
				
		// minimum size check
		if(this.minSize){
			var tm = this.minSize;
			if(newW < tm.w){
				newW = tm.w;
			}
			if(newH < tm.h){
				newH = tm.h;
			}
		}
		
		// maximum size check:
		if(this.constrainMax && this.maxSize){
			var ms = this.maxSize;
			if(newW > ms.w){
				newW = ms.w;
			}
			if(newH > ms.h){
				newH = ms.h;
			}
		}
		
		if(this.fixedAspect){
			var ta = this._aspect[this._aspect.prop];
			if(newW < newH){
				newH = newW * ta;
			}else if(newH < newW){
				newW = newH * ta;
			}
		}
		
		return { w: newW, h: newH }; // Object
	},
		
	_changeSizing: function(/*Event*/ e){
		// summary: apply sizing information based on information in (e) to attached node
		var tmp = this._getNewCoords(e);
		if(tmp === false){ return; }

		if(this.targetWidget && dojo.isFunction(this.targetWidget.resize)){
			this.targetWidget.resize(tmp);
		}else{
			if(this.animateSizing){
				var anim = dojo.fx[this.animateMethod]([
					dojo.animateProperty({
						node: this.targetDomNode,
						properties: {
							width: { start: this.startSize.w, end: tmp.w }
						},
						duration: this.animateDuration
					}),
					dojo.animateProperty({
						node: this.targetDomNode,
						properties: {
							height: { start: this.startSize.h, end: tmp.h }
						},
						duration: this.animateDuration
					})
				]);
				anim.play();
			}else{
				dojo.style(this.targetDomNode,{
					width: tmp.w + "px",
					height: tmp.h + "px"
				});
			}
		}
		if(this.intermediateChanges){
			this.onResize(e);
		}
	},

	_endSizing: function(/*Event*/ e){
		// summary: disconnect listenrs and cleanup sizing
		dojo.forEach(this._pconnects, dojo.disconnect);
		var pub = dojo.partial(dojo.publish, this.endTopic, [ this ]);
		if(!this.activeResize){
			this._resizeHelper.hide();
			this._changeSizing(e);
			setTimeout(pub, this.animateDuration + 15);
		}else{
			pub();
		}
		this._isSizing = false;
		this.onResize(e);
	},
	
	onResize: function(e){
		// summary: Stub fired when sizing is done. Fired once
		//	after resize, or often when `intermediateChanges` is
		//	set to true.
	}
	
});

dojo.declare("dojox.layout._ResizeHelper",
	dijit._Widget,
	{
	// summary: A global private resize helper shared between any
	//		`dojox.layout.ResizeHandle` with activeSizing off.
	
	show: function(){
		// summary: show helper to start resizing
		dojo.fadeIn({
			node: this.domNode,
			duration: 120,
			beforeBegin: function(n){ dojo.style(n, "display", "") }
		}).play();
	},
	
	hide: function(){
		// summary: hide helper after resizing is complete
		dojo.fadeOut({
			node: this.domNode,
			duration: 250,
			onEnd: function(n){ dojo.style(n, "display", "none") }
		}).play();
	},
	
	resize: function(/* Object */dim){
		// summary: size the widget and place accordingly

		// FIXME: this is off when padding present
		dojo.marginBox(this.domNode, dim);
	}
	
});

}

if(!dojo._hasResource["dojox.layout.FloatingPane"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.layout.FloatingPane"] = true;
dojo.provide("dojox.layout.FloatingPane");
dojo.experimental("dojox.layout.FloatingPane");










dojo.declare("dojox.layout.FloatingPane",
	[ dojox.layout.ContentPane, dijit._Templated ],
	{
	// summary:
	//		A non-modal Floating window.
	//
	// description:
	// 		Makes a `dojox.layout.ContentPane` float and draggable by it's title [similar to TitlePane]
	// 		and over-rides onClick to onDblClick for wipeIn/Out of containerNode
	// 		provides minimize(dock) / show() and hide() methods, and resize [almost]
	//
	// closable: Boolean
	//		Allow closure of this Node
	closable: true,

	// dockable: Boolean
	//		Allow minimizing of pane if true
	dockable: true,

	// resizable: Boolean
	//		Allow resizing of pane true if true
	resizable: false,

	// maxable: Boolean
	//		Horrible param name for "Can you maximize this floating pane?"
	maxable: false,

	// resizeAxis: String
	//		One of: x | xy | y to limit pane's sizing direction
	resizeAxis: "xy",

	// title: String
	//		Title to use in the header
	title: "",

	// dockTo: DomNode?
	//		if empty, will create private layout.Dock that scrolls with viewport
	//		on bottom span of viewport.
	dockTo: "",

	// duration: Integer
	//		Time is MS to spend toggling in/out node
	duration: 400,

	/*=====
	// iconSrc: String
	//		[not implemented yet] will be either icon in titlepane to left
	//		of Title, and/or icon show when docked in a fisheye-like dock
	//		or maybe dockIcon would be better?
	iconSrc: null,
	=====*/

	// contentClass: String
	// 		The className to give to the inner node which has the content
	contentClass: "dojoxFloatingPaneContent",

	// animation holders for toggle
	_showAnim: null,
	_hideAnim: null,
	// node in the dock (if docked)
	_dockNode: null,

	// privates:
	_restoreState: {},
	_allFPs: [],
	_startZ: 100,

	templateString: dojo.cache("dojox.layout", "resources/FloatingPane.html", "<div class=\"dojoxFloatingPane\" id=\"${id}\">\n\t<div tabindex=\"0\" role=\"button\" class=\"dojoxFloatingPaneTitle\" dojoAttachPoint=\"focusNode\">\n\t\t<span dojoAttachPoint=\"closeNode\" dojoAttachEvent=\"onclick: close\" class=\"dojoxFloatingCloseIcon\"></span>\n\t\t<span dojoAttachPoint=\"maxNode\" dojoAttachEvent=\"onclick: maximize\" class=\"dojoxFloatingMaximizeIcon\">&thinsp;</span>\n\t\t<span dojoAttachPoint=\"restoreNode\" dojoAttachEvent=\"onclick: _restore\" class=\"dojoxFloatingRestoreIcon\">&thinsp;</span>\t\n\t\t<span dojoAttachPoint=\"dockNode\" dojoAttachEvent=\"onclick: minimize\" class=\"dojoxFloatingMinimizeIcon\">&thinsp;</span>\n\t\t<span dojoAttachPoint=\"titleNode\" class=\"dijitInline dijitTitleNode\"></span>\n\t</div>\n\t<div dojoAttachPoint=\"canvas\" class=\"dojoxFloatingPaneCanvas\">\n\t\t<div dojoAttachPoint=\"containerNode\" role=\"region\" tabindex=\"-1\" class=\"${contentClass}\">\n\t\t</div>\n\t\t<span dojoAttachPoint=\"resizeHandle\" class=\"dojoxFloatingResizeHandle\"></span>\n\t</div>\n</div>\n"),
	
	attributeMap: dojo.delegate(dijit._Widget.prototype.attributeMap, {
		title: { type:"innerHTML", node:"titleNode" }
	}),
	
	postCreate: function(){
		this.inherited(arguments);
		new dojo.dnd.Moveable(this.domNode,{ handle: this.focusNode });
		//this._listener = dojo.subscribe("/dnd/move/start",this,"bringToTop");

		if(!this.dockable){ this.dockNode.style.display = "none"; }
		if(!this.closable){ this.closeNode.style.display = "none"; }
		if(!this.maxable){
			this.maxNode.style.display = "none";
			this.restoreNode.style.display = "none";
		}
		if(!this.resizable){
			this.resizeHandle.style.display = "none";
		}else{
			this.domNode.style.width = dojo.marginBox(this.domNode).w + "px";
		}
		this._allFPs.push(this);
		this.domNode.style.position = "absolute";
		
		this.bgIframe = new dijit.BackgroundIframe(this.domNode);
		this._naturalState = dojo.coords(this.domNode);
	},
	
	startup: function(){
		if(this._started){ return; }
		
//		this.inherited(arguments);

		if(this.resizable){
			if(dojo.isIE){
				this.canvas.style.overflow = "auto";
			}else{
				this.containerNode.style.overflow = "auto";
			}
			
			this._resizeHandle = new dojox.layout.ResizeHandle({
				targetId: this.id,
				resizeAxis: this.resizeAxis
			},this.resizeHandle);

		}

		if(this.dockable){
			// FIXME: argh.
			var tmpName = this.dockTo;

			if(this.dockTo){
				this.dockTo = dijit.byId(this.dockTo);
			}else{
				this.dockTo = dijit.byId('dojoxGlobalFloatingDock');
			}

			if(!this.dockTo){
				var tmpId, tmpNode;
				// we need to make our dock node, and position it against
				// .dojoxDockDefault .. this is a lot. either dockto="node"
				// and fail if node doesn't exist or make the global one
				// once, and use it on empty OR invalid dockTo="" node?
				if(tmpName){
					tmpId = tmpName;
					tmpNode = dojo.byId(tmpName);
				}else{
					tmpNode = dojo.create('div', null, dojo.body());
					dojo.addClass(tmpNode,"dojoxFloatingDockDefault");
					tmpId = 'dojoxGlobalFloatingDock';
				}
				this.dockTo = new dojox.layout.Dock({ id: tmpId, autoPosition: "south" }, tmpNode);
				this.dockTo.startup();
			}
						
			if((this.domNode.style.display == "none")||(this.domNode.style.visibility == "hidden")){
				// If the FP is created dockable and non-visible, start up docked.
				this.minimize();
			}
		}
		this.connect(this.focusNode,"onmousedown","bringToTop");
		this.connect(this.domNode,	"onmousedown","bringToTop");

		// Initial resize to give child the opportunity to lay itself out
		this.resize(dojo.coords(this.domNode));
		
		this._started = true;
	},

	setTitle: function(/* String */ title){
		// summary: Update the Title bar with a new string
		dojo.deprecated("pane.setTitle", "Use pane.set('title', someTitle)", "2.0");
		this.set("title", title);
		// this.setTitle = dojo.hitch(this, "setTitle") ??
	},
	
	close: function(){
		// summary: Close and destroy this widget
		if(!this.closable){ return; }
		dojo.unsubscribe(this._listener);
		this.hide(dojo.hitch(this,function(){
			this.destroyRecursive();
		}));
	},

	hide: function(/* Function? */ callback){
		// summary: Close, but do not destroy this FloatingPane
		dojo.fadeOut({
			node:this.domNode,
			duration:this.duration,
			onEnd: dojo.hitch(this,function() {
				this.domNode.style.display = "none";
				this.domNode.style.visibility = "hidden";
				if(this.dockTo && this.dockable){
					this.dockTo._positionDock(null);
				}
				if(callback){
					callback();
				}
			})
		}).play();
	},

	show: function(/* Function? */callback){
		// summary: Show the FloatingPane
		var anim = dojo.fadeIn({node:this.domNode, duration:this.duration,
			beforeBegin: dojo.hitch(this,function(){
				this.domNode.style.display = "";
				this.domNode.style.visibility = "visible";
				if (this.dockTo && this.dockable) { this.dockTo._positionDock(null); }
				if (typeof callback == "function") { callback(); }
				this._isDocked = false;
				if (this._dockNode) {
					this._dockNode.destroy();
					this._dockNode = null;
				}
			})
		}).play();
		this.resize(dojo.coords(this.domNode));
		this._onShow(); // lazy load trigger
	},

	minimize: function(){
//console.log("dojox.layout.FloatingPane.minimize");
		// summary: Hide and dock the FloatingPane
		if(!this._isDocked){ this.hide(dojo.hitch(this,"_dock")); }
	},

	maximize: function(){
//console.log("dojox.layout.FloatingPane.maximize");
		// summary: Make this FloatingPane full-screen (viewport)
		if(this._maximized){ return; }
		this._naturalState = dojo.position(this.domNode);
		if(this._isDocked){
			this.show();
			setTimeout(dojo.hitch(this,"maximize"),this.duration);
		}
		dojo.addClass(this.focusNode,"floatingPaneMaximized");
		this.resize(dojo.window.getBox());
		this._maximized = true;
	},

	_restore: function(){
//console.log("dojox.layout.FloatingPane._restore");

		if(this._maximized){
			this.resize(this._naturalState);
			dojo.removeClass(this.focusNode,"floatingPaneMaximized");
			this._maximized = false;
		}
	},

	_dock: function(){
		if(!this._isDocked && this.dockable){
			this._dockNode = this.dockTo.addNode(this);
			this._isDocked = true;
		}
	},
	
	resize: function(/* Object */dim){
//console.log("dojox.layout.FloatingPane.resize");
		// summary: Size the FloatingPane and place accordingly
		dim = dim || this._naturalState;
		this._currentState = dim;

		// From the ResizeHandle we only get width and height information
		var dns = this.domNode.style;
		
		if("t" in dim){ dns.top = dim.t + "px"; }
		if("l" in dim){ dns.left = dim.l + "px"; }
		dns.width = dim.w + "px";
		dns.height = dim.h + "px";

//console.log("dojox.layout.FloatingPane.resize    dim: " + dojo.toJson(dim, true));

		// Now resize canvas
		var mbCanvas = { l: 0, t: 0, w: dim.w, h: (dim.h - this.focusNode.offsetHeight) };
		dojo.marginBox(this.canvas, mbCanvas);

		// If the single child can resize, forward resize event to it so it can
		// fit itself properly into the content area
		this._checkIfSingleChild();
		if(this._singleChild && this._singleChild.resize){
			this._singleChild.resize(mbCanvas);
		}
	},
	
	bringToTop: function(){
		// summary: bring this FloatingPane above all other panes
		var windows = dojo.filter(
			this._allFPs,
			function(i){
				return i !== this;
			},
		this);
		windows.sort(function(a, b){
			return a.domNode.style.zIndex - b.domNode.style.zIndex;
		});
		windows.push(this);
		
		dojo.forEach(windows, function(w, x){
			w.domNode.style.zIndex = this._startZ + (x * 2);
			dojo.removeClass(w.domNode, "dojoxFloatingPaneFg");
		}, this);
		dojo.addClass(this.domNode, "dojoxFloatingPaneFg");
	},
	
	destroy: function(){
		// summary: Destroy this FloatingPane completely
		this._allFPs.splice(dojo.indexOf(this._allFPs, this), 1);
		if(this._resizeHandle){
			this._resizeHandle.destroy();
		}
		this.inherited(arguments);
	}
});


dojo.declare("dojox.layout.Dock",
	[dijit._Widget,dijit._Templated],
	{
	// summary:
	//		A widget that attaches to a node and keeps track of incoming / outgoing FloatingPanes
	// 		and handles layout

	templateString: '<div class="dojoxDock"><ul dojoAttachPoint="containerNode" class="dojoxDockList"></ul></div>',

	// private _docked: array of panes currently in our dock
	_docked: [],
	
	_inPositioning: false,
	
	autoPosition: false,
	
	addNode: function(refNode){
		// summary: Instert a dockNode refernce into the dock
		
		var div = dojo.create('li', null, this.containerNode),
			node = new dojox.layout._DockNode({
				title: refNode.title,
				paneRef: refNode
			}, div)
		;
		node.startup();
		return node;
	},

	startup: function(){
				
		if (this.id == "dojoxGlobalFloatingDock" || this.isFixedDock) {
			// attach window.onScroll, and a position like in presentation/dialog
			this.connect(window, 'onresize', "_positionDock");
			this.connect(window, 'onscroll', "_positionDock");
			if(dojo.isIE){
				this.connect(this.domNode, "onresize", "_positionDock");
			}
		}
		this._positionDock(null);
		this.inherited(arguments);

	},
	
	_positionDock: function(/* Event? */e){
		if(!this._inPositioning){
			if(this.autoPosition == "south"){
				// Give some time for scrollbars to appear/disappear
				setTimeout(dojo.hitch(this, function() {
					this._inPositiononing = true;
					var viewport = dojo.window.getBox();
					var s = this.domNode.style;
					s.left = viewport.l + "px";
					s.width = (viewport.w-2) + "px";
					s.top = (viewport.h + viewport.t) - this.domNode.offsetHeight + "px";
					this._inPositioning = false;
				}), 125);
			}
		}
	}


});

dojo.declare("dojox.layout._DockNode",
	[dijit._Widget,dijit._Templated],
	{
	// summary:
	//		dojox.layout._DockNode is a private widget used to keep track of
	//		which pane is docked.
	//
	// title: String
	// 		Shown in dock icon. should read parent iconSrc?
	title: "",

	// paneRef: Widget
	//		reference to the FloatingPane we reprasent in any given dock
	paneRef: null,

	templateString:
		'<li dojoAttachEvent="onclick: restore" class="dojoxDockNode">'+
			'<span dojoAttachPoint="restoreNode" class="dojoxDockRestoreButton" dojoAttachEvent="onclick: restore"></span>'+
			'<span class="dojoxDockTitleNode" dojoAttachPoint="titleNode">${title}</span>'+
		'</li>',

	restore: function(){
		// summary: remove this dock item from parent dock, and call show() on reffed floatingpane
		this.paneRef.show();
		this.paneRef.bringToTop();
		this.destroy();
	}

});

}

if(!dojo._hasResource["plugins.dojox.layout.Dock"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.dojox.layout.Dock"] = true;
dojo.provide("plugins.dojox.layout.Dock");



dojo.declare("plugins.dojox.layout.Dock",
	[dijit._Widget,dijit._Templated], {

// summary:
//		A widget that attaches to a node and keeps track of incoming / outgoing FloatingPanes
// 		and handles layout

templateString: '<div class="dojoxDock"><ul dojoAttachPoint="containerNode" class="dojoxDockList"></ul></div>',

// private _docked: array of panes currently in our dock
_docked: [],

_inPositioning: false,

autoPosition: false,

// CSS class of dock node. Default is 'dojoxDockNode' 
// dockClass: string
dockClass: "dojoxDockNode",

/////}}}}

addNode: function(refNode){
	// summary: Instert a dockNode refernce into the dock
	
	var div = dojo.create('li', null, this.containerNode);
	//console.log("Dock.addNode    this:");
	//console.dir({this_ie_Dock:this});
	//console.log("Dock.addNode    this.dockClass: " + this.dockClass);
	var	node = new plugins.dojox.layout._DockNode({
			title: refNode.title,
			paneRef: refNode,
			dockClass: refNode.dockClass
		}, div)
	;
	node.startup();
	return node;
},
startup: function(){
			
	if (this.id == "dojoxGlobalFloatingDock" || this.isFixedDock) {
		// attach window.onScroll, and a position like in presentation/dialog
		this.connect(window, 'onresize', "_positionDock");
		this.connect(window, 'onscroll', "_positionDock");
		if(dojo.isIE){
			this.connect(this.domNode, "onresize", "_positionDock");
		}
	}
	this._positionDock(null);
	this.inherited(arguments);

},
_positionDock: function(/* Event? */e){
	if(!this._inPositioning){
		if(this.autoPosition == "south"){
			// Give some time for scrollbars to appear/disappear
			setTimeout(dojo.hitch(this, function() {
				this._inPositiononing = true;
				var viewport = dojo.window.getBox();
				var s = this.domNode.style;
				s.left = viewport.l + "px";
				s.width = (viewport.w-2) + "px";
				s.top = (viewport.h + viewport.t) - this.domNode.offsetHeight + "px";
				this._inPositioning = false;
			}), 125);
		}
	}
}

});

dojo.declare("plugins.dojox.layout._DockNode",
    [ dojox.layout.Dock ], {

// summary:
//		dojox.layout._DockNode is a private widget used to keep track of
//		which pane is docked.
//

templateString:
	'<li dojoAttachEvent="onclick: restore" class="dojoxDockNode">'+
		'<span dojoAttachPoint="restoreNode" class="dojoxDockRestoreButton" dojoAttachEvent="onclick: restore"></span>'+
		'<span class="dojoxDockTitleNode" dojoAttachPoint="titleNode">${title}</span>'+
	'</li>',

// CSS class of dock node. Default is 'dojoxDockNode' 
// dockClass: string
dockClass: null,

/////}}}}

postCreate: function(){
	//console.log("DockNode.postCreate    this.dockClass: " + this.dockClass)
	//console.log("DockNode.postCreate    this.templateString: " + this.templateString)
	var dockClass = this.dockClass;
	if ( dockClass ) {
		//console.log("DockNode.postCreate    DOING dojo.addClass(this.domNode, dockClass)");
		dojo.attr(this.domNode, 'class', dockClass);
	}
	
	if ( this.dockClass ) {
		this.templateString = '<li dojoAttachEvent="onclick: restore" class="dojoxDockNode ' + this.dockClass + '">'+
			'<span dojoAttachPoint="restoreNode" class="dojoxDockRestoreButton" dojoAttachEvent="onclick: restore"></span>'+
			'<span class="dojoxDockTitleNode" dojoAttachPoint="titleNode">${title}</span>'+
		'</li>'
	}

	//console.log("DockNode.postCreate    this.templateString: " + this.templateString)

},
restore: function(){
	// summary: remove this dock item from parent dock, and call show() on reffed floatingpane
	this.paneRef.show();
	this.paneRef.bringToTop();
	this.destroy();
}

});

}

if(!dojo._hasResource["plugins.dojox.layout.FloatingPane"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.dojox.layout.FloatingPane"] = true;
dojo.provide("plugins.dojox.layout.FloatingPane");




dojo.declare("plugins.dojox.layout.FloatingPane",
    [ dojox.layout.FloatingPane ], {

/////}}}}

// CSS class of dock node. Default is 'dojoxDockNode' 
// dockClass: string
dockClass: "dojoxDockNode",

constructor: function(){

	//console.log("FloatingPane.constructor    this.dockClass: " + this.dockClass);
	//console.log("FloatingPane.constructor    arguments: " );
	//console.dir({arguments:arguments});

	this.inherited(arguments);
},

postCreate: function(){

	console.log("FloatingPane.postCreate    this.dockClass: " + this.dockClass);
	this.inherited(arguments);
	new dojo.dnd.Moveable(this.domNode,{ handle: this.focusNode });
	//this._listener = dojo.subscribe("/dnd/move/start",this,"bringToTop");

	if(!this.dockable){ this.dockNode.style.display = "none"; }
	if(!this.closable){ this.closeNode.style.diDocsplay = "none"; }
	if(!this.maxable){
		this.maxNode.style.display = "none";
		this.restoreNode.style.display = "none";
	}
	if(!this.resizable){
		this.resizeHandle.style.display = "none";
	}else{
		this.domNode.style.width = dojo.marginBox(this.domNode).w + "px";
	}
	this._allFPs.push(this);
	this.domNode.style.position = "absolute";
	
	this.bgIframe = new dijit.BackgroundIframe(this.domNode);
	this._naturalState = dojo.coords(this.domNode);

    //// CENTER WHEN MAXIMISED
    //dojo.connect(this, "maximize", this, "_position");        
},

startup: function(){
	if(this._started){ return; }
	
//		this.inherited(arguments);

	if(this.resizable){
		if(dojo.isIE){
			this.canvas.style.overflow = "auto";
		}else{
			this.containerNode.style.overflow = "auto";
		}
		
		this._resizeHandle = new dojox.layout.ResizeHandle({
			targetId: this.id,
			resizeAxis: this.resizeAxis
		},this.resizeHandle);

	}

	if(this.dockable){
		// FIXME: argh.
		var tmpName = this.dockTo;

		if(this.dockTo){
			this.dockTo = dijit.byId(this.dockTo);
		}else{
			this.dockTo = dijit.byId('dojoxGlobalFloatingDock');
		}

		if(!this.dockTo){
			var tmpId, tmpNode;
			// we need to make our dock node, and position it against
			// .dojoxDockDefault .. this is a lot. either dockto="node"
			// and fail if node doesn't exist or make the global one
			// once, and use it on empty OR invalid dockTo="" node?
			if(tmpName){
				tmpId = tmpName;
				tmpNode = dojo.byId(tmpName);
			}else{
				tmpNode = dojo.create('div', null, dojo.body());
				dojo.addClass(tmpNode,"dojoxFloatingDockDefault");
				tmpId = 'dojoxGlobalFloatingDock';
			}
			
			console.log("FloatingPane.startup    this:");
			console.dir({this_ie_FloatingPane:this});
			console.log("FloatingPane.startup    this.dockClass: " + this.dockClass);

			this.dockTo = new plugins.dojox.layout.Dock({
				id: tmpId,
				autoPosition: "south",
				dockClass: this.dockClass,
				paneRef: this
			}, tmpNode);
			this.dockTo.startup();
		}
					
		if((this.domNode.style.display == "none")||(this.domNode.style.visibility == "hidden")){
			// If the FP is created dockable and non-visible, start up docked.
			this.minimize();
		}
	}
	this.connect(this.focusNode,"onmousedown","bringToTop");
	this.connect(this.domNode,	"onmousedown","bringToTop");

	// Initial resize to give child the opportunity to lay itself out
	this.resize(dojo.coords(this.domNode));
	
	this._started = true;
},


//_position : function() {
//// 1. POSITION DIALOG IN CENTER OF PAGE
//// 2. DIALOG STAYS PUT ON PAGE SCROLL
//
//	// SET POSITION
//    this._setPosition();
//   // this._doSizing();
//
//	// ENSURE VISIBILITY
//    dojo.style(this.containerNode, "opacity", 1);
//    dojo.style(this.containerNode, "visibility", "visible");
//    dojo.style(this.containerNode, "hidden", null);	
//
//},
//
//_setPosition : function () {
//// EXTRACTED FROM dijit.Dialog
//    if (!dojo.hasClass(dojo.body(),"dojoMove")) {
//        var node = this.domNode;
//        //console.log("FloatingPane._setPosition    node:");
//        //console.dir({node:node});
//        
//        var viewport = dijit.getViewport();
//        //console.log("FloatingPane._setPosition    viewport:");
//        //console.dir({viewport:viewport});
//        
//        var p = this._relativePosition;
//        var mb = p ? null : dojo.marginBox(node);
//		mb = {
//			h	: 	278,
//			l	: 	-400,
//			t	:	0,
//			w	:	695
//		};
//        //console.log("FloatingPane._setPosition    mb:");
//        //console.dir({mb:mb});
//        
//        var left = Math.floor(viewport.l + (p ? p.l : (viewport.w - mb.w) / 2));
//        //console.log("FloatingPane._setPosition    left: " + left);
//        
//	
//        dojo.style(node,{
//            left: left + "px",
//            top: "100px"
//        });
//    }
//},
//
//_doSizing : function () {
//    if(!this.open){ dojo.style(this.containerNode, "opacity", 0); }
//    var pad = this.viewportPadding * 2; 
//    //console.log("FloatingPane._doSizing    pad: " + pad);
//    
//    var props = {
//        node: this.domNode,
//        duration: this.sizeDuration || dijit._defaultDuration,
//        easing: this.easing,
//        method: this.sizeMethod
//    };
//    //console.log("FloatingPane._doSizing    props:");
//    //console.dir({props:props});
//
//    // CHANGE _displaysize.h FROM "auto" TO 800, IGNORE this._vp 
//    //console.log("FloatingPane._doSizing    this._displaysize:");
//    //console.dir({this__displaysize:this._displaysize});
//    this._displaysize = { h: 0, w: 800 };
//    var ds = this._displaysize;
//    //console.log("FloatingPane._doSizing    ds: ");
//    //console.dir({ds:ds});
//    props['width'] = ds.w;
//    props['height'] = ds.h;
//	
//	// DO SIZING
//    //console.log("FloatingPane._doSizing    FINAL props:");
//    //console.dir({props:props});
//    this._sizing = dojox.fx.sizeTo(props);
//    this._sizing.play();
//}

});

}

if(!dojo._hasResource["dijit.TitlePane"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.TitlePane"] = true;
dojo.provide("dijit.TitlePane");






dojo.declare(
	"dijit.TitlePane",
	[dijit.layout.ContentPane, dijit._Templated, dijit._CssStateMixin],
{
	// summary:
	//		A pane with a title on top, that can be expanded or collapsed.
	//
	// description:
	//		An accessible container with a title Heading, and a content
	//		section that slides open and closed. TitlePane is an extension to
	//		`dijit.layout.ContentPane`, providing all the useful content-control aspects from it.
	//
	// example:
	// | 	// load a TitlePane from remote file:
	// |	var foo = new dijit.TitlePane({ href: "foobar.html", title:"Title" });
	// |	foo.startup();
	//
	// example:
	// |	<!-- markup href example: -->
	// |	<div dojoType="dijit.TitlePane" href="foobar.html" title="Title"></div>
	//
	// example:
	// |	<!-- markup with inline data -->
	// | 	<div dojoType="dijit.TitlePane" title="Title">
	// |		<p>I am content</p>
	// |	</div>

	// title: String
	//		Title of the pane
	title: "",

	// open: Boolean
	//		Whether pane is opened or closed.
	open: true,

	// toggleable: Boolean
	//		Whether pane can be opened or closed by clicking the title bar.
	toggleable: true,

	// tabIndex: String
	//		Tabindex setting for the title (so users can tab to the title then
	//		use space/enter to open/close the title pane)
	tabIndex: "0",

	// duration: Integer
	//		Time in milliseconds to fade in/fade out
	duration: dijit.defaultDuration,

	// baseClass: [protected] String
	//		The root className to be placed on this widget's domNode.
	baseClass: "dijitTitlePane",

	templateString: dojo.cache("dijit", "templates/TitlePane.html", "<div>\n\t<div dojoAttachEvent=\"onclick:_onTitleClick, onkeypress:_onTitleKey\"\n\t\t\tclass=\"dijitTitlePaneTitle\" dojoAttachPoint=\"titleBarNode\">\n\t\t<div class=\"dijitTitlePaneTitleFocus\" dojoAttachPoint=\"focusNode\">\n\t\t\t<img src=\"${_blankGif}\" alt=\"\" dojoAttachPoint=\"arrowNode\" class=\"dijitArrowNode\" role=\"presentation\"\n\t\t\t/><span dojoAttachPoint=\"arrowNodeInner\" class=\"dijitArrowNodeInner\"></span\n\t\t\t><span dojoAttachPoint=\"titleNode\" class=\"dijitTitlePaneTextNode\"></span>\n\t\t</div>\n\t</div>\n\t<div class=\"dijitTitlePaneContentOuter\" dojoAttachPoint=\"hideNode\" role=\"presentation\">\n\t\t<div class=\"dijitReset\" dojoAttachPoint=\"wipeNode\" role=\"presentation\">\n\t\t\t<div class=\"dijitTitlePaneContentInner\" dojoAttachPoint=\"containerNode\" role=\"region\" id=\"${id}_pane\">\n\t\t\t\t<!-- nested divs because wipeIn()/wipeOut() doesn't work right on node w/padding etc.  Put padding on inner div. -->\n\t\t\t</div>\n\t\t</div>\n\t</div>\n</div>\n"),

	attributeMap: dojo.delegate(dijit.layout.ContentPane.prototype.attributeMap, {
		title: { node: "titleNode", type: "innerHTML" },
		tooltip: {node: "focusNode", type: "attribute", attribute: "title"},	// focusNode spans the entire width, titleNode doesn't
		id:""
	}),

	buildRendering: function(){
		this.inherited(arguments);
		dojo.setSelectable(this.titleNode, false);
	},

	postCreate: function(){
		//console.log("dijit.TitlePane.postCreate()");
		this.inherited(arguments);
		
		// Hover and focus effect on title bar, except for non-toggleable TitlePanes
		// This should really be controlled from _setToggleableAttr() but _CssStateMixin
		// doesn't provide a way to disconnect a previous _trackMouseState() call
		if(this.toggleable){
			this._trackMouseState(this.titleBarNode, "dijitTitlePaneTitle");
		}

		// setup open/close animations
		var hideNode = this.hideNode, wipeNode = this.wipeNode;
		this._wipeIn = dojo.fx.wipeIn({
			node: this.wipeNode,
			duration: this.duration,
			beforeBegin: function(){
				hideNode.style.display="";
			}
		});
		this._wipeOut = dojo.fx.wipeOut({
			node: this.wipeNode,
			duration: this.duration,
			onEnd: function(){
				hideNode.style.display="none";
			}
		});
	},

	_setOpenAttr: function(/*Boolean*/ open, /*Boolean*/ animate){
		// summary:
		//		Hook to make set("open", boolean) control the open/closed state of the pane.
		// open: Boolean
		//		True if you want to open the pane, false if you want to close it.

		dojo.forEach([this._wipeIn, this._wipeOut], function(animation){
			if(animation && animation.status() == "playing"){
				animation.stop();
			}
		});

		if(animate){
			var anim = this[open ? "_wipeIn" : "_wipeOut"];
			anim.play();
		}else{
			this.hideNode.style.display = this.wipeNode.style.display = open ? "" : "none";
		}

		// load content (if this is the first time we are opening the TitlePane
		// and content is specified as an href, or href was set when hidden)
		if(this._started){
			if(open){
				this._onShow();
			}else{
				this.onHide();
			}
		}

		this.arrowNodeInner.innerHTML = open ? "-" : "+";

		dijit.setWaiState(this.containerNode,"hidden", open ? "false" : "true");
		dijit.setWaiState(this.focusNode, "pressed", open ? "true" : "false");

		this._set("open", open);

		this._setCss();
	},

	_setToggleableAttr: function(/*Boolean*/ canToggle){
		// summary:
		//		Hook to make set("toggleable", boolean) work.
		// canToggle: Boolean
		//		True to allow user to open/close pane by clicking title bar.

		dijit.setWaiRole(this.focusNode, canToggle ? "button" : "heading");
		if(canToggle){
			// TODO: if canToggle is switched from true to false shouldn't we remove this setting?
			dijit.setWaiState(this.focusNode, "controls", this.id+"_pane");
			dojo.attr(this.focusNode, "tabIndex", this.tabIndex);
		}else{
			dojo.removeAttr(this.focusNode, "tabIndex");
		}

		this._set("toggleable", canToggle);

		this._setCss();
	},

	_setContentAttr: function(/*String|DomNode|Nodelist*/ content){
		// summary:
		//		Hook to make set("content", ...) work.
		// 		Typically called when an href is loaded.  Our job is to make the animation smooth.

		if(!this.open || !this._wipeOut || this._wipeOut.status() == "playing"){
			// we are currently *closing* the pane (or the pane is closed), so just let that continue
			this.inherited(arguments);
		}else{
			if(this._wipeIn && this._wipeIn.status() == "playing"){
				this._wipeIn.stop();
			}

			// freeze container at current height so that adding new content doesn't make it jump
			dojo.marginBox(this.wipeNode, { h: dojo.marginBox(this.wipeNode).h });

			// add the new content (erasing the old content, if any)
			this.inherited(arguments);

			// call _wipeIn.play() to animate from current height to new height
			if(this._wipeIn){
				this._wipeIn.play();
			}else{
				this.hideNode.style.display = "";
			}
		}
	},

	toggle: function(){
		// summary:
		//		Switches between opened and closed state
		// tags:
		//		private

		this._setOpenAttr(!this.open, true);
	},

	_setCss: function(){
		// summary:
		//		Set the open/close css state for the TitlePane
		// tags:
		//		private

		var node = this.titleBarNode || this.focusNode;
		var oldCls = this._titleBarClass;
		this._titleBarClass = "dijit" + (this.toggleable ? "" : "Fixed") + (this.open ? "Open" : "Closed");
		dojo.replaceClass(node, this._titleBarClass, oldCls || "");

		this.arrowNodeInner.innerHTML = this.open ? "-" : "+";
	},

	_onTitleKey: function(/*Event*/ e){
		// summary:
		//		Handler for when user hits a key
		// tags:
		//		private

		if(e.charOrCode == dojo.keys.ENTER || e.charOrCode == ' '){
			if(this.toggleable){
				this.toggle();
			}
			dojo.stopEvent(e);
		}else if(e.charOrCode == dojo.keys.DOWN_ARROW && this.open){
			this.containerNode.focus();
			e.preventDefault();
	 	}
	},

	_onTitleClick: function(){
		// summary:
		//		Handler when user clicks the title bar
		// tags:
		//		private
		if(this.toggleable){
			this.toggle();
		}
	},

	setTitle: function(/*String*/ title){
		// summary:
		//		Deprecated.  Use set('title', ...) instead.
		// tags:
		//		deprecated
		dojo.deprecated("dijit.TitlePane.setTitle() is deprecated.  Use set('title', ...) instead.", "", "2.0");
		this.set("title", title);
	}
});

}

if(!dojo._hasResource["dijit.InlineEditBox"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.InlineEditBox"] = true;
dojo.provide("dijit.InlineEditBox");








dojo.declare("dijit.InlineEditBox",
	dijit._Widget,
	{
	// summary:
	//		An element with in-line edit capabilites
	//
	// description:
	//		Behavior for an existing node (`<p>`, `<div>`, `<span>`, etc.) so that
	// 		when you click it, an editor shows up in place of the original
	//		text.  Optionally, Save and Cancel button are displayed below the edit widget.
	//		When Save is clicked, the text is pulled from the edit
	//		widget and redisplayed and the edit widget is again hidden.
	//		By default a plain Textarea widget is used as the editor (or for
	//		inline values a TextBox), but you can specify an editor such as
	//		dijit.Editor (for editing HTML) or a Slider (for adjusting a number).
	//		An edit widget must support the following API to be used:
	//			- displayedValue or value as initialization parameter,
	//			and available through set('displayedValue') / set('value')
	//			- void focus()
	//			- DOM-node focusNode = node containing editable text

	// editing: [readonly] Boolean
	//		Is the node currently in edit mode?
	editing: false,

	// autoSave: Boolean
	//		Changing the value automatically saves it; don't have to push save button
	//		(and save button isn't even displayed)
	autoSave: true,

	// buttonSave: String
	//		Save button label
	buttonSave: "",

	// buttonCancel: String
	//		Cancel button label
	buttonCancel: "",

	// renderAsHtml: Boolean
	//		Set this to true if the specified Editor's value should be interpreted as HTML
	//		rather than plain text (ex: `dijit.Editor`)
	renderAsHtml: false,

	// editor: String|Function
	//		Class name (or reference to the Class) for Editor widget
	editor: "dijit.form.TextBox",

	// editorWrapper: String|Function
	//		Class name (or reference to the Class) for widget that wraps the editor widget, displaying save/cancel
	//		buttons.
	editorWrapper: "dijit._InlineEditor",

	// editorParams: Object
	//		Set of parameters for editor, like {required: true}
	editorParams: {},

	// disabled: Boolean
	//		If true, clicking the InlineEditBox to edit it will have no effect.
	disabled: false,

	onChange: function(value){
		// summary:
		//		Set this handler to be notified of changes to value.
		// tags:
		//		callback
	},

	onCancel: function(){
		// summary:
		//		Set this handler to be notified when editing is cancelled.
		// tags:
		//		callback
	},

	// width: String
	//		Width of editor.  By default it's width=100% (ie, block mode).
	width: "100%",

	// value: String
	//		The display value of the widget in read-only mode
	value: "",

	// noValueIndicator: [const] String
	//		The text that gets displayed when there is no value (so that the user has a place to click to edit)
	noValueIndicator: dojo.isIE <= 6 ?	// font-family needed on IE6 but it messes up IE8
		"<span style='font-family: wingdings; text-decoration: underline;'>&nbsp;&nbsp;&nbsp;&nbsp;&#x270d;&nbsp;&nbsp;&nbsp;&nbsp;</span>" :
		"<span style='text-decoration: underline;'>&nbsp;&nbsp;&nbsp;&nbsp;&#x270d;&nbsp;&nbsp;&nbsp;&nbsp;</span>",

	constructor: function(){
		// summary:
		//		Sets up private arrays etc.
		// tags:
		//		private
		this.editorParams = {};
	},

	postMixInProperties: function(){
		this.inherited(arguments);

		// save pointer to original source node, since Widget nulls-out srcNodeRef
		this.displayNode = this.srcNodeRef;

		// connect handlers to the display node
		var events = {
			ondijitclick: "_onClick",
			onmouseover: "_onMouseOver",
			onmouseout: "_onMouseOut",
			onfocus: "_onMouseOver",
			onblur: "_onMouseOut"
		};
		for(var name in events){
			this.connect(this.displayNode, name, events[name]);
		}
		dijit.setWaiRole(this.displayNode, "button");
		if(!this.displayNode.getAttribute("tabIndex")){
			this.displayNode.setAttribute("tabIndex", 0);
		}

		if(!this.value && !("value" in this.params)){ // "" is a good value if specified directly so check params){
		   this.value = dojo.trim(this.renderAsHtml ? this.displayNode.innerHTML :
		      (this.displayNode.innerText||this.displayNode.textContent||""));
		}
		if(!this.value){
		    this.displayNode.innerHTML = this.noValueIndicator;
		}

		dojo.addClass(this.displayNode, 'dijitInlineEditBoxDisplayMode');
	},

	setDisabled: function(/*Boolean*/ disabled){
		// summary:
		//		Deprecated.   Use set('disabled', ...) instead.
		// tags:
		//		deprecated
		dojo.deprecated("dijit.InlineEditBox.setDisabled() is deprecated.  Use set('disabled', bool) instead.", "", "2.0");
		this.set('disabled', disabled);
	},

	_setDisabledAttr: function(/*Boolean*/ disabled){
		// summary:
		//		Hook to make set("disabled", ...) work.
		//		Set disabled state of widget.
		dijit.setWaiState(this.domNode, "disabled", disabled);
		if(disabled){
			this.displayNode.removeAttribute("tabIndex");
		}else{
			this.displayNode.setAttribute("tabIndex", 0);
		}
		dojo.toggleClass(this.displayNode, "dijitInlineEditBoxDisplayModeDisabled", disabled);
		this._set("disabled", disabled);
	},

	_onMouseOver: function(){
		// summary:
		//		Handler for onmouseover and onfocus event.
		// tags:
		//		private
		if(!this.disabled){
			dojo.addClass(this.displayNode, "dijitInlineEditBoxDisplayModeHover");
		}
	},

	_onMouseOut: function(){
		// summary:
		//		Handler for onmouseout and onblur event.
		// tags:
		//		private
		dojo.removeClass(this.displayNode, "dijitInlineEditBoxDisplayModeHover");
	},

	_onClick: function(/*Event*/ e){
		// summary:
		//		Handler for onclick event.
		// tags:
		//		private
		if(this.disabled){ return; }
		if(e){ dojo.stopEvent(e); }
		this._onMouseOut();

		// Since FF gets upset if you move a node while in an event handler for that node...
		setTimeout(dojo.hitch(this, "edit"), 0);
	},

	edit: function(){
		// summary:
		//		Display the editor widget in place of the original (read only) markup.
		// tags:
		//		private

		if(this.disabled || this.editing){ return; }
		this.editing = true;

		// save some display node values that can be restored later
		this._savedPosition = dojo.style(this.displayNode, "position") || "static";
		this._savedOpacity = dojo.style(this.displayNode, "opacity") || "1";
		this._savedTabIndex = dojo.attr(this.displayNode, "tabIndex") || "0";

		if(this.wrapperWidget){
			var ew = this.wrapperWidget.editWidget;
			ew.set("displayedValue" in ew ? "displayedValue" : "value", this.value);
		}else{
			// Placeholder for edit widget
			// Put place holder (and eventually editWidget) before the display node so that it's positioned correctly
			// when Calendar dropdown appears, which happens automatically on focus.
			var placeholder = dojo.create("span", null, this.domNode, "before");

			// Create the editor wrapper (the thing that holds the editor widget and the save/cancel buttons)
			var ewc = typeof this.editorWrapper == "string" ? dojo.getObject(this.editorWrapper) : this.editorWrapper;
			this.wrapperWidget = new ewc({
				value: this.value,
				buttonSave: this.buttonSave,
				buttonCancel: this.buttonCancel,
				dir: this.dir,
				lang: this.lang,
				tabIndex: this._savedTabIndex,
				editor: this.editor,
				inlineEditBox: this,
				sourceStyle: dojo.getComputedStyle(this.displayNode),
				save: dojo.hitch(this, "save"),
				cancel: dojo.hitch(this, "cancel")
			}, placeholder);
			if(!this._started){
				this.startup();
			}
		}
		var ww = this.wrapperWidget;

		if(dojo.isIE){
			dijit.focus(dijit.getFocus()); // IE (at least 8) needs help with tab order changes
		}
		// to avoid screen jitter, we first create the editor with position:absolute, visibility:hidden,
		// and then when it's finished rendering, we switch from display mode to editor
		// position:absolute releases screen space allocated to the display node
		// opacity:0 is the same as visibility:hidden but is still focusable
		// visiblity:hidden removes focus outline

		dojo.style(this.displayNode, { position: "absolute", opacity: "0", display: "none" }); // makes display node invisible, display style used for focus-ability
		dojo.style(ww.domNode, { position: this._savedPosition, visibility: "visible", opacity: "1" });
		dojo.attr(this.displayNode, "tabIndex", "-1"); // needed by WebKit for TAB from editor to skip displayNode

		// Replace the display widget with edit widget, leaving them both displayed for a brief time so that
		// focus can be shifted without incident.  (browser may needs some time to render the editor.)
		setTimeout(dojo.hitch(this, function(){
			ww.focus(); // both nodes are showing, so we can switch focus safely
			ww._resetValue = ww.getValue();
		}), 0);
	},

	_onBlur: function(){
		// summary:
		//		Called when focus moves outside the InlineEditBox.
		//		Performs garbage collection.
		// tags:
		//		private

		this.inherited(arguments);
		if(!this.editing){
			/* causes IE focus problems, see TooltipDialog_a11y.html...
			setTimeout(dojo.hitch(this, function(){
				if(this.wrapperWidget){
					this.wrapperWidget.destroy();
					delete this.wrapperWidget;
				}
			}), 0);
			*/
		}
	},

	destroy: function(){
		if(this.wrapperWidget && !this.wrapperWidget._destroyed){
			this.wrapperWidget.destroy();
			delete this.wrapperWidget;
		}
		this.inherited(arguments);
	},

	_showText: function(/*Boolean*/ focus){
		// summary:
		//		Revert to display mode, and optionally focus on display node
		// tags:
		//		private

		var ww = this.wrapperWidget;
		dojo.style(ww.domNode, { position: "absolute", visibility: "hidden", opacity: "0" }); // hide the editor from mouse/keyboard events
		dojo.style(this.displayNode, { position: this._savedPosition, opacity: this._savedOpacity, display: "" }); // make the original text visible
		dojo.attr(this.displayNode, "tabIndex", this._savedTabIndex);
		if(focus){
			dijit.focus(this.displayNode);
		}
	},

	save: function(/*Boolean*/ focus){
		// summary:
		//		Save the contents of the editor and revert to display mode.
		// focus: Boolean
		//		Focus on the display mode text
		// tags:
		//		private

		if(this.disabled || !this.editing){ return; }
		this.editing = false;

		var ww = this.wrapperWidget;
		var value = ww.getValue();
		this.set('value', value); // display changed, formatted value

		this._showText(focus); // set focus as needed
	},

	setValue: function(/*String*/ val){
		// summary:
		//		Deprecated.   Use set('value', ...) instead.
		// tags:
		//		deprecated
		dojo.deprecated("dijit.InlineEditBox.setValue() is deprecated.  Use set('value', ...) instead.", "", "2.0");
		return this.set("value", val);
	},

	_setValueAttr: function(/*String*/ val){
		// summary:
		// 		Hook to make set("value", ...) work.
		//		Inserts specified HTML value into this node, or an "input needed" character if node is blank.

		val = dojo.trim(val);
		var renderVal = this.renderAsHtml ? val : val.replace(/&/gm, "&amp;").replace(/</gm, "&lt;").replace(/>/gm, "&gt;").replace(/"/gm, "&quot;").replace(/\n/g, "<br>");
		this.displayNode.innerHTML = renderVal || this.noValueIndicator;
		this._set("value", val);

		if(this._started){
			// tell the world that we have changed
			setTimeout(dojo.hitch(this, "onChange", val), 0); // setTimeout prevents browser freeze for long-running event handlers
		}
	},

	getValue: function(){
		// summary:
		//		Deprecated.   Use get('value') instead.
		// tags:
		//		deprecated
		dojo.deprecated("dijit.InlineEditBox.getValue() is deprecated.  Use get('value') instead.", "", "2.0");
		return this.get("value");
	},

	cancel: function(/*Boolean*/ focus){
		// summary:
		//		Revert to display mode, discarding any changes made in the editor
		// tags:
		//		private

		if(this.disabled || !this.editing){ return; }
		this.editing = false;

		// tell the world that we have no changes
		setTimeout(dojo.hitch(this, "onCancel"), 0); // setTimeout prevents browser freeze for long-running event handlers

		this._showText(focus);
	}
});

dojo.declare(
	"dijit._InlineEditor",
	 [dijit._Widget, dijit._Templated],
{
	// summary:
	// 		Internal widget used by InlineEditBox, displayed when in editing mode
	//		to display the editor and maybe save/cancel buttons.  Calling code should
	//		connect to save/cancel methods to detect when editing is finished
	//
	//		Has mainly the same parameters as InlineEditBox, plus these values:
	//
	// style: Object
	//		Set of CSS attributes of display node, to replicate in editor
	//
	// value: String
	//		Value as an HTML string or plain text string, depending on renderAsHTML flag

	templateString: dojo.cache("dijit", "templates/InlineEditBox.html", "<span data-dojo-attach-point=\"editNode\" role=\"presentation\" style=\"position: absolute; visibility:hidden\" class=\"dijitReset dijitInline\"\n\tdata-dojo-attach-event=\"onkeypress: _onKeyPress\"\n\t><span data-dojo-attach-point=\"editorPlaceholder\"></span\n\t><span data-dojo-attach-point=\"buttonContainer\"\n\t\t><button data-dojo-type=\"dijit.form.Button\" data-dojo-props=\"label: '${buttonSave}', 'class': 'saveButton'\"\n\t\t\tdata-dojo-attach-point=\"saveButton\" data-dojo-attach-event=\"onClick:save\"></button\n\t\t><button data-dojo-type=\"dijit.form.Button\"  data-dojo-props=\"label: '${buttonCancel}', 'class': 'cancelButton'\"\n\t\t\tdata-dojo-attach-point=\"cancelButton\" data-dojo-attach-event=\"onClick:cancel\"></button\n\t></span\n></span>\n"),
	widgetsInTemplate: true,

	postMixInProperties: function(){
		this.inherited(arguments);
		this.messages = dojo.i18n.getLocalization("dijit", "common", this.lang);
		dojo.forEach(["buttonSave", "buttonCancel"], function(prop){
			if(!this[prop]){ this[prop] = this.messages[prop]; }
		}, this);
	},

	buildRendering: function(){
		this.inherited(arguments);

		// Create edit widget in place in the template
		var cls = typeof this.editor == "string" ? dojo.getObject(this.editor) : this.editor;

		// Copy the style from the source
		// Don't copy ALL properties though, just the necessary/applicable ones.
		// wrapperStyle/destStyle code is to workaround IE bug where getComputedStyle().fontSize
		// is a relative value like 200%, rather than an absolute value like 24px, and
		// the 200% can refer *either* to a setting on the node or it's ancestor (see #11175)
		var srcStyle = this.sourceStyle,
			editStyle = "line-height:" + srcStyle.lineHeight + ";",
			destStyle = dojo.getComputedStyle(this.domNode);
		dojo.forEach(["Weight","Family","Size","Style"], function(prop){
			var textStyle = srcStyle["font"+prop],
				wrapperStyle = destStyle["font"+prop];
			if(wrapperStyle != textStyle){
				editStyle += "font-"+prop+":"+srcStyle["font"+prop]+";";
			}
		}, this);
		dojo.forEach(["marginTop","marginBottom","marginLeft", "marginRight"], function(prop){
			this.domNode.style[prop] = srcStyle[prop];
		}, this);
		var width = this.inlineEditBox.width;
		if(width == "100%"){
			// block mode
			editStyle += "width:100%;";
			this.domNode.style.display = "block";
		}else{
			// inline-block mode
			editStyle += "width:" + (width + (Number(width) == width ? "px" : "")) + ";";
		}
		var editorParams = dojo.delegate(this.inlineEditBox.editorParams, {
			style: editStyle,
			dir: this.dir,
			lang: this.lang
		});
		editorParams[ "displayedValue" in cls.prototype ? "displayedValue" : "value"] = this.value;
		this.editWidget = new cls(editorParams, this.editorPlaceholder);

		if(this.inlineEditBox.autoSave){
			// Remove the save/cancel buttons since saving is done by simply tabbing away or
			// selecting a value from the drop down list
			dojo.destroy(this.buttonContainer);
		}
	},

	postCreate: function(){
		this.inherited(arguments);

		var ew = this.editWidget;

		if(this.inlineEditBox.autoSave){
			// Selecting a value from a drop down list causes an onChange event and then we save
			this.connect(ew, "onChange", "_onChange");

			// ESC and TAB should cancel and save.  Note that edit widgets do a stopEvent() on ESC key (to
			// prevent Dialog from closing when the user just wants to revert the value in the edit widget),
			// so this is the only way we can see the key press event.
			this.connect(ew, "onKeyPress", "_onKeyPress");
		}else{
			// If possible, enable/disable save button based on whether the user has changed the value
			if("intermediateChanges" in ew){
				ew.set("intermediateChanges", true);
				this.connect(ew, "onChange", "_onIntermediateChange");
				this.saveButton.set("disabled", true);
			}
		}
	},

	_onIntermediateChange: function(val){
		// summary:
		//		Called for editor widgets that support the intermediateChanges=true flag as a way
		//		to detect when to enable/disabled the save button
		this.saveButton.set("disabled", (this.getValue() == this._resetValue) || !this.enableSave());
	},

	destroy: function(){
		this.editWidget.destroy(true); // let the parent wrapper widget clean up the DOM
		this.inherited(arguments);
	},

	getValue: function(){
		// summary:
		//		Return the [display] value of the edit widget
		var ew = this.editWidget;
		return String(ew.get("displayedValue" in ew ? "displayedValue" : "value"));
	},

	_onKeyPress: function(e){
		// summary:
		//		Handler for keypress in the edit box in autoSave mode.
		// description:
		//		For autoSave widgets, if Esc/Enter, call cancel/save.
		// tags:
		//		private

		if(this.inlineEditBox.autoSave && this.inlineEditBox.editing){
			if(e.altKey || e.ctrlKey){ return; }
			// If Enter/Esc pressed, treat as save/cancel.
			if(e.charOrCode == dojo.keys.ESCAPE){
				dojo.stopEvent(e);
				this.cancel(true); // sets editing=false which short-circuits _onBlur processing
			}else if(e.charOrCode == dojo.keys.ENTER && e.target.tagName == "INPUT"){
				dojo.stopEvent(e);
				this._onChange(); // fire _onBlur and then save
			}

			// _onBlur will handle TAB automatically by allowing
			// the TAB to change focus before we mess with the DOM: #6227
			// Expounding by request:
			// 	The current focus is on the edit widget input field.
			//	save() will hide and destroy this widget.
			//	We want the focus to jump from the currently hidden
			//	displayNode, but since it's hidden, it's impossible to
			//	unhide it, focus it, and then have the browser focus
			//	away from it to the next focusable element since each
			//	of these events is asynchronous and the focus-to-next-element
			//	is already queued.
			//	So we allow the browser time to unqueue the move-focus event
			//	before we do all the hide/show stuff.
		}
	},

	_onBlur: function(){
		// summary:
		//		Called when focus moves outside the editor
		// tags:
		//		private

		this.inherited(arguments);
		if(this.inlineEditBox.autoSave && this.inlineEditBox.editing){
			if(this.getValue() == this._resetValue){
				this.cancel(false);
			}else if(this.enableSave()){
				this.save(false);
			}
		}
	},

	_onChange: function(){
		// summary:
		//		Called when the underlying widget fires an onChange event,
		//		such as when the user selects a value from the drop down list of a ComboBox,
		//		which means that the user has finished entering the value and we should save.
		// tags:
		//		private

		if(this.inlineEditBox.autoSave && this.inlineEditBox.editing && this.enableSave()){
			dojo.style(this.inlineEditBox.displayNode, { display: "" });
			dijit.focus(this.inlineEditBox.displayNode); // fires _onBlur which will save the formatted value
		}
	},

	enableSave: function(){
		// summary:
		//		User overridable function returning a Boolean to indicate
		// 		if the Save button should be enabled or not - usually due to invalid conditions
		// tags:
		//		extension
		return (
			this.editWidget.isValid
			? this.editWidget.isValid()
			: true
		);
	},

	focus: function(){
		// summary:
		//		Focus the edit widget.
		// tags:
		//		protected

		this.editWidget.focus();
		setTimeout(dojo.hitch(this, function(){
			if(this.editWidget.focusNode && this.editWidget.focusNode.tagName == "INPUT"){
				dijit.selectInputText(this.editWidget.focusNode);
			}
		}), 0);
	}
});

}

if(!dojo._hasResource["dojox.timing._base"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.timing._base"] = true;
dojo.provide("dojox.timing._base");
dojo.experimental("dojox.timing");

dojox.timing.Timer = function(/*int*/ interval){
	// summary: Timer object executes an "onTick()" method repeatedly at a specified interval.
	//			repeatedly at a given interval.
	// interval: Interval between function calls, in milliseconds.
	this.timer = null;
	this.isRunning = false;
	this.interval = interval;

	this.onStart = null;
	this.onStop = null;
};

dojo.extend(dojox.timing.Timer, {
	onTick : function(){
		// summary: Method called every time the interval passes.  Override to do something useful.
	},
		
	setInterval : function(interval){
		// summary: Reset the interval of a timer, whether running or not.
		// interval: New interval, in milliseconds.
		if (this.isRunning){
			window.clearInterval(this.timer);
		}
		this.interval = interval;
		if (this.isRunning){
			this.timer = window.setInterval(dojo.hitch(this, "onTick"), this.interval);
		}
	},
	
	start : function(){
		// summary: Start the timer ticking.
		// description: Calls the "onStart()" handler, if defined.
		// 				Note that the onTick() function is not called right away,
		//				only after first interval passes.
		if (typeof this.onStart == "function"){
			this.onStart();
		}
		this.isRunning = true;
		this.timer = window.setInterval(dojo.hitch(this, "onTick"), this.interval);
	},
	
	stop : function(){
		// summary: Stop the timer.
		// description: Calls the "onStop()" handler, if defined.
		if (typeof this.onStop == "function"){
			this.onStop();
		}
		this.isRunning = false;
		window.clearInterval(this.timer);
	}
});

}

if(!dojo._hasResource["dojox.timing"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.timing"] = true;
dojo.provide("dojox.timing");


}

if(!dojo._hasResource["plugins.dojox.Timer"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.dojox.Timer"] = true;
dojo.provide("plugins.dojox.Timer");

/* 

	1. REPEATEDLY POLL WHILE WAITING FOR EVENTS TO FINISH
	
	2. CARRY OUT A SPECIFIED ACTION ON COMPLETION
	
	3. PASS ARGUMENTS TO poll AND onEnd CALLBACKS BY
	
		STORING THEM IN Timer OBJECT. NOTE: THIS MEANS
		
		THAT CARE MUST BE TAKEN TO AVOID OVERRIDING
		
		ANY OF Timer's METHODS OR SLOTS.
	
*/

// TIMER


dojo.declare( "plugins.dojox.Timer", null, {

// TIMING INTERVAL IN 1000ths OF A SECOND
interval : 3000,

// TRUE WHILE POLLING
polling : false,

// END POLLING WHEN TRUE
completed : false,

// CALLBACK TO BE FIRED BEFORE STARTING TIMER
onStart : null,

// CALLBACK TO BE FIRED AT EACH onTick EVENT
poll: null,

// CALLBACK TO BE FIRED WHEN POLLING HAS ENDED
onEnd : null,

// ATTENUATION VARIABLES
attenuate: false,
currentInterval : false,
stepInterval: 2000,
maxInterval: 10000,
tick: 1,

////}}}}}

constructor : function(args) {
	console.log("plugins.dojox.Timer.constructor     plugins.dojox.Timer.constructor");			
	if ( args == null )	return;
	
	if (args.interval != null)	this.interval = args.interval;
	if (args.attenuate != null)	this.attenuate = args.attenuate;
	if (args.stepInterval != null)	this.stepInterval = args.stepInterval;
	if (args.maxInterval != null)	this.maxInterval = args.maxInterval;

	this.poll 		= args.poll || function () {
		console.log("plugins.dojox.Timer.constructor    poll function is empty");
	}
	this.onStart 		= args.onStart || function () {
		console.log("plugins.dojox.Timer.constructor    onStart function is empty");
	}
	this.onEnd 		= args.onEnd || function () {
		console.log("plugins.dojox.Timer.constructor    onEnd function is empty");
	}

	this.currentInterval = this.interval;

	// INSTANTIATE NEW TIMER
	this.setTimer();
},

setTimer : function () {
	if ( this.timer != null )	return;
	
	if ( this.checkParent && ! this.parentWidget ) {
		console.log("plugins.dojox.Timer.setTimer    no parentWidget. Doing this.destroy()");
		this.destroy();
	}
	
	this.timer = new dojox.timing.Timer;
	this.setInterval(this.interval);
	
	var thisObject = this;
	this.timer.onTick = function() {
		console.log("plugins.dojox.Timer.setTimer     ONTICK this.timer.interval: " + this.interval);

		// STOP POLLING WHEN this.completed == true
		if ( thisObject.completed == true )
		{
			console.log("plugins.dojox.Timer.setTimer     Stopping timer because thisObject.completed: " + thisObject.completed);
			thisObject.stop();
			return;
		}

        setTimeout(function() {
            try {
				thisObject.completed = thisObject.poll(thisObject);		
				console.log("plugins.dojox.Timer.setTimer     Returned thisObject.completed: " + thisObject.completed);

				// STOP POLLING WHEN this.completed == true
				if ( thisObject.completed == true ) {
					console.log("plugins.dojox.Timer.setTimer     Stopping timer because thisObject.completed: " + thisObject.completed);
					thisObject.stop();
					return;
				}
				
            } catch(error) {
                console.log("plugins.dojox.Timer.setTimer     ERROR doing thisObject.poll(thisObject):" + dojo.toJson(error));
            }

	
			// INCREMENT TIMER DELAY IF attenuate IS TRUE
			if ( thisObject.attenuate == true && thisObject.tick != 1 ) {
				//thisObject.timer.stop();
				thisObject.currentInterval += thisObject.stepInterval;
				if ( thisObject.currentInterval > thisObject.maxInterval )
					thisObject.currentInterval = thisObject.maxInterval;
		
				console.log("plugins.dojox.Timer.setPoll    new thisObject.currentInterval: " + thisObject.currentInterval);
		
				thisObject.timer.setInterval(thisObject.currentInterval);
				//thisObject.timer.start();
			}
			else {
				thisObject.tick++;
			}

        }, 100);

	};	//	timer.onTick

},

setInterval : function (interval) {
	if ( interval == null )	return;
	this.timer.setInterval(interval);
},

setOnEnd : function (onEnd) {
	this.onEnd 	= onEnd || function () {
		console.log("plugins.dojox.Timer.setOnEnd    onEnd function is empty");
	}
},

setPoll : function (poll) {
	console.log("plugins.dojox.Timer.setPoll    poll: " + poll);
	this.poll 	= poll || function () {
		console.log("plugins.dojox.Timer.setPoll    poll function is empty");
	}
},

start : function () {
	console.log("plugins.dojox.Timer.start()");
	this.completed = false;
	this.onStart(this);
	this.timer.start();	
	this.polling = true;
},

stop : function () {
	console.log("plugins.dojox.Timer.stop()");
	this.timer.stop();
	this.polling = false;
	console.log("plugins.dojox.Timer.stop    this.polling: " + this.polling);
	
	this.onEnd(this);
}


});



}

if(!dojo._hasResource["dojox.fx._base"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.fx._base"] = true;
dojo.provide("dojox.fx._base");
// summary: Experimental and extended Animations beyond Dojo Core / Base functionality.
//	Provides advanced Lines, Animations, and convenience aliases.


dojo.mixin(dojox.fx, {

	// anim: Function
	//	Alias of `dojo.anim` - the shorthand `dojo.animateProperty` with auto-play
	anim: dojo.anim,

	// animateProperty: Function
	//	Alias of `dojo.animateProperty` - animate any CSS property
	animateProperty: dojo.animateProperty,

	// fadeTo: Function
	//		Fade an element from an opacity to an opacity.
	//		Omit `start:` property to detect. `end:` property is required.
	//		Ultimately an alias to `dojo._fade`
	fadeTo: dojo._fade,

	// fadeIn: Function
	//	Alias of `dojo.fadeIn` - Fade a node in.
	fadeIn: dojo.fadeIn,
	
	// fadeOut: Function
	//	Alias of `dojo.fadeOut` - Fades a node out.
	fadeOut: dojo.fadeOut,

	// combine: Function
	//	Alias of `dojo.fx.combine` - Run an array of animations in parallel
	combine: dojo.fx.combine,

	// chain: Function
	//	Alias of `dojo.fx.chain` - Run an array of animations in sequence
	chain: dojo.fx.chain,

	// slideTo: Function
	//	Alias of `dojo.fx.slideTo` - Slide a node to a defined top/left coordinate
	slideTo: dojo.fx.slideTo,

	// wipeIn: Function
	//	Alias of `dojo.fx.wipeIn` - Wipe a node to visible
	wipeIn: dojo.fx.wipeIn,

	// wipeOut: Function
	//	Alias of `dojo.fx.wipeOut` - Wipe a node to non-visible
	wipeOut: dojo.fx.wipeOut

});

dojox.fx.sizeTo = function(/* Object */args){
	// summary:
	//		Creates an animation that will size a node
	//
	// description:
	//		Returns an animation that will size the target node
	//		defined in args Object about it's center to
	//		a width and height defined by (args.width, args.height),
	//		supporting an optional method: chain||combine mixin
	//		(defaults to chain).
	//
	//	- works best on absolutely or relatively positioned elements
	//
	// example:
	//	|	// size #myNode to 400px x 200px over 1 second
	//	|	dojo.fx.sizeTo({
	//	|		node:'myNode',
	//	|		duration: 1000,
	//	|		width: 400,
	//	|		height: 200,
	//	|		method: "combine"
	//	|	}).play();
	//

	var node = args.node = dojo.byId(args.node),
		abs = "absolute";

	var method = args.method || "chain";
	if(!args.duration){ args.duration = 500; } // default duration needed
	if(method == "chain"){ args.duration = Math.floor(args.duration / 2); }
	
	var top, newTop, left, newLeft, width, height = null;

	var init = (function(n){
		return function(){
			var cs = dojo.getComputedStyle(n),
				pos = cs.position,
				w = cs.width,
				h = cs.height
			;
			
			top = (pos == abs ? n.offsetTop : parseInt(cs.top) || 0);
			left = (pos == abs ? n.offsetLeft : parseInt(cs.left) || 0);
			width = (w == "auto" ? 0 : parseInt(w));
			height = (h == "auto" ? 0 : parseInt(h));
			
			newLeft = left - Math.floor((args.width - width) / 2);
			newTop = top - Math.floor((args.height - height) / 2);

			if(pos != abs && pos != 'relative'){
				var ret = dojo.coords(n, true);
				top = ret.y;
				left = ret.x;
				n.style.position = abs;
				n.style.top = top + "px";
				n.style.left = left + "px";
			}
		}
	})(node);

	var anim1 = dojo.animateProperty(dojo.mixin({
		properties: {
			height: function(){
				init();
				return { end: args.height || 0, start: height };
			},
			top: function(){
				return { start: top, end: newTop };
			}
		}
	}, args));
	var anim2 = dojo.animateProperty(dojo.mixin({
		properties: {
			width: function(){
				return { start: width, end: args.width || 0 }
			},
			left: function(){
				return { start: left, end: newLeft }
			}
		}
	}, args));

	var anim = dojo.fx[(args.method == "combine" ? "combine" : "chain")]([anim1, anim2]);
	return anim; // dojo.Animation

};

dojox.fx.slideBy = function(/* Object */args){
	// summary:
	//		Returns an animation to slide a node by a defined offset.
	//
	// description:
	//		Returns an animation that will slide a node (args.node) from it's
	//		current position to it's current posision plus the numbers defined
	//		in args.top and args.left. standard dojo.fx mixin's apply.
	//
	// example:
	//	|	// slide domNode 50px down, and 22px left
	//	|	dojox.fx.slideBy({
	//	|		node: domNode, duration:400,
	//	|		top: 50, left: -22
	//	|	}).play();

	var node = args.node = dojo.byId(args.node),
		top, left;

	var init = (function(n){
		return function(){
			var cs = dojo.getComputedStyle(n);
			var pos = cs.position;
			top = (pos == 'absolute' ? n.offsetTop : parseInt(cs.top) || 0);
			left = (pos == 'absolute' ? n.offsetLeft : parseInt(cs.left) || 0);
			if(pos != 'absolute' && pos != 'relative'){
				var ret = dojo.coords(n, true);
				top = ret.y;
				left = ret.x;
				n.style.position = "absolute";
				n.style.top = top + "px";
				n.style.left = left + "px";
			}
		}
	})(node);
	init();
	
	var _anim = dojo.animateProperty(dojo.mixin({
		properties: {
			// FIXME: is there a way to update the _Line after creation?
			// null start values allow chaining to work, animateProperty will
			// determine them for us (except in ie6? -- ugh)
			top: top + (args.top || 0),
			left: left + (args.left || 0)
		}
	}, args));
	dojo.connect(_anim, "beforeBegin", _anim, init);
	return _anim; // dojo.Animation
};

dojox.fx.crossFade = function(/* Object */args){
	// summary:
	//		Returns an animation cross fading two element simultaneously
	//
	// args:
	//	args.nodes: Array - two element array of domNodes, or id's
	//
	//	all other standard animation args mixins apply. args.node ignored.
	//

	// simple check for which node is visible, maybe too simple?
	var node1 = args.nodes[0] = dojo.byId(args.nodes[0]),
		op1 = dojo.style(node1,"opacity"),
		node2 = args.nodes[1] = dojo.byId(args.nodes[1]),
		op2 = dojo.style(node2, "opacity")
	;
	
	var _anim = dojo.fx.combine([
		dojo[(op1 == 0 ? "fadeIn" : "fadeOut")](dojo.mixin({
			node: node1
		},args)),
		dojo[(op1 == 0 ? "fadeOut" : "fadeIn")](dojo.mixin({
			node: node2
		},args))
	]);
	return _anim; // dojo.Animation
};

dojox.fx.highlight = function(/*Object*/ args){
	// summary:
	//		Highlight a node
	//
	// description:
	//		Returns an animation that sets the node background to args.color
	//		then gradually fades back the original node background color
	//
	// example:
	//	|	dojox.fx.highlight({ node:"foo" }).play();

	var node = args.node = dojo.byId(args.node);

	args.duration = args.duration || 400;
	
	// Assign default color light yellow
	var startColor = args.color || '#ffff99',
		endColor = dojo.style(node, "backgroundColor")
	;

	// safari "fix"
	// safari reports rgba(0, 0, 0, 0) (black) as transparent color, while
	// other browsers return "transparent", rendered as white by default by
	// dojo.Color; now dojo.Color maps "transparent" to
	// djConfig.transparentColor ([r, g, b]), if present; so we can use
	// the color behind the effect node
	if(endColor == "rgba(0, 0, 0, 0)"){
		endColor = "transparent";
	}

	var anim = dojo.animateProperty(dojo.mixin({
		properties: {
			backgroundColor: { start: startColor, end: endColor }
		}
	}, args));

	if(endColor == "transparent"){
		dojo.connect(anim, "onEnd", anim, function(){
			node.style.backgroundColor = endColor;
		});
	}

	return anim; // dojo.Animation
};

 
dojox.fx.wipeTo = function(/*Object*/ args){
	// summary:
	//		Animate a node wiping to a specific width or height
	//
	// description:
	//		Returns an animation that will expand the
	//		node defined in 'args' object from it's current to
	//		the height or width value given by the args object.
	//
	//		default to height:, so leave height null and specify width:
	//		to wipeTo a width. note: this may be deprecated by a
	//
	//		Note that the final value should not include
	//		units and should be an integer.  Thus a valid args object
	//		would look something like this:
	//
	//		|	dojox.fx.wipeTo({ node: "nodeId", height: 200 }).play();
	//
	//		Node must have no margin/border/padding, so put another
	//		node inside your target node for additional styling.

	args.node = dojo.byId(args.node);
	var node = args.node, s = node.style;

	var dir = (args.width ? "width" : "height"),
		endVal = args[dir],
		props = {}
	;

	props[dir] = {
		// wrapped in functions so we wait till the last second to query (in case value has changed)
		start: function(){
			// start at current [computed] height, but use 1px rather than 0
			// because 0 causes IE to display the whole panel
			s.overflow = "hidden";
			if(s.visibility == "hidden" || s.display == "none"){
				s[dir] = "1px";
				s.display = "";
				s.visibility = "";
				return 1;
			}else{
				var now = dojo.style(node,dir);
				return Math.max(now, 1);
			}
		},
		end: endVal
	};

	var anim = dojo.animateProperty(dojo.mixin({ properties: props }, args));
	return anim; // dojo.Animation
};

}

if(!dojo._hasResource["dojox.fx"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.fx"] = true;
dojo.provide("dojox.fx");



}

if(!dojo._hasResource["dojox.widget.DialogSimple"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.widget.DialogSimple"] = true;
dojo.provide("dojox.widget.DialogSimple");




dojo.declare("dojox.widget.DialogSimple", [dojox.layout.ContentPane, dijit._DialogBase], {
	// summary: A Simple Dialog Mixing the `dojox.layout.ContentPane` functionality over
	//		top of a vanilla `dijit.Dialog`. See `dojox.widget.Dialog` for a more flexible
	//		dialog option allowing animations and different styles/theme support.
});

}

if(!dojo._hasResource['dojox.widget.Dialog']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['dojox.widget.Dialog'] = true;
dojo.provide('dojox.widget.Dialog');
dojo.experimental('dojox.widget.Dialog');





dojo.declare('dojox.widget.Dialog', dojox.widget.DialogSimple,
	{
	// summary:
	//		A Lightbox-like Modal-dialog for HTML Content
	//
	// description:
	//		An HTML-capable Dialog widget with advanced sizing
	//		options, animated show/hide and other useful options.
	//
	//		This Dialog is also very easy to apply custom styles to.
	//
	//		It works identically to a `dijit.Dialog` with several
	//		additional parameters.
	
	templateString: dojo.cache("dojox.widget", "Dialog/Dialog.html", "<div class=\"dojoxDialog\" tabindex=\"-1\" role=\"dialog\" aria-labelledby=\"${id}_title\">\n\t<div dojoAttachPoint=\"titleBar\" class=\"dojoxDialogTitleBar\">\n\t\t<span dojoAttachPoint=\"titleNode\" class=\"dojoxDialogTitle\" id=\"${id}_title\">${title}</span>\n\t</div>\n\t<div dojoAttachPoint=\"dojoxDialogWrapper\">\n\t\t<div dojoAttachPoint=\"containerNode\" class=\"dojoxDialogPaneContent\"></div>\n\t</div>\n\t<div dojoAttachPoint=\"closeButtonNode\" class=\"dojoxDialogCloseIcon\" dojoAttachEvent=\"onclick: onCancel\">\n\t\t\t<span dojoAttachPoint=\"closeText\" class=\"closeText\">x</span>\n\t</div>\n</div>\n"),
	
	// sizeToViewport: Boolean
	//		If true, fix the size of the dialog to the Viewport based on
	//		viewportPadding value rather than the calculated or natural
	//		stlye. If false, base the size on a passed dimension attribute.
	//		Eitherway, the viewportPadding value is used if the the content
	//		extends beyond the viewport size for whatever reason.
	sizeToViewport: false,
	
	// viewportPadding: Integer
	//		If sizeToViewport="true", this is the amount of padding in pixels to leave
	//		between the dialog border and the viewport edge.
	//		This value is also used when sizeToViewport="false" and dimensions exceeded
	//		by dialog content to ensure dialog does not go outside viewport boundary
	viewportPadding: 35,
	
	// dimensions: Array
	//		A two-element array of [widht,height] to animate the Dialog to if sizeToViewport="false"
	//		Defaults to [300,300]
	dimensions: null,
	
	// easing: Function?|String?
	//		An easing function to apply to the sizing animation.
	easing: null,
	
	// sizeDuration: Integer
	//		Time (in ms) to use in the Animation for sizing.
	sizeDuration: dijit._defaultDuration,
	
	// sizeMethod: String
	//		To be passed to dojox.fx.sizeTo, one of "chain" or "combine" to effect
	//		the animation sequence.
	sizeMethod: "chain",
	
	// showTitle: Boolean
	//		Toogle to show or hide the Title area. Can only be set at startup.
	showTitle: false,
	
	// draggable: Boolean
	//		Make the pane draggable. Differs from dijit.Dialog by setting default to false
	draggable: false, // simply over-ride the default from dijit.Dialog
	
	// modal: Boolean
	//		If true, this Dialog instance will be truly modal and prevent closing until
	//		explicitly told to by calling hide() - Defaults to false to preserve previous
	//		behaviors.
	modal: false,
	
	constructor: function(props, node){
		this.easing = props.easing || dojo._defaultEasing;
		this.dimensions = props.dimensions || [300, 300];
	},
	
	_setup: function(){
		// summary: Piggyback on dijit.Dialog's _setup for load-time options, deferred to

		this.inherited(arguments);
		if(!this._alreadyInitialized){
			this._navIn = dojo.fadeIn({ node: this.closeButtonNode });
			this._navOut = dojo.fadeOut({ node: this.closeButtonNode });
			if(!this.showTitle){
				dojo.addClass(this.domNode,"dojoxDialogNoTitle");
			}
		}
	},
	
	layout: function(e){
		this._setSize();
		this.inherited(arguments);
	},
	
	_setSize: function(){
		// summary: cache and set our desired end position
		this._vp = dojo.window.getBox();
		var tc = this.containerNode,
			vpSized = this.sizeToViewport
		;
		return this._displaysize = {
			w: vpSized ? tc.scrollWidth : this.dimensions[0],
			h: vpSized ? tc.scrollHeight : this.dimensions[1]
		}; // Object
	},
	
	show: function(){
		if(this.open){ return; }
		
		this._setSize();
		dojo.style(this.closeButtonNode,"opacity", 0);
		dojo.style(this.domNode, {
			overflow: "hidden",
			opacity: 0,
			width: "1px",
			height: "1px"
		});
		dojo.style(this.containerNode, {
			opacity: 0,
			overflow: "hidden"
		});
		
		this.inherited(arguments);

		if(this.modal){
			// prevent escape key from closing dialog
			// connect to body to trap this event from the Dialog a11y code, and stop escape key
			// from doing anything in the modal:true case:
			this._modalconnects.push(dojo.connect(dojo.body(), "onkeypress", function(e){
				if(e.charOrCode == dojo.keys.ESCAPE){
					dojo.stopEvent(e);
				}
			}));
		}else{
			// otherwise, allow clicking on the underlay to close
			this._modalconnects.push(dojo.connect(dijit._underlay.domNode, "onclick", this, "onCancel"));
		}
		this._modalconnects.push(dojo.connect(this.domNode,"onmouseenter",this,"_handleNav"));
		this._modalconnects.push(dojo.connect(this.domNode,"onmouseleave",this,"_handleNav"));
		
	},
	
	_handleNav: function(e){
		// summary: Handle's showing or hiding the close icon

		var navou = "_navOut",
			navin = "_navIn",
			animou = (e.type == "mouseout" ? navin : navou),
			animin = (e.type == "mouseout" ? navou : navin)
		;
		
		this[animou].stop();
		this[animin].play();
		
	},
	
	// an experiment in a quicksilver-like hide. too choppy for me.
	/*
	hide: function(){
		// summary: Hide the dialog

		// if we haven't been initialized yet then we aren't showing and we can just return
		if(!this._alreadyInitialized){
			return;
		}

		this._fadeIn && this._fadeIn.stop();

		if (this._scrollConnected){
			this._scrollConnected = false;
		}
		dojo.forEach(this._modalconnects, dojo.disconnect);
		this._modalconnects = [];
		if(this.refocus){
			this.connect(this._fadeOut,"onEnd",dojo.hitch(dijit,"focus",this._savedFocus));
		}
		if(this._relativePosition){
			delete this._relativePosition;
		}
		
		dojox.fx.sizeTo({
			node: this.domNode,
			duration:this.sizeDuration || this.duration,
			width: this._vp.w - 1,
			height: 5,
			onBegin: dojo.hitch(this,function(){
				this._fadeOut.play(this.sizeDuration / 2);
			})
		}).play();
		
		this.open = false;
	}, */

	_position: function(){
		
		if(!this._started){ return; } // prevent content: from firing this anim #8914
		
		if(this._sizing){
			this._sizing.stop();
			this.disconnect(this._sizingConnect);
			delete this._sizing;
		}
		
		this.inherited(arguments);
		
		if(!this.open){ dojo.style(this.containerNode, "opacity", 0); }
		var pad = this.viewportPadding * 2;
		
		var props = {
			node: this.domNode,
			duration: this.sizeDuration || dijit._defaultDuration,
			easing: this.easing,
			method: this.sizeMethod
		};

		var ds = this._displaysize || this._setSize();
		props['width'] = ds.w = (ds.w + pad >= this._vp.w || this.sizeToViewport)
			? this._vp.w - pad : ds.w;
			
		props['height'] = ds.h = (ds.h + pad >= this._vp.h || this.sizeToViewport)
			? this._vp.h - pad : ds.h;
		
		this._sizing = dojox.fx.sizeTo(props);
		this._sizingConnect = this.connect(this._sizing,"onEnd","_showContent");
		this._sizing.play();

	},

	_showContent: function(e){
		// summary: Show the inner container after sizing animation

		var container = this.containerNode;
		dojo.style(this.domNode, {
			overflow: "visible",
			opacity: 1
		});
		dojo.style(this.closeButtonNode,"opacity",1);
		dojo.style(container, {
			height: this._displaysize.h - this.titleNode.offsetHeight + "px",
			width: this._displaysize.w + "px",
			overflow:"auto"
		});
		dojo.anim(container, { opacity:1 });
	}
	
});

}

if(!dojo._hasResource["dojo.fx.easing"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.fx.easing"] = true;
dojo.provide("dojo.fx.easing");

dojo.getObject("fx.easing", true, dojo);

dojo.fx.easing = {
	// summary:
	//		Collection of easing functions to use beyond the default
	//		`dojo._defaultEasing` function.
	//
	// description:
	//
	//		Easing functions are used to manipulate the iteration through
	//		an `dojo.Animation`s _Line. _Line being the properties of an Animation,
	//		and the easing function progresses through that Line determing
	//		how quickly (or slowly) it should go. Or more accurately: modify
	//		the value of the _Line based on the percentage of animation completed.
	//
	//		All functions follow a simple naming convention of "ease type" + "when".
	//		If the name of the function ends in Out, the easing described appears
	//		towards the end of the animation. "In" means during the beginning,
	//		and InOut means both ranges of the Animation will applied, both
	//		beginning and end.
	//
	//		One does not call the easing function directly, it must be passed to
	//		the `easing` property of an animation.
	//
	//	example:
	//	|	
	//	|	var anim = dojo.fadeOut({
	//	|		node: 'node',
	//	|		duration: 2000,
	//	|		//	note there is no ()
	//	|		easing: dojo.fx.easing.quadIn
	//	|	}).play();
	//
	
	linear: function(/* Decimal? */n){
		// summary: A linear easing function
		return n;
	},

	quadIn: function(/* Decimal? */n){
		return Math.pow(n, 2);
	},

	quadOut: function(/* Decimal? */n){
		return n * (n - 2) * -1;
	},

	quadInOut: function(/* Decimal? */n){
		n = n * 2;
		if(n < 1){ return Math.pow(n, 2) / 2; }
		return -1 * ((--n) * (n - 2) - 1) / 2;
	},

	cubicIn: function(/* Decimal? */n){
		return Math.pow(n, 3);
	},

	cubicOut: function(/* Decimal? */n){
		return Math.pow(n - 1, 3) + 1;
	},

	cubicInOut: function(/* Decimal? */n){
		n = n * 2;
		if(n < 1){ return Math.pow(n, 3) / 2; }
		n -= 2;
		return (Math.pow(n, 3) + 2) / 2;
	},

	quartIn: function(/* Decimal? */n){
		return Math.pow(n, 4);
	},

	quartOut: function(/* Decimal? */n){
		return -1 * (Math.pow(n - 1, 4) - 1);
	},

	quartInOut: function(/* Decimal? */n){
		n = n * 2;
		if(n < 1){ return Math.pow(n, 4) / 2; }
		n -= 2;
		return -1 / 2 * (Math.pow(n, 4) - 2);
	},

	quintIn: function(/* Decimal? */n){
		return Math.pow(n, 5);
	},

	quintOut: function(/* Decimal? */n){
		return Math.pow(n - 1, 5) + 1;
	},

	quintInOut: function(/* Decimal? */n){
		n = n * 2;
		if(n < 1){ return Math.pow(n, 5) / 2; };
		n -= 2;
		return (Math.pow(n, 5) + 2) / 2;
	},

	sineIn: function(/* Decimal? */n){
		return -1 * Math.cos(n * (Math.PI / 2)) + 1;
	},

	sineOut: function(/* Decimal? */n){
		return Math.sin(n * (Math.PI / 2));
	},

	sineInOut: function(/* Decimal? */n){
		return -1 * (Math.cos(Math.PI * n) - 1) / 2;
	},

	expoIn: function(/* Decimal? */n){
		return (n == 0) ? 0 : Math.pow(2, 10 * (n - 1));
	},

	expoOut: function(/* Decimal? */n){
		return (n == 1) ? 1 : (-1 * Math.pow(2, -10 * n) + 1);
	},

	expoInOut: function(/* Decimal? */n){
		if(n == 0){ return 0; }
		if(n == 1){ return 1; }
		n = n * 2;
		if(n < 1){ return Math.pow(2, 10 * (n - 1)) / 2; }
		--n;
		return (-1 * Math.pow(2, -10 * n) + 2) / 2;
	},

	circIn: function(/* Decimal? */n){
		return -1 * (Math.sqrt(1 - Math.pow(n, 2)) - 1);
	},

	circOut: function(/* Decimal? */n){
		n = n - 1;
		return Math.sqrt(1 - Math.pow(n, 2));
	},

	circInOut: function(/* Decimal? */n){
		n = n * 2;
		if(n < 1){ return -1 / 2 * (Math.sqrt(1 - Math.pow(n, 2)) - 1); }
		n -= 2;
		return 1 / 2 * (Math.sqrt(1 - Math.pow(n, 2)) + 1);
	},

	backIn: function(/* Decimal? */n){
		// summary:
		//		An easing function that starts away from the target,
		//		and quickly accelerates towards the end value.
		//
		//		Use caution when the easing will cause values to become
		//		negative as some properties cannot be set to negative values.
		var s = 1.70158;
		return Math.pow(n, 2) * ((s + 1) * n - s);
	},

	backOut: function(/* Decimal? */n){
		// summary:
		//		An easing function that pops past the range briefly, and slowly comes back.
		//
		// description:
		//		An easing function that pops past the range briefly, and slowly comes back.
		//
		//		Use caution when the easing will cause values to become negative as some
		//		properties cannot be set to negative values.
		
		n = n - 1;
		var s = 1.70158;
		return Math.pow(n, 2) * ((s + 1) * n + s) + 1;
	},

	backInOut: function(/* Decimal? */n){
		// summary:
		//		An easing function combining the effects of `backIn` and `backOut`
		//
		// description:
		//		An easing function combining the effects of `backIn` and `backOut`.
		//		Use caution when the easing will cause values to become negative
		//		as some properties cannot be set to negative values.
		var s = 1.70158 * 1.525;
		n = n * 2;
		if(n < 1){ return (Math.pow(n, 2) * ((s + 1) * n - s)) / 2; }
		n-=2;
		return (Math.pow(n, 2) * ((s + 1) * n + s) + 2) / 2;
	},

	elasticIn: function(/* Decimal? */n){
		// summary:
		//		An easing function the elastically snaps from the start value
		//
		// description:
		//		An easing function the elastically snaps from the start value
		//
		//		Use caution when the elasticity will cause values to become negative
		//		as some properties cannot be set to negative values.
		if(n == 0 || n == 1){ return n; }
		var p = .3;
		var s = p / 4;
		n = n - 1;
		return -1 * Math.pow(2, 10 * n) * Math.sin((n - s) * (2 * Math.PI) / p);
	},

	elasticOut: function(/* Decimal? */n){
		// summary:
		//		An easing function that elasticly snaps around the target value,
		//		near the end of the Animation
		//
		// description:
		//		An easing function that elasticly snaps around the target value,
		//		near the end of the Animation
		//
		//		Use caution when the elasticity will cause values to become
		//		negative as some properties cannot be set to negative values.
		if(n==0 || n == 1){ return n; }
		var p = .3;
		var s = p / 4;
		return Math.pow(2, -10 * n) * Math.sin((n - s) * (2 * Math.PI) / p) + 1;
	},

	elasticInOut: function(/* Decimal? */n){
		// summary:
		//		An easing function that elasticly snaps around the value, near
		//		the beginning and end of the Animation.
		//
		// description:
		//		An easing function that elasticly snaps around the value, near
		//		the beginning and end of the Animation.
		//
		//		Use caution when the elasticity will cause values to become
		//		negative as some properties cannot be set to negative values.
		if(n == 0) return 0;
		n = n * 2;
		if(n == 2) return 1;
		var p = .3 * 1.5;
		var s = p / 4;
		if(n < 1){
			n -= 1;
			return -.5 * (Math.pow(2, 10 * n) * Math.sin((n - s) * (2 * Math.PI) / p));
		}
		n -= 1;
		return .5 * (Math.pow(2, -10 * n) * Math.sin((n - s) * (2 * Math.PI) / p)) + 1;
	},

	bounceIn: function(/* Decimal? */n){
		// summary:
		//		An easing function that 'bounces' near the beginning of an Animation
		return (1 - dojo.fx.easing.bounceOut(1 - n)); // Decimal
	},

	bounceOut: function(/* Decimal? */n){
		// summary:
		//		An easing function that 'bounces' near the end of an Animation
		var s = 7.5625;
		var p = 2.75;
		var l;
		if(n < (1 / p)){
			l = s * Math.pow(n, 2);
		}else if(n < (2 / p)){
			n -= (1.5 / p);
			l = s * Math.pow(n, 2) + .75;
		}else if(n < (2.5 / p)){
			n -= (2.25 / p);
			l = s * Math.pow(n, 2) + .9375;
		}else{
			n -= (2.625 / p);
			l = s * Math.pow(n, 2) + .984375;
		}
		return l;
	},

	bounceInOut: function(/* Decimal? */n){
		// summary:
		//		An easing function that 'bounces' at the beginning and end of the Animation
		if(n < 0.5){ return dojo.fx.easing.bounceIn(n * 2) / 2; }
		return (dojo.fx.easing.bounceOut(n * 2 - 1) / 2) + 0.5; // Decimal
	}
};

}

if(!dojo._hasResource["dojox.timing.Sequence"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.timing.Sequence"] = true;
dojo.provide("dojox.timing.Sequence");
dojo.experimental("dojox.timing.Sequence");

dojo.declare("dojox.timing.Sequence", null, {
	// summary:
	//	This class provides functionality to really sequentialize
	//	function calls. You need to provide a list of functions and
	//	some parameters for each (like: pauseBefore) and they will
	//	be run one after another. This can be very useful for slideshows
	//	or alike things.
	//
	// description:
	//	This array will contain the sequence defines resolved, so that
	// 	ie. repeat:10 will result in 10 elements in the sequence, so
	// 	the repeat handling is easier and we don't need to handle that
	// 	many extra cases. Also the doneFunction, if given is added at the
	// 	end of the resolved-sequences.

/*=====
	// _defsResolved: Array
	// 	The resolved sequence, for easier handling.
	_defsResolved: [],
=====*/

	// This is the time to wait before goOn() calls _go(), which
	// mostly results from a pauseAfter for a function that returned
	// false and is later continued by the external goOn() call.
	// The time to wait needs to be waited in goOn() where the
	// sequence is continued.

	// _goOnPause: Integer
	//	The pause to wait before really going on.
	_goOnPause: 0,

	_running: false,

	constructor: function(){
		this._defsResolved = [];
	},

	go: function(/* Array */defs, /* Function|Array? */doneFunction){
		// summary: Run the passed sequence definition
		//
		// defs: Array
		//		The sequence of actions
		// doneFunction: Function|Array?
		//		The function to call when done
		this._running = true;
		dojo.forEach(defs, function(cur){
			if(cur.repeat > 1){
				var repeat = cur.repeat;
				for(var j = 0; j < repeat; j++){
					cur.repeat = 1;
					this._defsResolved.push(cur);
				}
			}else{
				this._defsResolved.push(cur);
			}
		}, this);
		var last = defs[defs.length - 1];
		if(doneFunction){
			this._defsResolved.push({ func: doneFunction });
		}
		// stop the sequence, this actually just sets this._running to false
		this._defsResolved.push({ func: [this.stop, this] });
		this._curId = 0;
		this._go();
	},

	_go: function(){
		// summary: Execute one task of this._defsResolved.

		// if _running was set to false stop the sequence, this is the
		// case when i.e. stop() was called.
		if(!this._running){
			return;
		}
		var cur = this._defsResolved[this._curId];
		this._curId += 1;
		// create the function to call, the func property might be an array, which means
		// [function, context, parameter1, parameter2, ...]
		function resolveAndCallFunc(func) {
			var ret = null;
			if(dojo.isArray(func)){
				// Two elements might only be given when the function+context
				// is given, this is nice for using this, ie: [this.func, this]
				if(func.length>2){
					ret = func[0].apply(func[1], func.slice(2));
				}else{
					ret = func[0].apply(func[1]);
				}
			}else{
				ret = func();
			}
			return ret;
		}

		if(this._curId >= this._defsResolved.length){
			resolveAndCallFunc(cur.func); // call the last function, since it is the doneFunction we dont need to handle pause stuff
			// don't go on and call this._go() again, we are done
			return;
		}

		if(cur.pauseAfter){
			if(resolveAndCallFunc(cur.func) !== false){
				setTimeout(dojo.hitch(this, "_go"), cur.pauseAfter);
			}else{
				this._goOnPause = cur.pauseAfter;
			}
		}else if(cur.pauseBefore){
			var x = dojo.hitch(this,function(){
				if(resolveAndCallFunc(cur.func) !== false){
					this._go()
				}
			});
			setTimeout(x, cur.pauseBefore);
		}else{
			if(resolveAndCallFunc(cur.func) !== false){
				this._go();
			}
		}
	},

	goOn: function(){
		// summary: This method just provides a hook from the outside, so that
		//		an interrupted sequence can be continued.
		if(this._goOnPause){
			setTimeout(dojo.hitch(this, "_go"), this._goOnPause);
			this._goOnPause = 0; // reset it, so if the next one doesnt set it we dont use the old pause
		}else{ this._go(); }
	},

	stop: function(){
		// summary:  Stop the currently running sequence.
		//
		// description:
		//		This can only interrupt the sequence not the last function that
		//		had been started. If the last function was i.e. a slideshow
		//		that is handled inside a function that you have given as
		//		one sequence item it cant be stopped, since it is not controlled
		//		by this object here. In this case it would be smarter to
		//		run the slideshow using a sequence object so you can also stop
		//		it using this method.
		this._running = false;
	}

});

}

if(!dojo._hasResource["plugins.files.Dialog"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.files.Dialog"] = true;
dojo.provide("plugins.files.Dialog");

// DISPLAY A LOGIN DIALOGUE WINDOW AND AUTHENTICATE
// WITH THE SERVER TO RETRIEVE A SESSION ID WHICH IS
// STORED AS Agua.cookie("sessionid")





//dojo.require("Agua.cookie"); 


dojo.declare( "plugins.files.Dialog",
	[ plugins.core.Common ],
{
	loginMessageId: "loginMessage",

	loginLauncherId: "loginLauncher",

	message : '',
	
	parentFunction : null,
	
	args: null,
	
	dialogWidget: null,

	cssFiles: [
		dojo.moduleUrl("plugins", "files/css/dialog.css"),
		dojo.moduleUrl("dojox", "widget/Dialog/Dialog.css")
	],
	
	constructor: function (args)
	{
//	    ////////console.log("constructor	plugins.files.Dialog.constructor(args)");
		this.args = args;
		this.message = args.message;
		this.parentFunction = args.parentFunction;
		this.url = args.url;
		this.query = args.query;
		this.launchdialogWindow();
	},
	
	launchdialogWindow : function ()
	{
//	    ////////console.log("launchdialogWindow	plugins.files.Dialog.launchdialogWindow()");
		var dialogWindow = this;

		// CONSTRUCT INPUT ELEMENTS FOR LOGIN WINDOW
		var table = document.createElement("table");
		table.className = "dialogTable";

			var tr1 = document.createElement("tr");
		
				// SHOW MESSAGE
				var td1 = document.createElement("td");
				var text1 = document.createTextNode(this.message);
				td1.setAttribute("colspan", 2);
				td1.appendChild(text1);

			tr1.appendChild(td1);		
				
			var tr2 = document.createElement("tr");
		
				// DISPLAY 'YES' AND 'NO' BUTTONS
				var yesButton = new dijit.form.Button(); //forget to delete
				yesButton.setLabel("Yes");
				yesButton.domNode.setAttribute("class", "dialogButton");

					
				yesButton.onClick = function(e)
				{
//				    ////////console.log("yesButton.onClick	plugins.files.Dialog.yesButton.onClick(e)");
					
					dialogWindow.query += "&modifier=overwrite";
					dialogWindow.parentFunction(dialogWindow.url, dialogWindow.query);
					dialogWindow.fadeOut("yes");
				} 
		
				var yesTd = document.createElement("td");
				yesTd.setAttribute("align", "center");
				yesTd.setAttribute("colspan", 2);
				yesTd.appendChild(yesButton.domNode);
		
				// DISPLAY 'YES' AND 'NO' BUTTONS
				var noButton = new dijit.form.Button(); //forget to delete
				noButton.setLabel("No");
				noButton.domNode.setAttribute("class", "dialogButton");
		
				var dialogWindow = this;

				var noTd = document.createElement("td");
				noTd.setAttribute("align", "center");
				noTd.setAttribute("colspan", 2);
				noTd.appendChild(noButton.domNode);
		
			tr2.setAttribute("class", "centeredRow");
			tr2.appendChild(yesTd);
			tr2.appendChild(noTd);
		
		table.appendChild(tr1);
		table.appendChild(tr2);
		
		document.body.appendChild(table);

		// CREATE LOGIN WINDOW
		var progDialog = new dojox.widget.Dialog ({
			id: 				"loginDialog",
			dimensions: 		[250,200],
			draggable: 			true,
			sizeDuration: 		200,
			sizeMethod:      	"combine",
			viewportPadding:	"125",
			showTitle: 			"true",
			title: 				"Confirmation"
			
		}, "progDialog" );		
		progDialog.attr("class", "centered");
		
		this.dialogWidget = progDialog;
		
		// SHOW DIALOGUE
		// LATER: FIX THIS ERROR 'Error undefined running custom onLoad code'
		progDialog.setContent(table);
		progDialog.startup();
		progDialog.show();
	},

	fadeOut: function()
	{
//	    ////////console.log("fadeOut	plugins.files.Dialog.fadeOut()");
		// FADE OUT LOGIN WINDOW
		dojo.fadeOut({ node: "loginDialog", duration: 700 }).play();
		setTimeout( "dijit.byId('loginDialog').destroy()", 700);
	}

}); // END

}

if(!dojo._hasResource["plugins.dijit.Confirm"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.dijit.Confirm"] = true;
dojo.provide("plugins.dijit.Confirm");

// HAS A



// INHERITS



dojo.declare( "plugins.dijit.Confirm",
	[ dijit._Widget, dijit._Templated, plugins.core.Common ],
{
	//Path to the template of this widget. 
	templateString:"<div dojoAttachPoint=\"containerNode\">\n\n    <table\n        cellspacing=\"0px\" cellpadding=\"0px\"\n        height=\"300px\" width=\"100%\" >\n        <tr>\n            <td>\n                \n                <div\n                    dojoAttachPoint=\"dialog\"\n                    dojoType=\"dijit.Dialog\"\n                    class=\"confirmDialog\"\n                    closeText=\"false\"\n                    title=\"${title}\"\n                >\n                    \n                    <table\n                        cellpadding=\"0\"\n                        cellspacing=\"0\"\n                        width=\"100%\"\n                        >\n                        <tr class=\"message\" align=\"center\">\n                            <td\n                                align=\"center\"\n                                dojoAttachPoint=\"messageNode\"\n                                colspan=\"2\">${message}</td>\n                        </tr>\n                        \n                        <tr>\n                            <td align=\"center\" class=\"yesButton\">\n                                <button\n                                    dojoType=\"dijit.form.Button\"\n                                    type=\"button\"\n                                    label=\"Yes\"\n                                    dojoAttachEvent=\"onClick:doYes\"\n                                    >\n                                </button>\n                            </td>\n\n                            <td align=\"center\" class=\"noButton\">\n                                <div\n                                    dojoType=\"dijit.form.Button\"\n                                    type=\"button\"\n                                    label=\"No\"\n                                    dojoAttachEvent=\"onClick:doNo\"\n                                    >\n                                </div>\n                            </td>\n                        </tr>\n                    </table>\n\n                </div>\n            \n            </td>\n        </tr>\n    </table>\n</div>\n",

	// OR USE @import IN HTML TEMPLATE
	cssFiles : [ dojo.moduleUrl("plugins") + "/dijit/css/confirmdialog.css" ],

	// Calls dijit._Templated.widgetsInTemplate
	widgetsInTemplate : true,
	
	// PARENT plugins.workflow.Apps WIDGET
	parentWidget : null,
	
	// APPLICATION OBJECT
	application : null,
	
	// DIALOG TITLE
	title: null,
	
	// DISPLAYED MESSAGE 
	message : null,
	
	constructor : function(args)
	{
		//console.log("ConfirmDialog.constructor    plugins.dijit.Confirm.constructor()");

		this.title 				=	args.title;
		this.message 			=	args.message;
		this.parentWidget 		=	args.parentWidget;
		this.yesCallback 		=	args.yesCallback;
		this.noCallback 		=	args.noCallback;
		
		// LOAD CSS
        this.loadCSS();
	},

	getApplication : function ()
	{
		return this.application;
	},

	postCreate : function()
	{
		////console.log("ConfirmDialog.postCreate    plugins.dijit.Confirm.postCreate()");

		this.startup();
	},
	
	startup : function ()
	{
		//console.log("ConfirmDialog.startup    plugins.dijit.Confirm.startup()");
		//console.log("ConfirmDialog.startup    this.parentWidget: " + this.parentWidget);

		this.inherited(arguments);

		this.setDialogue();
		
		// ADD CSS NAMESPACE CLASS
		dojo.addClass(this.dialog.containerNode, "confirmDialog");
		dojo.addClass(this.dialog.titleNode, "confirmDialog");
		dojo.addClass(this.dialog.closeButtonNode, "confirmDialog");

		//console.log("ConfirmDialog.startup    END of startup()");
	},

	// SHOW THE DIALOGUE
	show: function ()
	{
		this.dialog.show();
	},

	// HIDE THE DIALOGUE
	hide: function ()
	{
		this.dialog.hide();
	},

	doYes : function(type)
	{
		//console.log("ConfirmDialog.doYes    plugins.dijit.Confirm.doYes()");
		
		this.yesCallback();
		this.dialog.hide();
	},

	doNo : function()
	{
		//console.log("ConfirmDialog.doNo    plugins.dijit.Confirm.doNo()");
		this.noCallback();
		this.dialog.hide();
	},


	// LOAD THE DIALOGUE VALUES
	load : function (args)
	{
		//console.log("Confirm.load    plugins.dijit.InputDialog.load()");
		//console.log("Confirm.load    args: " + dojo.toJson(args));

		if ( args.title == null )	{	args.title = "Input dialogue";	}
		this.dialog.titleNode.innerHTML	=	args.title;
		this.dialog.messageNode.innerHTML	=	args.message;
		this.dialog.yesCallback		=	args.yesCallback;
		this.dialog.noCallback		=	args.noCallback

		//console.log("Confirm.load    this.yesCallback: " + this.yesCallback.toString());

		this.show();
	},


	// APPEND TO DOCUMENT BODY
	setDialogue : function () {
		
		// APPEND DIALOG TO DOCUMENT
		//this.dialog.title = title;
		document.body.appendChild(this.dialog.domNode);
		//this.dialog.show();
	}

});
	

}

if(!dojo._hasResource["plugins.files._GroupDragPane"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.files._GroupDragPane"] = true;
dojo.provide("plugins.files._GroupDragPane");

/* SUMMARY:  HANDLE GETTING SELECTED OBJECT IN DND LIST

	OVERRIDE onDropInternal(), onDropExternal()

	OR onDrop TO COVER BOTH ON THE source/target OBJECT.

*/





// HAS A





dojo.declare("plugins.files._GroupDragPane",
	[dojox.widget._RollingListPane], {

// summary: a pane that will handle groups (treats them as menu items)

// templateString: string
//	our template
templateString: '<div><div dojoAttachPoint="containerNode"></div>' +
				'<div dojoAttachPoint="menuContainer">' +
					'<div dojoAttachPoint="menuNode"></div>' +
				'</div></div>',

// _dragSource: dijit.Menu
//  The menu that we will call addChild() on for adding items
_dragSource: null,

// dialog box to show copying
_copyBox : null,

// OBJECT-WIDE DEBUG STATUS
debug : false,

// polling : bool
// Whether or not the object is polling for completion 
polling : false,

// polling : bool
// Whether or not dragPane is loading
loading : false,

// core: object
// Contains refs to higher objects in hierarchy
// e.g., { folders: Folders.js object, files: XxxxxFiles.js object, ... }
core : null,

/////}}}}

constructor: function (args){
	this.inherited(arguments);
	
	//console.log("_GroupDragPane.constructor    ------------------ args:");
	//console.dir({args:args});
	this.core 		= args.core;
	this.path		=	args.path;
	this.parentPath	=	args.parentPath;
},
startup: function (){
	this.inherited(arguments);
	// 	RETURN IF THIS.LOADING == TRUE
	if ( this.loading )	{
		//console.log("_GroupDragPane.startup    Returning because this.loading == true");
		return;
	}
	
	// SET THIS.LOADING = FALSE
	//console.log("_GroupDragPane.startup    Setting this.loading = true");
	this.loading = true;

	// SET SEQUENCE AND STANDBY
	this.setSequence();
	this.setStandby();

	//console.groupEnd("_GroupDragPane-" + this.id + "    startup");
},
_doQuery: function () {
// summary: either runs the query or loads potentially not-yet-loaded items.
	this.isLoaded = false;

	this._setContentAndScroll(this.onFetchStart());

	this.store.fetch({
		query: this.path, 
		onComplete: function(items){
			this.items = items;
			this.onItems();
		}, 
		onError: function(e) {
			this._onError("Fetch", e);
		},
		scope: this
	});
},
onLoad : function (data) {
	
	// THIS.INHERITED
	//console.log("_GroupDragPane.onLoad    Doing this.inherited(arguments)");
	this.inherited(arguments);
	
	// SET THIS LOADING = FALSE
	//console.log("_GroupDragPane.onLoad    Setting this.loading = false");
	this.loading = false;

	//console.log("_GroupDragPane.onLoad    END");
},
_onLoadHandler: function(data){
// OVERRIDE TO AVOID THIS ERROR:
// Error undefined running custom onLoad code: This deferred has already been resolved

	// summary:
	//		This is called whenever new content is being loaded
	this.isLoaded = true;
	try{
		//this.onLoadDeferred.callback(data);
		//console.log("_GroupDragPane._onLoadHandler    Doing this.onLoad(data)");
		this.onLoad(data);
	}
	catch(e) {
		//////console.error('Error '+this.widgetId+' running custom onLoad code: ' + e.message);
	}


    //console.log("_GroupDragPane._onLoadHandler    END");
	
	//console.groupEnd("FileManager-" + this.id + "    roundRobin");
	//console.log("_GroupDragPane._onLoadHandler    Doing this.core.folders.roundRobin()");
	this.core.folders.roundRobin();
},
_loadCheck: function(/* Boolean? */ forceLoad){
// summary: checks that the store is loaded
	var displayState = this._isShown();
	if((this.store || this.items) && (forceLoad || (this.refreshOnShow && displayState) || (!this.isLoaded && displayState))){
		
		this.query = this.path;
		//console.log("_GroupDragPane._loadCheck    this.query: " + this.query);

		this._doQuery();
	}
},
_setContent: function(/*String|DomNode|Nodelist*/cont){
	if(!this._dragSource){
		// Only set the content if we don't already have a menu
		//this.inherited(arguments);
	}
},
createMenu : function (type) {
// ADD PROGRAMMATIC CONTEXT MENU
	//console.log("_GroupDragPane.createMenu     type: " + type);
	
	if ( type == "workflow" ) {
		if ( this.workflowMenu ) return this.workflowMenu.menu;
	}
	else if ( type == "folder" ) {
		if ( this.folderMenu ) return this.folderMenu.menu;
	}
	else {
		if ( this.fileMenu ) return this.fileMenu.menu;
	}
},
addItem : function (name, type, username, location) {
	// REMOVE EMPTY ITEM IF PRESENT
	this.removeEmptyItem();
	
	// INSERT NEW CHILD
	var item = new Object;
	item.name = name;
	item.type = [type];
	item.directory = true;
	item.parentPath = this.path;
	item.path = name;
	item.children = [];
	//console.log("_GroupDragPane.addItem    item: ");
	//console.dir({item:item});
	this.items.push(item);

	// SET FILECACHE
	var cacheItem = dojo.clone(item);
	Agua.setFileCache(username, location, cacheItem);

	// GENERATE CHILD
	var newChild = this.parentWidget._getMenuItemForItem(item, this);
	//console.log("_GroupDragPane.addItem    newChild: ");
	//console.dir({newChild:newChild});

	// INSERT CHILD
	this._dragSource.insertNodes(false, [ newChild ]);

	// ADD 'directory' CLASS TO NEW CHILD
	var allNodes = this._dragSource.getAllNodes();
	var node = allNodes[allNodes.length - 1];
	node.setAttribute("dndType", "file");
	dojo.addClass(node, "directory");
	
	// ADD item ATTRIBUTE ON NODE
	node.item = item;
	node.item._S = newChild.store;

	// ADD MENU
	var dynamicMenu = this.createMenu(type);
	//console.log("_GroupDragPane.addItem   dynamicMenu: ");
	//console.dir({dynamicMenu:dynamicMenu});
	
	// BIND THE MENU TO THE DND NODE
	dynamicMenu.bindDomNode(node);
	
	// CONNECT ONCLICK
	dojo.connect(node, "onclick", this, "onclickHandler");
},	
renameItem : function (dndItem, newItemName) {
	//console.log("WorkflowMenu.renameWorkflow     dndItem: ");
	//console.dir({dndItem:dndItem});
	var itemName = dndItem.item.name;
	//console.log("_GroupDragPane.renameItem    itemName: " + itemName);
	//console.log("_GroupDragPane.renameItem    newItemName: " + newItemName);

	// RENAME DND ITEM
	dndItem.innerHTML = newItemName;
	
	for ( i = 0; i < this.items.length; i++ ) {
		var itemObject = this.items[i];
		if ( itemObject.name == itemName ) {
			//console.log("_GroupDragPane.renameItem    Renaming item: " + i + ":");
			//console.log("_GroupDragPane.renameItem    itemObject: ");
			//console.dir({itemObject:itemObject});

			// REPLACE name AND path VALUES
			itemObject.name = newItemName;
			itemObject.path = newItemName;
			
			// REPLACE parentPath IN CHILDREN
				if ( itemObject.children.length ) {
					for ( var i = 0; i < itemObject.children.length; i++ ) {
						var parentPath = itemObject.children[i].parentPath;
						//console.log("_GroupDragPane.renameItem    child " + i + " parentPath: " + parentPath);
						var re = new RegExp(itemName + "$");
						parentPath = parentPath.replace(re, newItemName);
						//console.log("_GroupDragPane.renameItem    child " + i + " NEW parentPath: " + parentPath);
						itemObject.children[i].parentPath = parentPath;
					}
				}
			
			break;
		}
	}
},
deleteItem : function (dndItem) {
	//console.log("_GroupDragPane.deleteItem    dndItem: ");
	//console.dir({dndItem:dndItem});

	for ( i = 0; i < this.items.length; i++ ) {
		var itemObject = this.items[i];
		//console.log("_GroupDragPane.deleteItem    itemObject: ");
		//console.dir({itemObject:itemObject});
		if ( itemObject.name == dndItem.item.name ) {
			this.items.splice(i, 1);
			break;
		}
	}
	
	// DESTROY DND ITEM
	dojo.destroy(dndItem);

	// ADD 'EMPTY' ITEM IF NEEDED
	if ( ! this.items.length )	{
		this.addEmptyItem();
		//console.log("_GroupDragPane.deleteItem    Doing this.onItems()");
		this.onItems();
	}
	
	// REMOVE ALL DOWNSTREAM DRAG PANES
	var fileDrag = this.parentWidget;
	var children = fileDrag.getChildren();
	var index = children.length;
	for ( var i = 0; i < children.length; i++ ) {
		//console.log("_GroupDragPane.deleteItem    child " + i);
		//console.dir({child:children[i]});
		if ( children[i] == this ) {
			index  = i;
			break;
		}
	}
	//console.log("_GroupDragPane.deleteItem    children.length: " + children.length);
	//console.log("_GroupDragPane.deleteItem    index: " + index);
	
	// QUIT IF THIS IS THE LAST PANE
	if ( index == children.length )	return;
	
	// OTHERWISE, REMOVE ALL DOWNSTREAM PANES
	//console.log("_GroupDragPane.deleteItem    Doing fileDrag._removAfter(" + index + ")");
	fileDrag._removeAfter(index);
},
removeEmptyItem : function () {
    var nodes = this._dragSource.getAllNodes();
    //console.log("_GroupDragPane.removeEmptyItem    nodes:");
    //console.dir({nodes:nodes});
    var nodesCopy = dojo.clone(this._dragSource.getAllNodes());
    //console.dir({nodesCopy:nodesCopy});

    //console.log("_GroupDragPane.removeEmptyItem    nodes[0].item.name:");
    //console.dir({item:nodes[0].item.name});

    if ( nodes[0].item.name != "<EMPTY>" ) return;

	//console.log("_GroupDragPane.removeEmptyItem    Doing dndItems.splice(0, 1)");

	this.items.splice(0, 1);
	dojo.destroy(nodes[0]);
},
addEmptyItem : function () {
// INSERT A FAKE ITEM WITH NAME <EMPTY>
	//console.log("_GroupDragPane.addEmptyItem    this.parentPath: " + this.parentPath);
	//console.log("_GroupDragPane.addEmptyItem    this.path: " + this.path);

	if ( this.items.length ) return;

	var item = new Object;
	item.name = "<EMPTY>";
	item.parentPath = this.path;
	//console.log("_GroupDragPane.addEmptyItem    item: ");
	//console.dir({item:item});

	this.items.push(item);
},
inItems : function (itemName) {
// RETURN TRUE IF FILE NAME EXISTS IN THIS GROUP DRAG PANE, ELSE RETURN FALSE
	//console.log("_GroupDragPane.inItems    itemName: " + itemName);
	if ( itemName == null )	return;
	
	var dndItems = this._dragSource.getAllNodes();
	//console.log("_GroupDragPane.inItems    dndItems: ");
	//console.dir({dndItems:dndItems});
	
	for ( var i = 0; i < dndItems.length; i++ )
	{
		//console.log("_GroupDragPane.inItems    dndItems[i].innerHTML: " + dndItems[i].innerHTML);
		if ( itemName == dndItems[i].innerHTML )	return true;
	}
	
	return false;
},
onItems : function() {
//	called after a fetch or load - at this point, this.items should be set and loaded.
	//////console.log("_GroupDragPane.onItems    this.items.length: " + this.items.length);
	////////console.log("_GroupDragPane.onItems    this.items: " + dojo.toJson(this.items));	

	var thisObject = this;
	
	for ( var i = 0; i < this.items.length; i++)
	{			
		this.items[i].path = this.items[i].name;
	}	
	
	var selectItem, hadChildren = false;
	
	this._dragSource = this._getDragSource(
		{
			path: this.path,
			parentPath: this.parentPath
		}
	);

	// ADD THE STORE'S parentPath TO THE MENU
	this._dragSource.store = this.store;

	// IF THERE ARE NO ITEMS FOR THIS DIRECTORY,
	// INSERT A FAKE ITEM WITH NAME <EMPTY> 
	if ( ! this.items.length )	this.addEmptyItem()

	var child, selectMenuItem;
	if ( this.items.length )
	{
		dojo.forEach(
			this.items,
			function(item)
		{
			child = this.parentWidget._getMenuItemForItem(item, this);
			if ( child )
			{
				this._dragSource.insertNodes(false, [child]);
				var insertedNodes = this._dragSource.getAllNodes();
				var lastNode = insertedNodes[insertedNodes.length - 1];
				
				// ADD DATA STORE TO ITEM'S CHILDREN
				if ( item.children )
				{
					for ( var i = 0; i < item.children.length; i++ )
					{
						item.children[i]._S = item._S;
						var childParentPath;
						var fullPath = '';
						if ( item.parentPath )	fullPath = item.parentPath;
						if ( item.path )	{
							if ( fullPath )
								fullPath += "/" + item.path;
							else
								fullPath = item.path;
						}
						if ( fullPath )
							item.children[i].parentPath = fullPath;
					}
					////console.log("_GroupDragPane.onItems    [] []  [] [] [] [] [] [] [] [] [] [] Setting item.directory = true");
					item.directory = true;
				}

				// ADD ITEM TO THIS NODE
				lastNode.item = item;
				
				// SET CLASS
				dojo.hasClass(lastNode, "dojoxRollingListItemSelected");

				var applicationName = lastNode.innerHTML;
	
				// GET indexInParent - THE LEVEL OF THIS MENU IN THE PARENT
				var indexInParent = this.getIndexInParent();
	
				// SET nodeType BASED ON THE indexInParent TO COINCIDE WITH accept PARAMETER
				// OF DND SOURCE OF SAME LEVEL (E.G., Workflows CAN BE DRAGGED NEXT TO OTHER
				// WORKFLOWS BUT NOT INTO THE LOWER FILE DIRECTORIES)
				var nodeType;
				if ( indexInParent == 0 )
				{
					nodeType = 'workflow';
				}
				else
				{
					if ( item.directory == false || item.directory == "false" )
						nodeType = "file";
					else
						nodeType = "folder";
				}
				////console.log("_GroupDragPane.onItems    [] [] [] [] [] [] [] [] [] [] [] item: ");
				////console.dir({item:item});
				////console.log("_GroupDragPane.onItems    [] [] [] [] [] [] [] [] [] [] [] nodeType: " + nodeType);

				// GENERATE DYNAMIC DHTML MENU
				// AND BIND MENU TO THE DND NODE
				var dynamicMenu = thisObject.createMenu(nodeType);
				//////console.log("_GroupDragPane.onItems    dynamicMenu: " + dynamicMenu);
				if ( dynamicMenu != null )
				{
					dynamicMenu.bindDomNode( lastNode );
				}
				lastNode.setAttribute("dndType", nodeType);					

				// CONNECT ONCLICK
				dojo.connect(lastNode, "onclick", this, "onclickHandler");

				var _dragSource = this._dragSource;
				this._dragSource.onDropExternal = function(source, nodes, copy) {
					thisObject.onDropExternal(source, nodes, copy, _dragSource, item, lastNode);
				};
				
			} // if(child)
			
		}, this); // dojo.forEach(this.items, function(item)

	} // if ( this.items.length )
	
	// ADD dojo.connect TO DND SOURCE NODES
	//////console.log("_GroupDragPane.onItems    Adding dojo.connect to DND source nodes");
	var allNodes = this._dragSource.getAllNodes();
	//////console.log("_GroupDragPane.onItems    allNodes.length: " + allNodes.length);
	for ( var i = 0; i < allNodes.length; i++ ) {
		var node = allNodes[i];
		dojo.addClass(node, "fileDrag");

		if ( ! node.item.directory || node.item.directory == "false" )
		{
			dojo.addClass(node, "file");
			dojo.addClass(node, "fileClosed");
		}
		else
		{
			dojo.addClass(node, "directory");
			dojo.addClass(node, "directoryClosed");
		}
		
		var applicationName = node.innerHTML;

		// GET indexInParent - THE LEVEL OF THIS MENU IN THE PARENT
		var indexInParent = this.getIndexInParent();

		// SET nodeType BASED ON THE indexInParent TO COINCIDE WITH accept PARAMETER
		// OF DND SOURCE OF SAME LEVEL (E.G., Workflows CAN BE DRAGGED NEXT TO OTHER
		// WORKFLOWS BUT NOT INTO THE LOWER FILE DIRECTORIES)
		var nodeType;
		if ( indexInParent == 0 )
		{
			nodeType = 'workflow';
		}
		else
		{
			nodeType = "file";
		}
		node.setAttribute("dndType", nodeType);
	}	

	this.containerNode.innerHTML = "";		
	this.containerNode.appendChild(this.menuNode);
	this.parentWidget.scrollIntoView(this);
	
	//////console.log("_GroupDragPane.onItems    END");
	
	//////console.log("_GroupDragPane.onItems    BEFORE this.inherited(arguments)");
	this.inherited(arguments);
	//////console.log("_GroupDragPane.onItems    AFTER this.inherited(arguments)");

	////////console.log("_GroupDragPane.onItems    END OF SUB");
},
onDropExternal : function (source, nodes, copy, _dragSource, item, lastNode) {
/*
	OVERRIDE dojo.dnd.Source.onDropExternal TO NOTIFY SERVER OF CHANGES.

	COMPLETE THE COPY ON THE REMOTE FILESYSTEM AS FOLLOWS:
	
		1. CARRY OUT DND COPY
	   
		2. CHECK IF FILENAME ALREADY EXISTS, IF SO
			   DO POPUP TO CONFIRM OVERWRITE	
	   
		3. MESSAGE SERVER TO COPY FILES
	   
		4. SHOW ANIMATED 'COPYING' DIALOGUE
	   
		5. POLL SERVER FOR STATUS AND WAIT UNTIL COMPLETE
	   
		6. RELOAD THE PANE TO SHOW THE NEW FILE SYSTEM
*/

	//console.log("_GroupDragPane.onDropExternal    plugins.files._GroupDragPane.onDropExternal(source, nodes, copy, _dragSource, item, lastNode, childScope)");
	//console.log("_GroupDragPane.onDropExternal     source: " + source);
	//console.dir({node:nodes});
	//console.dir({_dragSource:_dragSource});
	//console.dir({item:item});
	//console.log("_GroupDragPane.onDropExternal     copy: " + copy);

	// SET this.lastNode
	this.lastNode = lastNode;
	this._dragSource = _dragSource;

	// RESET URL
	var location	=	this.store.putData.location;
	//console.log("_GroupDragPane.onDropExternal     location: " + location);
	
	var file = nodes[0].item.parentPath + "/" + nodes[0].item.path;
	var destination = this.path;
	if ( location && ! destination.match(/^\//) )
		destination = location + "/" + this.path;
	
	// DO copyFile
	//console.log("_GroupDragPane.onDropExternal     Doing this.checkFilePresent(file, destination)");
	this.checkFilePresent(file, destination);
},
checkFilePresent : function (file, destination) {
	//console.log("_GroupDragPane.checkFilePresent     file: " + file);
	//console.log("_GroupDragPane.checkFilePresent     destination: " + destination);

	// CHECK IF A FILE OR FOLDER WITH THE SAME NAME AS THE DROPPED 
	// FILE/FOLDER ALREADY EXISTS IN THIS FOLDER
	if ( this.inItems(file) ) {
		//console.log("_GroupDragPane.checkFilePresent     file ALREADY EXISTS: " + file);
		thisObject.confirmOverwrite(file, destination);
	}
	else {
		this.prepareCopy(file, destination);
		this.copyFile();
		this.delayedPollCopy();
	}
},
prepareCopy : function (file, destination) {
	// SET this.putData
	var putData = this.store.putData;
	//console.log("_GroupDragPane.prepareCopy     BEFORE putData: ");
	//console.dir({putData:putData});
	putData.mode 			=	"copyFile";
	putData.sessionid		=	Agua.cookie('sessionid');
	putData.username		=	Agua.cookie('username');
	putData.file			=	file;
	putData.destination		=	destination;
	this.putData 	= 	putData;
	//console.log("_GroupDragPane.prepareCopy     this.putData: ");
	//console.dir({this_putData:this.putData});
},
confirmOverwrite : function(file, destination) {
	//console.log("_GroupDragPane.confirmOverwrite    file: " + file);
	//console.log("_GroupDragPane.confirmOverwrite    destination: " + destination);
	
	// SET CALLBACKS
	var thisObject = this;
	var yesCallback = function() {
		thisObject.prepareCopy(file, destination);
		thisObject.copyFile();
		thisObject.delayedPollCopy();
	};
	var noCallback = function() {};
	var title = "Delete file: " + file + "?";
	var message = "File already exists<br>Do you want to overwrite it?<br><span style='color: #222;'>Click 'Yes' to delete or 'No' to cancel</span>";
	//console.log("_GroupDragPane.confirmOverwrite    title: " + title);
	//console.log("_GroupDragPane.confirmOverwrite    message: " + message);

	// REFRESH CONFIRM WIDGET
	if ( this.confirm != null ) 	this.confirm.destroy();

	// SHOW DIALOGUE
	this.confirm = new plugins.dijit.Confirm({
		parentWidget : this,
		title: title,
		message : message,
		yesCallback : yesCallback,
		noCallback : noCallback
	});
	this.confirm.show();
},
copyFile : function () {
//	2. CHECK IF FILENAME ALREADY EXISTS AND IF SO CONFIRM OVERWRITE
	var putData = this.putData;
	//console.log("_GroupDragPane.copyFile    putData: ");
	//console.dir({putData:putData});

	var url = Agua.cgiUrl + "folders.cgi?";
	//console.log("_GroupDragPane.copyFile    url: " + url);

	// SHOW STANDBY
	this.standby.show();

	var thisObject = this;
	dojo.xhrPut({
		url: url,
		handleAs: "json-comment-optional",
		sync: false,
		putData: dojo.toJson(putData),
		handle: function(response){
			//console.log("_GroupDragPane.copyFile    response: ");
			//console.dir({response:response});
			if ( ! response || ! response.error ) {
				//console.log("_GroupDragPane.copyFile    Doing startPollCopy");
				thisObject.pollCopy();
			}
			else if ( response.error ) {
				// HIDE STANDBY
				thisObject.standby.hide();
	
				Agua.toastMessage({
					message: response.error,
					type: "error"
				});
			}
		}
	});
},
delayedPollCopy : function (delay) {
	//console.log("_GroupDragPane.delayedPollCopy    Doing this.sequence.go(commands, ...)");
	if ( ! delay ) delay = 6000;
	var commands = [
		{ func: [this.showMessage, this, "_GroupDragPane.delayedPollCopy"], pauseAfter: delay },
		{ func: this.pollCopy } // no array, just a function to call 
	];
	//console.log("_GroupDragPane.delayedPollCopy    commands: " + commands);
	//console.dir({commands:commands});
	
	this.sequence.go(commands, function(){ });	
},
showMessage : function (message)  {
	//console.log(message);
},
pollCopy : function() {
// 5. POLL SERVER FOR STATUS AND WAIT UNTIL COMPLETE
	if ( ! this.putData ) {
		if ( this.standby )
			this.standby.hide();
		return;
	}
	
	this.putData.modifier = "status";
	//console.log("_GroupDragPane.pollCopy    this.putData: ");
	//console.dir({this_putData:this.putData});

	var url = Agua.cgiUrl + "folders.cgi?";
	//console.log("_GroupDragPane.copyFile    url: " + url);

	var thisObject = this;
	var completed = false;
	dojo.xhrPut({
		url			: 	url,
		handleAs	: 	"json-comment-optional",
		sync		: 	false,
		putData		:	dojo.toJson(this.putData),
		handle		: 	function (response) {
			//console.log("_GroupDragPane.pollCopy    this.response: ");
			//console.dir({response:response});
			
			if ( response.status == 'completed' ) {
				thisObject.polling = false;
				thisObject.standby.hide();
				
				// DELETE EXISTING FILECACHE
				Agua.setFileCache(thisObject.putData.username, thisObject.putData.destination, null);
				
				// RELOAD PANE
				var putData = new Object;
				putData.mode 			=	"fileSystem";
				putData.sessionid		=	Agua.cookie('sessionid');
				putData.username		=	thisObject.putData.username;
				putData.url				=	Agua.cgiUrl + "folders.cgi?";
				putData.path			=	putData.destination;
				thisObject.parentWidget.store.putData		=	putData;
				
				//console.log("_GroupDragPane.pollCopy    AFTER putData:");
				//console.dir({putData:putData});
			
				// SET this.url AND this.putData
				thisObject.url 		= 	putData.url;
				thisObject.putData 	= 	putData;
				
				thisObject.reloadPane();
			}
			else if ( response.error ) {
				thisObject.polling = false;
				thisObject.standby.hide();
			}
			else
				thisObject.delayedPollCopy();
		}
	});
},
setSequence : function () {
	this.sequence = new dojox.timing.Sequence({});
},
setStandby : function () {
	//console.log("_GroupDragPane.setStandby    _GroupDragPane.setStandby()");
	//if ( this.standby )	return this.standby;
	
	var id = dijit.getUniqueId("dojox_widget_Standby");
	this.standby = new dojox.widget.Standby ({
		target: this.parentWidget.domNode,
		onClick: "reload",
		text: "Copying",
		id : id,
		url: "plugins/core/images/agua-biwave-24.png"
	});
	document.body.appendChild(this.standby.domNode);
	//console.log("_GroupDragPane.setStandby    this.standby: " + this.standby);

	return this.standby;
},
reloadPane : function() {
	//console.group("_GroupDragPane-" + this.id + "    reloadPane");
	
	//console.log("_GroupDragPane.reloadPane    plugins.files._GroupDragPane.reloadPane()");
	var item = this.lastNode.item;
	//console.log("_GroupDragPane.reloadPane    item: ");
	//console.dir({item:item});
	
	var children = item.children;
	if ( ! children )
		children = item.items;
	
	// CHANGE item PATH, NAME AND PARENTPATH TO ONE FOLDER UP
	item = this.itemParent(item);
	
	var itemPane = this.parentWidget._getPaneForItem(item, this._dragSource, children);
	this.query = itemPane.store.query;
	if ( itemPane )
	{
		var paneIndex = this.getIndexInParent();
		this.parentWidget.addChild( itemPane, this.getIndexInParent() );
	}

	//console.groupEnd("_GroupDragPane-" + this.id + "    reloadPane");
},
itemParent : function(item) {
	//console.log("_GroupDragPane.itemParent(item)");
	//console.dir({item:item});
	
	// SET DIRECTORY = TRUE
	item.directory = true;
	
	// CHANGE NAME, PATH AND PARENTPATH
	//
	// 1. IF PARENTPATH CONTAINS MULTIPLE LEVELS,
	// 		E.G., 'Project1/Workflow1-assembly'
	if ( item.parentPath.match(/^.+\/([^\/]+)$/) )
	{
		item.path = item.parentPath.match(/^(.+?)\/([^\/]+)$/)[2];
		item.parentPath = item.parentPath.match(/^(.+?)\/([^\/]+)$/)[1];
	}

	// 2. IF PARENTPATH IS AT THE TOP LEVEL, E.G., 'Project1',
	// 		SET PATH = PARENTPATH AND PARENTPATH = '' 
	else if ( item.parentPath.match(/\/*[^\/]+$/) )
	{
		item.path = item.parentPath;
		item.parentPath = '';
	}						
	item.name = item.path;
	//item.parentPath = item.parentPath.match(/^(.+?)\/[^\/]+$/)[1];

	//console.log("_GroupDragPane.itemParent    Returning item:");
	//console.dir({item:item});
	return item;
},
onclickHandler : function (e) {
// HANDLE CLICK ON FILE OR FOLDER
	//console.group("_GroupDragPane-" + this.id + "    onClickHandler");
	//console.log("_GroupDragPane._onClickHandler    XXXXXXXXXXXXXXXXXXXXXXXXXxx e.target.item: ");

	//console.dir({e_target_item:e.target.item});
	//console.log("_GroupDragPane._onClickHandler    XXXXXXXXXXXXXXXXXXXXXXXXXxx this: " + this);

	
	// GET THE CLICKED DND SOURCE ITEM NODE
	var item = e.target.item;
	var children = item.children || item.items;

	
	var itemPane = this.parentWidget._getPaneForItem(item, this, children);

	// SET this.query TO itemPane.store.query
	this.query = itemPane.store.query;
	//console.log("_GroupDragPane._onClickHandler    this.query: " + dojo.toJson(this.query, true));
	
	if(itemPane)
	{
		// CALLS addChild IN FileDrag
		// summary: adds a child to this rolling list - if passed an insertIndex,
		//  then all children from that index on will be removed and destroyed
		//  before adding the child.
		//console.log("_GroupDragPane._onClickHandler    Doing this.parentWidget.addChild(itemPane, " + (this.getIndexInParent() + 1) + ")");
		
		this.parentWidget.addChild(itemPane, this.getIndexInParent() + 1);
	}
	else
	{
		this.parentWidget(this);
		this.parentWidget._onItemClick(null, this, selectMenuItem.item, selectMenuItem.children);
	}

	//console.groupEnd("_GroupDragPane-" + this.id + "    onClickHandler");
},
focus: function (force){
	// summary: sets the focus to this current widget

	
	if(this._dragSource){
		if(this._pendingFocus){
			this.disconnect(this._pendingFocus);
		}
		delete this._pendingFocus;
		
		// We focus the right widget - either the focusedChild, the
		//   selected node, the first menu item, or the menu itself
		var focusWidget = this._dragSource.focusedChild;
		if(!focusWidget){
			var focusNode = dojo.query(".dojoxRollingListItemSelected", this.domNode)[0];
			if(focusNode){
				focusWidget = dijit.byNode(focusNode);
			}
		}
		
		if(!focusWidget){
			focusWidget = this._dragSource.getAllNodes()[0] || this._dragSource;
		}

		this._focusByNode = false;

		if(focusWidget.focusNode){
			if(!this.parentWidget._savedFocus || force){
				try{focusWidget.focusNode.focus();}catch(e){}
			}
			window.setTimeout(function(){
				try{
					dijit.scrollIntoView(focusWidget.focusNode);
				}catch(e){}
			}, 1);
		}else if(focusWidget.focus){
			if(!this.parentWidget._savedFocus || force){
				focusWidget.focus();
			}
		}else{
			this._focusByNode = true;
		}
		this.inherited(arguments);
	}else if(!this._pendingFocus){
		this._pendingFocus = this.connect(this, "onItems", "focus");
	}
	else
	{
	}
	
},
_getDragSource: function(){
	// summary: returns a widget to be used for the container widget.
	// GET UNIQUE ID FOR THIS MENU TO BE USED IN DND SOURCE LATER
	var objectName = "dojo.dnd.Source";
	var id = dijit.getUniqueId(objectName.replace(/\./g,"_"));
	//var id = dijit.getUniqueId(this.declaredClass.replace(/\./g,"_"));

	// SET THE MENU NODE'S ID TO THIS NEW ID
	this.menuNode.id = id;

	// GET indexInParent - THE LEVEL OF THIS DRAG SOURCE IN THE PARENT
	var indexInParent = this.getIndexInParent();
	
	// SET accept BASED ON THE indexInParent
	
	var acceptType;
	if ( indexInParent == 0 )
	{
		acceptType = 'workflow';
	}
	else
	{
		acceptType = "file";
	}

	// GENERATE DND SOURCE WITH UNIQUE ID
	var dragSource = new dojo.dnd.Source(
		id,
		{
			accept: [ acceptType ],
			copyOnly: true
		}
	);
		
	// SET baseClass
	this.menuNode.setAttribute('class', 'fileDrag');
	
	// SET PARENTPATH AND PATH
	if ( this.path )
	{
		dragSource.path = this.path;
	}
	if ( this.parentPath )
	{
		dragSource.parentPath = this.parentPath;
	}

	if(!dragSource._started){
		dragSource.startup();
	}

	return dragSource;
},
getPreviousPane : function () {
// RETURN THE PREVIOUS DRAG PANE IN THE FILE DRAG

	var fileDrag = this.parentWidget;
	//console.log("fileMenu.getPreviousPane    fileDrag: ");
	//console.dir({fileDrag:fileDrag});
	//console.dir({fileDrag:fileDrag});
	
	var index = 0;
	var children = fileDrag.getChildren();
	//console.log("fileMenu.getPreviousPane    children.length: " + children.length);
	
	for ( var i = 0; i < children.length; i++ ) {
		if ( children[i] == this ) {
			index = i;
			break;
		}
	}

	if ( index == 0 )    return null;
	return children[index - 1];
}

});


}

if(!dojo._hasResource["plugins.files._FileInfoPane"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.files._FileInfoPane"] = true;
dojo.provide("plugins.files._FileInfoPane");



// 
// 

//

dojo.declare("plugins.files._FileInfoPane", 
	[dojox.widget._RollingListPane], {

	// summary: a pane to display the information for the currently-selected
	//	file

	// templateString: string
	//	delete our template string
	templateString: "",
	
	//Path to the template of this widget. 
	templateString:"<div class=\"dojoxFileInfoPane\">\n\t<table>\n\t\t<tbody>\n\t\t\t<tr>\n\t\t\t\t<td class=\"dojoxFileInfoLabel dojoxFileInfoNameLabel\">Filename </td>\n\t\t\t\t<td colspan=\"3\" align=\"left\" class=\"dojoxFileInfoName\" dojoAttachPoint=\"nameNode\"></td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td class=\"dojoxFileInfoLabel dojoxFileInfoSizeLabel\">Size (bytes) </td>\n\t\t\t\t<td align=\"left\" class=\"dojoxFileInfoSize\" dojoAttachPoint=\"sizeNode\"></td>\n\t\t\t\t<td class=\"dojoxFileInfoLabel dojoxFileInfoBytesLabel\">Sample (bytes) </td>\n\t\t\t\t<td align=\"left\" class=\"dojoxFileInfoBytes\" dojoAttachPoint=\"bytesNode\"></td>\n\t\t\t</tr>\n\t\t</tbody>\n\t</table>\n<hr>\t\n\t<table>\n\t\t<tbody>\n\t\t\t<tr>\n\t\t\t\t<td align=\"left\" class=\"dojoxFileInfoSample\" dojoAttachPoint=\"sampleNode\"></td>\n\t\t\t</tr>\n\t\t</tbody>\n\t</table>\n</div>\n\n\t\n",
	
	//// templatePath: String. Our template path
	//templateString:"<div class=\"dojoxFileInfoPane\">\r\n\t<table>\r\n\t\t<tbody>\r\n\t\t\t<tr>\r\n\t\t\t\t<td class=\"dojoxFileInfoLabel dojoxFileInfoNameLabel\">Filename </td>\r\n\t\t\t\t<td class=\"dojoxFileInfoName\" dojoAttachPoint=\"nameNode\"></td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td class=\"dojoxFileInfoLabel dojoxFileInfoSizeLabel\">Size (bytes) </td>\r\n\t\t\t\t<td class=\"dojoxFileInfoSize\" dojoAttachPoint=\"sizeNode\"></td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td class=\"dojoxFileInfoLabel dojoxFileInfoPathLabel\">Sample </td>\r\n\t\t\t\t<td class=\"dojoxFileInfoPath\" dojoAttachPoint=\"sampleNode\"></td>\r\n\t\t\t</tr>\r\n\t\t</tbody>\r\n\t</table>\r\n</div>\r\n",
	
	////}}


postMixInProperties: function(){
//	    ////////console.log("FileDrag.postMixInProperties	plugins.files.FileDrag.postMixInProperties()");
	//this._messages = dojo.i18n.getLocalization("dojox.widget", "FileDrag", this.lang);
	this.inherited(arguments);
},

onItems: function() {
	//////console.log("files._FileInfoPane.onItems	plugins.files._FileInfoPane.onItems()");
	//////console.log("files._FileInfoPane.onItems	this.parentWidget: " + this.parentWidget);

	// summary:
	//	called after a fetch or load - at this point, this.items should be
	//  set and loaded.
	var store = this.store, item = this.items[0];
//    //////console.log("files._FileInfoPane.onItems	////console.dir(this.store): ");
//	////console.dir(this.store);

	////console.log("files._FileInfoPane.onItems	////console.dir(item): ");
	////console.dir(item);

	
	if(!item){
		this._onError("Load", new Error("No item defined"));
	}
	else
	{
		//////console.log("files._FileInfoPane.onItems	////console.dir(item): ");
		//this.nameNode.innerHTML = store.getLabel(item);
		this.nameNode.innerHTML = store.getValue(item, "name");
		this.sampleNode.innerHTML = store.getValue(item, "sample");
		this.sizeNode.innerHTML = store.getValue(item, "size");			
		this.bytesNode.innerHTML = store.getValue(item, "bytes");			
		this.parentWidget.scrollIntoView(this);

	    ////console.log("files._FileInfoPane.onItems	////console.dir(this.containerNode): ");
		//////console.dir(this.containerNode);

		//////console.log("files._FileInfoPane.onItems	BEFORE this.inherited(arguments)");
		this.inherited(arguments);
		//////console.log("files._FileInfoPane.onItems	AFTER this.inherited(arguments)");

		//this._setContent(this.domNode, true);

		//this._setContentAndScroll(this.containerNode, false);

		//this.refresh();
		//this.parentWidget.scrollIntoView(this);

	}
},



_setContentAndScroll: function(/*String|DomNode|Nodelist*/cont, /*Boolean?*/isFakeContent){
// OVERRIDE TO AVOID this._setContent

// summary: sets the value of the content and scrolls it into view

	//////console.log("files._FileInfoPane._setContentAndScroll    files._FileInfoPane._setContentAndScroll(cont, isFakeContent)");
	//////console.log("files._FileInfoPane._setContentAndScroll    BEFORE this._setContent");

return;

	this._setContent(cont, isFakeContent);
	//////console.log("files._FileInfoPane._setContentAndScroll    AFTER this._setContent");

	this.parentWidget.scrollIntoView(this);
},


//	,
//	
///* OVERRIDE TO AVOID THIS ERROR:
//
//Error undefined running custom onLoad code: This deferred has already been resolved
//
//NB: this.onLoad(data) CALLS onLoad IN dijit.layout.ContentPane:
//
//	// EVENT's, should be overide-able
//	onLoad: function(data){
//		// summary:
//		//		Event hook, is called after everything is loaded and widgetified
//		// tags:
//		//		callback
//	},
//*/
//	_onLoadHandler: function(data){
//
////////console.log("plugins.files.FileInfoPane._onLoadHandler    plugins.files.FileInfoPane._onLoadHandler(data)");
////////console.log("plugins.files.FileInfoPane._onLoadHandler    data: " + data);
//		// summary:
//		//		This is called whenever new content is being loaded
//		this.isLoaded = true;
//		try{
//			this.onLoadDeferred.callback(data);
//			this.onLoad(data);
//		}catch(e){
//			////console.error('Error '+this.widgetId+' running custom onLoad code: ' + e.message);
//		}
//	}	
});


}

if(!dojo._hasResource["plugins.files.FileDrag"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.files.FileDrag"] = true;
dojo.provide("plugins.files.FileDrag");






dojo.declare("plugins.files.FileDrag",	
	[ plugins.core.Common, dojox.widget.RollingList ],
{
// summary: a specialized version of RollingList that handles file information
//  in a store

// CSS FILES
cssFiles : [
	dojo.moduleUrl("dojox") + "widget/Dialog/Dialog.css",
	dojo.moduleUrl("dojox") + "widget/RollingList/RollingList.css",
	dojo.moduleUrl("plugins.files") + "/FileDrag/FileDrag.css"
],

templateString: "<div class=\"dojoxRollingList ${className}\"\n\t><div class=\"dojoxRollingListContainer\" dojoAttachPoint=\"containerNode\" dojoAttachEvent=\"onkeypress:_onKey\"\n\t></div\n\t><div class=\"dojoxRollingListButtons\" dojoAttachPoint=\"buttonsNode\"\n        ><button dojoType=\"dijit.form.Button\" dojoAttachPoint=\"okButton\"\n\t\t\t\tdojoAttachEvent=\"onClick:_onExecute\">${okButtonLabel}</button\n        ><button dojoType=\"dijit.form.Button\" dojoAttachPoint=\"cancelButton\"\n\t\t\t\tdojoAttachEvent=\"onClick:_onCancel\">${cancelButtonLabel}</button\n\t></div\n></div>\n",

className: "dojoxFileDrag",

// pathSeparator: string
//  Our file separator - it will be guessed if not set
pathSeparator: "",

// topDir: string
//	The top directory string - it will be guessed if not set
topDir: "",
	
// parentAttr: string
//	the attribute to read for finding our parent directory
parentAttr: "parentDir",

// pathAttr: string
//  the attribute to read for getting the full path of our file
pathAttr: "path",

// path: string
// full path to file
path : '',

// core: object
// Contains refs to higher objects in hierarchy
// e.g., { folders: Folders object, files: XxxxxFiles object, ... }
core : null,

//////}}
	
constructor: function (args){
	this.inherited(arguments);
	
	//console.log("FileDrag.constructor    args:");
	//console.dir({args:args});
	this.core = args.core;
	this.path = args.path;
},
addChild: function (itemPane, index){
	//console.log("FileDrag.addChild    itemPane:");
	//console.dir({itemPane:itemPane});
	//console.log("FileDrag.addChild    index: " + index);
	
	//console.log("FileDrag.addChild    Doing this.inherited(arguments)");
	this.inherited(arguments);
},
_itemsMatch: function(/*item*/ item1, /*item*/ item2){
	// Summary: returns whether or not the two items match - checks ID if
	//  they aren't the exact same object - ignoring trailing slashes

	return true;
},
selectChild : function (childName) {
	//////console.log("FileDrag.selectChild    childName: " + childName);
	
	dojo.forEach(this.getChildren(), function(child, index){
			
		//////console.log("FileDrag.selectChild    child " + index + ": ");
		////////console.dir(child)
		
	});
},
// RELOAD THE WHOLE FILE PANE
reload : function () {
	//////console.log("FileDrag.reload	plugins.files.FileDrag.reload()");

	// DESTROY CHILD WIDGETS
	//////console.log("FileDrag.reload	Doing this._removeAfter(0)");
	this._removeAfter(0);
	
	// SET this._started TO FALSE
	this._started = false;
	
	// DO startup
	this.load();
},
startup: function(){
	//console.group("FileDrag-" + this.id + "    startup");
	//console.log("FileDrag.startup    plugins.files.FileDrag.startup()");
	//console.log("FileDrag.startup    this:");
	
	// HACK TO SET WIDTH AND HEIGHT
	this.domNode.setAttribute('style', 'height: auto !important; width: auto !important; overflow-y: scroll !important; overflow-x: hidden !important; border: none !important;');
	
	this.buttonsNode.setAttribute('style', 'display: none !important');

	// LOAD CSS
	this.loadCSS(this.cssFiles);

	if(this._started){ return; }

	//////console.log("FileDrag.startup	BEFORE this.inherited(arguments)");
	this.inherited(arguments);
	//////console.log("FileDrag.startup	AFTER this.inherited(arguments)");

	// Figure out our file separator if we don't have it yet
	var conn, child = this.getChildren()[0];
	//////console.log("FileDrag.startup	AFTER var conn, child = this.getChildren()[0]");
	
	var setSeparator = dojo.hitch(this, function(){
		//console.log("FileDrag.startup	INSIDE setSeparator");
		
		if (conn) {
			this.disconnect(conn);
		}
		delete conn;
		var item = child.items[0];
		//console.log("FileDrag.startup    setSeparator    item:");
		//console.dir({item:item});
		
		if (item) {
			var store = this.store;
			var parent = store.getValue (item, this.parentAttr);
			var path = store.getValue (item, this.pathAttr);
			
			this.pathSeparator = this.pathSeparator || store.pathSeparator;
			if (!this.pathSeparator) {
				this.pathSeparator = path.substring (parent.length, parent.length + 1);
			}
			if (!this.topDir){
				this.topDir = parent;
				
				
				// AVOID ERROR: "TypeError: this.topDir is undefined"
				if ( ! this.topDir )	return;
				
				
				
				if (this.topDir.lastIndexOf (this.pathSeparator) !=  (this.topDir.length - 1)) {
					this.topDir += this.pathSeparator;
				}
			}
		}
	});
	
	
	if (!this.pathSeparator || !this.topDir) {
		if (!child.items){
			conn = this.connect (child, "onItems", setSeparator);
		}else{
			setSeparator ();
		}
	}
	//console.log("FileDrag.startup	AFTER setSeparator    this.topDir: " + this.topDir);

	//console.log("FileDrag.startup	END");
	//console.groupEnd("FileDrag-" + this.id + "    startup");
},
_removeAfter: function(/*Widget or int*/ idx){
	//////console.log("FileDrag._removeAfter	idx: " + idx);
	// summary: removes all widgets after the given widget (or index)
	
	if (typeof idx != "number" ){

		//////console.log("FileDrag._removeAfter	Doing idx = this.getIndexOfChild(idx)");

		idx = this.getIndexOfChild(idx);
	}
	
	var numberChildren = this.getChildren().length;
	//////console.log("FileDrag._removeAfter	numberChildren: " + numberChildren);

	//if ( idx < 0 )	{	idx = 0;	}		
	//if(idx >= 0)
	//{
		dojo.forEach(this.getChildren(), function(c, i){
			
			//if(i > idx || (idx == 0 && numberChildren > 0) )
			if(i > idx )
			{
				//////console.log("FileDrag._removeAfter	i (" + i + ") > idx (" + idx + "). Doing this.removeChild(c)");
				this.removeChild(c);
				//////console.log("FileDrag._removeAfter	AFTER this.removeChild(c)");
				
				//c.destroyRecursive();
				c.destroy();
				//////console.log("FileDrag._removeAfter	AFTER c.destroy()");
			}
		}, this);
	//}
	
	
	var children = this.getChildren(), child = children[children.length - 1];
	var selItem = null;
	while(child && !selItem){
		var val = child._getSelected ? child._getSelected() : null;
		if(val){
			selItem = val.item;
		}
		child = child.parentPane;
	}
	if(!this._setInProgress){
		this._setValue(selItem);
	}

	//////console.log("FileDrag._removeAfter	END FileDrag._removeAfter");
},
addChild: function(/*Widget*/ widget, /*int?*/ insertIndex){
	//////console.log("FileDrag.addChild	widget: " + widget);
	//////console.log("FileDrag.addChild	insertIndex: " + insertIndex);
			
	// summary: adds a child to this rolling list - if passed an insertIndex,
	//  then all children from that index on will be removed and destroyed
	//  before adding the child.

	this._removeAfter(insertIndex - 1);
	
	//////console.log("FileDrag.addChild     BEFORE this.inherited(arguments)");
	this.inherited(arguments);
	//////console.log("FileDrag.addChild     AFTER this.inherited(arguments)");
	
	if(!widget._started){
		widget.startup();
	}
	
	this.layout();
	
	if(!this._savedFocus){
		widget.focus();
	}
},
removeChild : function ( dragPane ) {
	
},
getChildItems: function(item){
	//////console.log("FileDrag.getChildItems	plugins.files.FileDrag.getChildItems(item)");


	var ret = this.inherited(arguments);
	
	
	// CHECK IF THE ITEM IS A DIRECTORY AND EMPTY
	if(!ret && this.store.getValue(item, "directory")){
		// It's an empty directory - so pass through an empty array
		ret = [];
	}
	
	return ret;
},
_getMenuItemForItem: function(/*item*/ item, /* dijit._Contained */ parentPane) {
// summary: returns a widget for the given store item.  The returned
//  item will be added to this widget's container widget.  null will
//  be passed in for an "empty" item. */

	var widgetItem;
	widgetItem = this.getMenuItemForItem(item, parentPane, null);

	// ADD this.store AND item TO WIDGET ITEM
	widgetItem.store = this.store;
	widgetItem.item = item;

//	if ( item && item.children )

	return widgetItem;
},
getMenuItemForItem: function(/*item*/ item, /* dijit._Contained */ parentPane, /* item[]? */ children){
	//////console.log("FileDrag.getMenuItemForItem	plugins.files.FileDrag.getMenuItemForItem(/*item*/ item, /* dijit._Contained */ parentPane, /* item[]? */ children)");

	if ( item == '<EMPTY>' )
	{
		var menuItem = {
			data : 'EMPTY',
			type : [ 'file' ]
		};
		return menuItem;	
	}

	//var parentWidgetNode = parentPane.parentWidget.domNode;
	//var childNodes = parentWidgetNode.childNodes;
	//var parentWidgetNode = parentPane.parentWidget.domNode;

	////console.log("FileDrag.getMenuItemForItem    Getting childNodes");
	var childNodes = this.parentWidget.domNode.childNodes;
	////console.log("FileDrag.getMenuItemForItem    childNodes.length: " + childNodes.length);
	
	var dragType = "workflow";
	if ( childNodes.length > 1 ) {
		dragType = "file";
	}

	// SET DND ITEM
	var menuItem = {
		data : item.name,
		type : [ dragType ]
	};
	
	return menuItem;
},
_getPaneForItem : function(/* item? */ item, /* dijit._Contained? */ parentPane, /* item[]? */ children){
	// OVERRIDE OF RollingList METHOD
	// summary: gets the pane for the given item, and mixes in our needed parts
	// Returns the pane for the given item (null if the root pane) - after mixing in
	// its stuff.

	//console.group("FileDrag-" + this.id + "    _getPaneForItem");

	//console.log("FileDrag._getPaneForItem	   caller: " + this._getPaneForItem.caller.nom);

	//console.log("FileDrag._getPaneForItem	   item: ");
	//console.dir({item:item});

	//console.log("FileDrag._getPaneForItem	   this.store: ");
	//console.dir({this_store:this.store});

	//console.log("FileDrag._getPaneForItem	   this.query: ");
	//console.dir({this_query:this.query});

	var pane = this.getPaneForItem(item, parentPane, children);

	// REQUIRED: SET 'store' OF RETURNED PANE FOR ITEM
	//console.log("FileDrag._getPaneForItem	   this.store: ");
	//console.dir({this_store:this.store});
		
	var parentPath = this.getPreviousParentPath();
	if ( ! parentPath ) {
		parentPath = this.store.path;
	}

	//console.log("FileDrag._getPaneForItem	   oooooooo BEFORE parentPath: " + parentPath);
	if ( item && item.name ) {
		if ( parentPath ) {
			parentPath += "/";
		}
		parentPath  += item.name
	}
	//console.log("FileDrag._getPaneForItem	   oooooooo AFTER parentPath: " + parentPath);
	
	//console.log("FileDrag._getPaneForItem	   Doing new plugins.dojox.data.FileStore");
	pane.store = new plugins.dojox.data.FileStore(
		{
			url					: 	this.store.url,
			putData				: 	this.store.putData,
			pathAsQueryParam	: 	true,
			path				:	parentPath,
			parentPath			:	parentPath,
			core				:	this.core
		}
	);

	pane.store.path = this.path;
	this.store.path = this.path;

	if ( item )
	{
		//////console.log("plugins.files.FileDrag._getPaneForItem    item && item.parentPath");
		// ADD CURRENT DIRECTORY TO PATH OF pane.store.path
		// I.E., pane.store.path = Project1/Workflow1/inputdir INSTEAD
		// OF JUST Project1/inputdir IN FETCH
		pane.store.path = item.parentPath ;
		//console.log("FileDrag._getPaneForItem    pane.store.path: " + pane.store.path);
		if ( pane.store.path == '' ) {
			//console.log("FileDrag._getPaneForItem    Setting pane.store.path = item.name : " + item.name);	
			pane.store.path = item.name;
		}
	
		// UPDATE FULL PATH IN FileStore's this.query
		// OTHERWISE WILL SUCCESSFULLY LOAD THE SAME BASE DIRECTORY (E.G., Project1) AGAIN AND AGAIN
		//console.log("plugins.files.FileDrag._getPaneForItem    BEFORE this.store.path: " + dojo.toJson(this.store.path, true));
		this.store.path += "/" + item.name
		//console.log("plugins.files.FileDrag._getPaneForItem    AFTER this.store.path: " + dojo.toJson(this.store.path, true));
	
		pane.path = item.parentPath + "/" + item.name;
		// NEEDED TO INCREMENT PATH
		pane.store.path = item.parentPath + "/" + item.name;
	}
	else
	{
		pane.path = this.path;
	}

	pane.store.parentPath = this.path;


	pane.parentWidget = this;
	pane.parentPane = parentPane || null;
	
	if( !item )
	{
		//console.log("FileDrag._getPaneForItem    !item. Setting pane.query = this.query: " + this.query);
		//console.dir({this_store:this.store});
	
		pane.query = this.query;
		pane.queryOptions = this.queryOptions;
	}
	else if ( children )
	{
		pane.items = children;
	}
	else {
		pane.items = [item];
	}

	//console.log("FileDrag._getPaneForItem    Returning pane: ");
	//console.dir({pane:pane});
	
	//console.groupEnd("FileDrag-" + this.id + "    _getPaneForItem");

	return pane;
},
getPaneForItem : function(/*item*/ item, /* dijit._Contained */ parentPane, /* item[]? */ children){
	//////console.log("FileDrag.getPaneForItem	plugins.files.FileDrag.getPaneForItem(/*item*/ item, /* dijit._Contained */ parentPane, /* item[]? */ children)");
//		//////console.log("FileDrag.getPaneForItem	   item: " + item);
	//console.log("FileDrag.getPaneForItem	   item: ");
	//console.dir({item:item});

	var groupDragPane = null;
	var path = '';
	
	// GET PATHS OF ALL CHILDREN
	var parentPath = '';
	var groupPanes = this.getChildren();
	if ( groupPanes ) {
		for ( var i = 0; i < groupPanes.length; i++ ) {
			//console.log("FileDrag.getPaneForItem	   groupPanes[" + i + "]: ");
			//console.dir({groupPane:groupPanes[i]});
		}	
	}

	//console.log("FileDrag.getPaneForItem	groupPanes.length: " + groupPanes.length);
	
	if ( groupPanes && groupPanes.length > 0 ) {
		parentPath = groupPanes[groupPanes.length - 1].store.path;
	}

	var path = parentPath;
	if ( item && item.path )
		path += "/" + item.path

	//console.log("FileDrag.getPaneForItem    XXXXXXXX parentPath: " + parentPath);
	//console.log("FileDrag.getPaneForItem    XXXXXXXX path: " + path);
	if ( item ) {
		//console.log("FileDrag.getPaneForItem    XXXXXXXX this.store.getValue(item, directory): " + dojo.toJson(this.store.getValue(item, "directory")));
	}

	if ( !item || (this.store.isItem(item) && groupPanes) || this.store.getValue(item, "directory") )
	{
		this.core.filedrag = this;
		
		groupDragPane = new plugins.files._GroupDragPane({
			parentPath		: 	parentPath,
			path			: 	path,
			fileMenu		: 	this.fileMenu,
			workflowMenu	: 	this.workflowMenu,
			folderMenu		: 	this.folderMenu,
			core			:	this.core
		});
		//console.log("FileDrag.getPaneForItem	   groupDragPane: " + groupDragPane);
	}
	else
	//if(this.store.isItem(item) && ! this.store.getValue(item, "directory"))
	{
		// GENERATE A FILE INFO PANE
		groupDragPane = new plugins.files._FileInfoPane({});
		
		// REMOVE dijitContentPane CLASS TO PREVENT overflow: auto CSS
		dojo.removeClass(groupDragPane.domNode, 'dijitContentPane');
	}
		
	//console.log("FileDrag.getPaneForItem	   Returning groupDragPane: " + groupDragPane);
	//console.dir({groupDragPane:groupDragPane});

	return groupDragPane;
},
getPreviousParentPath : function () {
// GET parentPath FOR NEWLY CREATED _GroupDragPane CHILD
// FROM parentPath OF PRECEDING CHILD
	var parentPath = '';
	var groupPanes = this.getChildren();
	if ( groupPanes ) {
		for ( var i = 0; i < groupPanes.length; i++ ) {
			//console.log("FileDrag.getPreviousParentPath	   groupPanes[" + i + "]: ");
			//console.dir({groupPane:groupPanes[i]});
		}	
	}

	//console.log("FileDrag.getPreviousParentPath	groupPanes.length: " + groupPanes.length);
	
	if ( groupPanes && groupPanes.length > 0 ) {
		parentPath = groupPanes[groupPanes.length - 1].store.path;
	}
	//console.log("FileDrag.getPreviousParentPath    XSXSXSXSX Returning parentPath: " + parentPath);

	return parentPath;
},
_setPathValueAttr: function(/*string*/ path){
	//////console.log("FileDrag._setPathValueAttr	plugins.files.FileDrag._setPathValueAttr(/*string*/ path)");
	// Summary: sets the value of this widget based off the given path
	if(!path){
		//this.attr("value", null);
		this.set("value", null);
		return;
	}
	if(path.lastIndexOf(this.pathSeparator) == (path.length - 1)){
		path = path.substring(0, path.length - 1);
	}
	this.store.fetchItemByIdentity({identity: path,
									onItem: dojo.hitch(this, "attr", "value"),
									scope: this});
},
_getPathValueAttr: function(/*item?*/val){
	//////console.log("FileDrag._getPathValueAttr	plugins.files.FileDrag._getPathValueAttr(/*item?*/val)");
	// summary: returns the path value of the given value (or current value
	//  if not passed a value)
	if(!val){
		val = this.value;
	}
	if(val && this.store.isItem(val)){
		return this.store.getValue(val, this.pathAttr);
	}else{
		return "";
	}
},
/*
//// loadingMessage: String
////	Message that shows while downloading
//loadingMessage: "<span class='dijitContentPaneLoading'>${loadingState}</span>", 
//
//// errorMessage: String
////	Message that shows if an error occurs
//errorMessage: "<span class='dijitContentPaneError'>${errorState}</span>", 
//
*/
onFetchStart: function(){

	//console.log("FileDrag.onFetchStart    plugins.files.FileDrag.onFetchStart()");

	//////console.log("FileDrag.onFetchStart	plugins.files.FileDrag.onFetchStart()");
	// summary:
	//		called before a fetch starts
	return this.loadingMessage;
},
onFetchError: function(/*Error*/ error){
	//////console.log("FileDrag.onFetchError	plugins.files.FileDrag.onFetchError(/*item?*/val)");
	//////console.log("FileDrag.onFetchError	error: " + dojo.toJson(error));

	// summary:
	//	called when a fetch error occurs.
	return this.errorMessage;
}
	
});

}

if(!dojo._hasResource["plugins.menu.Menu"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.menu.Menu"] = true;
dojo.provide("plugins.menu.Menu");

/* SUMMARY:  A CONTEXT MENU THAT IS AWARE OF THE UNDERLYING CLICKED TARGET. 

  ... AND WHICH YOU CAN BIND TO MULTIPLE DIFFERENT TARGETS
*/



dojo.declare("plugins.menu.Menu",
[ dijit.Menu ], {
	////}}
	
// SET TO FALSE TO DISABLE MENU OPEN
enabled : true,
	
_openMyself: function(args){

console.log("Menu._openMyself    plugins.menu.Menu._openMyself(args)");
	// summary:
	//		Internal function for opening myself when the user does a right-click or something similar.
	// args:
	//		This is an Object containing:
	//		* target:
	//			The node that is being clicked
	//		* iframe:
	//			If an <iframe> is being clicked, iframe points to that iframe
	//		* coords:
	//			Put menu at specified x/y position in viewport, or if iframe is
	//			specified, then relative to iframe.
	//
	//		_openMyself() formerly took the event object, and since various code references
	//		evt.target (after connecting to _openMyself()), using an Object for parameters
	//		(so that old code still works).


	// QUIT OPEN IF MENU IS NOT enabled
	if ( this.enabled == false )	return;

	// ADD THIS TO ENABLE IDENTIFICATION OF THE UNDERLYING TARGET
	// NODE WHEN THE MENU IS CLICKED
	this.currentTarget = args.target;

	// SET CURRENT TARGET CSS TO INDICATE ORIGIN OF MENU CLICK
	if ( this.currentTarget ) {
		console.log("plugins.menu.Menu._openMyself    Setting add class 'dojoDndItemOver' to this.currentTarget: " + this.currentTarget);
		console.dir({currentTarget:this.currentTarget});
		dojo.addClass(this.currentTarget, 'dojoDndItemOver');
		
		var classes = dojo.attr(this.currentTarget, 'class');
		console.log("plugins.menu.Menu._openMyself    this.currentTarget classes: " + classes)
	}

	var target = args.target,
		iframe = args.iframe,
		coords = args.coords;

	// Get coordinates to open menu, either at specified (mouse) position or (if triggered via keyboard)
	// then near the node the menu is assigned to.
	if(coords){
		if(iframe){
			// Specified coordinates are on <body> node of an <iframe>, convert to match main document
			var od = target.ownerDocument,
				ifc = dojo.position(iframe, true),
				win = this._iframeContentWindow(iframe),
				scroll = dojo.withGlobal(win, "_docScroll", dojo);

			var cs = dojo.getComputedStyle(iframe),
				tp = dojo._toPixelValue,
				left = (dojo.isIE && dojo.isQuirks ? 0 : tp(iframe, cs.paddingLeft)) + (dojo.isIE && dojo.isQuirks ? tp(iframe, cs.borderLeftWidth) : 0),
				top = (dojo.isIE && dojo.isQuirks ? 0 : tp(iframe, cs.paddingTop)) + (dojo.isIE && dojo.isQuirks ? tp(iframe, cs.borderTopWidth) : 0);

			coords.x += ifc.x + left - scroll.x;
			coords.y += ifc.y + top - scroll.y;
		}
	}else{
		coords = dojo.position(target, true);
		coords.x += 10;
		coords.y += 10;
	}

	var self=this;
	var savedFocus = dijit.getFocus(this);
	function closeAndRestoreFocus(){
		// user has clicked on a menu or popup
		if(self.refocus){
			dijit.focus(savedFocus);
		}
		dijit.popup.close(self);
	}
	dijit.popup.open({
		popup: this,
		x: coords.x,
		y: coords.y,
		onExecute: closeAndRestoreFocus,
		onCancel: closeAndRestoreFocus,
		orient: this.isLeftToRight() ? 'L' : 'R'
	});
	this.focus();

	this._onBlur = function(){

console.log("plugins.menu.Menu._onBlur");

		this.inherited('_onBlur', arguments);
		// Usually the parent closes the child widget but if this is a context
		// menu then there is no parent
		dijit.popup.close(this);
		// don't try to restore focus; user has clicked another part of the screen
		// and set focus there
	};
}


});

}

if(!dojo._hasResource["plugins.dijit.InputDialog"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.dijit.InputDialog"] = true;
dojo.provide("plugins.dijit.InputDialog");

// HAS A



// INHERITS



dojo.declare( "plugins.dijit.InputDialog",
	[ dijit._Widget, dijit._Templated, plugins.core.Common ],
{
//////}}
	
//Path to the template of this widget. 
templateString:"<div dojoAttachPoint=\"containerNode\">\n\n    <table\n        cellspacing=\"0px\"\n        height=\"300px\" width=\"100%\" style=\"padding: 0; margin: 0;\"\n        class=\"inputDialog\">\n        <tr>\n            <td align=\"center\">\n                \n                <div\n                    dojoAttachPoint=\"dialog\"\n                    dojoType=\"dijit.Dialog\"\n                    closeText=\"false\"\n                    title=\"${title}\"\n                    style=\"margin-right: auto; margin-left: auto; text-align: center;\"\n                    >\n                    \n                    <table\n                        cellpadding=\"0\"\n                        cellspacing=\"0\"\n                        class=\"inputDialog\"\n                        width=\"100%\"\n                        >\n\n                        <tr class=\"message\" align=\"center\">\n                            <td\n                                align=\"center\"\n                                dojoAttachPoint=\"messageNode\"\n                                colspan=\"2\">${message}</td>\n                        </tr>\n\n                        <tr class=\"input\" align=\"center\" dojoAttachPoint=\"inputContainer\">\n                            <td align=\"center\" colspan=\"2\" >\n                                <input type=\"text\" align=\"center\"\n                                dojoAttachPoint=\"inputNode\"\n                                value=\"\"></input>\n                            </td>\n                        </tr>\n                        \n\n                        <tr\n                            dojoAttachPoint=\"checkboxContainer\"\n                            class=\"hidden\">\n\n                            <td colspan=\"2\">\n                                <table>\n                                    <tr>\n                                        <td class=\"leftColumn\"\n                                            dojoAttachPoint=\"checkboxMessageNode\"\n                                            class=\"hidden\"\n                                        >\n                                        </td>\n                                        <td class=\"rightColumn\">\n                                            <input\n                                                dojoAttachPoint=\"checkbox\"  \n                                                style=\"visibility: hidden\"\n                                                type=\"checkbox\"\n                                                class=\"hidden\"\n                                        >\n                                        </td>\n                                    </tr>\n                                </table>\n                            </td>\n\n                        </tr>\n                        \n\n                        <tr>\n                            <td align=\"center\" class=\"enterButton\">\n                                <button\n                                    dojoType=\"dijit.form.Button\"\n                                    type=\"button\"\n                                    label=\"Enter\"\n                                    dojoAttachEvent=\"onClick:doEnter\"\n                                    >\n                                </button>\n                            </td>\n\n                            <td align=\"center\" class=\"cancelButton\">\n                                <div\n                                    dojoType=\"dijit.form.Button\"\n                                    type=\"button\"\n                                    label=\"Cancel\"\n                                    dojoAttachEvent=\"onClick:doCancel\"\n                                    >\n                                </div>\n                            </td>\n                        </tr>\n                        \n                        \n                    </table>\n\n                </div>\n            \n            </td>\n        </tr>\n    </table>\n</div>\n",

// OR USE @import IN HTML TEMPLATE
cssFiles : [
	dojo.moduleUrl("plugins", "dijit/css/inputdialog.css")
],

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

// PARENT plugins.workflow.Apps WIDGET
parentWidget : null,

// APPLICATION OBJECT
application : null,

/* DIALOG VARIABLES
  
TITLE

MESSAGE

INPUT MESSAGE

CHECKBOX	CHECKBOX MESSAGE

ENTER CALLBACK				CANCEL CALLBACK
  
*/
// DIALOG TITLE
//title: null,
//message: null,
//inputMessage: null,
//parentWidget: null,
//enterCallback: null,
//cancelCallback: null,
//checkboxMessage: null,


// DISPLAYED MESSAGE 
message : null,

constructor : function(args) {
	////console.log("InputDialog.constructor    plugins.dijit.InputDialog.constructor()");

	//this.title 				=	args.title;
	//this.message 			=	args.message;
	//this.inputMessage 		=	args.inputMessage;
	//this.parentWidget 		=	args.parentWidget;
	//this.enterCallback 		=	args.enterCallback;
	//this.cancelCallback 	=	args.cancelCallback;
	//this.checkboxMessage 	=	args.checkboxMessage;
	
	// SET ENTER BUTTON AND CANCEL BUTTON LABELS
	this.setEnterLabel(args.enterLabel);
	this.setCancelLabel(args.cancelLabel);
		
	// LOAD CSS
	this.loadCSS();
},

postCreate : function() {
	//////console.log("InputDialog.postCreate    plugins.dijit.InputDialog.postCreate()");

	this.startup();
},

startup : function () {
	////console.log("InputDialog.startup    plugins.dijit.InputDialog.startup()");
	////console.log("InputDialog.startup    this.parentWidget: " + this.parentWidget);

	this.inherited(arguments);

	// SET UP DIALOG
	this.setDialogue();

	// SHOW INPUT IF this.inputMessage IS DEFINED
	this.showInputbox(this.inputMessage);

	// SHOW CHECKBOX IF this.checkboxMessage IS DEFINED
	this.showCheckbox(this.checkboxMessage);
	
	// ADD CSS NAMESPACE CLASS FOR TITLE CSS STYLING
	this.setNamespaceClass("inputDialog");
},

setNamespaceClass : function (ccsClass) {
// ADD CSS NAMESPACE CLASS
	dojo.addClass(this.dialog.containerNode, ccsClass);
	dojo.addClass(this.dialog.titleNode, ccsClass);
	dojo.addClass(this.dialog.closeButtonNode, ccsClass);	
},

show: function () {
// SHOW THE DIALOGUE
	this.dialog.show();
	this.enterButton.focus();
},

hide: function () {
// HIDE THE DIALOGUE
	this.dialog.hide();
},

doEnter : function(type) {
// RUN ENTER CALLBACK IF 'ENTER' CLICKED
	//console.log("InputDialog.doEnter    plugins.dijit.InputDialog.doEnter()");
	var input = this.inputNode.value;
	var checked = this.checkbox.checked;
	if ( checked == true ) checked = 1;
	else checked = 0;
	
	// DO CALLBACK
	this.dialog.enterCallback(input, checked);	

	// REMOVE INPUT AND HIDE
	this.inputNode.value = '';
	this.dialog.hide();
},

doCancel : function() {
// RUN CANCEL CALLBACK IF 'CANCEL' CLICKED
	////console.log("InputDialog.doCancel    plugins.dijit.InputDialog.doCancel()");
	this.dialog.cancelCallback();
	this.dialog.hide();
},

setDialogue : function () {
	// APPEND DIALOG TO DOCUMENT
	document.body.appendChild(this.dialog.domNode);
	
	this.dialog.parentWidget = this;
	
	// AVOID this._fadeOutDeferred NOT DEFINED ERROR
	this._fadeOutDeferred = function () {};
},

load : function (args) {
// LOAD THE DIALOGUE VALUES
	//////console.log("InputDialog.load    plugins.dijit.InputDialog.load()");
	//////console.log("InputDialog.load    args: " + dojo.toJson(args));
	//////console.log("InputDialog.load    ////console.dir(this.dialog)");
	//////console.dir(this.dialog);

	// SET THE DIALOG
	if ( args.title == null )	{	args.title = "";	}
	this.dialog.titleNode.innerHTML	=	args.title;
	this.messageNode.innerHTML		=	args.message;
	this.dialog.enterCallback		=	args.enterCallback;
	this.dialog.cancelCallback		=	args.cancelCallback

	// SET CHECKBOX BOX IF CHECKBOX MESSAGE IS DEFINED
	this.showCheckbox(args.checkboxMessage);

	// SET ENTER BUTTON AND CANCEL BUTTON LABELS
	this.setEnterLabel(args.enterLabel);
	this.setCancelLabel(args.cancelLabel);

	this.show();
},

showInputbox : function (inputMessage) {
	//console.log("InputDialog.showInputbox    plugins.dijit.InputDialog.showInputbox(inputMessage)");
	//console.log("InputDialog.showInputbox    inputMessage: " + inputMessage);

	if ( inputMessage == null )
	{
		//console.log("InputDialog.showInputbox    Doing dojo.destroy(this.inputContainer)");
		dojo.destroy(this.inputContainer);
	}
	else {
		this.inputNode.style.visibility = "visible";
		this.checkbox.style.visibility = "visible";
		this.inputNode.innerHTML = inputMessage;
		
		// ACTIVATE 'YES' KEY ON PRESS 'RETURN'
		var thisObject = this;
		this.inputNode.onkeypress = function(evt){
			var key = evt.which;
			//console.log("dijit.InputDialog    inputNode._onKey	key: " + key);
			if ( key == 13 )
			{
				//console.log("dijit.InputDialog    inputNode._onKey	   Doing this.doEnter");
				evt.stopPropagation();
				thisObject.doEnter();
		
			}    
		};

	}
},

showCheckbox : function (message) {
	//console.log("InputDialog.showCheckbox    plugins.dijit.InputDialog.showCheckbox(message)");
	//console.log("InputDialog.showCheckbox    message: " + message);
	//console.log("InputDialog.showCheckbox    this.inputNode.style.visibility: " + this.inputNode.style.visibility);
	//console.log("InputDialog.showCheckbox    this.checkbox.style.visibility: " + this.checkbox.style.visibility);
	//console.log("InputDialog.showCheckbox    this.checkbox: " + this.checkbox);

	if ( message == null )
	{
		dojo.addClass(this.checkboxMessageNode, "hidden");
		dojo.addClass(this.checkbox, "hidden");
		//this.inputNode.style.visibility = "hidden";
		//this.checkbox.style.visibility = "hidden";
		//this.checkbox.style.height = "0px";
		//dojo.destroy(this.checkboxContainer);
	}
	else {
		dojo.removeClass(this.checkboxMessageNode, "hidden");
		dojo.removeClass(this.checkbox, "hidden");
		//this.inputNode.style.visibility = "visible";
		//this.checkbox.style.visibility = "visible";
		this.inputNode.innerHTML = message;
		//this.checkbox.style.height = "20px";
	}

	//////console.log("InputDialog.showCheckbox    END");
},

setEnterLabel : function (label) {

	////console.log("InputDialog.setEnterLabel    label: " + label);
	if ( label != null && this.enterButton != null )
		this.enterButton.set('label', label);	
},

setCancelLabel : function (label) {

	////console.log("InputDialog.setCancelLabel    label: " + label);
	if ( label != null && this.cancelButton != null )
		this.cancelButton.set('label', label);	
}



});
	

}

if(!dojo._hasResource["plugins.dijit.InteractiveDialog"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.dijit.InteractiveDialog"] = true;
dojo.provide("plugins.dijit.InteractiveDialog");
/* CLASS SUMMARY: AN INTERACTIVE INPUT DIALOG
  
	INTERACTIVELY RUN 'Enter' CALLBACK UNTIL CLOSED BY CALLBACK.

	UNLIKE IT'S PARENT CLASS inputDialog, interactiveDialog DOES

	NOT IMMEDIATELY DISAPPEAR AFTER 'Enter' HAS BEEN CLICKED.

	RATHER, IT HANGS AROUND UNTIL THE enterCallback METHOD CLOSES IT.
*/

// HAS A



// INHERITS




dojo.declare( "plugins.dijit.InteractiveDialog",
	[ plugins.dijit.InputDialog ],
{
	//////}}
	
// SHOW THE DIALOGUE
show: function () {
	this.dialog.show();	
},

// HIDE THE DIALOGUE
hide: function () {
	this.dialog.hide();
},

doEnter : function(type) {
	console.log("InteractiveDialog.doEnter    plugins.dijit.InteractiveDialog.doEnter()");
	
	console.log("InteractiveDialog.doEnter    Doing this.dialog.hide()");
	this.dialog.hide();

	var input = '';
	if ( this.inputNode != null ) input = this.inputNode.value;
	var checked = false;
	if ( this.checkbox != null ) checked = this.checkbox.checked;
	if ( checked == true ) checked = 1;
	else checked = 0;
	
	console.log("InteractiveDialog.doEnter    input: " + input);		
	console.log("InteractiveDialog.doEnter    checked: " + checked);

	// DO CALLBACK
	this.dialog.enterCallback(input, checked, this);		
},

// RUN CANCEL CALLBACK IF 'CANCEL' CLICKED
doCancel : function() {
	console.log("InteractiveDialog.doCancel    plugins.dijit.InteractiveDialog.doCancel()");
	this.dialog.hide();
	this.dialog.cancelCallback();
},

close : function () {
	// REMOVE INPUT AND HIDE
	this.dialog.hide();
	this.inputNode.value = '';
}


});
	

}

if(!dojo._hasResource["plugins.dijit.ConfirmDialog"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.dijit.ConfirmDialog"] = true;
dojo.provide("plugins.dijit.ConfirmDialog");

// HAS A



// INHERITS



dojo.declare( "plugins.dijit.ConfirmDialog",
	[ dijit._Widget, dijit._Templated, plugins.core.Common ],
{
	//Path to the template of this widget. 
	templateString:"<div dojoAttachPoint=\"containerNode\">\n\n    <table\n        cellspacing=\"0px\" cellpadding=\"0px\"\n        height=\"300px\" width=\"100%\" >\n        <tr>\n            <td>\n                \n                <div\n                    dojoAttachPoint=\"dialog\"\n                    dojoType=\"dijit.Dialog\"\n                    class=\"confirmDialog\"\n                    closeText=\"false\"\n                    title=\"${title}\"\n                >\n                    \n                    <table\n                        cellpadding=\"0\"\n                        cellspacing=\"0\"\n                        width=\"100%\"\n                        >\n                        <tr class=\"message\" align=\"center\">\n                            <td\n                                align=\"center\"\n                                dojoAttachPoint=\"messageNode\"\n                                colspan=\"2\">${message}</td>\n                        </tr>\n                        \n                        <tr>\n                            <td align=\"center\" class=\"yesButton\">\n                                <button\n                                    dojoType=\"dijit.form.Button\"\n                                    type=\"button\"\n                                    label=\"Yes\"\n                                    dojoAttachEvent=\"onClick:doYes\"\n                                    >\n                                </button>\n                            </td>\n\n                            <td align=\"center\" class=\"noButton\">\n                                <div\n                                    dojoType=\"dijit.form.Button\"\n                                    type=\"button\"\n                                    label=\"No\"\n                                    dojoAttachEvent=\"onClick:doNo\"\n                                    >\n                                </div>\n                            </td>\n                        </tr>\n                    </table>\n\n                </div>\n            \n            </td>\n        </tr>\n    </table>\n</div>\n",

	// OR USE @import IN HTML TEMPLATE
	cssFiles : [ dojo.moduleUrl("plugins.dijit") + "/css/confirmdialog.css" ],

	// Calls dijit._Templated.widgetsInTemplate
	widgetsInTemplate : true,
	
	// PARENT plugins.workflow.Apps WIDGET
	parentWidget : null,
	
	// APPLICATION OBJECT
	application : null,
	
	// DIALOG TITLE
	title: null,
	
	// DISPLAYED MESSAGE 
	message : null,
	
	constructor : function(args)
	{
		//console.log("Confirm.constructor    plugins.dijit.ConfirmDialog.constructor()");

		this.title 				=	args.title;
		this.message 			=	args.message;
		this.parentWidget 		=	args.parentWidget;
		this.yesCallback 		=	args.yesCallback;
		this.noCallback 		=	args.noCallback;
		
		// LOAD CSS
        this.loadCSS();
	},

	getApplication : function ()
	{
		return this.application;
	},

	postCreate : function()
	{
		////console.log("Confirm.postCreate    plugins.dijit.ConfirmDialog.postCreate()");

		this.startup();
	},
	
	startup : function ()
	{
		//console.log("Confirm.startup    plugins.dijit.ConfirmDialog.startup()");
		//console.log("Confirm.startup    this.parentWidget: " + this.parentWidget);

		this.inherited(arguments);

		// SET UP DIALOG
		this.setDialogue();
		
		// ADD CSS NAMESPACE CLASS
		dojo.addClass(this.dialog.containerNode, "confirmDialog");
		dojo.addClass(this.dialog.titleNode, "confirmDialog");
		dojo.addClass(this.dialog.closeButtonNode, "confirmDialog");
		
		// REMOVE CLOSE BUTTON NODE
		this.dialog.closeButtonNode.setAttribute('display', 'none');
		this.dialog.closeButtonNode.setAttribute('visibility', 'hidden');
	},

	// SHOW THE DIALOGUE
	show: function ()
	{
		this.dialog.show();
	},

	// HIDE THE DIALOGUE
	hide: function ()
	{
		this.dialog.hide();
	},

	doYes : function(type)
	{
		//console.log("Confirm.doYes    plugins.dijit.ConfirmDialog.doYes()");
		
		// DO CALLBACK
		this.dialog.yesCallback();
		
		// HIDE
		this.dialog.hide();
	},

	doNo : function()
	{
		//console.log("Confirm.doNo    plugins.dijit.ConfirmDialog.doNo()");

		// DO CALLBACK
		this.dialog.noCallback();
	
		// HIDE
		this.dialog.hide();
	},


	// LOAD THE DIALOGUE VALUES
	load : function (args)
	{
		//console.log("ConfirmDialog.load    plugins.dijit.InputDialog.load()");
		//console.log("ConfirmDialog.load    args: " + dojo.toJson(args));

		if ( args.title == null )	{	args.title = "";	}
		this.dialog.titleNode.innerHTML	=	args.title;
		this.messageNode.innerHTML	=	args.message;
		this.dialog.yesCallback		=	args.yesCallback;
		this.dialog.noCallback		=	args.noCallback

		//console.log("ConfirmDialog.load    this.yesCallback: " + this.yesCallback.toString());

		this.show();
	},


	// APPEND TO DOCUMENT BODY
	setDialogue : function () {
		
		// APPEND DIALOG TO DOCUMENT
		//this.dialog.title = title;
		document.body.appendChild(this.dialog.domNode);
		//this.dialog.show();
	}

});
	

}

if(!dojo._hasResource["dojox.form.uploader.Base"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.form.uploader.Base"] = true;
dojo.provide("dojox.form.uploader.Base");




dojo.declare("dojox.form.uploader.Base", [dijit._Widget, dijit._Templated], {
	//
	// Version: 1.6
	//
	// summary:
	// 		The Base class used for dojox.form.Uploader and dojox.form.uploader.FileList.
	//
	// 	description:
	// 		Should not be used as a standalone. To be mixed in with other classes.
	//

	getForm: function(){
		// summary:
		// 		Finds the parent form of the Uploader, if it exists.
		//
		if(!this.form){
			var n = this.domNode;
			while(n && n.tagName && n !== document.body){
				if(n.tagName.toLowerCase() == "form"){
					this.form = n;
					break;
				}
				n = n.parentNode;
			}
		}
		return this.form // Node;
	},

	getUrl: function(){
		// summary:
		// 		Finds the URL to upload to, whether it be the action in the parent form, this.url or
		// 		this.uploadUrl
		//
		if(this.uploadUrl) this.url = this.uploadUrl;
		if(this.url) return this.url;
		if(this.getForm()) this.url = this.form.action;
		return this.url; // String
	},


	connectForm: function(){
		////console.log("connectForm...", this.url, !!this.uploadUrl, !!this.getForm())

		this.url = this.getUrl();

		if(!this._fcon && !!this.getForm()){
			this._fcon = true;
			this.connect(this.form, "onsubmit", function(evt){
				dojo.stopEvent(evt);
				this.submit(dojo.formToObject(this.form));
			});
			////console.log("----------------form connected:", this.url)
		}
		////console.log("form:", this.form, this.url);
	},

	supports: function(what){
		//	summary:
		// 		Does feature testing for uploader capabilities. (No browser sniffing - yay)
		//
		if(!this._hascache){
			this._hascache = {
				testDiv: dojo.create("div"),
				testInput: dojo.create("input", {type:"file"}),
				xhr:!!window.XMLHttpRequest ? new XMLHttpRequest() : {}
			};
			dojo.style(this._hascache.testDiv, "opacity", .7);
		}
		switch(what){
			case "FormData":
				return !!window.FormData;
			case "sendAsBinary":
				return !!this._hascache.xhr.sendAsBinary;
			case "opacity":
				return dojo.style(this._hascache.testDiv, "opacity") == .7;
			case "multiple":
				if(this.force == "flash" || this.force == "iframe") return false;
				var res = dojo.attr(this._hascache.testInput, "multiple");
				return res===true || res===false; // IE will be undefined
		}
		return false; // Boolean
	},
	getMimeType: function(){
		//	summary:
		//		Returns the mime type that should be used in an HTML5 upload form. Return result
		//		may change as the current use is very generic.
		//
		return "application/octet-stream"; //image/gif
	},
	getFileType: function(/* String */name){
		// summary:
		// 		Gets the extension of a file
		return name.substring(name.lastIndexOf(".")+1).toUpperCase(); // String
	},
	convertBytes: function(bytes){
		// summary:
		// 		Converts bytes. Returns an object with all conversions. The "value" property is
		// 		considered the most likely desired result.
		//
		var kb = Math.round(bytes/1024*100000)/100000;
		var mb = Math.round(bytes/1048576*100000)/100000;
		var gb = Math.round(bytes/1073741824*100000)/100000;
		var value = bytes;
		if(kb>1) value = kb.toFixed(1)+" kb";
		if(mb>1) value = mb.toFixed(1)+" mb";
		if(gb>1) value = gb.toFixed(1)+" gb";
		return {
			kb:kb,
			mb:mb,
			gb:gb,
			bytes:bytes,
			value: value
		}; // Object
	}
});

}

if(!dojo._hasResource["dojox.form.Uploader"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.form.Uploader"] = true;
dojo.provide("dojox.form.Uploader");
dojo.experimental("dojox.form.Uploader");



	//
	// TODO:
	//		i18n
	//		label via innerHTML
	//		Doc and or test what can be extended.
	//		Doc custom file events
	//		Use new FileReader() for thumbnails
	//		flashFieldName should default to Flash
	//		get('value'); and set warning
	//

dojo.declare("dojox.form.Uploader", [dojox.form.uploader.Base], {
	//
	// Version: 1.6
	//
	// summary:
	//		A widget that creates a stylable file-input button, with optional multi-file selection,
	//		using only HTML elements. Non-HTML5 browsers have fallback options of Flash or an iframe.
	//
	//	description:
	//		A bare-bones, stylable file-input button, with optional multi-file selection. The list
	//		of files is not displayed, that is for you to handle by connecting to the onChange
	//		event, or use the dojox.form.uploader.FileList.
	//
	//		Uploader without plugins does not have any ability to upload - it is for use in forms
	//		where you handle the upload either by a standard POST or with Ajax using an iFrame. This
	//		class is for convenience of multiple files only. No progress events are available.
	//
	//		If the browser supports a file-input with the "multiple" attribute, that will be used.
	//		If the browser does not support "multiple" (ergo, IE) multiple inputs are used,
	//		one for each selection.
	//
	//
	//	uploadOnSelect: Boolean
	//		If true, uploads imediately after a file has been selected. If false,
	//		waits for upload() to be called.
	uploadOnSelect:false,
	//	tabIndex: Number|String
	//		The tab order in the DOM.
	tabIndex:0,
	//	multiple: Boolean
	//		If true and flash mode, multiple files may be selected from the dialog.
	multiple:false,
	//
	//	label: String
	//		The text used in the button that when clicked, opens a system Browse Dialog.
	label:"Upload...",
	//
	// url: String
	//		The url targeted for upload. An absolute URL is preferred. Relative URLs are
	//		changed to absolute.
	url:"",
	//
	//	name: String
	//		The name attribute needs to end with square brackets: [] as this is the standard way
	//		of handling an attribute "array". This requires a slightly different technique on the
	//		server.
	name:"uploadedfile",
	//
	//	flashFieldName: String
	//		If set, this will be the name of the field of the flash uploaded files that the server
	//		is expecting. If not set, "Flash" is appended to the "name" property.
	flashFieldName:"",
	//
	//	uploadType: String [readonly]
	//		The type of uploader being used. As an alternative to determining the upload type on the
	//		server based on the fieldName, this property could be sent to the server to help
	//		determine what type of parsing should be used.
	uploadType:"form",
	//
	_nameIndex:0,
	widgetsInTemplate:true,
	templateString:'<div class="dojoxFileInput"><div dojoType="dijit.form.Button" dojoAttachPoint="button">${label}</div></div>',

	postMixInProperties: function(){
		this._inputs = [];
		this._getButtonStyle(this.srcNodeRef);
		this.inherited(arguments);
	},
	postCreate: function(){
		var restore = false;
		var parent = this.domNode.parentNode;
		var position = this._getNodePosition(this.domNode);
		if(!this.btnSize.w || !this.btnSize.h) {
			dojo.body().appendChild(this.domNode);
			this._getButtonStyle(this.domNode);
			restore = true;
		}
		this._setButtonStyle();
		if(restore){
			dojo.place(this.domNode, position.node, position.pos)
		}
		this.inherited(arguments);
	},

	/*************************
	 *	   Public Events	 *
	 *************************/

	onChange: function(/* Array */fileArray){
		//	summary:
		// 		stub to connect
		// 		Fires when files are selected
		// 		Event is an array of last files selected
	},

	onBegin: function(/* Array */dataArray){
		// summary:
		// 		Fires when upload begins
	},

	onProgress: function(/* Object */customEvent){
		// summary:
		// 		Stub to connect
		// 		Fires on upload progress. Event is a normalized object of common properties
		// 		from HTML5 uploaders and the Flash uploader. Will not fire for IFrame.
		// customEvent:
		// 		bytesLoaded: Number
		// 			Amount of bytes uploaded so far of entire payload (all files)
		//		bytesTotal: Number
		//			Amount of bytes of entire payload (all files)
		//		type: String
		//			Type of event (progress or load)
		//		timeStamp: Number
		//			Timestamp of when event occurred
	},

	onComplete: function(/* Object */customEvent){
		// summary:
		// 		stub to connect
		// 		Fires when all files have uploaded
		// 		Event is an array of all files
		
		console.log("dojox.form.Uploader.onComplete()");
		
		this.reset();
	},

	onCancel: function(){
		// summary:
		// 		Stub to connect
		// 		Fires when dialog box has been closed
		//		without a file selection
	},

	onAbort: function(){
		// summary:
		// 		Stub to connect
		// 		Fires when upload in progress was canceled
	},

	onError: function(/* Object or String */evtObject){
		// summary:
		//		Fires on errors
		//
		//FIXME: Unsure of a standard form of error events
	},

	/*************************
	 *	   Public Methods	 *
	 *************************/

	upload: function(/*Object ? */formData){
		// summary:
		// 		When called, begins file upload. Only supported with plugins.
	},

	submit: function(/* form Node ? */form){
		// summary:
		//		If Uploader is in a form, and other data should be sent along with the files, use
		//		this instead of form submit. Only supported with plugins.
	},

	reset: function(){
		// summary
		// 		Resets entire input, clearing all files.
		// 		NOTE:
		// 		Removing individual files is not yet supported, because the HTML5 uploaders can't
		// 		be edited.
		// 		TODO:
		// 		Add this ability by effectively, not uploading them
		//
		
		this._disconnectButton();
		//dojo.forEach(this._inputs, dojo.destroy, dojo);
		this._inputs = [];
		this._nameIndex = 0;
		this._createInput();
	},

	getFileList: function(){
		// summary:
		// 		Returns a list of selected files.
		//

		//console.log("dojox.form.Uploader.getFileList     caller: " + this.getFileList.caller.nom);

		var fileArray = [];
		if(this.supports("multiple")){
			dojo.forEach(this.inputNode.files, function(f, i){
				fileArray.push({
					index:i,
					name:f.name,
					size:f.size,
					type:f.type
				});
			}, this);
		}else{
			dojo.forEach(this._inputs, function(n, i){
				fileArray.push({
					index:i,
					name:n.value.substring(n.value.lastIndexOf("\\")+1),
					size:0,
					type:n.value.substring(n.value.lastIndexOf(".")+1)
				});
			}, this)

		}
		
		//console.log("dojox.form.Uploader.getFileList    Returning fileArray:");
		//console.dir({fileArray:fileArray});
		
		return fileArray; // Array
	},

	/*********************************************
	 *	   Private Property. Get off my lawn.	 *
	 *********************************************/

	_getValueAttr: function(){
		// summary:
		//		Internal. To get disabled use: uploader.get("disabled");
		return this.getFileList();
	},

	_setValueAttr: function(disabled){
		//console.error("Uploader value is read only");
	},

	_getDisabledAttr: function(){
		// summary:
		//		Internal. To get disabled use: uploader.get("disabled");
		return this._disabled;
	},

	_setDisabledAttr: function(disabled){
		// summary:
		//		Internal. To set disabled use: uploader.set("disabled", true);
		if(this._disabled == disabled){ return; }
		this.button.set('disabled', disabled);
		dojo.style(this.inputNode, "display", disabled ? "none" : "block");
	},

	_getNodePosition: function(node){
		if(node.previousSibling){
			return {
				node:node.previousSibling,
				pos:"after"
			}
		}
		return {
			node:node.nextSibling,
			pos:"before"
		}
	},

	_getButtonStyle: function(node){
		if(!node){
			// we don't want this to happen. But if it does, try and display *something*.
			this.btnSize = {
				w:200,
				h:25
			};
		}else{
			this.btnSize = dojo.marginBox(node);
		}
	},

	_setButtonStyle: function(){
		var hasParent = true;
		if(!this.domNode.parentNode || !this.domNode.parentNode.tagName){
			document.body.appendChild(this.domNode);
			hasParent = false;
		}

		dojo.style(this.domNode, {
			width:this.btnSize.w+"px",
			height:(this.btnSize.h+4)+"px",
			overflow:"hidden",
			position:"relative"
		});

		this.inputNodeFontSize = Math.max(2, Math.max(Math.ceil(this.btnSize.w / 60), Math.ceil(this.btnSize.h / 15)));
		this._createInput();

		dojo.style(this.button.domNode, {
			margin:"0px",
			display:"block",
			verticalAlign:"top" // IE fix

		});

		dojo.style(this.button.domNode.firstChild, {
			margin:"0px",
			display:"block"
			//height:this.btnSize.h+"px"
		});

		if(!hasParent){
			document.body.removeChild(this.domNode);
		}
	},

	_createInput: function(){

//console.log("dojox.form.Uploader._createInput    BEFORE this.inputNode:");
//console.dir({inputNode:this.inputNode});

		if(this._inputs.length){
			dojo.style(this.inputNode, {
				top:"500px"
			});
			this._disconnectButton();
			this._nameIndex++;
		}

		var name;
		if(this.supports("multiple")){
			// FF3.5+, WebKit
			name = this.name+"s[]";
		}else{
			// <=IE8
			name = this.name + (this.multiple ? this._nameIndex : "");
		}
		this.inputNode = dojo.create("input", {type:"file", name:name, className:"dojoxInputNode"}, this.domNode, "first");
		if(this.supports("multiple") && this.multiple){
			dojo.attr(this.inputNode, "multiple", true);
		}
		this._inputs.push(this.inputNode);


		dojo.style(this.inputNode, {
			fontSize:this.inputNodeFontSize+"em"
		});
		var size = dojo.marginBox(this.inputNode);

		dojo.style(this.inputNode, {
			position:"absolute",
			top:"-2px",
			left:"-"+(size.w-this.btnSize.w-2)+"px",
			opacity:0
		});
		this._connectButton();

//console.log("dojox.form.Uploader._createInput    AFTER this.inputNode:");
//console.dir({inputNode:this.inputNode});

	},

	_connectButton: function(){
		this._cons = [];
		var cs = dojo.hitch(this, function(nm){
			this._cons.push(dojo.connect(this.inputNode, nm, this, function(evt){
				this.button._cssMouseEvent({type:nm})
			}));
		});
		cs("mouseover");
		cs("mouseout");
		cs("mousedown");
		this._cons.push(dojo.connect(this.inputNode, "change", this, function(evt){
			
			//console.log("dojox.form.Uploader._connectButton    fired this.inputNode 'change'");
			//console.log("dojox.form.Uploader._connectButton    this.supports('multiple'): " + this.supports("multiple"));

			//console.log("dojox.form.Uploader._connectButton    BEFORE this.onChange, this.inputNode.files: ");
			//console.dir({files:this.inputNode.files});

			this.onChange(this.getFileList(evt));

			//console.log("dojox.form.Uploader._connectButton    AFTER this.onChange, this.inputNode.files: ");
			//console.dir({files:this.inputNode.files});
			
			if(!this.supports("multiple") && this.multiple) this._createInput();
		}));


		this.button.set('tabIndex', -1);

		if(this.tabIndex > -1){
			this.inputNode.tabIndex = this.tabIndex;
			var restoreBorderStyle = dojo.style(this.button.domNode.firstChild, "border");
			this._cons.push(dojo.connect(this.inputNode, "focus", this, function(){
				dojo.style(this.button.domNode.firstChild, "border", "1px dashed #ccc");
			}));
			this._cons.push(dojo.connect(this.inputNode, "blur", this, function(){
				dojo.style(this.button.domNode.firstChild, "border", restoreBorderStyle);
			}));
		}
	},

	_disconnectButton: function(){

		console.log("dojox.form.Uploaders._disconnectButton    this._cons:");
		console.dir({this_cons:this._cons});

		//dojo.forEach(this._cons, dojo.disconnect, dojo);
	}
});

(function(){
	dojox.form.UploaderOrg = dojox.form.Uploader;
	var extensions = [dojox.form.UploaderOrg];
	dojox.form.addUploaderPlugin = function(plug){
		
		console.log("dojox.form.Uploader.addUploaderPlugin    XXXXXXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXXXX plug: " + plug);
		
		// summary:
		// 		Handle Uploader plugins. When the dojox.form.addUploaderPlugin() function is called,
		// 		the dojox.form.Uploader is recreated using the new plugin (mixin).
		//
		extensions.push(plug);
		dojo.declare("dojox.form.Uploader", extensions, {});
	}
})();

}

if(!dojo._hasResource["dojox.form.uploader.FileList"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.form.uploader.FileList"] = true;
dojo.provide("dojox.form.uploader.FileList");



dojo.declare("dojox.form.uploader.FileList", [dojox.form.uploader.Base], {
	//
	// Version: 1.6
	//
	// summary:
	//		A simple widget that provides a list of the files currently selected by
	//		dojox.form.Uploader
	//
	//	description:
	//		There is a required CSS file: resources/UploaderFileList.css.
	//		This is a very simple widget, and not beautifully styled. It is here mainly for test
	//		cases, but could very easily be used, extended, modified, or copied.
	//
	//	uploaderId: String
	//		The id of the dojox.form.Uploader to connect to.
	uploaderId:"",
	//	uploader: dojox.form.Uploader
	//		The dojox.form.Uploader to connect to. Use either this property of unploaderId. This
	//		property is populated if uploaderId is used.
	//
	uploader:null,
	//	headerIndex: String
	// 		The label for the index column.
	//
	headerIndex:"#",
	//	headerType: String
	// 		The label for the file type column.
	//
	headerType:"Type",
	//	headerFilename: String
	// 		The label for the file name column.
	//
	headerFilename:"File Name",
	//	headerFilesize: String
	// 		The label for the file size column.
	//
	headerFilesize:"Size",

	_upCheckCnt:0,
	rowAmt:0,

	templateString:	'<div class="dojoxUploaderFileList">' +
						'<div dojoAttachPoint="progressNode" class="dojoxUploaderFileListProgress"><div dojoAttachPoint="percentBarNode" class="dojoxUploaderFileListProgressBar"></div><div dojoAttachPoint="percentTextNode" class="dojoxUploaderFileListPercentText">0%</div></div>' +
						'<table class="dojoxUploaderFileListTable">'+
							'<tr class="dojoxUploaderFileListHeader"><th class="dojoxUploaderIndex">${headerIndex}</th><th class="dojoxUploaderIcon">${headerType}</th><th class="dojoxUploaderFileName">${headerFilename}</th><th class="dojoxUploaderFileSize">${headerFilesize}</th></tr>'+
							'<tr ><td colSpan="4" class="dojoxUploaderFileListContainer" dojoAttachPoint="containerNode">'+
								'<table class="dojoxUploaderFileListContent" dojoAttachPoint="listNode"></table>'+
							'</td><tr>'+
						'</table>'+
						'<div>'
						,

	postCreate: function(){
		this.setUploader();
		this.hideProgress();
	},

	reset: function(){
		// summary:
		//		Clears all rows of items. Happens automatically if Uploader is reset, but you
		//		could call this directly.
		//
		
		console.log("dojox.form.uploader.FileList.reset()");
		
		for(var i=0;i<this.rowAmt;i++){
			this.listNode.deleteRow(0);
		}
		this.rowAmt = 0;
	},

	setUploader: function(){
		// summary:
		//		Connects to the Uploader based on the uploader or the uploaderId properties.
		//
		if(!this.uploaderId && !this.uploader){
			//console.warn("uploaderId not passed to UploaderFileList");
		}else if(this.uploaderId && !this.uploader){
			this.uploader = dijit.byId(this.uploaderId);
		}else if(this._upCheckCnt>4){
			//console.warn("uploader not found for ID ", this.uploaderId);
			return;
		}
		if(this.uploader){
			this.connect(this.uploader, "onChange", "_onUploaderChange");
			this.connect(this.uploader, "reset", "reset");
			this.connect(this.uploader, "onBegin", function(){
				this.showProgress(true);
			});
			this.connect(this.uploader, "onProgress", "_progress");
			this.connect(this.uploader, "onComplete", function(){
				setTimeout(dojo.hitch(this, function(){
					this.hideProgress(true);
				}), 1250);
			});
		}else{
			this._upCheckCnt++;
			setTimeout(dojo.hitch(this, "setUploader"), 250);
		}
	},

	hideProgress: function(/* Boolean */animate){
		var o = animate ? {
			ani:true,
			endDisp:"none",
			beg:15,
			end:0
		} : {
			endDisp:"none",
			ani:false
		};
		this._hideShowProgress(o);
	},

	showProgress: function(/* Boolean */animate){
		var o = animate ? {
			ani:true,
			endDisp:"block",
			beg:0,
			end:15
		} : {
			endDisp:"block",
			ani:false
		};
		this._hideShowProgress(o);
	},

	_progress: function(/* Object */ customEvent){
		this.percentTextNode.innerHTML = customEvent.percent;
		dojo.style(this.percentBarNode, "width", customEvent.percent);
	},

	_hideShowProgress: function(o){
		var node = this.progressNode;
		var onEnd = function(){
			dojo.style(node, "display", o.endDisp);
		}
		if(o.ani){
			dojo.style(node, "display", "block");
			dojo.animateProperty({
				node: node,
				properties:{
					height:{
						start:o.beg,
						end:o.end,
						units:"px"
					}
				},
				onEnd:onEnd
			}).play();
		}else{
			onEnd();
		}
	},

	_onUploaderChange: function(fileArray){

		//console.log("dojox.form.Uploader.FileList._onUploaderChange    this.uploader.inputNode:");
		//console.dir({inputNode:this.uploader.inputNode});
		//console.dir({files:this.uploader.inputNode.files});

		//this.reset();
		dojo.forEach(fileArray, function(f, i){
			this._addRow(i+1, this.getFileType(f.name), f.name, f.size);
		}, this)
	},

	_addRow: function(index, type, name, size){

		var c, r = this.listNode.insertRow(-1);
		c = r.insertCell(-1);
		dojo.addClass(c, "dojoxUploaderIndex");
		c.innerHTML = index;

		c = r.insertCell(-1);
		dojo.addClass(c, "dojoxUploaderIcon");
		c.innerHTML = type;

		c = r.insertCell(-1);
		dojo.addClass(c, "dojoxUploaderFileName");
		c.innerHTML = name;
		c = r.insertCell(-1);
		dojo.addClass(c, "dojoxUploaderSize");
		c.innerHTML = this.convertBytes(size).value;

		this.rowAmt++;
	}
});

}

if(!dojo._hasResource["dojox.form.uploader.plugins.HTML5"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.form.uploader.plugins.HTML5"] = true;
dojo.provide("dojox.form.uploader.plugins.HTML5");

dojo.declare("dojox.form.uploader.plugins.HTML5", [], {
	//
	// Version: 1.6
	//
	// summary:
	//		A plugin for dojox.form.Uploader that adds HTML5 multiple-file upload capabilities and
	//		progress events.
	//
	//	description:
	//		Add this plugin to have HTML5 capabilities in the Uploader. Note that it does not add
	//		these capabilities to browsers that don't support them. For IE or older browsers, add
	//		additional plugins: IFrame or Flash.
	//
	errMsg:"Error uploading files. Try checking permissions",

	// Overwrites "form" and could possibly be overwritten again by iframe or flash plugin.
	uploadType:"html5",

	postCreate: function(){
		this.connectForm();
		this.inherited(arguments);
		if(this.uploadOnSelect){
			this.connect(this, "onChange", "upload");
		}
	},

	/*************************
	 *	   Public Methods	 *
	 *************************/

	upload: function(/*Object ? */formData){
		// summary:
		// 		See: dojox.form.Uploader.upload
		//
		this.onBegin(this.getFileList());
		if(this.supports("FormData")){
			this.uploadWithFormData(formData);
		}else if(this.supports("sendAsBinary")){
			this.sendAsBinary(formData);
		}
	},

	submit: function(/* form Node ? */form){
		// summary:
		//		See: dojox.form.Uploader.submit
		//
		form = !!form ? form.tagName ? form : this.getForm() : this.getForm();
		var data = dojo.formToObject(form);
		//console.log("form data:", data);
		this.upload(data);
	},

	sendAsBinary: function(/* Object */data){
		// summary:
		// 		Used primarily in FF < 4.0. Sends files and form object as binary data, written to
		// 		still enable use of $_FILES in PHP (or equivalent).
		// tags:
		// 		private
		//
		if(!this.getUrl()){
			//console.error("No upload url found.", this); return;
		}

		// The date/number doesn't matter but amount of dashes do. The actual boundary
		// will have two more dashes than this one which is used in the header.
		var boundary = "---------------------------" + (new Date).getTime();
		var xhr = this.createXhr();

		xhr.setRequestHeader("Content-Type", "multipart/form-data; boundary=" + boundary);

		// finally send the request as binary data
		// still accessed as $_FILES
		var msg = this._buildRequestBody(data, boundary);
		if(!msg){
			this.onError(this.errMsg);
		}else{
			xhr.sendAsBinary(msg);
		}
	},
	
	uploadWithFormData: function(/* Object */data){
		// summary
		// 		Used with WebKit and Firefox 4+
		// 		Upload files using the much friendlier FormData browser object.
		// tags:
		// 		private
		//
		if(!this.getUrl()){
			//console.error("No upload url found.", this); return;
		}

		var fd = new FormData();
		dojo.forEach(this.inputNode.files, function(f, i){

		//console.log("dojox.form.Uploader.HTML5.uploadWithFormData     this.inputNode: ");
		//console.dir({inputNode:this.inputNode});
		//console.log("dojox.form.Uploader.HTML5.uploadWithFormData     file " + i + ":");
		//console.dir({file:f});

			fd.append(this.name+"s[]", f);
		}, this);

		if(data){
			for(var nm in data){
				fd.append(nm, data[nm]);
			}
		}

		var xhr = this.createXhr();
		xhr.send(fd);
	},

	_xhrProgress: function(evt){
		if(evt.lengthComputable){
			var o = {
				bytesLoaded:evt.loaded,
				bytesTotal:evt.total,
				type:evt.type,
				timeStamp:evt.timeStamp
			};
			if(evt.type == "load"){
				// 100%
				o.percent = "100%",
				o.decimal = 1;
			}else{
				o.decimal = evt.loaded / evt.total;
				o.percent = Math.ceil((evt.loaded / evt.total)*100)+"%";
			}
			this.onProgress(o);
		}
	},

	createXhr: function(){
		
		//console.log("dojox.form.Uploader.HTML5.createXhr()");

		var xhr = new XMLHttpRequest();
		var timer;
        xhr.upload.addEventListener("progress", dojo.hitch(this, "_xhrProgress"), false);
        xhr.addEventListener("load", dojo.hitch(this, "_xhrProgress"), false);
        xhr.addEventListener("error", dojo.hitch(this, function(evt){
			this.onError(evt);
			clearInterval(timer);
		}), false);
        xhr.addEventListener("abort", dojo.hitch(this, function(evt){
			this.onAbort(evt);
			clearInterval(timer);
		}), false);
        xhr.onreadystatechange = dojo.hitch(this, function() {
			if (xhr.readyState === 4) {
				console.info("dojox.form.uploader.plugins.HTML5    COMPLETE")
				clearInterval(timer);
				//this.onComplete(dojo.eval(xhr.responseText));
				this.onComplete({});
			}
		});
        xhr.open("POST", this.getUrl());

		timer = setInterval(dojo.hitch(this, function(){
			try{
				if(typeof(xhr.statusText)){} // accessing this error throws an error. Awesomeness.
			}catch(e){
				//this.onError("Error uploading file."); // not always an error.
				clearInterval(timer);
			}
		}),250);

		return xhr;
	},

	_buildRequestBody : function(data, boundary) {
		var EOL  = "\r\n";
		var part = "";
		boundary = "--" + boundary;

		var filesInError = [];
		dojo.forEach(this.inputNode.files, function(f, i){
			var fieldName = this.name+"s[]";//+i;
			var fileName  = this.inputNode.files[i].fileName;
			var binary;

			try{
				binary = this.inputNode.files[i].getAsBinary() + EOL;
				part += boundary + EOL;
				part += 'Content-Disposition: form-data; ';
				part += 'name="' + fieldName + '"; ';
				part += 'filename="'+ fileName + '"' + EOL;
				part += "Content-Type: " + this.getMimeType() + EOL + EOL;
				part += binary;
			}catch(e){
				filesInError.push({index:i, name:fileName});
			}
		}, this);

		if(filesInError.length){
			if(filesInError.length >= this.inputNode.files.length){
				// all files were bad. Nothing to upload.
				this.onError({
					message:this.errMsg,
					filesInError:filesInError
				});
				part = false;
			}
		}

		if(!part) return false;

		if(data){
			for(var nm in data){
				part += boundary + EOL;
				part += 'Content-Disposition: form-data; ';
				part += 'name="' + nm + '"' + EOL + EOL;
				part += data[nm] + EOL;
			}
		}


		part += boundary + "--" + EOL;
		return part;
	}

});
dojox.form.addUploaderPlugin(dojox.form.uploader.plugins.HTML5);

}

if(!dojo._hasResource["plugins.form.Uploader"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.form.Uploader"] = true;
dojo.provide("plugins.form.Uploader");

// UPLOADER


//dojo.require("dojox.form.uploader.plugins.Flash");

//dojo.require("dojox.form.uploader.plugins.IFrame");

// LAYOUT





dojo.declare( "plugins.form.Uploader",
	[ dijit._Widget, dijit._Templated, plugins.core.Common ], {
//Path to the template of this widget. 
templateString:"<div dojoAttachPoint=\"containerNode\">\n\n<div id=\"attachPoint\" ></div>\n\n    <table\n        cellspacing=\"0px\"\n        height=\"300px\"\n        width=\"600px\"\n        style=\"padding: 0; margin: 0;\"\n\t\tclass=\"pageTable\"\n\t>\n        <tr>\n            <td align=\"center\">\n\t\t\t<td id=\"colForm\">\n                \n                <div\n                    dojoAttachPoint=\"dialog\"\n                    dojoType=\"dijit.Dialog\"\n                    closeText=\"true\"\n                    title=\"File Upload\"\n                    class=\"uploader\"\n\t\t\t\t\tdraggable=\"true\"\n                    style=\"margin-right: auto; margin-left: auto; text-align: center;\"\n\t\t\t\t>\n\n\t\t\t\t<form\n\t\t\t\t\tmethod=\"post\"\n\t\t\t\t\taction=\"../../../../../../cgi-bin/agua/upload.cgi\"\n\t\t\t\t\tenctype=\"multipart/form-data\" >\n\n\t\t\t\t\t<fieldset>\n\t\n\t\t\t\t\t\t<input\n\t\t\t\t\t\t\tdojoType=\"dojox.form.Uploader\"\n\t\t\t\t\t\t\tdojoAttachPoint=\"uploader\"\n\t\t\t\t\t\t\tclass=\"browseButton\"\n\t\t\t\t\t\t\tname=\"uploadedfile\"\n\t\t\t\t\t\t\tselectMultipleFiles=\"true\"\n\t\t\t\t\t\t\tmultiple=\"true\"\n\t\t\t\t\t\t\ttype=\"file\"\n\t\t\t\t\t\t\ttitle=\"Click to Select Files\"\n\t\t\t\t\t\t\tid=\"${uploaderId}\">\n\n<!--\t\t\t\t\t\t<div class=\"destination\">\n\t\t\t\t\t\t\tDestination\n\t\t\t\t\t\t\t<div dojoAttachPoint=\"destination\"></div>\n\t\t\t\t\t\t</div>\n\n-->\t\t\t\t\t\t<input\n\t\t\t\t\t\t\tdojoAttachPoint=\"path\"\n\t\t\t\t\t\t\ttype=\"hidden\"\n\t\t\t\t\t\t\tname=\"path\"\n\t\t\t\t\t\t\tvalue=\"\" />\n\t\t\t\t\t\t\n\t\t\t\t\t\t<input\n\t\t\t\t\t\t\ttype=\"hidden\"\n\t\t\t\t\t\t\tdojoAttachPoint=\"username\"\n\t\t\t\t\t\t\tname=\"username\"\n\t\t\t\t\t\t\tvalue=\"${username}\" />\n\t\t\t\t\t\t<input\n\t\t\t\t\t\t\ttype=\"hidden\"\n\t\t\t\t\t\t\tname=\"sessionid\"\n\t\t\t\t\t\t\tvalue=\"${sessionid}\" />\n\t\t\t\t\t\t<input\n\t\t\t\t\t\t\tdojoType=\"dijit.form.Button\"\n\t\t\t\t\t\t\tdojoAttachEvent=\"onClick:clear\"\n\t\t\t\t\t\t\tlabel=\"Clear\"\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t<input\n\t\t\t\t\t\t\ttype=\"submit\"\n\t\t\t\t\t\t\tlabel=\"Submit\"\n\t\t\t\t\t\t\tdojoType=\"dijit.form.Button\" />\n\t\t\t\t\t\t<div\n\t\t\t\t\t\t\tdojoType=\"dojox.form.uploader.FileList\"\n\t\t\t\t\t\t\tdojoAttachPoint=\"fileList\"\n\t\t\t\t\t\t\tuploaderId=\"${uploaderId}\">\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</fieldset>\n\t\t\t\t</form>\n\t\t\t\t\n\t\t\t</td>\n\t\t\t\n\t\t\t<td\n\t\t\t\tdojoAttachPoint=\"images\"\n\t\t\t>\n\t\t\t</td>\n\t\t</tr>\n\t</table>\n\n\n</div>\n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

// PARENT WIDGET
parentWidget : null,

// CSS FILES
cssFiles : [
	dojo.moduleUrl("plugins", "form/css/uploader.css"),
	dojo.moduleUrl("dojox", "form/resources/UploaderFileList.css"),
	dojo.moduleUrl("dijit", "themes/dijit.css"),
	//dojo.moduleUrl("dijit", "themes/claro/Common.css"),
	//dojo.moduleUrl("dijit", "themes/claro/form/Common.css"),
	//dojo.moduleUrl("dijit", "themes/claro/Dialog.css"),
	//dojo.moduleUrl("dijit", "themes/claro/form/Button.css"),
	//dojo.moduleUrl("dijit", "themes/claro/layout/TabContainer.css"),
	//dojo.moduleUrl("dijit", "themes/claro/Dialog.css"),
],

////}}}}
constructor : function(args) {
	console.log("Uploader.constructor    args: ");
	console.dir({args:args});

	// SET ARGS
	if ( args != null ) {
        this.url = args.url;
    	this.parentWidget = args.parentWidget;
    	this.username = args.username;
    	this.sessionid = args.sessionid;
    	this.path = args.path;
    }
	
	// LOAD CSS
	this.loadCSS(this.cssFiles);
},
postCreate: function() {
// RUN STARTUP
	console.log("Uploader.postCreate    plugins.form.Uploader.postCreate()");
	this.startup();
},
startup : function () {
	console.log("Uploader.startup    plugins.form.Uploader.startup()");

	// SET UP THE ELEMENT OBJECTS AND THEIR VALUE FUNCTIONS
	this.inherited(arguments);
    
    // SET UP UPLOADER
    this.setUploader();
},
clear : function () {
	console.log("Uploader.clear    this.fileList:");
	console.dir({fileList:this.fileList});
	this.fileList.reset();
},
setUploader : function () {
	console.log("Uploader.setUploader    plugins.form.Uploader.setUploader()");
	console.log("Uploader.setUploader    this.dialog: " + this.dialog);

	//this.dialog.show();
	this.handleUpload(this.uploader, this.images);

	console.log("Uploader.setUploader    this.dialog: " + this.dialog);

	var thisObject = this;
	
	dojo.connect(this.uploader, "onComplete", this, "onComplete");

    this.uploader.onComplete = function(/* Object */customEvent){
	// 		Fires when all files have uploaded
	// 		Event is an array of all files
        console.log("Uploader.onComplete    dojox.form.plugins.Uploader.onComplete(data)");
        console.log("Uploader.onComplete    customEvent: ");
		console.dir({customEvent:customEvent});
        thisObject.onComplete(customEvent);
    	//this.reset();
    }

	this.uploader.createXhr = function(){
		
		console.log("Uploader.setUploader    OVERRIDE plugins.dojox.form.Uploader.HTML5.createXhr()");

		var xhr = new XMLHttpRequest();
		var timer;
        xhr.upload.addEventListener("progress", dojo.hitch(this, "_xhrProgress"), false);
        xhr.addEventListener("load", dojo.hitch(this, "_xhrProgress"), false);
        xhr.addEventListener("error", dojo.hitch(this, function(evt){
			this.onError(evt);
			clearInterval(timer);
		}), false);
        xhr.addEventListener("abort", dojo.hitch(this, function(evt){
			this.onAbort(evt);
			clearInterval(timer);
		}), false);
        xhr.onreadystatechange = dojo.hitch(this, function() {
			if (xhr.readyState === 4) {
				console.info("plugins.dojox.form.uploader.plugins.HTML5    COMPLETE")
				clearInterval(timer);
				//this.onComplete(dojo.eval(xhr.responseText));
				this.onComplete({});
			}
		});
        xhr.open("POST", this.getUrl());

		timer = setInterval(dojo.hitch(this, function(){
			try{
				if(typeof(xhr.statusText)){} // accessing this error throws an error. Awesomeness.
			}catch(e){
				//this.onError("Error uploading file."); // not always an error.
				clearInterval(timer);
			}
		}),250);

		return xhr;
	};
},

handleUpload : function(upl, node){

	dojo.connect(upl, "onComplete", function(dataArray){

        console.log("Uploader.handleUpload    INSIDE dojo.connect");
		
		dojo.forEach(dataArray, function(file){
			console.log("display:", file)

			var div = dojo.create('div', {className:'thumb'});
			var span = dojo.create('span', {className:'thumbbk'}, div);
			var img = dojo.create('img', {src:file.file}, span);
			node.appendChild(div);
		});
	});
},
onComplete : function (customEvent) {
// 		Fires when all files have uploaded
// 		Event is an array of all files
    console.log("Uploader.onComplete    form.Uploader.onComplete(customEvent)");
    console.info("Uploader.onComplete    FILL ME IN");
},
fixInputNode : function () {

    var inputnode = this.uploader._inputs[0];
    console.log("Uploader.setInputNode     inputnode: " + inputnode);
    console.dir(inputnode);

    var style = dojo.attr(inputnode, 'style');
    console.log("Uploader.setInputNode     style: " + dojo.toJson(style));
    style += " left: 0px !important;";
    dojo.attr(inputnode, 'style',  style);    
},
setPath : function (value) {
	console.log("Uploader.setPath     plugins.form.Uploader.setPath(value)");
	console.log("Uploader.setPath     value: " + value);		
	if ( value == null )    return;
    this.path.value = value;
	this.dialog.set('title', "Upload to: " + value);
},
getPath : function () {
	return this.path.innerHTML;
},
show: function () {
// SHOW THE DIALOGUE
	this.dialog.show();
},
hide: function () {
// HIDE THE DIALOGUE
	this.dialog.hide();
}
});


}

if(!dojo._hasResource["dojo.io.iframe"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.io.iframe"] = true;
dojo.provide("dojo.io.iframe");

dojo.getObject("io", true, dojo);

/*=====
dojo.declare("dojo.io.iframe.__ioArgs", dojo.__IoArgs, {
	constructor: function(){
		//	summary:
		//		All the properties described in the dojo.__ioArgs type, apply
		//		to this type. The following additional properties are allowed
		//		for dojo.io.iframe.send():
		//	method: String?
		//		The HTTP method to use. "GET" or "POST" are the only supported
		//		values.  It will try to read the value from the form node's
		//		method, then try this argument. If neither one exists, then it
		//		defaults to POST.
		//	handleAs: String?
		//		Specifies what format the result data should be given to the
		//		load/handle callback. Valid values are: text, html, xml, json,
		//		javascript. IMPORTANT: For all values EXCEPT html and xml, The
		//		server response should be an HTML file with a textarea element.
		//		The response data should be inside the textarea element. Using an
		//		HTML document the only reliable, cross-browser way this
		//		transport can know when the response has loaded. For the html
		//		handleAs value, just return a normal HTML document.  NOTE: xml
		//		is now supported with this transport (as of 1.1+); a known issue
		//		is if the XML document in question is malformed, Internet Explorer
		//		will throw an uncatchable error.
		//	content: Object?
		//		If "form" is one of the other args properties, then the content
		//		object properties become hidden form form elements. For
		//		instance, a content object of {name1 : "value1"} is converted
		//		to a hidden form element with a name of "name1" and a value of
		//		"value1". If there is not a "form" property, then the content
		//		object is converted into a name=value&name=value string, by
		//		using dojo.objectToQuery().
		this.method = method;
		this.handleAs = handleAs;
		this.content = content;
	}
});
=====*/

dojo.io.iframe = {
	// summary:
	//		Sends an Ajax I/O call using and Iframe (for instance, to upload files)
	
	create: function(/*String*/fname, /*String*/onloadstr, /*String?*/uri){
		//	summary:
		//		Creates a hidden iframe in the page. Used mostly for IO
		//		transports.  You do not need to call this to start a
		//		dojo.io.iframe request. Just call send().
		//	fname: String
		//		The name of the iframe. Used for the name attribute on the
		//		iframe.
		//	onloadstr: String
		//		A string of JavaScript that will be executed when the content
		//		in the iframe loads.
		//	uri: String
		//		The value of the src attribute on the iframe element. If a
		//		value is not given, then dojo/resources/blank.html will be
		//		used.
		if(window[fname]){ return window[fname]; }
		if(window.frames[fname]){ return window.frames[fname]; }
		var cframe = null;
		var turi = uri;
		if(!turi){
			if(dojo.config["useXDomain"] && !dojo.config["dojoBlankHtmlUrl"]){
				console.warn("dojo.io.iframe.create: When using cross-domain Dojo builds,"
					+ " please save dojo/resources/blank.html to your domain and set djConfig.dojoBlankHtmlUrl"
					+ " to the path on your domain to blank.html");
			}
			turi = (dojo.config["dojoBlankHtmlUrl"]||dojo.moduleUrl("dojo", "resources/blank.html"));
		}
		var cframe = dojo.place(
			'<iframe id="'+fname+'" name="'+fname+'" src="'+turi+'" onload="'+onloadstr+
			'" style="position: absolute; left: 1px; top: 1px; height: 1px; width: 1px; visibility: hidden">',
		dojo.body());

		window[fname] = cframe;

		return cframe;
	},

	setSrc: function(/*DOMNode*/iframe, /*String*/src, /*Boolean*/replace){
		//summary:
		//		Sets the URL that is loaded in an IFrame. The replace parameter
		//		indicates whether location.replace() should be used when
		//		changing the location of the iframe.
		try{
			if(!replace){
				if(dojo.isWebKit){
					iframe.location = src;
				}else{
					frames[iframe.name].location = src;
				}
			}else{
				// Fun with DOM 0 incompatibilities!
				var idoc;
				if(dojo.isIE || dojo.isWebKit){
					idoc = iframe.contentWindow.document;
				}else{ //  if(d.isMozilla){
					idoc = iframe.contentWindow;
				}
	
				//For Safari (at least 2.0.3) and Opera, if the iframe
				//has just been created but it doesn't have content
				//yet, then iframe.document may be null. In that case,
				//use iframe.location and return.
				if(!idoc){
					iframe.location = src;
					return;
				}else{
					idoc.location.replace(src);
				}
			}
		}catch(e){
			console.log("dojo.io.iframe.setSrc: ", e);
		}
	},

	doc: function(/*DOMNode*/iframeNode){
		//summary: Returns the document object associated with the iframe DOM Node argument.
		var doc = iframeNode.contentDocument || // W3
			(
				(
					(iframeNode.name) && (iframeNode.document) &&
					(dojo.doc.getElementsByTagName("iframe")[iframeNode.name].contentWindow) &&
					(dojo.doc.getElementsByTagName("iframe")[iframeNode.name].contentWindow.document)
				)
			) ||  // IE
			(
				(iframeNode.name)&&(dojo.doc.frames[iframeNode.name])&&
				(dojo.doc.frames[iframeNode.name].document)
			) || null;
		return doc;
	},

	send: function(/*dojo.io.iframe.__ioArgs*/args){
		//summary:
		//		Function that sends the request to the server.
		//		This transport can only process one send() request at a time, so if send() is called
		//multiple times, it will queue up the calls and only process one at a time.
		if(!this["_frame"]){
			this._frame = this.create(this._iframeName, dojo._scopeName + ".io.iframe._iframeOnload();");
		}

		//Set up the deferred.
		var dfd = dojo._ioSetArgs(
			args,
			function(/*Deferred*/dfd){
				//summary: canceller function for dojo._ioSetArgs call.
				dfd.canceled = true;
				dfd.ioArgs._callNext();
			},
			function(/*Deferred*/dfd){
				//summary: okHandler function for dojo._ioSetArgs call.
				var value = null;
				try{
					var ioArgs = dfd.ioArgs;
					var dii = dojo.io.iframe;
					var ifd = dii.doc(dii._frame);
					var handleAs = ioArgs.handleAs;

					//Assign correct value based on handleAs value.
					value = ifd; //html
					if(handleAs != "html"){
						if(handleAs == "xml"){
							//	FF, Saf 3+ and Opera all seem to be fine with ifd being xml.  We have to
							//	do it manually for IE6-8.  Refs #6334.
							if(dojo.isIE < 9 || (dojo.isIE && dojo.isQuirks)){
								dojo.query("a", dii._frame.contentWindow.document.documentElement).orphan();
								var xmlText=(dii._frame.contentWindow.document).documentElement.innerText;
								xmlText=xmlText.replace(/>\s+</g, "><");
								xmlText=dojo.trim(xmlText);
								//Reusing some code in base dojo for handling XML content.  Simpler and keeps
								//Core from duplicating the effort needed to locate the XML Parser on IE.
								var fauxXhr = { responseText: xmlText };
								value = dojo._contentHandlers["xml"](fauxXhr); // DOMDocument
							}
						}else{
							value = ifd.getElementsByTagName("textarea")[0].value; //text
							if(handleAs == "json"){
								value = dojo.fromJson(value); //json
							}else if(handleAs == "javascript"){
								value = dojo.eval(value); //javascript
							}
						}
					}
				}catch(e){
					value = e;
				}finally{
					ioArgs._callNext();
				}
				return value;
			},
			function(/*Error*/error, /*Deferred*/dfd){
				//summary: errHandler function for dojo._ioSetArgs call.
				dfd.ioArgs._hasError = true;
				dfd.ioArgs._callNext();
				return error;
			}
		);

		//Set up a function that will fire the next iframe request. Make sure it only
		//happens once per deferred.
		dfd.ioArgs._callNext = function(){
			if(!this["_calledNext"]){
				this._calledNext = true;
				dojo.io.iframe._currentDfd = null;
				dojo.io.iframe._fireNextRequest();
			}
		};

		this._dfdQueue.push(dfd);
		this._fireNextRequest();
		
		//Add it the IO watch queue, to get things like timeout support.
		dojo._ioWatch(
			dfd,
			function(/*Deferred*/dfd){
				//validCheck
				return !dfd.ioArgs["_hasError"];
			},
			function(dfd){
				//ioCheck
				return (!!dfd.ioArgs["_finished"]);
			},
			function(dfd){
				//resHandle
				if(dfd.ioArgs._finished){
					dfd.callback(dfd);
				}else{
					dfd.errback(new Error("Invalid dojo.io.iframe request state"));
				}
			}
		);

		return dfd;
	},

	_currentDfd: null,
	_dfdQueue: [],
	_iframeName: dojo._scopeName + "IoIframe",

	_fireNextRequest: function(){
		//summary: Internal method used to fire the next request in the bind queue.
		try{
			if((this._currentDfd)||(this._dfdQueue.length == 0)){ return; }
			//Find next deferred, skip the canceled ones.
			do{
				var dfd = this._currentDfd = this._dfdQueue.shift();
			} while(dfd && dfd.canceled && this._dfdQueue.length);

			//If no more dfds, cancel.
			if(!dfd || dfd.canceled){
				this._currentDfd =  null;
				return;
			}

			var ioArgs = dfd.ioArgs;
			var args = ioArgs.args;

			ioArgs._contentToClean = [];
			var fn = dojo.byId(args["form"]);
			var content = args["content"] || {};
			if(fn){
				if(content){
					// if we have things in content, we need to add them to the form
					// before submission
					var pHandler = function(name, value) {
						dojo.create("input", {type: "hidden", name: name, value: value}, fn);
						ioArgs._contentToClean.push(name);
					};
					for(var x in content){
						var val = content[x];
						if(dojo.isArray(val) && val.length > 1){
							var i;
							for (i = 0; i < val.length; i++) {
								pHandler(x,val[i]);
							}
						}else{
							if(!fn[x]){
								pHandler(x,val);
							}else{
								fn[x].value = val;
							}
						}
					}
				}
				//IE requires going through getAttributeNode instead of just getAttribute in some form cases,
				//so use it for all.  See #2844
				var actnNode = fn.getAttributeNode("action");
				var mthdNode = fn.getAttributeNode("method");
				var trgtNode = fn.getAttributeNode("target");
				if(args["url"]){
					ioArgs._originalAction = actnNode ? actnNode.value : null;
					if(actnNode){
						actnNode.value = args.url;
					}else{
						fn.setAttribute("action",args.url);
					}
				}
				if(!mthdNode || !mthdNode.value){
					if(mthdNode){
						mthdNode.value= (args["method"]) ? args["method"] : "post";
					}else{
						fn.setAttribute("method", (args["method"]) ? args["method"] : "post");
					}
				}
				ioArgs._originalTarget = trgtNode ? trgtNode.value: null;
				if(trgtNode){
					trgtNode.value = this._iframeName;
				}else{
					fn.setAttribute("target", this._iframeName);
				}
				fn.target = this._iframeName;
				dojo._ioNotifyStart(dfd);
				fn.submit();
			}else{
				// otherwise we post a GET string by changing URL location for the
				// iframe
				var tmpUrl = args.url + (args.url.indexOf("?") > -1 ? "&" : "?") + ioArgs.query;
				dojo._ioNotifyStart(dfd);
				this.setSrc(this._frame, tmpUrl, true);
			}
		}catch(e){
			dfd.errback(e);
		}
	},

	_iframeOnload: function(){
		var dfd = this._currentDfd;
		if(!dfd){
			this._fireNextRequest();
			return;
		}

		var ioArgs = dfd.ioArgs;
		var args = ioArgs.args;
		var fNode = dojo.byId(args.form);
	
		if(fNode){
			// remove all the hidden content inputs
			var toClean = ioArgs._contentToClean;
			for(var i = 0; i < toClean.length; i++) {
				var key = toClean[i];
				//Need to cycle over all nodes since we may have added
				//an array value which means that more than one node could
				//have the same .name value.
				for(var j = 0; j < fNode.childNodes.length; j++){
					var chNode = fNode.childNodes[j];
					if(chNode.name == key){
						dojo.destroy(chNode);
						break;
					}
				}
			}

			// restore original action + target
			if(ioArgs["_originalAction"]){
				fNode.setAttribute("action", ioArgs._originalAction);
			}
			if(ioArgs["_originalTarget"]){
				fNode.setAttribute("target", ioArgs._originalTarget);
				fNode.target = ioArgs._originalTarget;
			}
		}

		ioArgs._finished = true;
	}
};

}

if(!dojo._hasResource["plugins.files.FileMenu"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.files.FileMenu"] = true;
dojo.provide("plugins.files.FileMenu");

// WIDGET PARSER


// INHERITS


// HAS A







dojo.declare("plugins.files.FileMenu",
	[ dijit._Widget, dijit._Templated, plugins.core.Common ], {
		
//Path to the template of this widget. 
templateString:"<div dojoAttachPoint=\"containerNode\">\n\n<div\n    dojoAttachPoint=\"menu\"\n    class=\"filemenu\"\n    dojoType=\"plugins.menu.Menu\"\n    title=\"List of options for file-specific actions\"\n>\n\n    <div dojoType=\"dijit.MenuItem\"\n        label=\"File Menu\"\n        dojoAttachPoint=\"titleNode\"\n        class=\"title\"\n        disabled=\"false\"\n    >\n    </div>\n\n    <div\n        dojoAttachPoint=\"selectNode\"\n        dojoType=\"dijit.MenuItem\"\n        dojoAttachEvent=\"onClick:select\"\n        class=\"select\"\n        disabled=\"true\"\n    >\n        <U>S</U>elect\n    </div>\n    <div\n        dojoAttachPoint=\"addNode\"\n        dojoType=\"dijit.MenuItem\"\n        dojoAttachEvent=\"onClick:add\"\n        class=\"add\"\n        disabled=\"true\"\n    >\n        <U>A</U>dd\n    </div>\n\n    <div\n        dojoAttachPoint=\"newFolderNode\"\n        dojoType=\"dijit.MenuItem\"\n        dojoAttachEvent=\"onClick:newFolder\"\n        class=\"newFolder\"\n        >\n        <U>N</U>ew Folder\n    </div>\n\n    <div\n        dojoAttachPoint=\"renameNode\"\n        dojoType=\"dijit.MenuItem\"\n        dojoAttachEvent=\"onClick:rename\"\n        class=\"rename\"\n        >\n        Rena<U>m</U>e\n\n    </div>\n\n<!--    <div dojoType=\"dijit.MenuSeparator\">\n    </div>\n-->\n    <div\n        dojoAttachPoint=\"deleteNode\"\n        dojoType=\"dijit.MenuItem\"\n        dojoAttachEvent=\"onClick:deleteFile\"\n        class=\"delete\"\n        >\n        De<U>l</U>ete\n    </div>\n\n<!--    <div dojoType=\"dijit.MenuSeparator\">\n    </div>\n-->\n    <div\n        dojoAttachPoint=\"openWorkflowNode\"\n        dojoType=\"dijit.MenuItem\"\n        dojoAttachEvent=\"onClick:openWorkflow\"\n        class=\"openWorkflow\"\n        >        \n        <U>O</U>pen Workflow\n    </div>\n\n\n<!--    <div dojoType=\"dijit.MenuSeparator\">\n    </div>\n-->\n    <div\n        dojoAttachPoint=\"uploadNode\"\n        dojoType=\"dijit.MenuItem\"\n        dojoAttachEvent=\"onClick:upload\"\n        class=\"upload\"\n        style=\"height: 20px !important;\"\n        widgetsInTemplate=\"true\"\n        >\n\n        <U>U</U>pload file\n        <!--<div class=\"fileInputMask\"></div>-->\n        \n    </div>\n\n<!--    <div dojoType=\"dijit.MenuSeparator\">\n    </div>\n-->\n    <div\n        dojoAttachPoint=\"downloadNode\"\n        dojoType=\"dijit.MenuItem\"\n        class=\"download\"\n        dojoAttachEvent=\"onClick:download\"    \n        >\n        Do<U>w</U>nload file\n    </div>\n\n\n\n</div>\n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

//addingApp STATE
addingApp : false,

// OR USE @import IN HTML TEMPLATE
cssFiles : [
	dojo.moduleUrl("plugins", "files/css/filemenu.css"),
	dojo.moduleUrl("dojox", "form/resources/FileInput.css")
],

// PARENT WIDGET
parentWidget : null,

// delay: Integer (thousandths of a second)
// Poll delay
delay : 6000,

/////}}
	
constructor : function(args) {
	//////console.log("FileMenu.constructor     plugins.files.FileMenu.constructor");			

	// GET INFO FROM ARGS
	this.parentWidget = args.parentWidget;

	// LOAD CSS
	this.loadCSS();		
},
postCreate : function() {
	//////console.log("Controller.postCreate    plugins.files.Controller.postCreate()");

	// SET INPUT DIALOG
	this.setInputDialog();

	// SET INTERACTIVE DIALOG
	this.setInteractiveDialog();

	// SET CONFIRM DIALOG
	this.setConfirmDialog();

	// SET LABEL
	this.setTitle("File Menu");

	// CONNECT SHORTKEYS FOR MENU
	this.setMenu();

	// DO INHERITED STARTUP
	this.startup();
},
startup : function () {
	console.group("FileMenu    " + this.id + "    startup");

	// COMPLETE CONSTRUCTION OF OBJECT
	this.inherited(arguments);	 

	// SET THE UPLOAD OBJECT
	this.setUploader();

	// DISABLE MENU ITEMS
	this.disableMenuItem('select');
	this.disableMenuItem('add');
	this.menu._started = false;
	this.menu.startup();

	// STOP PROPAGATION TO NORMAL RIGHTCLICK CONTEXT MENU
	dojo.connect(this.menu.domNode, "oncontextmenu", function (event) {
		event.stopPropagation();
	});

	// SUBSCRIBE TO UPDATES
	Agua.updater.subscribe(this, "updateProjects");
	Agua.updater.subscribe(this, "updateWorkflows");	

	console.groupEnd("FileMenu    " + this.id + "    startup");
},
updateProjects : function (args) {
// RELOAD RELEVANT DISPLAYS
	////console.log("workflow.Stages.updateProjects    workflow.Stages.updateProjects(args)");
	////console.log("workflow.Stages.updateProjects    args:");
	////console.dir(args);

	this.parentWidget.updateProjects();
},
updateClusters : function (args) {
// RELOAD RELEVANT DISPLAYS
	////console.log("admin.Clusters.updateClusters    admin.Clusters.updateClusters(args)");
	////console.log("admin.Clusters.updateClusters    args:");
	////console.dir(args);
	this.setClusterCombo();
},
// SELECT
select : function (event) {
// STORE SELECTED FILE OR FOLDER
    //console.log("FileMenu.select    plugins.files.FileSelectorMenu.select(event)");

    //console.log("FileMenu.select    event: " + event);
    //console.log("FileMenu.select    event.target: " + event.target);

    // GET PROJECT WIDGET
    var location = this.getPath();
    if ( ! location == null ) {
        //console.log("FileMenu.select     location is null. Returning");
        return;
    }
    var filename = this.menu.currentTarget.innerHTML;

    //console.log("FileMenu.select     filename: " + filename);
    //console.log("FileMenu.select     location: " + location);
    //console.log("FileMenu.select     this.type: " + this.type);
    
    var newValue;
    if ( filename != null && location != null )    newValue = location + "/" + filename;
    else if ( location != null )    newValue = location;
    else if ( filename != null )    newValue = filename;
    //console.log("FileMenu.select     newValue: " + newValue);

    var application = this.parameterWidget.core.parameters.application;
    application.value = newValue;
    //console.log("FileMenu.select     application: ");
    //console.dir({application:application});
    
    //console.log("FileMenu.select     Doing this.parameterWidget.changeValue()");
    this.parameterWidget.changeValue(this.parameterWidget.valueNode, this.parameterWidget.valueNode.innerHTML, newValue, this.type);

    //console.log("FileMenu.select     Doing this.parameterWidget.core.io.chainOutputs()");
    var force = true;
    this.parameterWidget.core.io.chainOutputs(application, true);
    var stageRow = this.parameterWidget.core.parameters.stageRow;
    var node = stageRow.domNode;
    node.application = stageRow.application;
    node.parentWidget = stageRow;
    this.parameterWidget.core.stages.loadParametersPane(node);


    this.hide();
},
// ADD
add : function () {
// ADD VALUE TO PARAMETER
    var location = this.getPath();
    if ( location == null ) {
        //console.log("FileMenu.add     location is null. Returning");
        return;
    }

    var filename = this.menu.currentTarget.innerHTML;
    //console.log("FileMenu.add     filename: " + filename);
    //console.log("FileMenu.add     location: " + location);
    //console.log("FileMenu.add     this.type: " + this.type);
    //console.log("FileMenu.add     this.parameterWidget.valueNode.innerHTML: " + this.parameterWidget.valueNode.innerHTML);

    var newValue;
    if ( filename != null && location != null )    newValue = location + "/" + filename;
    else if ( location != null )    newValue = location;
    else if ( filename != null )    newValue = filename;
    //console.log("FileMenu.add     newValue: " + newValue);

    this.parameterWidget.addValue(this.parameterWidget.valueNode,   this.parameterWidget.valueNode.innerHTML, newValue, this.type);

    this.hide();
},
// UPLOAD
upload : function (event) {
	//console.log("FileMenu.upload     this.menu.currentTarget: " + this.menu.currentTarget);
	//console.dir({currentTarget:this.menu.currentTarget});

	//console.log("FileMenu.upload     Doing dojo.stopEvent(event)");
	dojo.stopEvent(event);	

	// SET UPLOADER PATH AND SHOW
	var item = this.menu.currentTarget.item;
	//console.log("FileMenu.upload     item: ");
	//console.dir({item:item});
	var path = item.parentPath;
	//console.log("FileMenu.upload     path: " + path);
	if ( ! path )	return;
	this.uploader.setPath(path);
	this.uploader.show();

	// SET RELOAD CALLBACK
	var parentFolder = path.match('([^\/]+)$')[1];
	//console.log("parentFolder: " + parentFolder);
	
	var dragPane = dijit.getEnclosingWidget(this.menu.currentTarget.offsetParent);
	//console.log("fileMenu.upload    dragPane: " + dragPane);

	this.callback = dojo.hitch(this, "reloadPane", dragPane, parentFolder);
},
onComplete : function() {
	//console.log("fileMenu.onComplete    this.callback: " + this.callback);
    this.callback();
},
reloadPane : function(dragPane, folder) {
// USE FAKE event TO RELOAD DIRECTORY
	//console.log("fileMenu.reloadPane    dragPane: ");
	//console.dir({dragPane:dragPane});
	//console.log("fileMenu.reloadPane    folder: " + folder);
	
	// SET FAKE EVENT
	var fileDrag = dragPane.parentWidget;
	//console.log("fileMenu.reloadPane    fileDrag: ");
	//console.dir({fileDrag:fileDrag});

	var index = 0;
	var items = dragPane.items;
	for ( var i = 0; i < items.length; i++ ) {
		if ( items[i].name == folder ) {
			index = i;
			break;
		}
	}
	//console.log("fileMenu.reloadPane    index: " + index);
	var event = { target: { item: items[index] } };

	// RESET putData
	fileDrag.store.putData.query 	= 	dragPane.path;
	fileDrag.store.putData.mode		=	"fileSystem";
	
	dragPane.onclickHandler(event);
},
setUploader : function () {
	//console.log("FileMenu.setUploader     plugins.files.FileMenu.setUploader()");
	var uploaderId = dijit.getUniqueId("plugins.form.UploadDialog");
	var username = Agua.cookie('username');
	var sessionid = Agua.cookie('sessionid');
	this.uploader = new plugins.form.Uploader(
	{
		uploaderId	: uploaderId,
		username	: 	username,
		sessionid	: 	sessionid,
		url			:	Agua.cgiUrl + "upload.cgi"
	});
	
	// SET CONNECT
	dojo.connect(this.uploader, "onComplete", this, "onComplete");
},	//	setUploader
setMenu : function () {
// CONNECT SHORTKEYS FOR MENU
	//////console.log("FileMenu.setMenu     plugins.files.Workflow.setMenu()");

	this.disableRightClick();
	
	this.setShortKeys();
	
	this.menu.onCancel = function(event) {
		////console.log("FileMenu.setMenu     DOING this.menu.onCancel(event)");
	}
},
disableRightClick : function () {
	//// STOP PROPAGATION TO NORMAL RIGHTCLICK CONTEXT MENU
	dojo.connect(this.menu.domNode, "contextmenu", function (event)
	{
		////console.log("FileMenu.setMenu    quenching contextmenu");
		event.preventDefault();
		event.stopPropagation();
		return false;
	});
},
setShortKeys : function () {
	// NOTE: USE accelKey IN DOJO 1.3 ONWARDS
	dojo.connect(this.menu, "onKeyPress", dojo.hitch(this, function(event)
	{
		////console.log("FileMenu.setMenu     this.menu.onKeyPress(event)");
		var key = event.charOrCode;
		if ( this.altOn == true )
		{
			switch (key)
			{
				case "n" : this.newFolder(); break;
				case "m" : this.rename(); break;
				case "l" : this.deleteFile(); break;
				case "o" : this.openWorkflow(); break;
				case "u" : this.upload(); break;
				case "w" : this.download(); break;
			}
		}
		event.stopPropagation();
	}));

	// SET ALT KEY ON/OFF
	dojo.connect(this.menu, "onKeyDown", dojo.hitch(this, function(event){
		////console.log("FileMenu.setMenu     this.menu.onKeyDown(event)");
		var keycode = event.keyCode;
		if ( keycode == 18 )	this.altOn = true;
	}));
	dojo.connect(this.menu, "onKeyUp", dojo.hitch(this, function(event){
		////console.log("FileMenu.setMenu     this.menu.onKeyUp(event)");
		var keycode = event.keyCode;
		if ( keycode == 18 )	this.altOn = false;
	}));	
},
// OPEN WORKFLOW
openWorkflow : function () {
	//console.log("FileMenu.openWorkflow     plugins.files.FileMenu.openWorkflow()");

	// LABEL THIS AS SELECTED FILE
	dojo.addClass(this.menu.currentTarget, 'dojoDndItemOver');
	
	var item = this.menu.currentTarget.item;
	//console.log("FileMenu.openWorkflow     item: " + dojo.toJson(item));
	if ( ! item.parentPath.match(/^([^\/]+)\/([^\/]+)/) )	return;
	var project = item.parentPath.match(/^([^\/]+)\/[^\/]+/)[1];	
	var workflow = item.parentPath.match(/^[^\/]+\/([^\/]+)/)[1];	
	//console.log("FileMenu.openWorkflow     project: " + project);
	//console.log("FileMenu.openWorkflow     workflow: " + workflow);
	var workflowController = Agua.controllers["workflow"];
	//console.log("FileMenu.openWorkflow     workflowController: " + workflowController);
	if ( workflowController == null )	return;
	//console.log("FileMenu.openWorkflow     Doing workflowController.createTab({ project: " + project + ", workflow: " + workflow + "})");
	workflowController.createTab({ project: project, workflow: workflow });
},
// RENAME
rename : function () {
// RENAME FILE OR FOLDER
	// GET INPUTS
	var username		= this.getUserName();
	var dragPane  		= this.getDragPane();
	var dndItem 		= this.menu.currentTarget;
	var item 			= this.menu.currentTarget.item;
	var path 			= item.path;
	var oldFileName		= item.path;
	var parentPath 		= item.parentPath;
	var interactiveDialog = this.interactiveDialog;

	// SET TITLE AND MESSAGE
	var title = "Rename file '" + oldFileName + "'";
	var message = "Please enter new name";
	
	// CALLBACKS
	var cancelCallback = function () {};
	var enterCallback = dojo.hitch(this, function (newFileName)
		{
			// SANITY CHECK
			if ( newFileName == null )	return;
			newFileName = newFileName.replace(/\s+/, '');
			if ( newFileName == '' )	return;
			//console.log("FileMenu.rename    newFileName: " + newFileName);

			// CHECK IF NAME EXISTS ALREADY
			if ( dragPane.inItems(newFileName) ) {
				Agua.toastMessage({message: "FileName '" + newFileName + "' already exists " });
				interactiveDialog.dialog.duration = 1500;
				interactiveDialog.messageNode.innerHTML = "Workflow already exists";
				return;
			}

			// RENAME FILECACHE 
			//console.log("FileMenu.renameWorkflow    Doing Agua.renameFileTree()");
			var newFilePath 	= parentPath + "/" + newFileName;
			var oldFilePath 	= parentPath + "/" + path;
			Agua.renameFileTree(username, oldFilePath, newFilePath);

			// RENAME DND ITEM
			//console.log("FileMenu.renameWorkflow    Doing dragPane.renameItem(dndItem, newFileName))");
			dragPane.renameItem(dndItem, newFileName);

			// CHANGE FILE ON SERVER
			Agua.renameFile(oldFilePath, newFilePath);
		}
	);		

	// SHOW THE DIALOG
	this.loadInputDialog(title, message, enterCallback, cancelCallback);
},
// NEW FOLDER
newFolder : function () {
// CREATE A NEW FOLDER
	// GET INPUTS
	var username = this.getUserName();
	var dragPane = this.getDragPane();
	//console.log("FileMenu.newFolder    location: " + location);

	// SET TITLE AND MESSAGE
	var title = "New Folder";
	var message = "Please enter folder name";
	
	// CALLBACKS
	var cancelCallback = function (){};
	var enterCallback = dojo.hitch(this, function (newFolderName)
		{
			// SANITY CHECK
			if ( newFolderName == null )	return;
			newFolderName = newFolderName.replace(/\s+/, '');
			if ( newFolderName == '' )	return;

			// CHECK IF NAME EXISTS ALREADY
			if ( dragPane.inItems(newFolderName) ) {
				//console.log("FileMenu.newFolder    File '" + newFolderName + "' already exists. Returning");
				return;
			}

			// ADD ITEM TO DRAGPANE AND SET FILECACHE
			var location = dragPane.path + "/" + newFolderName;
			dragPane.addItem(newFolderName, "folder", username, location);

			// CREATE FOLDER ON SERVER	
			var url 		= 	Agua.cgiUrl + "folders.cgi?";
			var folderPath 	= 	dragPane.path + "/" + newFolderName;
			var query 		= 	new Object;
			query.mode		=	"newFolder";
			query.sessionid	=	Agua.cookie('sessionid');
			query.username	=	Agua.cookie('username');
			query.folderpath=	folderPath;
			
			var thisObject = this;
			dojo.xhrPut(
				{
					url			: 	url,
					putData		:	dojo.toJson(query),
					handleAs	: 	"json",
					sync		: 	false,
					handle		: 	function(response) {
						if ( response.error ) {
							Agua.error(response.error);
						}
						else if ( response.status ) {
							// status: initiated, ongoing, completed
							Agua.warning(response.status);
							var parentNode = thisObject.menu.currentTarget.parentNode;
							parentNode.removeChild(thisObject.menu.currentTarget);
						}
					}
				}
			);
		}
	);		

	// SHOW THE DIALOG
	this.loadInputDialog(title, message, enterCallback, cancelCallback);
},
// DELETE
deleteFile : function () {
	console.log("FileMenu.deleteFile     plugins.files.Workflow.deleteFile(event)");
	if ( this.menu.currentTarget == null )	return;

	// GET THE PROJECT WIDGET
	var filename = this.menu.currentTarget.item.name;
	////console.log("FileMenu.deleteFile     filename: " + filename);

	var isDirectory = this.menu.currentTarget.item.directory;
	////console.log("FileMenu.deleteFile     isDirectory: " + isDirectory);
	var type = "file";
	if ( isDirectory == true )	type = "folder";

	var dragPane = dijit.getEnclosingWidget(this.menu.currentTarget);
	//////console.log("FileMenu.newFolder     dragPane: " + dragPane);
	//console.log("FileMenu.deleteFile    Doing dragPane.standby.show()");
	dragPane.standby.show();

	// CALLBACKS
	var noCallback = function (){
		//console.log("FileMenu.deleteFile    noCallback()");
		//console.log("FileMenu.deleteFile    Doing dragPane.standby.hide()");
		dragPane.standby.hide();
	};
	var yesCallback = dojo.hitch(this, function ()
		{
			////console.log("FileMenu.newFolder    Doing enterCallback");
			//dragPane._dragSource.deleteSelectedNodes();

			var item = this.menu.currentTarget.item;
			var file = item.parentPath + "/" + item.path;
			
			var url = Agua.cgiUrl + "folders.cgi?";
			var putData 		= 	new Object;
			putData.mode		=	"removeFile";
			putData.sessionid	=	Agua.cookie('sessionid');
			putData.username	=	Agua.cookie('username');
			putData.file		=	file;
	
			var thisObject = this;
			dojo.xhrPut(
				{
					url			: 	url,
					putData		:	dojo.toJson(putData),
					handleAs	: 	"json",
					sync		: 	false,
					handle		: 	function(response) {
						if ( response.error ) {
							//console.log("FileMenu.deleteFile    xhrPut response. Doing dragPane.standby.hide()");
							dragPane.standby.hide();

							Agua.error(response.error);
						}
						else if ( response.status ) {
							thisObject.pollDelete(putData, dragPane);
						}
					}
				}
			);
		}
	);

	// SET TITLE AND MESSAGE
	var title = "Delete " + type + ":<br>" + filename;
	var message = "All its data will be destroyed";

	// SHOW THE DIALOG
	this.loadConfirmDialog(title, message, yesCallback, noCallback);
	
},	//	deleteFile
delayedPollDelete : function (putData, dragPane) {
	//console.log("FileMenu.delayedPollDelete    Doing this.sequence.go(commands, ...)");
	var delay = this.delay;
	var commands = [
		{ func: [this.showMessage, this, "FileMenu.delayedPollDelete"], pauseAfter: delay },
		{ func: [this.pollDelete, this, putData, dragPane ] } 
	];
	//console.log("FileMenu.delayedPollDelete    commands: ");
	//console.dir({commands:commands});
	
	this.sequence.go(commands, function(){ });	
},
pollDelete : function(putData, dragPane) {
// POLL SERVER UNTIL status == 'completed'
	//console.log("FileMenu.pollDelete    putData: ");
	//console.dir({putData:putData});
	//console.log("FileMenu.pollDelete    dragPane: ");
	//console.dir({dragPane:dragPane});
	
	putData.modifier = "status";
	var url = Agua.cgiUrl + "folders.cgi?";

	var thisObject = this;
	dojo.xhrPut({
		url			: 	url,
		handleAs	: 	"json-comment-optional",
		sync		: 	false,
		putData		:	dojo.toJson(putData),
		handle		: 	function (response) {
			//console.log("FileMenu.pollDelete    this.response: ");
			//console.dir({response:response});
			
			// status: initiated, ongoing, completed
			if ( response.status == 'completed' ) {
				thisObject.handleDelete(putData, dragPane, response);
			}
			else if ( response.error ) {
				thisObject.standby.hide();
			}
			else
				thisObject.delayedPollDelete(putData, dragPane);
		}
	});
},
handleDelete : function (putData, dragPane, response) {
	//console.log("FileMenu.handleDelete    putData: ");
	//console.dir({putData:putData});
	//console.log("FileMenu.handleDelete    dragPane: ");
	//console.dir({dragPane:dragPane});
	//console.log("FileMenu.handleDelete    response: ");
	//console.dir({response:response});

	// HIDE STANDBY
	dragPane.standby.hide();
	
	// DELETE EXISTING FILECACHE
	var location = putData.file;
	var folder = location.match(/^(.+?)\/[^\/]+$/)[1];
	//console.log("FileMenu.handleDelete    folder: " + folder);
	Agua.setFileCache(putData.username, location, null);
	Agua.setFileCache(putData.username, folder, null);

	// RELOAD DRAGPANE
	var path = dragPane.path;
	var folder = path.match(/([^\/]+)$/)[1];
	//console.log("FileMenu.handleDelete    folder: " + folder);
	var previousPane = dragPane.getPreviousPane();
	//console.log("FileMenu.handleDelete    previousPane: ");
	//console.dir({previousPane:previousPane});
	
	this.reloadPane(previousPane, folder);	
},
// DOWNLOAD
download : function () {
// DOWNLOAD FILE FROM FOLDER
	////console.log("FileMenu.download     plugins.files.Workflow.download()");

	var item = this.menu.currentTarget.item;
	////console.log("FileMenu.download     item: " + dojo.toJson(item));

	if ( ! item.parentPath.match(/^([^\/]+)\/([^\/]+)/) )	return;
	var project = item.parentPath.match(/^([^\/]+)\/[^\/]+/)[1];	
	var workflow = item.parentPath.match(/^[^\/]+\/([^\/]+)/)[1];	
	////console.log("FileMenu.download     project: " + project);
	////console.log("FileMenu.download     workflow: " + workflow);

	var filepath = item.parentPath;
	if ( item.path != null && item.path != '' )
		filepath += "/" + item.path;
	////console.log("FileMenu.download     filepath: " + filepath);
	
	var url = item._S.url;
	var owner;
	if ( url.match(/owner=([^&]+)/) )
	{
		owner = url.match(/owner=([^&]+)/)[1];	
	}
	////console.log("FileMenu.download     owner: " + owner);

	var query = "?mode=downloadFile";

	// SET requestor = THIS_USER IF core.parameters.shared IS TRUE
	if ( owner != null )
	{
		query += "&username=" + owner;
		query += "&requestor=" + Agua.cookie('username');
	}
	else
	{
		query += "&username=" + Agua.cookie('username');
	}

	query += "&sessionid=" + Agua.cookie('sessionid');
	query += "&filepath=" + filepath;
	////console.log("FileMenu.download     query: " + query);
	
	var downloadUrl = Agua.cgiUrl + "download.cgi";
	////////console.log("FileMenu.download     url: " + url);
	
	var args = {
		method: "GET",
		url: downloadUrl + query,
		handleAs: "json",
		timeout: 10000,
		load: this.handleDownload
	};
	////////console.log("FileMenu.download     args: ", args);

	// do an IFrame request to download the csv file.
	////console.log("FileMenu.download     Doing dojo.io.iframe.send(args))");
	var value = dojo.io.iframe.send(args);
	////console.log("FileMenu.download     value: " + dojo.toJson(value));

},
handleDownload : function (response, ioArgs) {
	////console.log("ParameterRow.handleDownload     plugins.workflow.ParameterRow.handleDownload(response, ioArgs)");
	////console.log("ParameterRow.handleDownload     response: " + dojo.toJson(response));
	////console.log("ParameterRow.handleDownload     response.message: " + response.message);

	if ( response.message == "ifd.getElementsByTagName(\"textarea\")[0] is undefined" )
	{
		Agua.toastMessage({
			message: "Download failed: File is not present",
			type: "error"
		});
	}	
},
openFileDownload : function (filepath) {
	////console.log("FileMenu.openFileDownload     plugins.files.FileMenu.openFileDownload(filepath)");
	////console.log("FileMenu.openFileDownload     filepath: " + filepath);
	
	var query = "?username=" + Agua.cookie('username');
	query += "&sessionid=" + Agua.cookie('sessionid');
	query += "&filepath=" + filepath;
	
	var url = Agua.cgiUrl + "download.cgi";	
	var args = {
		method: "GET",
		url: url + query,
		//content: {},
		handleAs: "html",
		timeout: 10000
		//load: dojo.hitch(this, "onDownloadComplete"),
		//error: dojo.hitch(this, "onDownloadError")
	};
	// do an IFrame request to download the csv file.
	////console.log("FileMenu.openFileDownload    Doing dojo.io.iframe.send(args))");
	dojo.io.iframe.send(args);
},
// UTILITIES
setConfirmDialog : function () {
	var yesCallback = function (){};
	var noCallback = function (){};
	var title = "Dialog title";
	var message = "Dialog message";
	
	this.confirmDialog = new plugins.dijit.ConfirmDialog(
		{
			title 				:	title,
			message 			:	message,
			parentWidget 		:	this,
			yesCallback 		:	yesCallback,
			noCallback 			:	noCallback
		}			
	);
},
loadConfirmDialog : function (title, message, yesCallback, noCallback) {
	////console.log("FileMenu.loadConfirmDialog    plugins.files.FileMenu.loadConfirmDialog()");
	////console.log("FileMenu.loadConfirmDialog    yesCallback.toString(): " + yesCallback.toString());
	////console.log("FileMenu.loadConfirmDialog    title: " + title);
	////console.log("FileMenu.loadConfirmDialog    message: " + message);
	////console.log("FileMenu.loadConfirmDialog    yesCallback: " + yesCallback);
	////console.log("FileMenu.loadConfirmDialog    noCallback: " + noCallback);

	this.confirmDialog.load(
		{
			title 				:	title,
			message 			:	message,
			yesCallback 		:	yesCallback,
			noCallback 			:	noCallback
		}			
	);
},
setInputDialog : function () {
	var enterCallback = function (){};
	var cancelCallback = function (){};
	var title = "";
	var message = "";
	
	this.inputDialog = new plugins.dijit.InputDialog(
		{
			title 				:	title,
			message 			:	message,
			inputMessage		:	"",
			parentWidget 		:	this,
			enterCallback 		:	enterCallback,
			cancelCallback 		:	cancelCallback
		}			
	);
},
loadInputDialog : function (title, message, enterCallback, cancelCallback) {
	////console.log("FileMenu.loadInputDialog    plugins.files.FileMenu.loadInputDialog()");
	////console.log("FileMenu.loadInputDialog    enterCallback.toString(): " + enterCallback.toString());
	////console.log("FileMenu.loadInputDialog    title: " + title);
	////console.log("FileMenu.loadInputDialog    message: " + message);
	////console.log("FileMenu.loadInputDialog    enterCallback: " + enterCallback);
	////console.log("FileMenu.loadInputDialog    cancelCallback: " + cancelCallback);

	this.inputDialog.load(
		{
			title 				:	title,
			message 			:	message,
			enterCallback 		:	enterCallback,
			cancelCallback 		:	cancelCallback
		}			
	);
},
setInteractiveDialog : function () {
	var enterCallback = function (){};
	var cancelCallback = function (){};
	var title = "";
	var message = "";
	
	////console.log("FileMenu.setInteractiveDialog    plugins.files.FileMenu.setInteractiveDialog()");
	this.interactiveDialog = new plugins.dijit.InteractiveDialog(
		{
			title 				:	title,
			message 			:	message,
			inputMessage 		:	"",
			parentWidget 		:	this,
			enterCallback 		:	enterCallback,
			cancelCallback 		:	cancelCallback
		}			
	);
	////console.log("FileMenu.setInteractiveDialog    this.interactiveDialog: " + this.interactiveDialog);
},
loadInteractiveDialog : function (title, message, enterCallback, cancelCallback, checkboxMessage) {
	////console.log("FileMenu.loadInteractiveDialog    plugins.files.FileMenu.loadInteractiveDialog()");
	////console.log("FileMenu.loadInteractiveDialog    enterCallback.toString(): " + enterCallback.toString());
	////console.log("FileMenu.loadInteractiveDialog    title: " + title);
	////console.log("FileMenu.loadInteractiveDialog    message: " + message);
	////console.log("FileMenu.loadInteractiveDialog    enterCallback: " + enterCallback);
	////console.log("FileMenu.loadInteractiveDialog    cancelCallback: " + cancelCallback);

	this.interactiveDialog.load(
		{
			title 				:	title,
			message 			:	message,
			checkboxMessage 	:	checkboxMessage,
			enterCallback 		:	enterCallback,
			cancelCallback 		:	cancelCallback
		}			
	);
},
bind : function (node) {
// BIND THE MENU TO A NODE
	////console.log("FileMenu.bind     plugins.files.FileMenu.bind(node)");
	if ( node == null )
		////console.log("FileMenu.bind     node is null. Returning...");

	return this.menu.bindDomNode(node);	
},
getPath : function () {
// RETURN THE FILE PATH OF THE FOCUSED GROUP DRAG PANE
	////console.log("FileMenu.getPath     plugins.files.FileMenu.getPath()");
	////console.log("FileMenu.setUploader     this.menu.currentTarget: " + this.menu.currentTarget);
	var groupDragPane = dijit.getEnclosingWidget(this.menu.currentTarget);
	////console.log("FileMenu.setUploader     groupDragPane: " + groupDragPane);

	if ( groupDragPane == null || ! groupDragPane )	return;
	////console.log("FileMenu.setUploader     Returning path: " + groupDragPane.path);

	return groupDragPane.path;
},
hide : function () {
	////console.log("FileMenu.hide    this.parentWidget: " + this.parentWidget);
	this.parentWidget.hide();
},
setTitle : function (title) {
// SET THE MENU TITLE
	//console.log("FileMenu.setTitle    title: " + title);
	this.titleNode.containerNode.innerHTML = title;
},
show : function () {
	////console.log("FileMenu.show    files.FileMenu.show()");
	
	//console.log("FileMenu.show    this.menu.currentTarget: " + this.menu.currentTarget);
	//console.dir({currentTarget:this.menu.currentTarget});
	dojo.addClass(this.menu.currentTarget, 'dojoDndItemOver');

	dojo.style(this.containerNode, {
		opacity: 1,
		overflow: "visible"
	});
},
disableMenuItem : function (name) {
	//console.log("FileMenu.disableMenuItem    name: " + name);

	if ( this[name + "Node"] )
		this[name + "Node"].disabled = true;
    var item = this[name + "Node"];
	dojo.addClass(item.domNode, "dijitMenuItemDisabled");
},
enableMenuItem : function (name) {
	//console.log("FileMenu.enableMenuItem    name: " + name);
	if ( this[name + "Node"] )
		this[name + "Node"].disabled = false;
    var item = this[name + "Node"];
	dojo.removeClass(item.domNode, "dijitMenuItemDisabled");
},
disable : function () {
	////console.log("FileMenu.disable    files.FileMenu.disable()");
	this.menu.enabled = false;
},
enable : function () {
	////console.log("FileMenu.enable    files.FileMenu.enable()");
	this.menu.enabled = true;
},
setShortKeys : function () {
	// NOTE: USE accelKey IN DOJO 1.3 ONWARDS
	dojo.connect(this.menu, "onKeyPress", dojo.hitch(this, function(event)
	{
		////console.log("FileMenu.setMenu     this.menu.onKeyPress(event)");
		var key = event.charOrCode;
		if ( this.altOn == true )
		{
			switch (key)
			{
				case "s" : this.select(); break;
				case "a" : this.add(); break;
				case "n" : this.newFolder(); break;
				case "m" : this.rename(); break;
				case "l" : this.deleteFile(); break;
				case "o" : this.openWorkflow(); break;
				case "u" : this.upload(); break;
				case "w" : this.download(); break;
				case "r" : this.refresh(); break;
			}
		}
		event.stopPropagation();
	}));

	// SET ALT KEY ON/OFF
	dojo.connect(this.menu, "onKeyDown", dojo.hitch(this, function(event){
		////console.log("FileMenu.setMenu     this.menu.onKeyDown(event)");
		var keycode = event.keyCode;
		if ( keycode == 18 )	this.altOn = true;
	}));
	dojo.connect(this.menu, "onKeyUp", dojo.hitch(this, function(event){
		////console.log("FileMenu.setMenu     this.menu.onKeyUp(event)");
		var keycode = event.keyCode;
		if ( keycode == 18 )	this.altOn = false;
	}));	
},
refresh : function (event) {
	//console.log("FileMenu.refresh    DO NOTHING");
},
// UTILITIES
getFilesWidget : function () {
// RETURN THE PROJECT TAB WIDGET CONTAINING THIS FILE DRAG OBJECT
	if ( this.menu.currentTarget == null )	return null;

	// GET THE PROJECT WIDGET
	var item = this.menu.currentTarget.item;
	var widget = dijit.getEnclosingWidget(this.menu.currentTarget);
	var filesWidget = widget.parentWidget.parentWidget;
	//console.log("WorkflowMenu.getFilesWidget     filesWidget: " + filesWidget);

	return filesWidget;
},
getProjectName : function () {
// RETURN THE PROJECT NAME FOR THIS FILE DRAG OBJECT
	
	// SANITY		
	if ( this.menu.currentTarget == null )	return null;

	// GET THE PROJECT WIDGET
	var item = this.menu.currentTarget.item;
	//////////console.log("WorkflowMenu.newFolder     this.menu.currentTarget: " + this.menu.currentTarget);
	//////////console.log("WorkflowMenu.newFolder     item: " + item);
	var widget = dijit.getEnclosingWidget(this.menu.currentTarget);
	var projectName = widget.path;

	return projectName;
},
getStandby : function () {
	//console.log("WorkflowMenu.getStandby    WorkflowMenu.getStandby()");
	
	if ( this.standby )	return this.standby;

	var id = dijit.getUniqueId("dojox_widget_Standby");
	this.standby = new dojox.widget.Standby (
		{
			onClick	: 	"reload",
			text	: 	"",
			id 		: 	id,
			url		: 	"plugins/core/images/agua-biwave-24.png"
		}
	);
	document.body.appendChild(this.standby.domNode);
	//console.log("WorkflowMenu.getStandby    this.standby: " + this.standby);

	return this.standby;
},
getFileDrag : function () {
	var dragPane = this.getDragPane();
	return dragPane.parentWidget;
},
getDragPane : function () {
	//console.log("WorkflowMenu.getDragPane     this.menu.currentTarget: " );
	//console.dir({this_menu_currentTarget:this.menu.currentTarget});

	return dijit.getEnclosingWidget(this.menu.currentTarget);
},
getUserName : function () {
	// GET USERNAME
	var fileDrag = this.getFileDrag();
	return fileDrag.owner;
},
selectTarget : function (args) {
	var dragPane = this.getDragPane();
	dragPane._dragSource._addItemClass(this.menu.currentTarget, "Selected");
},
deselectTarget : function (args) {
	var dragPane = this.getDragPane();
	dragPane._dragSource._removeItemClass(this.menu.currentTarget, "Selected");
}

}); // plugins.files.FileMenu

}

if(!dojo._hasResource["plugins.files.FolderMenu"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.files.FolderMenu"] = true;

dojo.provide("plugins.files.FolderMenu");

// WIDGET PARSER


// INHERITS


// HAS A


dojo.declare("plugins.files.FolderMenu",
	[ plugins.files.FileMenu ], {

	//Path to the template of this widget. 
templateString:"<div dojoAttachPoint=\"containerNode\">\n\n<div\n    dojoAttachPoint=\"menu\"\n    class=\"filemenu\"\n    dojoType=\"plugins.menu.Menu\"\n    title=\"List of options for folder-specific actions\"\n>\n\n    <div dojoType=\"dijit.MenuItem\"\n        label=\"Folder Menu\"\n        dojoAttachPoint=\"titleNode\"\n        class=\"title\"\n        disabled=\"false\"\n    >\n    </div>\n\n\n    <div\n        dojoAttachPoint=\"refreshNode\"\n        dojoType=\"dijit.MenuItem\"\n        class=\"refresh\"\n        dojoAttachEvent=\"onClick:refresh\"    \n        >\n        <U>R</U>efresh\n    </div>\n\n    <div\n        dojoAttachPoint=\"selectNode\"\n        dojoType=\"dijit.MenuItem\"\n        dojoAttachEvent=\"onClick:select\"\n        class=\"select\"\n        disabled=\"true\"\n    >\n        <U>S</U>elect\n    </div>\n    <div\n        dojoAttachPoint=\"addNode\"\n        dojoType=\"dijit.MenuItem\"\n        dojoAttachEvent=\"onClick:add\"\n        class=\"add\"\n        disabled=\"true\"\n    >\n        <U>A</U>dd\n    </div>\n\n    <div\n        dojoAttachPoint=\"newFolderNode\"\n        dojoType=\"dijit.MenuItem\"\n        dojoAttachEvent=\"onClick:newFolder\"\n        class=\"newFolder\"\n        >\n        <U>N</U>ew Folder\n    </div>\n\n    <div\n        dojoAttachPoint=\"renameNode\"\n        dojoType=\"dijit.MenuItem\"\n        dojoAttachEvent=\"onClick:rename\"\n        class=\"rename\"\n        >\n        Rena<U>m</U>e\n\n    </div>\n\n    <div\n        dojoAttachPoint=\"deleteNode\"\n        dojoType=\"dijit.MenuItem\"\n        dojoAttachEvent=\"onClick:deleteFile\"\n        class=\"delete\"\n        >\n        De<U>l</U>ete\n    </div>\n\n    <div\n        dojoAttachPoint=\"openWorkflowNode\"\n        dojoType=\"dijit.MenuItem\"\n        dojoAttachEvent=\"onClick:openWorkflow\"\n        class=\"openWorkflow\"\n        >        \n        <U>O</U>pen Workflow\n    </div>\n\n    <div\n        dojoAttachPoint=\"uploadNode\"\n        dojoType=\"dijit.MenuItem\"\n        dojoAttachEvent=\"onClick:upload\"\n        class=\"upload\"\n        style=\"height: 20px !important;\"\n        widgetsInTemplate=\"true\"\n        >\n        <U>U</U>pload file\n    </div>\n\n\n</div>\n",

/////}}}}}
constructor : function(args) {
	////////console.log("FolderMenu.constructor     plugins.files.FolderMenu.constructor");			
	// GET INFO FROM ARGS
	//this.parentWidget = args.parentWidget;

	// LOAD CSS
	this.loadCSS();		
},
postCreate : function() {
	////////console.log("FolderMenu.postCreate    plugins.files.FolderMenu.postCreate()");

	// DISABLE DOWNLOAD
	//this.downloadNode.destroy();
	
	// SET LABEL
	this.setTitle("Folder Menu");

	// SET INPUT DIALOG
	this.setInputDialog();

	// SET CONFIRM DIALOG
	this.setConfirmDialog();

	// CONNECT SHORTKEYS FOR MENU
	this.setMenu();

	// SET THE UPLOAD OBJECT
	this.setUploader();

	// DO STARTUP
	this.startup();
},
refresh : function (event) {
    var folder = this.menu.currentTarget.innerHTML;
	//console.log("FolderMenu.refresh    folder: " + folder);
	
	var dragPane = dijit.getEnclosingWidget(this.menu.currentTarget.offsetParent);
	//console.log("FolderMenu.refresh    dragPane: ");
	//console.dir({dragPane:dragPane});

	// GET LOCATION
	var location = dragPane.path + "/" + folder;
	//console.log("FolderMenu.refresh    location: " + location);

	// GET USERNAME
	var fileDrag = dragPane.parentWidget;
	//console.log("FolderMenu.refresh    fileDrag.store: ");
	//console.dir({fileDrag_store:fileDrag.store});
	var username = fileDrag.owner;
	//console.log("FolderMenu.refresh    username: " + username);	

	// RESET putData
	fileDrag.store.putData.mode		=	"fileSystem";
		
	// REMOVE EXISTING FILE CACHE
	//console.log("FolderMenu.refresh    Doing Agua.setFileCache(username, location, null)");
	Agua.setFileCache(username, location, null);
	
	//console.log("FolderMenu.refresh    Doing this.reloadPane(dragPane, folder)");	
	this.reloadPane(dragPane, folder);
}



}); // plugins.files.FolderMenu

}

if(!dojo._hasResource["plugins.dijit.SelectiveDialog"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.dijit.SelectiveDialog"] = true;
dojo.provide("plugins.dijit.SelectiveDialog");

/* CLASS SUMMARY: AN INTERACTIVE DIALOG WITH AN OPTIONAL COMBOBOX 
  
	AND OPTIONAL CHECKBOX.
  
	LIKE ITS INHERITED CLASS, InteractiveDialog, SelectiveDialog
	
	WAITS UNTIL THE enterCallback METHOD CLOSES IT, SO THE 
	
	enterCallback METHOD CAN VALIDATE THE INPUT AND CLOSE
	
	THE DIALOG WHEN THE CORRECT INPUT IS PRESENT.
	
*/

// HAS A



// INHERITS




dojo.declare( "plugins.dijit.SelectiveDialog",
	[ plugins.dijit.InteractiveDialog ], {
//Path to the template of this widget. 
templateString:"<div dojoAttachPoint=\"containerNode\">\n\n    <table\n        cellspacing=\"0px\"\n        height=\"300px\" width=\"100%\" style=\"padding: 0; margin: 0;\"\n        class=\"selectiveDialog\">\n        <tr>\n            <td align=\"center\">\n                \n<div\n    dojoAttachPoint=\"dialog\"\n    dojoType=\"dijit.Dialog\"\n    closeText=\"false\"\n    class=\"title\"\n    title=\"${title}\"\n    style=\"margin-right: auto; margin-left: auto; text-align: center;\"\n    >\n\n    <table\n        cellpadding=\"0\"\n        cellspacing=\"0\"\n        class=\"selectiveDialog\"\n        width=\"100%\"\n        >\n\n        <tr class=\"message\" align=\"center\">\n            <td\n                align=\"center\"\n                dojoAttachPoint=\"messageNode\"\n                colspan=\"2\">${message}</td>\n        </tr>\n\n        <tr width=\"100%\">\n            <td\n                width=\"100%\"\n                align=\"right\"\n                class=\"leftColumn\"\n                dojoAttachPoint=\"comboMessageNode\">\n            </td>\n            <td align=\"center\" width=\"100%\">\n                <select\n                    dojoAttachPoint=\"combo\"\n                    class=\"combo\"\n                    autocomplete=\"false\"\n                >\n                </select>\n            </td>\n        </tr>\n        \n        <tr align=\"center\" dojoAttachPoint=\"inputContainer\">\n            <td class=\"leftColumn\"\n                dojoAttachPoint=\"inputMessageNode\">\n            </td>\n            <td class=\"input\" align=\"center\">\n                <input\n                    type=\"text\"\n                    class=\"inputNode\"\n                    dojoAttachPoint=\"inputNode\"\n                value=\"\"></input>\n            </td>\n        </tr>\n        \n\n         <tr\n            dojoAttachPoint=\"checkboxContainer\"\n            class=\"hidden\">\n\n            <td colspan=\"2\">\n                <table>\n                    <tr>\n                        <td class=\"leftColumn\"\n                            dojoAttachPoint=\"checkboxMessageNode\"\n                            style=\"visibility: visible\">\n                        </td>\n                        <td class=\"rightColumn\">\n                            <input\n                                dojoAttachPoint=\"checkbox\"  \n                                style=\"visibility: visible\"\n                                type=\"checkbox\"\n                                class=\"checkbox\"\n                        >\n                        </td>\n                    </tr>\n                </table>\n            </td>\n        </tr>\n\n         <tr>\n            <td align=\"center\" class=\"enterButton\">\n                <button\n                    dojoAttachPoint=\"enterButton\"\n                    dojoType=\"dijit.form.Button\"\n                    type=\"button\"\n                    label=\"Enter\"\n                    dojoAttachEvent=\"onClick:doEnter\"\n                    >\n                </button>\n            </td>\n\n            <td align=\"center\" class=\"cancelButton\">\n                <div\n                    dojoAttachPoint=\"cancelButton\"\n                    dojoType=\"dijit.form.Button\"\n                    type=\"button\"\n                    label=\"Cancel\"\n                    dojoAttachEvent=\"onClick:doCancel\"\n                    >\n                </div>\n            </td>\n        </tr>\n    </table>\n</div>\n            \n            </td>\n        </tr>\n    </table>\n</div>\n",

// OR USE @import IN HTML TEMPLATE
cssFiles : [ dojo.moduleUrl("plugins.dijit") + "/css/selectivedialog.css" ],

//////}}
constructor : function(args) {
	////console.log("SelectiveDialog.constructor    plugins.dijit.SelectiveDialog.constructor()");

	//this.title 				=	args.title;
	//this.message 			=	args.message;
	//this.parentWidget 		=	args.parentWidget;
	//this.enterCallback 		=	args.enterCallback;
	//this.cancelCallback 	=	args.cancelCallback;
	
	// LOAD CSS
	this.loadCSS();
},
postCreate : function() {
	this.startup();
},
startup : function () {
	////console.log("SelectiveDialog.startup    plugins.dijit.SelectiveDialog.startup()");
	////console.log("SelectiveDialog.startup    this.parentWidget: " + this.parentWidget);

	this.inherited(arguments);

	// SHOW INPUT IF this.comboMessage IS DEFINED
	this.showComboMessage(this.comboMessage);

	// SET UP DIALOG
	this.setDialogue();
	
	// SET LISTENERS
	this.setListeners();
	
	// ADD CSS NAMESPACE CLASS FOR TITLE CSS STYLING
	this.setNamespaceClass("selectiveDialog");	
},
setListeners : function () {
	// DO LOGIN IF 'RETURN' KEY PRESSED WHILE IN PASSWORD INPUT
	var thisObject = this;
	dojo.connect(this.combo, "onkeypress", function(event) {
		var key = event.charOrCode;
		console.log("SelectiveDialog.set    this.combo onKeyPress FIRED");
		
		// STOP EVENT BUBBLING
		event.stopPropagation();   

		// LOGIN IF 'RETURN' KEY PRESSED
		if ( key == 13 )
		{
			thisObject.doEnter();
		}

		// QUIT LOGIN WINDOW IF 'ESCAPE' KEY IS PRESSED
		if (key == dojo.keys.ESCAPE)
		{
			// FADE OUT LOGIN WINDOW
			thisObject.doCancel();
		}
	});	
	
},
setCombo : function () {
	////console.log("SelectiveDialog.setCombo    plugins.dijit.SelectiveDialog.setCombo()");
	////console.log("SelectiveDialog.setCombo    this.comboValues: " + dojo.toJson(this.comboValues));
	////console.log("SelectiveDialog.setCombo    this.combo: " + this.combo);

	while ( this.combo.length )
	{
		this.combo.options[this.combo.length - 1] = null;
	}

	for ( var i = 0; i < this.comboValues.length; i++ )
	{
		var option = document.createElement("OPTION");
		option.text = this.comboValues[i];
		option.value = this.comboValues[i];
		this.combo.options.add(option);
	}
},
// SHOW CHECKBOX
showComboMessage : function (comboMessage) {
	////console.log("SelectiveDialog.showComboMessage    plugins.dijit.SelectiveDialog.showComboMessage(comboMessage)");
	////console.log("SelectiveDialog.showComboMessage    comboMessage: " + comboMessage);

	if ( comboMessage == null )
	{
		dojo.attr(this.combo.parentNode, 'colspan', 2);
		dojo.destroy(this.comboMessageNode);
	}
},
// LOAD THE DIALOGUE VALUES
load : function (args) {
	////console.log("SelectiveDialog.load    plugins.dijit.SelectiveDialog.load()");
	//////console.log("SelectiveDialog.load    args: " + dojo.toJson(args));

	this.title 				=	args.title || '';
	this.message 			=	args.message;
	this.comboValues 		=	args.comboValues;
	this.parentWidget 		=	args.parentWidget;
	this.enterCallback 		=	args.enterCallback;
	this.cancelCallback 	=	args.cancelCallback;

	// SET THE DIALOG
	this.dialog.titleNode.innerHTML	=	args.title;
	this.messageNode.innerHTML		=	args.message;
	this.inputMessageNode.innerHTML		=	args.inputMessage || '';
	this.comboMessageNode.innerHTML		=	args.comboMessage || '';
	this.checkboxMessageNode.innerHTML	=	args.checkboxMessage || '';
	this.dialog.enterCallback		=	args.enterCallback;
	this.dialog.cancelCallback		=	args.cancelCallback

	// SET CHECKBOX BOX IF CHECKBOX MESSAGE IS DEFINED
	this.showCheckbox(args.checkboxMessage);

	// SET ENTER BUTTON AND CANCEL BUTTON LABELS
	this.setEnterLabel(args.enterLabel);
	this.setCancelLabel(args.cancelLabel);

	// SET COMBO BOX
	this.setCombo();

	this.show();
},
doEnter : function(type) {
	////console.log("SelectiveDialog.doEnter    plugins.dijit.SelectiveDialog.doEnter()");	
	var input = '';
	if ( this.inputNode != null ) input = this.inputNode.value;

	var checked;
	if ( this.checkbox.checked == true ) checked = 1;
	else checked = 0;

	var selected = this.combo.value;

	// DO CALLBACK
	this.dialog.enterCallback(input, selected, checked, this);	
}
});

}

if(!dojo._hasResource["plugins.files.WorkflowMenu"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.files.WorkflowMenu"] = true;
dojo.provide("plugins.files.WorkflowMenu");

// WIDGET PARSER


// INHERITS


// HAS A



dojo.declare("plugins.files.WorkflowMenu",
	[ plugins.files.FileMenu ], {
	/////}}	
	
//Path to the template of this widget. 
templateString:"<div dojoAttachPoint=\"containerNode\">\n\n<div\n    dojoAttachPoint=\"menu\"\n    class=\"workflowmenu\"\n    dojoType=\"plugins.menu.Menu\">\n\n    <div dojoType=\"dijit.MenuItem\"\n        label=\"Workflow Menu\"\n        dojoAttachPoint=\"titleNode\"\n        class=\"title\"\n        disabled=\"false\">\n    </div>\n\n    <div\n        dojoAttachPoint=\"refreshNode\"\n        dojoType=\"dijit.MenuItem\"\n        class=\"refresh\"\n        dojoAttachEvent=\"onClick:refresh\"    \n        >\n        <U>R</U>efresh\n    </div>\n\n\n    <div\n        dojoAttachPoint=\"selectNode\"\n        dojoType=\"dijit.MenuItem\"\n        dojoAttachEvent=\"onClick:select\"\n        class=\"select\"\n        >\n        <U>S</U>elect\n    </div>\n    <div\n        dojoAttachPoint=\"addNode\"\n        dojoType=\"dijit.MenuItem\"\n        dojoAttachEvent=\"onClick:add\"\n        class=\"add\"\n        >\n        <U>A</U>dd\n    </div>\n\n    <div\n        dojoAttachPoint=\"newProjectNode\"\n        dojoType=\"dijit.MenuItem\"\n        dojoAttachEvent=\"onClick:newProject\"\n        class=\"newProject\"\n        >\n        New <U>P</U>roject\n    </div>\n\n    <div\n        dojoAttachPoint=\"newWorkflowNode\"\n        dojoType=\"dijit.MenuItem\"\n        dojoAttachEvent=\"onClick:newWorkflow\"\n        class=\"newWorkflow\"\n        >\n        New <U>W</U>orkflow\n    </div>\n\n    <div\n        dojoAttachPoint=\"copyWorkflowNode\"\n        dojoType=\"dijit.MenuItem\"\n        dojoAttachEvent=\"onClick:copyWorkflow\"\n        class=\"copyWorkflow\"\n        disabled=\"false\"\n        >\n        <U>C</U>opy Workflow\n    </div>\n\n    <div\n        dojoAttachPoint=\"renameWorkflowNode\"\n        dojoType=\"dijit.MenuItem\"\n        class=\"renameWorkflow\"\n        dojoAttachEvent=\"onClick:renameWorkflow\"    \n        >\n        <U>R</U>ename Workflow\n    </div>\n\n    <div\n        dojoAttachPoint=\"openWorkflowNode\"\n        dojoType=\"dijit.MenuItem\"\n        dojoAttachEvent=\"onClick:openWorkflow\"\n        class=\"openWorkflow\"\n        >\n        <U>O</U>pen Workflow\n    </div>\n\n    <div\n        dojoAttachPoint=\"deleteProjectNode\"\n        dojoType=\"dijit.MenuItem\"\n        dojoAttachEvent=\"onClick:deleteProject\"\n        class=\"deleteProject\"\n        >\n        <U>D</U>elete Project\n    </div>\n\n    <div\n        dojoAttachPoint=\"deleteWorkflowNode\"\n        dojoType=\"dijit.MenuItem\"\n        dojoAttachEvent=\"onClick:deleteWorkflow\"\n        class=\"deleteWorkflow\"\n        >\n        De<U>l</U>ete Workflow\n    </div>\n\n\n</div>\n",

// OR USE @import IN HTML TEMPLATE
cssFiles : [
	dojo.moduleUrl("plugins", "files/css/workflowmenu.css")
],

constructor : function() {
	// LOAD CSS
	this.loadCSS();		

},
postCreate : function() {
	// SET INPUT DIALOG
	this.setInputDialog();

	// SET INTERACTIVE DIALOG
	this.setInteractiveDialog();

	// SET CONFIRM DIALOG
	this.setConfirmDialog();

	// SET LABEL
	this.setTitle("Workflow Menu");

	// CONNECT SHORTKEYS FOR MENU
	this.setMenu();
	
	// DO STARTUP
	this.startup();
},
startup : function () {
	//////console.log("FileMenu.startup    plugins.files.FileMenu.startup()");

	// COMPLETE CONSTRUCTION OF OBJECT
	this.inherited(arguments);	 

	// CONNECT SHORTKEYS FOR MENU
	this.setMenu();	

	// DISABLE MENU ITEMS
	this.disableMenuItem('select');
	this.disableMenuItem('add');

	// CONNECT HIGHLIGHT TARGET WITH hide/dhow
	dojo.connect(this.menu, "_openMyself", this, "selectTarget");
	dojo.connect(this.menu, "_markInactive", this, "deselectTarget");

	// SET SELECTIVE DIALOG FOR copyWorkflow	
	this.setSelectiveDialog();

	// SUBSCRIBE TO UPDATES
	Agua.updater.subscribe(this, "updateProjects");
},
updateProjects : function (args) {
	//console.warn("WorkflowMenu.updateProjects    args:");
	//console.dir(args);

},
setTitle : function (title) {
// NO TITLE - DO NOTHING
},
setShortKeys : function () {
	// NOTE: USE accelKey IN DOJO 1.3 ONWARDS
	dojo.connect(this.menu, "onKeyPress", dojo.hitch(this, function(event)
	{
		////console.log("FileMenu.setMenu     this.menu.onKeyPress(event)");
		var key = event.charOrCode;
		if ( this.altOn == true )
		{
			switch (key)
			{
				case "s" : this.select(); break;
				case "a" : this.add(); break;
				case "p" : this.newProject(); break;
				case "w" : this.newWorkflow(); break;
				case "r" : this.renameWorkflow(); break;
				case "d" : this.deleteProject(); break;
				case "l" : this.deleteWorkflow(); break;
				case "o" : this.openWorkflow(); break;
				case "c" : this.copyWorkflow(); break;
			}
		}
		event.stopPropagation();
	}));

	// SET ALT KEY ON/OFF
	dojo.connect(this.menu, "onKeyDown", dojo.hitch(this, function(event){
		////console.log("FileMenu.setMenu     this.menu.onKeyDown(event)");
		var keycode = event.keyCode;
		if ( keycode == 18 )	this.altOn = true;
	}));
	dojo.connect(this.menu, "onKeyUp", dojo.hitch(this, function(event){
		////console.log("FileMenu.setMenu     this.menu.onKeyUp(event)");
		var keycode = event.keyCode;
		if ( keycode == 18 )	this.altOn = false;
	}));	
},
// MAIN METHODS
newProject : function () {
// ADD A NEW PROJECT USING A DIALOG BOX FOR PROJECT NAME INPUT
	// GET INPUTS
	var username = this.getUserName();
	var interactiveDialog = this.interactiveDialog;
	var filesWidget = this.getFilesWidget();
	//console.log("WorkflowMenu.newProject     filesWidget: " + filesWidget);
	//console.dir({filesWidget:filesWidget});
	
	// CALLBACKS
	var cancelCallback = function () {};
	var enterCallback = dojo.hitch(this, function (projectName)
		{
			// SANITY CHECK
			if ( projectName == null )	return;
			if ( projectName == '' )	return;
			projectName = projectName.replace(/\s+/g, '');
			//console.log("WorkflowMenu.newProject    projectName: " + projectName);
		
			// NEW PROJECT OBJECT
			var projectObject = new Object;
			projectObject.name = projectName;
			if ( Agua.isProject(projectName) == true )
			{
				//console.log("WorkflowMenu.newProject    project " + projectName + " already exists. Returning");
				interactiveDialog.messageNode.innerHTML = "Project already exists";
				return;
			}
			
			// ADD PROJECT FILEDRAG
			var directory = {
				username	:	username,
				owner		:	username,
				name		:	projectName,
				title		:	projectName
			};
			//console.log("WorkflowMenu.newProject    Doing filesWidget.addChild()");
			filesWidget.addChild(directory);
			
			// ADD PROJECT
			Agua.addProject(projectObject);
		}
	);		

	var title = "New Project";
	var message = "Please enter project name";
	//console.log("WorkflowMenu.newProject    plugins.files.WorkflowMenu.newProject()");
	this.loadInputDialog(title, message, enterCallback, cancelCallback);
},
newWorkflow : function () {
// ADD A NEW WORKFLOW USING A DIALOG BOX FOR WORKFLOW NAME INPUT

	// GET INPUTS
	var projectName = this.getProjectName();
	var interactiveDialog = this.interactiveDialog;
	var username = this.getUserName();
	var dragPane = this.getDragPane();
	
	// SET TITLE AND MESSAGE
	var title = "New Workflow";
	var message = "Please enter workflow name";
	
	// CALLBACKS
	var cancelCallback = function () {};

	// CALLBACK CALL FORMAT:
	// this.dialog.enterCallback(input, checked);	
	var enterCallback = dojo.hitch(this, function (workflowName, undefined ) {
		// SANITY CHECK
		workflowName = workflowName.replace(/\s+/, '');
		if ( ! workflowName )	return;
		// QUIT IF WORKFLOW EXISTS ALREADY
		if ( Agua.isWorkflow({ project: projectName, name: workflowName }) == true )
		{
			//console.log("WorkflowMenu.newWorkflow    Workflow '" + workflowName + "' already exists in project " + projectName + ". Sending message to dialog.");
			interactiveDialog.messageNode.innerHTML = "Workflow already exists";
			return;
		}
		else {
			interactiveDialog.messageNode.innerHTML = "Creating workflow";
			interactiveDialog.close();
		}
		
		// ADD WORKFLOW
		var location = dragPane.path + "/" + workflowName;
		//console.log("WorkflowMenu.newWorkflow    location: " + location);
		Agua.addWorkflow({ project: projectName, name: workflowName });

		// ADD ITEM TO DRAGPANE
		dragPane.addItem(workflowName, "workflow", username, location);
	});

	// SHOW THE DIALOG
	this.loadInteractiveDialog(title, message, enterCallback, cancelCallback);
},
copyWorkflow : function () {
// DISPLAY A 'Copy Workflow' DIALOG THAT ALLOWS THE USER TO SELECT 
// THE DESTINATION PROJECT AND THE NAME OF THE NEW WORKFLOW

	////console.log("WorkflowMenu.copyWorkflow    plugins.files.WorkflowMenu.copyWorkflow()");
	////console.log("WorkflowMenu.copyWorkflow    this.selectiveDialog: " + this.selectiveDialog);

	var item = this.menu.currentTarget.item;
	//////console.log("WorkflowMenu.copyWorkflow     item: " + dojo.toJson(item));
	var sourceProject = item.parentPath;	
	var sourceWorkflow = item.path;	
	////console.log("WorkflowMenu.copyWorkflow     sourceProject: " + sourceProject);
	////console.log("WorkflowMenu.copyWorkflow     sourceWorkflow: " + sourceWorkflow);

	// SET CALLBACKS
	var cancelCallback = function (){
		////console.log("WorkflowMenu.copyWorkflow    cancelCallback()");
	};
	var thisObject = this;
	
	var enterCallback = dojo.hitch(this, function (targetProject, targetWorkflow, copyFiles, dialogWidget)
		{
			////console.log("WorkflowMenu.copyWorkflow    Doing enterCallback(targetWorkflow, targetProject, copyfiles, dialogWidget)");
			////console.log("WorkflowMenu.copyWorkflow    targetWorkflow: " + targetWorkflow);
			////console.log("WorkflowMenu.copyWorkflow    targetProject: " + targetProject);
			////console.log("WorkflowMenu.copyWorkflow    copyFiles: " + copyFiles);
			////console.log("WorkflowMenu.copyWorkflow    dialogWidget: " + dialogWidget);
			
			// SET BUTTON LABELS
			var enterLabel = "Copy";
			var cancelLabel = "Cancel";
			
			// SANITY CHECK
			if ( targetWorkflow == null || targetWorkflow == '' )	return;
			targetWorkflow = targetWorkflow.replace(/\s+/, '');
			////console.log("WorkflowMenu.copyWorkflow    targetWorkflow: " + targetWorkflow);

			// QUIT IF WORKFLOW IS EMPTY
			if ( targetWorkflow == null || targetWorkflow == '' )
			{
				dialogWidget.messageNode.innerHTML = "Please input name of new Workflow";
				return;
			}

			// QUIT IF WORKFLOW EXISTS ALREADY
			if ( Agua.isWorkflow({ project: targetProject, name: targetWorkflow }) == true )
			{
				////console.log("WorkflowMenu.copyWorkflow    Workflow '" + targetWorkflow + "' already exists in project " + targetProject + ". Sending message to dialog.");
				
				dialogWidget.messageNode.innerHTML = "/" + targetWorkflow + "' already exists in '" + targetProject + "'";
				return;
			}
			else {
				////console.log("WorkflowMenu.copyWorkflow    Workflow '" + targetWorkflow + "' is unique in project " + targetProject + ". Adding workflow.");

				dialogWidget.messageNode.innerHTML = "Creating workflow";
				dialogWidget.close();
			}
			
			thisObject._copyWorkflow(sourceProject, sourceWorkflow, targetWorkflow, targetProject, copyFiles);
		}
	);		

	// SHOW THE DIALOG
	this.selectiveDialog.load(
		{
			title 				:	"Copy Workflow",
			message 			:	"Source: '" + sourceProject + ":" + sourceWorkflow + "'",
			comboValues 		:	Agua.getProjectNames(),
			inputMessage 		:	"Workflow name",
			comboMessage 		:	"Project",
			checkboxMessage		:	"Copy files",
			parentWidget 		:	this,
			enterCallback 		:	enterCallback,
			cancelCallback 		:	cancelCallback,
			enterLabel			:	"Copy",
			cancelLabel			:	"Cancel"
		}			
	);

},
_copyWorkflow : function (sourceProject, sourceWorkflow, targetProject, targetWorkflow, copyFiles) {
	////console.log("WorkflowMenu._copyWorkflow    WorkflowMenu._copyWorkflow(sourceProject, sourceWorkflow, targetProject, targetWorkflow, copyFiles)");
	
	var username = Agua.cookie('username');
	// ADD PROJECT
	Agua.copyWorkflow(username, sourceProject, sourceWorkflow, username, targetProject, targetWorkflow, copyFiles);
},
renameWorkflow : function () {
	// GET PROJECT WIDGET		
	var filesWidget = this.getFilesWidget();
	if ( filesWidget == null )	return;
	//console.log("WorkflowMenu.renameWorkflow     filesWidget: " + filesWidget);

	// GET DRAGPANE
	var dragPane = this.getDragPane();
	//console.log("WorkflowMenu.renameWorkflow     dragPane: ");
	//console.dir({dragPane:dragPane});
	
	// GET USERNAME
	var username = this.getUserName();
	
	// GET DND ITEM		
	var dndItem = this.menu.currentTarget;
	//console.log("WorkflowMenu.deleteWorkflow    dndItem: ");
	//console.dir({dndItem:dndItem});

	// SET WORKFLOW OBJECT
	var projectName = this.getProjectName();
	var oldWorkflowName = this.getWorkflowName();
	var workflowNumber = this.getWorkflowNumber();
	var workflowObject 		= new Object;
	workflowObject.project 	= projectName;
	workflowObject.name 	= oldWorkflowName;
	workflowObject.number	= workflowNumber;
	//console.log("WorkflowMenu.deleteWorkflow     workflowObject: ");
	//console.dir({workflowObject:workflowObject});

	// SET TITLE AND MESSAGE
	var title = "Rename workflow '" + oldWorkflowName + "'";
	var message = "Please enter new name";
	
	// CALLBACKS
	var cancelCallback = function () {};
	var enterCallback = dojo.hitch(this, function (newWorkflowName)
		{
			if ( newWorkflowName == null )	return;
			newWorkflowName = newWorkflowName.replace(/\s+/, '');
			if ( newWorkflowName == '' )	return;

			// CHECK IF NAME EXISTS ALREADY
			if ( Agua.isWorkflow({
				project: projectName,
				name: newWorkflowName })
			) {
				//console.log("WorkflowMenu.renameWorkflow    Workflow '" + newWorkflowName + "' already exists. Returning");
				return;
			}
			
			// RENAME FILECACHE 
			//console.log("WorkflowMenu.renameWorkflow    Doing Agua.renameFileTree()");
			var oldLocation = projectName + "/" + oldWorkflowName;
			var newLocation = projectName + "/" + newWorkflowName;
			Agua.renameFileTree(username, oldLocation, newLocation);

			// RENAME DND ITEM
			dragPane.renameItem(dndItem, newWorkflowName);
	
			// RENAME WORKFLOW (AND STAGES, STAGEPARAMETERS, ETC.)
			//console.log("WorkflowMenu.renameWorkflow    Doing Agua.renameWorkflow()");
            Agua.renameWorkflow(workflowObject, newWorkflowName);

			// RELOAD RELEVANT DISPLAYS
			Agua.updater.update("updateProjects", {originator: this.parentWidget, reload: false});
		}
	);		

	// SHOW THE DIALOG
	this.loadInputDialog(title, message, enterCallback, cancelCallback);	
},
openWorkflow : function () {
	//console.log("WorkflowMenu.openWorkflow    plugins.files.WorkflowMenu.openWorkflow()");

	// LABEL THIS AS SELECTED WORKFLOW
	dojo.addClass(this.menu.currentTarget, 'dojoDndItemOver');

	// GET PROJECT WIDGET		
	var filesWidget = this.getFilesWidget();
	if ( filesWidget == null )	return;
	//console.log("WorkflowMenu.openWorkflow     filesWidget: " + filesWidget);

	var projectName = this.getProjectName();
	//console.log("WorkflowMenu.openWorkflow     projectName: " + projectName);

	var workflowName = this.getWorkflowName();
	//console.log("WorkflowMenu.openWorkflow     workflowName: " + workflowName);

	// CHECK IF WORKFLOW CONTROLLER IS LOADED
	var workflowController = Agua.controllers["workflow"];
	//console.log("WorkflowMenu.openWorkflow    workflowController: " + workflowController);

	// OPEN WORKFLOW TAB
	if ( Agua.controllers["workflow"] ) 
		Agua.controllers["workflow"].createTab({project: projectName, workflow: workflowName});
},
deleteWorkflow : function () {
// DELETE A WORKFLOW AFTER DIALOG BOX CONFIRMATION BY USER

	// SET WORKFLOW OBJECT
	var projectName = this.getProjectName();
	var workflowName = this.getWorkflowName();
	var workflowNumber = this.getWorkflowNumber();
	var workflowObject 		= new Object;
	workflowObject.project 	= projectName;
	workflowObject.name 	= workflowName;
	workflowObject.number	= workflowNumber;
	//console.log("WorkflowMenu.deleteWorkflow     workflowObject: ");
	//console.dir({workflowObject:workflowObject});
	
	// CALLBACKS
	var noCallback = function () { };
	var yesCallback = dojo.hitch(this, function () {

		// QUIT IF WORKFLOW DOES NOT EXIST
		if ( Agua.isWorkflow({ project: projectName, name: workflowName }) == false ) {
			//console.log("WorkflowMenu.deleteWorkflow    workflow " + workflowName + " does not exist. Returning");
			return;
		}

		// GET DND ITEM		
		var dndItem = this.menu.currentTarget;
		//console.log("WorkflowMenu.deleteWorkflow    dndItem: ");
		//console.dir({dndItem:dndItem});

		// REMOVE FILECACHES FOR FILE/FOLDER
		this.removeItemFileCache(dndItem);

		// REMOVE DND ITEM FROM DRAGPANE
		var dragPane = dijit.getEnclosingWidget(this.menu.currentTarget);
		//console.log("WorkflowMenu.deleteWorkflow     dragPane: " + dragPane);
		//console.dir({dragPane:dragPane});
		dragPane.deleteItem(dndItem);
		
		// REMOVE WORKFLOW
		Agua.removeWorkflow(workflowObject);
	});		

	// SET TITLE AND MESSAGE
	var title = "Delete workflow '" + workflowName + "'?";
	var message = "All files and data will be destroyed";

	// SHOW THE DIALOG
	this.loadConfirmDialog(title, message, yesCallback, noCallback);
},
removeItemFileCache : function (dndItem) {
	var location = dndItem.item.parentPath + "/" + dndItem.item.path;
	var username = this.getUserName();
	//console.log("WorkflowMenu.removeItemFileCache     location: " + location);
	//console.log("WorkflowMenu.removeItemFileCache     username: " + username);
	Agua.removeFileTree(username, location);	
},
deleteProject : function () {
// DELETE A PROJECT AFTER DIALOG BOX CONFIRMATION BY USER
	// GET PROJECT WIDGET		
	var filesWidget = this.getFilesWidget();
	//console.log("WorkflowMenu.deleteProject     filesWidget: " );
	//console.dir({filesWidget:filesWidget});

	var fileDrag = this.getFileDrag();
	//console.log("WorkflowMenu.deleteProject     fileDrag: " );
	//console.dir({fileDrag:fileDrag});

	if ( filesWidget == null )	return;
	////////console.log("WorkflowMenu.deleteProject     filesWidget: " + filesWidget);

	var projectName = this.getProjectName();
	////////console.log("WorkflowMenu.deleteProject     projectName: " + projectName);

	// CALLBACKS
	var noCallback = function (){
		////////console.log("WorkflowMenu.deleteProject    noCallback()");
	};
	var yesCallback = dojo.hitch(this, function ()
		{
			// SANITY CHECK
			if ( ! Agua.isProject(projectName) ) {
				return;
			}

			// REMOVE PROJECT
			Agua.removeProject({ name: projectName });
			
			// RELOAD THE PROJECTS TAB
			setTimeout(function(thisObj) {
				//console.log("WorkflowMenu.deleteProject    Doing filesWidget.removeChild()");
				filesWidget.removeChild(fileDrag);
			}, 1000, this);
		}
	);		

	// SET TITLE AND MESSAGE
	var title = "Delete project '" + projectName + "'?";
	var message = "All workflows and data will be destroyed";

	// SHOW THE DIALOG
	this.loadConfirmDialog(title, message, yesCallback, noCallback);
	
},
refresh : function (event) {
    var folder = this.menu.currentTarget.innerHTML;
	//console.log("WorkflowMenu.refresh    folder: " + folder);
	
	var dragPane = dijit.getEnclosingWidget(this.menu.currentTarget.offsetParent);
	//console.log("WorkflowMenu.refresh    dragPane: ");
	//console.dir({dragPane:dragPane});

	// GET LOCATION
	var location = dragPane.path + "/" + folder;
	//console.log("WorkflowMenu.refresh    location: " + location);

	// GET USERNAME
	var fileDrag = dragPane.parentWidget;
	//console.log("WorkflowMenu.refresh    fileDrag.store: ");
	//console.dir({fileDrag_store:fileDrag.store});
	var username = fileDrag.owner;
	//console.log("WorkflowMenu.refresh    username: " + username);	

	// RESET putData
	fileDrag.store.putData.mode		=	"fileSystem";
		
	// REMOVE EXISTING FILE CACHE
	//console.log("WorkflowMenu.refresh    Doing Agua.setFileCache(username, location, null)");
	Agua.setFileCache(username, location, null);
	
	//console.log("WorkflowMenu.refresh    Doing this.reloadPane(dragPane, folder)");	
	this.reloadPane(dragPane, folder);
},
// UTILITIES
getWorkflowName : function () {
// RETURN THE WORKFLOW NAME FOR THIS GROUP DRAG PANE OBJECT
	var item = this.menu.currentTarget.item;
	var workflowName = item.path;
	workflowName = workflowName.replace(/\s+/g, '');
	//////////console.log("WorkflowMenu.getWorkflowName     workflowName: " + workflowName);

	return workflowName;
},
getWorkflowNumber : function () {
// RETURN THE WORKFLOW Number FOR THIS GROUP DRAG PANE OBJECT
	var workflowName = this.menu.currentTarget.item.path;
	var dragPane = this.getDragPane();
	for ( var i = 0; i < dragPane.items.length; i++ ) {
		if ( dragPane.items[i].name == workflowName ) {
			return (i + 1);
		}
	}

	return null;
},
setSelectiveDialog : function () {
	var enterCallback = function (){};
	var cancelCallback = function (){};
	var title = "";
	var message = "";
	
	//////console.log("WorkflowMenu.setSelectiveDialog    plugins.files.Stages.setSelectiveDialog()");
	this.selectiveDialog = new plugins.dijit.SelectiveDialog(
		{
			title 				:	title,
			message 			:	message,
			inputMessage 		:	"",
			checkboxMessage 	:	"",
			parentWidget 		:	this,
			enterCallback 		:	enterCallback,
			cancelCallback 		:	cancelCallback
		}			
	);
	//////console.log("WorkflowMenu.setSelectiveDialog    this.selectiveDialog: " + this.selectiveDialog);
},
loadSelectiveDialog : function (title, message, comboValues, inputMessage, comboMessage, checkboxMessage, enterCallback, cancelCallback) {
	//////console.log("WorkflowMenu.loadSelectiveDialog    enterCallback.toString(): " + enterCallback.toString());
	//////console.log("WorkflowMenu.loadSelectiveDialog    title: " + title);
	//////console.log("WorkflowMenu.loadSelectiveDialog    message: " + message);
	//////console.log("WorkflowMenu.loadSelectiveDialog    enterCallback: " + enterCallback);
	//////console.log("WorkflowMenu.loadSelectiveDialog    cancelCallback: " + cancelCallback);

	this.selectiveDialog.load(
		{
			title 				:	title,
			message 			:	message,
			comboValues 		:	comboValues,
			inputMessage 		:	inputMessage,
			comboMessage 		:	comboMessage,
			checkboxMessage		:	checkboxMessage,
			parentWidget 		:	this,
			enterCallback 		:	enterCallback,
			cancelCallback 		:	cancelCallback
		}			
	);
},
getStandby : function () {
	//console.log("WorkflowMenu.getStandby    WorkflowMenu.getStandby()");
	
	if ( this.standby )	return this.standby;

	var id = dijit.getUniqueId("dojox_widget_Standby");
	this.standby = new dojox.widget.Standby (
		{
			onClick	: 	"reload",
			text	: 	"",
			id 		: 	id,
			url		: 	"plugins/core/images/agua-biwave-24.png"
		}
	);
	document.body.appendChild(this.standby.domNode);
	//console.log("WorkflowMenu.getStandby    this.standby: " + this.standby);

	return this.standby;
},
getFileDrag : function () {
	var dragPane = this.getDragPane();
	return dragPane.parentWidget;
},
getDragPane : function () {
	//console.log("WorkflowMenu.getDragPane     this.menu.currentTarget: " );
	//console.dir({this_menu_currentTarget:this.menu.currentTarget});

	return dijit.getEnclosingWidget(this.menu.currentTarget);
},
getUserName : function () {
	// GET USERNAME
	var fileDrag = this.getFileDrag();
	return fileDrag.owner;
},
selectTarget : function (args) {
	var dragPane = this.getDragPane();
	dragPane._dragSource._addItemClass(this.menu.currentTarget, "Selected");
},
deselectTarget : function (args) {
	var dragPane = this.getDragPane();
	dragPane._dragSource._removeItemClass(this.menu.currentTarget, "Selected");
}

}); // plugins.files.WorkflowMenu

}

if(!dojo._hasResource["plugins.dojox.data.FileStore"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.dojox.data.FileStore"] = true;
dojo.provide("plugins.dojox.data.FileStore");



dojo.declare("plugins.dojox.data.FileStore", [dojox.data.FileStore], {
// path: string
// full path to file
path : '',

// putdata: object
// data for xhrPut
putData: null,

////}}}}	

constructor: function (args){
	this.inherited(arguments);

	//console.log("FileStore.constructor    caller: " + this.constructor.caller.nom);
	
	//console.log("FileStore.constructor    args:");
	//console.dir({args:args});
	if ( ! args ) {
		//console.log("FileStore.constructor    args not defined. Returning:");
		return;
	}
	this.core 		= 	args.core;
	this.path		=	args.path;
	this.putData	=	args.putData;
	this.parentPath	=	args.parentPath;

	// SET _processResult CALLBACK
	this.processResultCallback = dojo.hitch(this, "_processResult");
},
_assertIsItem: function(/* item */ item){
	// summary:
	//      This function tests whether the item passed in is indeed an item in the store.
	// item:
	//		The item to test for being contained by the store.

	//console.log("plugins.dojox.data.FileStore._assertIsItem    caller: " + this._assertIsItem.caller.nom);
	////console.log("plugins.dojox.data.FileStore._assertIsItem    item: " + dojo.toJson(item));

	if(!this.isItem(item)){
		//console.warn("dojox.data.FileStore: a function was passed an item argument that was not an item");
	
		//throw new Error("dojox.data.FileStore: a function was passed an item argument that was not an item");
	}
},
_assertIsAttribute: function(/* attribute-name-string */ attribute){
	// summary:
	//		This function tests whether the item passed in is indeed a valid 'attribute' like type for the store.
	// attribute:
	//		The attribute to test for being contained by the store.
	if(typeof attribute !== "string"){
		throw new Error("dojox.data.FileStore: a function was passed an attribute argument that was not an attribute name string");
	}
},
loadItem: function(keywordArgs){
	// summary:
	//      See dojo.data.api.Read.loadItem()
	var item = keywordArgs.item;
	var self = this;
	var scope = keywordArgs.scope || dojo.global;

	var content = {};

	if(this.options.length > 0){
		content.options = dojo.toJson(this.options);
	}

	if(this.pathAsQueryParam){
		content.path = item.parentPath + this.pathSeparator + item.name;
	}

	var xhrData = {
		url: this.pathAsQueryParam? this.url : this.url + "/" + item.parentPath + "/" + item.name,
		handleAs: "json-comment-optional",
		content: content,
		preventCache: this.urlPreventCache,
		failOk: this.failOk
	};

	var deferred = dojo.xhrGet(xhrData);
	deferred.addErrback(function(error){
			if(keywordArgs.onError){
				keywordArgs.onError.call(scope, error);
			}
	});
	
	deferred.addCallback(function(data){
		delete item.parentPath;
		delete item._loaded;
		dojo.mixin(item, data);
		self._processItem(item);
		if(keywordArgs.onItem){
			keywordArgs.onItem.call(scope, item);
		}
	});
},
isItem: function(item){
	// summary:
	//      See dojo.data.api.Read.isItem()
	//console.log("plugins.dojox.data.FileStore.isItem    caller: " + this.isItem.caller.nom);
	////console.log("plugins.dojox.data.FileStore.isItem    item: " + dojo.toJson(item));
	
	if(item && item[this._storeRef] === this){
		return true;
	}
	return false;
},
close: function(request){
	// summary:
	//      See dojo.data.api.Read.close()
},
fetch: function(request){
	//console.log("plugins.dojox.data.FileStore.fetch    caller: " + this.fetch.caller.nom);
	//console.log("plugins.dojox.data.FileStore.fetch    request: " );
	//console.dir({request:request});

	request = request || {};
	if(!request.store){
		request.store = this;
	}

	var self = this;
	var scope = request.scope || dojo.global;
	
	//console.log("plugins.dojox.data.FileStore.fetch    this.path: " );
	//console.dir({this_path:this.path});
	//console.dir({this_parentPath:this.parentPath});
	//console.dir({this_name:this.name});

	//console.log("plugins.dojox.data.FileStore.fetch    BEFORE request.query: ");
	//console.dir({request_query:request.query});

	// Generate request parameters
	var reqParams = {};
	if ( request.query ) {
		//request.query = request.query.replace(/^\//, '');
		reqParams.query = request.query;
	}
	//console.log("plugins.dojox.data.FileStore.fetch    AFTER request.query: " );
	//console.dir({request_query:request.query});

	var putData = this.putData;
	if ( request.query )
		putData.query = request.query;

	//console.log("plugins.dojox.data.FileStore.fetch    putData:");
	//console.dir({putData:putData});

	var callback = this.processResultCallback;
	Agua.getFileSystem(putData, callback, request);

},
fetchItemByIdentity: function(keywordArgs){
	// summary:
	//      See dojo.data.api.Read.loadItem()
	var path = keywordArgs.identity;
	var self = this;
	var scope = keywordArgs.scope || dojo.global;

	var content = {};

	if(this.options.length > 0){
		content.options = dojo.toJson(this.options);
	}

	if(this.pathAsQueryParam){
		content.path = path;
	}
	
	var xhrData = {
		url: this.pathAsQueryParam? this.url : this.url + "/" + path,
		handleAs: "json-comment-optional",
		content: content,
		preventCache: this.urlPreventCache,
		failOk: this.failOk
	};

	var deferred = dojo.xhrGet(xhrData);
	deferred.addErrback(function(error){
			if(keywordArgs.onError){
				keywordArgs.onError.call(scope, error);
			}
	});
	
	deferred.addCallback(function(data){
		var item = self._processItem(data);
		if(keywordArgs.onItem){
			keywordArgs.onItem.call(scope, item);
		}
	});
},
_processResult: function(data, request){
	//console.log("FileStore._processResult    caller: " + this._processResult.caller.nom);
	//console.log("FileStore._processResult    data: ")
	//console.dir({data:data});
	//console.log("FileStore._processResult    request: ")
	//console.dir({request:request});
	
	if ( ! request ) {
		//console.log("FileStore._processResult    Returning because request is null");
		return;
	}

	 var scope = request.scope || dojo.global;
	 try{

		 //If the data contains a path separator, set ours
		 if(data.pathSeparator){
			 this.pathSeparator = data.pathSeparator;
		 }

	//console.log("FileStore._processResult    ONE");

			
		 //Invoke the onBegin handler, if any, to return the
		 //size of the dataset as indicated by the service.
		 if(request.onBegin){
			 request.onBegin.call(scope, data.total, request);
		 }

	//console.log("FileStore._processResult    TWO");

		 //Now process all the returned items thro
		 var items = this._processItemArray(data.items);

		 if(request.onItem){
			var i;
			for(i = 0; i < items.length; i++){
				request.onItem.call(scope, items[i], request);
			}
			items = null;
		 }

	//console.log("FileStore._processResult    THREE");

		 if(request.onComplete){
			
		////console.log("FileStore._processResult    items:");
		////console.dir({items:items});
		////console.log("FileStore._processResult    request.onComplete: " + request.FileStore);
		////console.log("FileStore._processResult    request.onComplete.toString(): " + request.onComplete.toString());
		//
		////console.log("FileStore._processResult    Doing request.onComplete.call(scope, items, request)");
		
			 request.onComplete.call(scope, items, request);
		 }
		 
		 
	//console.log("FileStore._processResult    FOUR");

	 }catch (e){
		 if(request.onError){
			 request.onError.call(scope, e, request);
		 }else{
			 //console.log(e);
		 }
	 }
	 
	////console.log("FileStore._processResult    END");
	////console.log("FileStore._processResult    this.core.folders: " + this.core.folders);
	////console.log("FileStore._processResult    Doing this.core.folders.roundRobin(): ");
	//this.core.folders.roundRobin();
},
_processItemArray : function(itemArray) {
	// Internal function for processing an array of items for return.
	
	if ( ! itemArray ) {
		//console.log("plugins.dojox.data.FileStore._processItemArray    itemArray is null. Returning empty array []");
		return [];
	}
	
	var i;
	for(i = 0; i < itemArray.length; i++){
		this._processItem(itemArray[i]);
	}
	return itemArray;
},
_processItem: function(item){
	//	summary:
	//		Internal function for processing an item returned from the store.
	//		It sets up the store ref as well as sets up the attributes necessary
	//		to invoke a lazy load on a child, if there are any.
	if(!item){return null;}
	item[this._storeRef] = this;
	if(item.children && item.directory){
		if(dojo.isArray(item.children)){
			var children = item.children;
			var i;
			for(i = 0; i < children.length; i++ ){
				var name = children[i];
				if(dojo.isObject(name)){
					children[i] = this._processItem(name);
				}else{
					children[i] = {name: name, _loaded: false, parentPath: item.path};
					children[i][this._storeRef] = this;
				}
			}
		}else{
			delete item.children;
		}
	}
	return item;
}


});


}

if(!dojo._hasResource["plugins.dijit.layout.BorderContainer"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.dijit.layout.BorderContainer"] = true;
dojo.provide("plugins.dijit.layout.BorderContainer");




dojo.declare("plugins.dijit.layout.BorderContainer",
//	[dijit._Widget, dijit._Container, dijit._Contained],
	[ dijit.layout.BorderContainer ],
{

	layout : function(changedRegion, changedChild, type){

		//console.log("BorderContainer.layout    plugins.dijit.layout.BorderContainer.layout(changedRegion, changedChild, type)");
		//console.log("BorderContainer.layout    changedRegion: " + changedRegion);
		//console.log("BorderContainer.layout    changedChild: " + changedChild);
		//console.log("BorderContainer.layout    type: " + type);

		for(var region in this._splitters){ this._computeSplitterThickness(region); }
		this._layoutChildren(changedRegion, changedChild, type);
	},



	// type argument is "hide" or "show"
	_layoutChildren : function(/*String?*/changedRegion, changedChild, type){

		//console.log("BorderContainer._layoutChildren    plugins.dijit.layout.BorderContainer._layoutChildren(changedRegion, changedChild, type)");
		//console.log("BorderContainer._layoutChildren    DOING: " + type + " " + changedRegion);

		if ( changedChild != null )
		{
			////console.log("BorderContainer._layoutChildren    dojo.marginBox(changedChild.domNode).w: " + dojo.marginBox(changedChild.domNode).w);
			//console.log("BorderContainer._layoutChildren    changedChild.width: " + changedChild.width);

			// ADDED type ARGUMENT: "hide" OR "show"
			if ( type == "hide" )
			{
				if ( /left|right|center/.test(changedRegion) && changedChild.minWidth )
				{
					//console.log("BorderContainer._layoutChildren    Setting changedChild width: " + changedChild.minWidth + "px" );
					dojo.style(changedChild, "width", changedChild.minWidth + "px");
					dojo.marginBox(changedChild).w = changedChild.minWidth;


					changedChild.style.width = changedChild.minWidth + "px";
				}
				else if ( /top|bottom/.test(changedRegion) && changedChild.minHeight )
				{
					changedChild.style.height = changedChild.minHeight + "px";
				}
			}

			else if ( type == "show" )
			{
				if ( /left|right|center/.test(changedRegion) && changedChild.width )
				{
				//console.log("BorderContainer._layoutChildren    Setting changedChild width: " + changedChild.width + "px" );
					changedChild.style.width = changedChild.width + "px";
				}
				else if ( /top|bottom/.test(changedRegion) && changedChild.height )
				{
					//changedChild.style.height = changedChild.height + "px";
					dojo.style(changedChild, "width", changedChild.width + "px");
					dojo.marginBox(changedChild).w = changedChild.width;
				}
			}

			//console.log("BorderContainer._layoutChildren    changedChild.style.width: " + changedChild.style.width);

		}
		
		
		
		//console.log("BorderContainer._layoutChildren    this._center: " + this._center);
		//console.log("BorderContainer._layoutChildren    this._center.style: " + this._center.style);

		var sidebarLayout = (this.design == "sidebar");
		var topHeight = 0, bottomHeight = 0, leftWidth = 0, centerWidth = 0, rightWidth = 0;
		var topStyle = {}, leftStyle = {}, rightStyle = {}, bottomStyle = {},
			centerStyle = (this._center && this._center.style) || {};

		var changedSide = /left|right|center/.test(changedRegion);

		var layoutSides = !changedRegion || (!changedSide && !sidebarLayout);
		var layoutTopBottom = !changedRegion || (changedSide && sidebarLayout);

		layoutSides = !changedRegion;

		//console.log("BorderContainer._layoutChildren    layoutSides: " + layoutSides);

		// Ask browser for width/height of side panes.
		// Would be nice to cache this but height can change according to width
		// (because words wrap around).  I don't think width will ever change though
		// (except when the user drags a splitter). 
		if(this._top){
			topStyle = layoutTopBottom && this._top.style;
			topHeight = dojo.marginBox(this._top).h;
		}
		if(this._left){
			leftStyle = layoutSides && this._left.style;
			leftWidth = dojo.marginBox(this._left).w;
		}
		if(this._center){
			//centerStyle = layoutSides && this._center.style;
			centerWidth = dojo.marginBox(this._center).w;
		}
		if(this._right){
			rightStyle = layoutSides && this._right.style;
			rightWidth = dojo.marginBox(this._right).w;
		}
		if(this._bottom){
			bottomStyle = layoutTopBottom && this._bottom.style;
			bottomHeight = dojo.marginBox(this._bottom).h;
		}


		//console.log("BorderContainer._layoutChildren    leftWidth: " + leftWidth);
		//console.log("BorderContainer._layoutChildren    centerWidth: " + centerWidth);
		//console.log("BorderContainer._layoutChildren    rightWidth: " + rightWidth);


		if ( centerStyle )
		{
			//console.log("BorderContainer._layoutChildren    centerStyle.left: " + dojo.toJson(centerStyle.left));
		}


		var splitters = this._splitters;
		
		var topSplitter = splitters.top, bottomSplitter = splitters.bottom,
			leftSplitter = splitters.left, rightSplitter = splitters.right,
			centerSplitter = splitters.center;

		var splitterThickness = this._splitterThickness;
		var topSplitterThickness = splitterThickness.top || 0,
			leftSplitterThickness = splitterThickness.left || 0,
			rightSplitterThickness = splitterThickness.right || 0,
			bottomSplitterThickness = splitterThickness.bottom || 0,
			centerSplitterThickness = splitterThickness.center || 0;

		// Check for race condition where CSS hasn't finished loading, so
		// the splitter width == the workflowport width (#5824)
		if(leftSplitterThickness > 50 || rightSplitterThickness > 50){
			setTimeout(dojo.hitch(this, function(){
				// Results are invalid.  Clear them out.
				this._splitterThickness = {};

				for(var region in this._splitters){
					this._computeSplitterThickness(region);
				}
				this._layoutChildren();
			}), 50);
			return false;
		}

		var pe = this.pe;		

		var containerWidth = this._borderBox.w - pe.l - pe.r;
		
		// FOR ANY CHANGES OF THE LEFT OR MIDDLE PANES,
		// THE RIGHT PANE ABSORBS THE DIFFERENCE IN WIDTH
		var middleWidth;
		if ( changedChild != null )
		{
			if ( this._center == changedChild.domNode )
			{
				//console.log("BorderContainer._layoutChildren    CENTER WIDGET");
				middleWidth = centerWidth;
				rightWidth = containerWidth - (leftWidth  + leftSplitterThickness + centerWidth + centerSplitterThickness);

				if ( type == "hide" )
				{
					dojo.removeClass(this._right, "dojoxExpandoClosed");
					dojo.style(dijit.byNode(this._right).cwrapper, "visibility", "visible");
					dojo.style(dijit.byNode(this._right).cwrapper, "opacity", "1");
					dijit.byNode(this._right)._showing = true; 

				}

				// ADJUST LEFT WIDTH DUE TO GROWTH
				if ( dojo.hasClass(this._left, "dojoxExpandoClosed") )
				{
					leftWidth = leftWidth - 2;
				}
			}
			else if ( this._right == changedChild.domNode )
			{
				//console.log("BorderContainer._layoutChildren    RIGHT WIDGET ");
				middleWidth = containerWidth - (leftWidth  + leftSplitterThickness + rightWidth + rightSplitterThickness);
				
				if ( type == "hide" )
				{
					dojo.removeClass(this._center, "dojoxExpandoClosed");
					dojo.style(dijit.byNode(this._center).cwrapper, "visibility", "visible");
					dojo.style(dijit.byNode(this._center).cwrapper, "opacity", "1");
					dijit.byNode(this._center)._showing = true; 
				}

				// ADJUST LEFT WIDTH DUE TO GROWTH
				if ( dojo.hasClass(this._left, "dojoxExpandoClosed") )
				{
					leftWidth = leftWidth - 2;
				}
			}
			else
			{
				//console.log("BorderContainer._layoutChildren    LEFT WIDGET");

				// IF RIGHT PANE IS CLOSED, ADJUST THE MIDDLE PANE
				if ( dojo.hasClass(this._right, "dojoxExpandoClosed") )
				{
					//console.log("BorderContainer._layoutChildren    rightPane is closed");
					middleWidth = containerWidth - (leftWidth  + leftSplitterThickness + rightWidth + rightSplitterThickness);

					// ADJUST RIGHT WIDTH DUE TO GROWTH
					rightWidth = rightWidth - 2;
				}
				else
				{
					middleWidth = centerWidth;
					rightWidth = containerWidth - (leftWidth  + leftSplitterThickness + centerWidth + centerSplitterThickness);
				}
				

				//if ( rightWidth < 1 )
				//{
				//	rightWidth = tempRightWidth;
				//	middleWidth = containerWidth - (leftWidth  + leftSplitterThickness + rightWidth + rightSplitterThickness);
				//}
			}
		}
		else
		{
			middleWidth = containerWidth - (leftWidth  + leftSplitterThickness + rightWidth + rightSplitterThickness);
		}

		//console.log("BorderContainer._layoutChildren    AFTER leftWidth: " + leftWidth);
		//console.log("BorderContainer._layoutChildren    AFTER middleWidth: " + middleWidth);
		//console.log("BorderContainer._layoutChildren    AFTER rightWidth: " + rightWidth);

		if ( centerStyle )
		{
			//console.log("BorderContainer._layoutChildren    centerStyle.left: " + dojo.toJson(centerStyle.left));
		}


		var sidebarWidth = sidebarLayout ? middleWidth : containerWidth;


		// New margin-box size of each pane
		var dim = {
			top:	{ w: sidebarWidth, h: topHeight },
			bottom: { w: sidebarWidth, h: bottomHeight },
			left:	{ w: leftWidth, h: sidebarHeight },
			right:	{ w: rightWidth, h: sidebarHeight },
			center:	{ h: middleHeight, w: middleWidth }
		};

		var splitterBounds = {
			left: (sidebarLayout ? leftWidth + leftSplitterThickness: 0) + pe.l + "px",
			center: (sidebarLayout ? centerWidth + centerSplitterThickness: 0) + pe.l + "px",
			right: (sidebarLayout ? rightWidth + rightSplitterThickness: 0) + pe.r + "px"
		};

		if(topSplitter){
			dojo.mixin(topSplitter.style, splitterBounds);
			topSplitter.style.top = topHeight + pe.t + "px";
		}

		if(bottomSplitter){
			dojo.mixin(bottomSplitter.style, splitterBounds);
			bottomSplitter.style.bottom = bottomHeight + pe.b + "px";
		}

		splitterBounds = {
			top: (sidebarLayout ? 0 : topHeight + topSplitterThickness) + pe.t + "px",
			bottom: (sidebarLayout ? 0 : bottomHeight + bottomSplitterThickness) + pe.b + "px"
		};

		if(leftSplitter){
			dojo.mixin(leftSplitter.style, splitterBounds);
			leftSplitter.style.left = leftWidth + pe.l + "px";
		}

		if(centerSplitter){
			dojo.mixin(centerSplitter.style, splitterBounds);
			centerSplitter.style.center = centerWidth + pe.r +  "px";
		}

		if(rightSplitter){
			dojo.mixin(rightSplitter.style, splitterBounds);
			rightSplitter.style.right = rightWidth + pe.r +  "px";
		}

		dojo.mixin(centerStyle, {
			top: pe.t + topHeight + topSplitterThickness + "px",
			left: pe.l + leftWidth + leftSplitterThickness + "px",
			center: pe.l + centerWidth + centerSplitterThickness + "px",
			right: pe.r + rightWidth + rightSplitterThickness + "px",
			bottom: pe.b + bottomHeight + bottomSplitterThickness + "px"
		});

		var bounds = {
			top: sidebarLayout ? pe.t + "px" : centerStyle.top,
			bottom: sidebarLayout ? pe.b + "px" : centerStyle.bottom
		};
		dojo.mixin(leftStyle, bounds);
		dojo.mixin(rightStyle, bounds);
		
		
		leftStyle.left = pe.l + "px";
		rightStyle.right = pe.r + "px";
		topStyle.top = pe.t + "px";
		bottomStyle.bottom = pe.b + "px";
		
		if(sidebarLayout){
			topStyle.left = bottomStyle.left = leftWidth + leftSplitterThickness + pe.l + "px";
			topStyle.right = bottomStyle.right = rightWidth + rightSplitterThickness + pe.r + "px";
		}
		else
		{
			topStyle.left = bottomStyle.left = pe.l + "px";
			topStyle.right = bottomStyle.right = pe.r + "px";
		}

		// More calculations about sizes of panes
		var containerHeight = this._borderBox.h - pe.t - pe.b;
		var middleHeight = containerHeight - ( topHeight + topSplitterThickness + bottomHeight + bottomSplitterThickness);
		var sidebarHeight = sidebarLayout ? containerHeight : middleHeight;

		// Nodes in IE don't respond to t/l/b/r, and
		// TEXTAREA doesn't respond in any browser
		var janky = dojo.isIE || dojo.some(this.getChildren(), function(child){
			return child.domNode.tagName == "TEXTAREA" || child.domNode.tagName == "INPUT";
		});


		if(janky){
			
			// Set the size of the children the old fashioned way, by setting
			// CSS width and height
			var resizeWidget = function(widget, changes, result){
				if(widget){
					(widget.resize ? widget.resize(changes, result) : dojo.marginBox(widget.domNode, changes));
				}
			};

			if(leftSplitter){ leftSplitter.style.height = sidebarHeight; }
			if(rightSplitter){ rightSplitter.style.height = sidebarHeight; }

			resizeWidget(this._leftWidget, {h: sidebarHeight}, dim.left);
			resizeWidget(this._rightWidget, {h: sidebarHeight}, dim.right);

			if(topSplitter){ topSplitter.style.width = sidebarWidth; }
			if(bottomSplitter){ bottomSplitter.style.width = sidebarWidth; }
			resizeWidget(this._topWidget, {w: sidebarWidth}, dim.top);
			resizeWidget(this._bottomWidget, {w: sidebarWidth}, dim.bottom);

			// CHANGED:
			//resizeWidget(this._centerWidget, dim.center);
			resizeWidget(this._centerWidget, {h: sidebarHeight}, dim.center);
		}


		else
		{
			// We've already sized the children by setting
			// style.top/bottom/left/right...
			// Now just need to call resize() on those children
			// telling them their new size,
			// so they can re-layout themselves

			// Calculate which panes need a notification
			var resizeList = {};
			if(changedRegion){

				//console.log("BorderContainer._layoutChildren    changedRegion: " + changedRegion);
				
				resizeList[changedRegion] = resizeList.center = true;
				if ( /left|right|center/.test(changedRegion) ){
					resizeList.left = resizeList.right = true;
				}
				else if ( /top|bottom|center/.test(changedRegion) ){
					resizeList.top = resizeList.bottom = true;
				}
			}

			//console.log("BorderContainer._layoutChildren    resizeList: " + dojo.toJson(resizeList));

			dojo.forEach(this.getChildren(), function(child){
				//console.log("BorderContainer._layoutChildren    DOING resize on child: " + child.region);

				if(child.resize && (!changedRegion || child.region in resizeList)){
					child.resize(null, dim[child.region]);
				}
			}, this);
		}
	}

//
//	startup: function(){
//	    //console.log("dijit.layout.BorderContainer.startup	dijit.layout.BorderContainer.startup()");
//return;
//
//		this.inherited(arguments);
//
//		//this.resize();
//
//		dojo.connect(window, "onresize", this, "resize");
//
//	},
//
//
//	resize: function(newSize, currentSize){
//	    //console.log("plugins.dijit.layout.BorderContainer.resize	plugins.dijit.layout.BorderContainer.resize(newSize, currentSize)");
//		// resetting potential padding to 0px to provide support for 100% width/height + padding
//		// TODO: this hack doesn't respect the box model and is a temporary fix
//		//if (!this.cs || !this.pe){
//
//		    //console.log("plugins.dijit.layout.BorderContainer.resize	!this.cs || !this.pe");
//
//			var node = this.domNode;
//			this.cs = dojo.getComputedStyle(node);
//			this.pe = dojo._getPadExtents(node, this.cs);
//			this.pe.r = dojo._toPixelValue(node, this.cs.paddingRight);
//			this.pe.b = dojo._toPixelValue(node, this.cs.paddingBottom);
//
//			dojo.style(node, "padding", "0px");
//		//}
//
//		this.inherited(arguments);
//	},
//
//
//	layout : function(changedRegion, changedChild, type){
//
//		//console.log("BorderContainer.layout    plugins.dijit.layout.BorderContainer.layout(changedRegion, changedChild, type)");
//		//console.log("BorderContainer.layout    changedRegion: " + changedRegion);
//		//console.log("BorderContainer.layout    changedChild: " + changedChild);
//		if ( changedChild && changedChild.expand )
//		{
//			//console.log("BorderContainer.layout    changedChild.expand: " + changedChild.expand);
//		}
//		//console.log("BorderContainer.layout    type: " + type);
//
//		for(var region in this._splitters){ this._computeSplitterThickness(region); }
//		this._layoutChildren(changedRegion, changedChild, type);
//	},
//
//
//
//	// type argument is "hide" or "show"
//	_layoutChildren : function(/*String?*/changedRegion, changedChild, type){
//
//		//console.log("BorderContainer._layoutChildren    plugins.dijit.layout.BorderContainer._layoutChildren(changedRegion, changedChild, type)");
//		//console.log("BorderContainer._layoutChildren    DOING: " + type + " " + changedRegion);
//
//		if ( changedChild != null )
//		{
//			////console.log("BorderContainer._layoutChildren    dojo.marginBox(changedChild.domNode).w: " + dojo.marginBox(changedChild.domNode).w);
//			//console.log("BorderContainer._layoutChildren    changedChild.width: " + changedChild.width);
//
//			// ADDED type ARGUMENT: "hide" OR "show"
//			if ( type == "hide" )
//			{
//				if ( /left|right|center/.test(changedRegion) && changedChild.minWidth )
//				{
//					//console.log("BorderContainer._layoutChildren    Setting changedChild width: " + changedChild.minWidth + "px" );
//					dojo.style(changedChild, "width", changedChild.minWidth + "px");
//					dojo.marginBox(changedChild).w = changedChild.minWidth;
//
//
//					changedChild.style.width = changedChild.minWidth + "px";
//				}
//				else if ( /top|bottom/.test(changedRegion) && changedChild.minHeight )
//				{
//					changedChild.style.height = changedChild.minHeight + "px";
//				}
//			}
//
//			else if ( type == "show" )
//			{
//				if ( /left|right|center/.test(changedRegion) && changedChild.width )
//				{
//				//console.log("BorderContainer._layoutChildren    Setting changedChild width: " + changedChild.width + "px" );
//					changedChild.style.width = changedChild.width + "px";
//				}
//				else if ( /top|bottom/.test(changedRegion) && changedChild.height )
//				{
//					//changedChild.style.height = changedChild.height + "px";
//					dojo.style(changedChild, "width", changedChild.width + "px");
//					dojo.marginBox(changedChild).w = changedChild.width;
//				}
//			}
//
//			//console.log("BorderContainer._layoutChildren    changedChild.style.width: " + changedChild.style.width);
//
//		}
//		
//		
//		
//		//console.log("BorderContainer._layoutChildren    this._center: " + this._center);
//		//console.log("BorderContainer._layoutChildren    this._center.style: " + this._center.style);
//
//		var sidebarLayout = (this.design == "sidebar");
//		var topHeight = 0, bottomHeight = 0, leftWidth = 0, centerWidth = 0, rightWidth = 0;
//		var topStyle = {}, leftStyle = {}, rightStyle = {}, bottomStyle = {},
//			centerStyle = (this._center && this._center.style) || {};
//
//		var changedSide = /left|right|center/.test(changedRegion);
//
//		var layoutSides = !changedRegion || (!changedSide && !sidebarLayout);
//		var layoutTopBottom = !changedRegion || (changedSide && sidebarLayout);
//
//		layoutSides = !changedRegion;
//
//		//console.log("BorderContainer._layoutChildren    layoutSides: " + layoutSides);
//
//		// Ask browser for width/height of side panes.
//		// Would be nice to cache this but height can change according to width
//		// (because words wrap around).  I don't think width will ever change though
//		// (except when the user drags a splitter). 
//		if(this._top){
//			topStyle = layoutTopBottom && this._top.style;
//			topHeight = dojo.marginBox(this._top).h;
//		}
//		if(this._left){
//			leftStyle = layoutSides && this._left.style;
//			leftWidth = dojo.marginBox(this._left).w;
//		}
//		if(this._center){
//			//centerStyle = layoutSides && this._center.style;
//			centerWidth = dojo.marginBox(this._center).w;
//		}
//		if(this._right){
//			rightStyle = layoutSides && this._right.style;
//			rightWidth = dojo.marginBox(this._right).w;
//		}
//		if(this._bottom){
//			bottomStyle = layoutTopBottom && this._bottom.style;
//			bottomHeight = dojo.marginBox(this._bottom).h;
//		}
//
//
//		//console.log("BorderContainer._layoutChildren    leftWidth: " + leftWidth);
//		//console.log("BorderContainer._layoutChildren    centerWidth: " + centerWidth);
//		//console.log("BorderContainer._layoutChildren    rightWidth: " + rightWidth);
//
//
//		if ( centerStyle )
//		{
//			//console.log("BorderContainer._layoutChildren    centerStyle.left: " + dojo.toJson(centerStyle.left));
//		}
//
//
//		var splitters = this._splitters;
//		
//		var topSplitter = splitters.top, bottomSplitter = splitters.bottom,
//			leftSplitter = splitters.left, rightSplitter = splitters.right,
//			centerSplitter = splitters.center;
//
//		var splitterThickness = this._splitterThickness;
//		var topSplitterThickness = splitterThickness.top || 0,
//			leftSplitterThickness = splitterThickness.left || 0,
//			rightSplitterThickness = splitterThickness.right || 0,
//			bottomSplitterThickness = splitterThickness.bottom || 0,
//			centerSplitterThickness = splitterThickness.center || 0;
//
//		// Check for race condition where CSS hasn't finished loading, so
//		// the splitter width == the workflowport width (#5824)
//		if(leftSplitterThickness > 50 || rightSplitterThickness > 50){
//			setTimeout(dojo.hitch(this, function(){
//				// Results are invalid.  Clear them out.
//				this._splitterThickness = {};
//
//				for(var region in this._splitters){
//					this._computeSplitterThickness(region);
//				}
//				this._layoutChildren();
//			}), 50);
//			return false;
//		}
//
//		var pe = this.pe;		
//
//		var containerWidth = this._borderBox.w - pe.l - pe.r;
//		
//		// USE WINDOW WIDTH IF BORDER BOX HAS NOT BEEN ACTIVATED BY RESIZE
//		if ( containerWidth <= 0 )
//		{
//			containerWidth = document.body.offsetWidth;
//		}
//		
//		//console.log("BorderContainer._layoutChildren    containerWidth: " + containerWidth);
//		//console.log("BorderContainer._layoutChildren    this.minWidth: " + this.minWidth);
//		//console.log("BorderContainer._layoutChildren    this.containerNode.style: " + this.containerNode.style);
//		//console.log("BorderContainer._layoutChildren    this.containerNode.style.width: " + this.containerNode.style.width);
//		
//		//console.log("BorderContainer._layoutChildren    window.innerWidth: " + window.innerWidth);
//		//console.log("BorderContainer._layoutChildren    window.innerHeight: " + window.innerHeight);
//
//		//console.log("BorderContainer._layoutChildren    document.body.offsetWidth: " + document.body.offsetWidth);
//		//console.log("BorderContainer._layoutChildren    document.body.offsetHeight: " + document.body.offsetHeight);
//
//
//		
//		// FOR ANY CHANGES OF THE LEFT OR MIDDLE PANES,
//		// THE RIGHT PANE ABSORBS THE DIFFERENCE IN WIDTH
//		var middleWidth;
//		if ( changedChild != null )
//		{
//			if ( this._center == changedChild.domNode )
//			{
//				//console.log("BorderContainer._layoutChildren    CENTER WIDGET");
//	
//				var leftPane = dijit.byNode(this._left);
//				var centerPane = dijit.byNode(this._center);
//				var rightPane = dijit.byNode(this._right);
//
//				// BIAS LEFT PANE FIRST 
//				if ( leftPane.expand )
//				{
//					//console.log("BorderContainer._layoutChildren    leftPane.expand: " + leftPane.expand);
//
//					middleWidth = centerWidth;
//					leftWidth = containerWidth - (rightWidth  + rightSplitterThickness + centerWidth + centerSplitterThickness);
//				}
//				else if ( rightPane.expand )
//				{
//					//console.log("BorderContainer._layoutChildren    changedChild.expand: " + rightPane.expand);
//					middleWidth = centerWidth;
//					rightWidth = containerWidth - (leftWidth  + leftSplitterThickness + centerWidth + centerSplitterThickness);
//				}
//				else
//				{
//					//console.log("BorderContainer._layoutChildren    NEITHER leftPane.expand NOR rightPane.expand ARE TRUE. DEFAULT = expand RIGHT PANE.");
//					middleWidth = centerWidth;
//					rightWidth = containerWidth - (leftWidth  + leftSplitterThickness + centerWidth + centerSplitterThickness);
//				}
//		
//				if ( type == "hide" )
//				{
//					dojo.removeClass(this._right, "dojoxExpandoClosed");
//					dojo.style(dijit.byNode(this._right).cwrapper, "visibility", "visible");
//					dojo.style(dijit.byNode(this._right).cwrapper, "opacity", "1");
//					dijit.byNode(this._right)._showing = true; 
//
//				}
//
//				// ADJUST LEFT WIDTH DUE TO GROWTH
//				if ( dojo.hasClass(this._left, "dojoxExpandoClosed") )
//				{
//					leftWidth = leftWidth - 2;
//				}
//			}
//			else if ( this._right == changedChild.domNode )
//			{
//				//console.log("BorderContainer._layoutChildren    RIGHT WIDGET ");
//				middleWidth = containerWidth - (leftWidth  + leftSplitterThickness + rightWidth + rightSplitterThickness);
//				
//				if ( type == "hide" )
//				{
//					dojo.removeClass(this._center, "dojoxExpandoClosed");
//					dojo.style(dijit.byNode(this._center).cwrapper, "visibility", "visible");
//					dojo.style(dijit.byNode(this._center).cwrapper, "opacity", "1");
//					dijit.byNode(this._center)._showing = true; 
//				}
//
//				// ADJUST LEFT WIDTH DUE TO GROWTH
//				if ( dojo.hasClass(this._left, "dojoxExpandoClosed") )
//				{
//					leftWidth = leftWidth - 2;
//				}
//			}
//			else
//			{
//				//console.log("BorderContainer._layoutChildren    LEFT WIDGET");
//
//				// IF RIGHT PANE IS CLOSED, ADJUST THE MIDDLE PANE
//				if ( dojo.hasClass(this._right, "dojoxExpandoClosed") )
//				{
//					//console.log("BorderContainer._layoutChildren    rightPane is closed");
//					middleWidth = containerWidth - (leftWidth  + leftSplitterThickness + rightWidth + rightSplitterThickness);
//
//					// ADJUST RIGHT WIDTH DUE TO GROWTH
//					rightWidth = rightWidth - 2;
//				}
//				else
//				{
//					middleWidth = centerWidth;
//					rightWidth = containerWidth - (leftWidth  + leftSplitterThickness + centerWidth + centerSplitterThickness);
//				}
//				
//
//				//if ( rightWidth < 1 )
//				//{
//				//	rightWidth = tempRightWidth;
//				//	middleWidth = containerWidth - (leftWidth  + leftSplitterThickness + rightWidth + rightSplitterThickness);
//				//}
//			}
//		}
//		else
//		{
//			middleWidth = containerWidth - (leftWidth  + leftSplitterThickness + rightWidth + rightSplitterThickness);
//			var centerPane = dijit.byNode(this._center);
//
//			// EXPAND MIDDLE PANE BY DEFAULT, UNLESS THE WIDTH IS GREATER
//			// THAN IT'S MAXWIDTH, IN WHICH CASE, EXPAND THE RIGHT PANE
//			if ( centerPane && centerPane.maxWidth )
//			{
//				//console.log("BorderContainer._layoutChildren    centerPane.maxWidth: " + centerPane.maxWidth);
//				middleWidth = containerWidth - (leftWidth  + leftSplitterThickness + rightWidth + rightSplitterThickness);
//				if ( middleWidth > centerPane.maxWidth )
//				{
//					//console.log("BorderContainer._layoutChildren    middleWidth > centerPane.maxWidth");
//					rightWidth += middleWidth - centerPane.maxWidth;
//					middleWidth = centerPane.maxWidth;
//					//console.log("BorderContainer._layoutChildren    middleWidth: " + middleWidth);
//					//console.log("BorderContainer._layoutChildren    rightWidth: " + rightWidth);
//
//				}
//				else if ( centerPane.minWidth )
//				{
//					var minWidth = centerPane.minWidth;
//					if ( middleWidth < minWidth )
//					{
//						//console.log("BorderContainer._layoutChildren    middleWidth < minWidth");
//						middleWidth = minWidth;
//						rightWidth = containerWidth - (leftWidth  + leftSplitterThickness + middleWidth + rightSplitterThickness);
//						//console.log("BorderContainer._layoutChildren    middleWidth: " + middleWidth);
//						//console.log("BorderContainer._layoutChildren    containerWidth: " + containerWidth);
//						//console.log("BorderContainer._layoutChildren    leftWidth: " + leftWidth);
//						//console.log("BorderContainer._layoutChildren    rightWidth: " + rightWidth);
//					}
//				}
//			}
//
//			// EXPAND MIDDLE PANE BY DEFAULT, UNLESS THE WIDTH IS GREATER
//			// THAN IT'S MAXWIDTH, IN WHICH CASE, EXPAND THE RIGHT PANE
//			if ( dijit.byNode(this._center) && dijit.byNode(this._center).maxWidth )
//			{
//				var maxWidth = dijit.byNode(this._center).maxWidth;
//				middleWidth = containerWidth - (leftWidth  + leftSplitterThickness + rightWidth + rightSplitterThickness);
//				if ( middleWidth > maxWidth )
//				{
//					rightWidth += middleWidth - maxWidth;
//					middleWidth = maxWidth;
//				}
//			}
//
//
//
//
//
//
//				//////else if ( centerPane.minWidth )
//				//////{
//				//////	var minWidth = centerPane.minWidth;
//				//////	if ( middleWidth < minWidth )
//				//////	{
//				//////		////console.log("BorderContainer._layoutChildren    middleWidth < minWidth");
//				//////
//				//////		middleWidth = minWidth;
//				//////		rightWidth += middleWidth - maxWidth;
//				//////		rightWidth = containerWidth - (leftWidth  + leftSplitterThickness + middleWidth + rightSplitterThickness);
//				//////		////console.log("BorderContainer._layoutChildren    middleWidth: " + middleWidth);
//				//////		////console.log("BorderContainer._layoutChildren    rightWidth: " + rightWidth);
//				//////	}
//				//////}
//
//
//
//		}
//
//		//console.log("BorderContainer._layoutChildren    AFTER leftWidth: " + leftWidth);
//		//console.log("BorderContainer._layoutChildren    AFTER middleWidth: " + middleWidth);
//		//console.log("BorderContainer._layoutChildren    AFTER rightWidth: " + rightWidth);
//
//		if ( centerStyle )
//		{
//			//console.log("BorderContainer._layoutChildren    centerStyle.left: " + dojo.toJson(centerStyle.left));
//		}
//
//
//		var sidebarWidth = sidebarLayout ? middleWidth : containerWidth;
//
//
//		// New margin-box size of each pane
//		var dim = {
//			top:	{ w: sidebarWidth, h: topHeight },
//			bottom: { w: sidebarWidth, h: bottomHeight },
//			left:	{ w: leftWidth, h: sidebarHeight },
//			right:	{ w: rightWidth, h: sidebarHeight },
//			center:	{ h: middleHeight, w: middleWidth }
//		};
//
//		var splitterBounds = {
//			left: (sidebarLayout ? leftWidth + leftSplitterThickness: 0) + pe.l + "px",
//			center: (sidebarLayout ? centerWidth + centerSplitterThickness: 0) + pe.l + "px",
//			right: (sidebarLayout ? rightWidth + rightSplitterThickness: 0) + pe.r + "px"
//		};
//
//		if(topSplitter){
//			dojo.mixin(topSplitter.style, splitterBounds);
//			topSplitter.style.top = topHeight + pe.t + "px";
//		}
//
//		if(bottomSplitter){
//			dojo.mixin(bottomSplitter.style, splitterBounds);
//			bottomSplitter.style.bottom = bottomHeight + pe.b + "px";
//		}
//
//		splitterBounds = {
//			top: (sidebarLayout ? 0 : topHeight + topSplitterThickness) + pe.t + "px",
//			bottom: (sidebarLayout ? 0 : bottomHeight + bottomSplitterThickness) + pe.b + "px"
//		};
//
//		if(leftSplitter){
//			dojo.mixin(leftSplitter.style, splitterBounds);
//			leftSplitter.style.left = leftWidth + pe.l + "px";
//		}
//
//		if(centerSplitter){
//			dojo.mixin(centerSplitter.style, splitterBounds);
//			centerSplitter.style.center = centerWidth + pe.r +  "px";
//		}
//
//		if(rightSplitter){
//			dojo.mixin(rightSplitter.style, splitterBounds);
//			rightSplitter.style.right = rightWidth + pe.r +  "px";
//		}
//
//		dojo.mixin(centerStyle, {
//			top: pe.t + topHeight + topSplitterThickness + "px",
//			left: pe.l + leftWidth + leftSplitterThickness + "px",
//			center: pe.l + centerWidth + centerSplitterThickness + "px",
//			right: pe.r + rightWidth + rightSplitterThickness + "px",
//			bottom: pe.b + bottomHeight + bottomSplitterThickness + "px"
//		});
//
//		var bounds = {
//			top: sidebarLayout ? pe.t + "px" : centerStyle.top,
//			bottom: sidebarLayout ? pe.b + "px" : centerStyle.bottom
//		};
//		dojo.mixin(leftStyle, bounds);
//		dojo.mixin(rightStyle, bounds);
//		
//		
//		leftStyle.left = pe.l + "px";
//		rightStyle.right = pe.r + "px";
//		topStyle.top = pe.t + "px";
//		bottomStyle.bottom = pe.b + "px";
//		
//		if(sidebarLayout){
//			topStyle.left = bottomStyle.left = leftWidth + leftSplitterThickness + pe.l + "px";
//			topStyle.right = bottomStyle.right = rightWidth + rightSplitterThickness + pe.r + "px";
//		}
//		else
//		{
//			topStyle.left = bottomStyle.left = pe.l + "px";
//			topStyle.right = bottomStyle.right = pe.r + "px";
//		}
//
//		// More calculations about sizes of panes
//		var containerHeight = this._borderBox.h - pe.t - pe.b;
//		var middleHeight = containerHeight - ( topHeight + topSplitterThickness + bottomHeight + bottomSplitterThickness);
//		var sidebarHeight = sidebarLayout ? containerHeight : middleHeight;
//
//		// Nodes in IE don't respond to t/l/b/r, and
//		// TEXTAREA doesn't respond in any browser
//		var janky = dojo.isIE || dojo.some(this.getChildren(), function(child){
//			return child.domNode.tagName == "TEXTAREA" || child.domNode.tagName == "INPUT";
//		});
//
//
//		if(janky){
//			
//			// Set the size of the children the old fashioned way, by setting
//			// CSS width and height
//			var resizeWidget = function(widget, changes, result){
//				if(widget){
//					(widget.resize ? widget.resize(changes, result) : dojo.marginBox(widget.domNode, changes));
//				}
//			};
//
//			if(leftSplitter){ leftSplitter.style.height = sidebarHeight; }
//			if(rightSplitter){ rightSplitter.style.height = sidebarHeight; }
//
//			resizeWidget(this._leftWidget, {h: sidebarHeight}, dim.left);
//			resizeWidget(this._rightWidget, {h: sidebarHeight}, dim.right);
//
//			if(topSplitter){ topSplitter.style.width = sidebarWidth; }
//			if(bottomSplitter){ bottomSplitter.style.width = sidebarWidth; }
//			resizeWidget(this._topWidget, {w: sidebarWidth}, dim.top);
//			resizeWidget(this._bottomWidget, {w: sidebarWidth}, dim.bottom);
//
//			// CHANGED:
//			//resizeWidget(this._centerWidget, dim.center);
//			resizeWidget(this._centerWidget, {h: sidebarHeight}, dim.center);
//		}
//
//
//		else
//		{
//			// We've already sized the children by setting
//			// style.top/bottom/left/right...
//			// Now just need to call resize() on those children
//			// telling them their new size,
//			// so they can re-layout themselves
//
//			// Calculate which panes need a notification
//			var resizeList = {};
//			if(changedRegion){
//
//				//console.log("BorderContainer._layoutChildren    changedRegion: " + changedRegion);
//				
//				resizeList[changedRegion] = resizeList.center = true;
//				if ( /left|right|center/.test(changedRegion) ){
//					resizeList.left = resizeList.right = true;
//				}
//				else if ( /top|bottom|center/.test(changedRegion) ){
//					resizeList.top = resizeList.bottom = true;
//				}
//			}
//
//			//console.log("BorderContainer._layoutChildren    resizeList: " + dojo.toJson(resizeList));
//
//			dojo.forEach(this.getChildren(), function(child){
//				//console.log("BorderContainer._layoutChildren    DOING resize on child: " + child.region);
//				//console.log("BorderContainer._layoutChildren    dim[child.region]: " + dojo.toJson(dim[child.region]));
//
//				if(child.resize && (!changedRegion || child.region in resizeList)){
//					child.resize(null, dim[child.region]);
//				}
//			}, this);
//		}
//	}

});


}

if(!dojo._hasResource["dojox.layout.ExpandoPane"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.layout.ExpandoPane"] = true;
dojo.provide("dojox.layout.ExpandoPane");
dojo.experimental("dojox.layout.ExpandoPane"); // just to show it can be done?





dojo.declare("dojox.layout.ExpandoPane",
	[dijit.layout.ContentPane, dijit._Templated, dijit._Contained, dijit._Container],
	{
	// summary: An experimental collapsing-pane for dijit.layout.BorderContainer
	//
	// description:
	//		Works just like a ContentPane inside of a borderContainer. Will expand/collapse on
	//		command, and supports having Layout Children as direct descendants
	//

	//maxHeight: "",
	//maxWidth: "",
	//splitter: false,
	attributeMap: dojo.delegate(dijit.layout.ContentPane.prototype.attributeMap, {
	        title: { node: "titleNode", type: "innerHTML" }
	}),
	
	templateString: dojo.cache("dojox.layout", "resources/ExpandoPane.html", "<div class=\"dojoxExpandoPane\">\n\t<div dojoAttachPoint=\"titleWrapper\" class=\"dojoxExpandoTitle\">\n\t\t<div class=\"dojoxExpandoIcon\" dojoAttachPoint=\"iconNode\" dojoAttachEvent=\"onclick:toggle\"><span class=\"a11yNode\">X</span></div>\t\t\t\n\t\t<span class=\"dojoxExpandoTitleNode\" dojoAttachPoint=\"titleNode\">${title}</span>\n\t</div>\n\t<div class=\"dojoxExpandoWrapper\" dojoAttachPoint=\"cwrapper\" dojoAttachEvent=\"ondblclick:_trap\">\n\t\t<div class=\"dojoxExpandoContent\" dojoAttachPoint=\"containerNode\"></div>\n\t</div>\n</div>\n"),

	// easeOut: String|Function
	//		easing function used to hide pane
	easeOut: "dojo._DefaultEasing",
	
	// easeIn: String|Function
	//		easing function use to show pane
	easeIn: "dojo._DefaultEasing",
	
	// duration: Integer
	//		duration to run show/hide animations
	duration: 420,

	// startExpanded: Boolean
	//		Does this widget start in an open (true) or closed (false) state
	startExpanded: true,

	// previewOpacity: Float
	//		A value from 0 .. 1 indicating the opacity to use on the container
	//		when only showing a preview
	previewOpacity: 0.75,
	
	// previewOnDblClick: Boolean
	//		If true, will override the default behavior of a double-click calling a full toggle.
	//		If false, a double-click will cause the preview to popup
	previewOnDblClick: false,

	baseClass: "dijitExpandoPane",

	postCreate: function(){
		this.inherited(arguments);
		this._animConnects = [];

		this._isHorizontal = true;
		
		if(dojo.isString(this.easeOut)){
			this.easeOut = dojo.getObject(this.easeOut);
		}
		if(dojo.isString(this.easeIn)){
			this.easeIn = dojo.getObject(this.easeIn);
		}
	
		var thisClass = "", rtl = !this.isLeftToRight();
		if(this.region){
			switch(this.region){
				case "trailing" :
				case "right" :
					thisClass = rtl ? "Left" : "Right";
					break;
				case "leading" :
				case "left" :
					thisClass = rtl ? "Right" : "Left";
					break;
				case "top" :
					thisClass = "Top";
					break;
				case "bottom" :
					thisClass = "Bottom";
					break;
			}
			dojo.addClass(this.domNode, "dojoxExpando" + thisClass);
			dojo.addClass(this.iconNode, "dojoxExpandoIcon" + thisClass);
			this._isHorizontal = /top|bottom/.test(this.region);
		}
		dojo.style(this.domNode, {
			overflow: "hidden",
			padding:0
		});
		
		this.connect(this.domNode, "ondblclick", this.previewOnDblClick ? "preview" : "toggle");
		
		if(this.previewOnDblClick){
			this.connect(this.getParent(), "_layoutChildren", dojo.hitch(this, function(){
				this._isonlypreview = false;
			}));
		}
		
	},
	
	_startupSizes: function(){
		
		this._container = this.getParent();
		this._closedSize = this._titleHeight = dojo.marginBox(this.titleWrapper).h;
		
		if(this.splitter){
			// find our splitter and tie into it's drag logic
			var myid = this.id;
			dijit.registry.filter(function(w){
				return w && w.child && w.child.id == myid;
			}).forEach(dojo.hitch(this,function(w){
				this.connect(w,"_stopDrag","_afterResize");
			}));
		}
		
		this._currentSize = dojo.contentBox(this.domNode);	// TODO: can compute this from passed in value to resize(), see _LayoutWidget for example
		this._showSize = this._currentSize[(this._isHorizontal ? "h" : "w")];
		this._setupAnims();

		if(this.startExpanded){
			this._showing = true;
		}else{
			this._showing = false;
			this._hideWrapper();
			this._hideAnim.gotoPercent(99,true);
		}
		
		this._hasSizes = true;
	},
	
	_afterResize: function(e){
		var tmp = this._currentSize;						// the old size
		this._currentSize = dojo.marginBox(this.domNode);	// the new size
		var n = this._currentSize[(this._isHorizontal ? "h" : "w")]
		if(n > this._titleHeight){
			if(!this._showing){
				this._showing = !this._showing;
				this._showEnd();
			}
			this._showSize = n;
			this._setupAnims();
		}else{
			this._showSize = tmp[(this._isHorizontal ? "h" : "w")];
			this._showing = false;
			this._hideWrapper();
			this._hideAnim.gotoPercent(89,true);
		}
		
	},
	
	_setupAnims: function(){
		// summary: Create the show and hide animations
		dojo.forEach(this._animConnects, dojo.disconnect);
		
		var _common = {
				node:this.domNode,
				duration:this.duration
			},
			isHorizontal = this._isHorizontal,
			showProps = {},
			hideProps = {},
			dimension = isHorizontal ? "height" : "width"
		;

		showProps[dimension] = {
			end: this._showSize
		};
		hideProps[dimension] = {
			end: this._closedSize
		};
		
		this._showAnim = dojo.animateProperty(dojo.mixin(_common,{
			easing:this.easeIn,
			properties: showProps
		}));
		this._hideAnim = dojo.animateProperty(dojo.mixin(_common,{
			easing:this.easeOut,
			properties: hideProps
		}));

		this._animConnects = [
			dojo.connect(this._showAnim, "onEnd", this, "_showEnd"),
			dojo.connect(this._hideAnim, "onEnd", this, "_hideEnd")
		];
	},
	
	preview: function(){
		// summary: Expand this pane in preview mode (does not affect surrounding layout)

		if(!this._showing){
			this._isonlypreview = !this._isonlypreview;
		}
		this.toggle();
	},

	toggle: function(){
		// summary: Toggle this pane's visibility
		if(this._showing){
			this._hideWrapper();
			this._showAnim && this._showAnim.stop();
			this._hideAnim.play();
		}else{
			this._hideAnim && this._hideAnim.stop();
			this._showAnim.play();
		}
		this._showing = !this._showing;
	},
	
	_hideWrapper: function(){
		// summary: Set the Expando state to "closed"
		dojo.addClass(this.domNode, "dojoxExpandoClosed");
		
		dojo.style(this.cwrapper,{
			visibility: "hidden",
			opacity: "0",
			overflow: "hidden"
		});
	},
	
	_showEnd: function(){
		// summary: Common animation onEnd code - "unclose"
		dojo.style(this.cwrapper, {
			opacity: 0,
			visibility:"visible"
		});
		dojo.anim(this.cwrapper, {
			opacity: this._isonlypreview ? this.previewOpacity : 1
		}, 227);
		dojo.removeClass(this.domNode, "dojoxExpandoClosed");
		if(!this._isonlypreview){
			setTimeout(dojo.hitch(this._container, "layout"), 15);
		}else{
			this._previewShowing = true;
			this.resize();
		}
	},
	
	_hideEnd: function(){
		// summary: Callback for the hide animation - "close"

		// every time we hide, reset the "only preview" state
		if(!this._isonlypreview){
			setTimeout(dojo.hitch(this._container, "layout"), 25);
		}else{
			this._previewShowing = false;
		}
		this._isonlypreview = false;
		
	},
	
	resize: function(/* Object? */newSize){
		// summary:
		//		we aren't a layout widget, but need to act like one:
		// newSize: Object
		//		The size object to resize to

		if(!this._hasSizes){ this._startupSizes(newSize); }
		
		// compute size of container (ie, size left over after title bar)
		var currentSize = dojo.marginBox(this.domNode);
		this._contentBox = {
			w: newSize && "w" in newSize ? newSize.w : currentSize.w,
			h: (newSize && "h" in newSize ? newSize.h : currentSize.h) - this._titleHeight
		};
		dojo.style(this.containerNode, "height", this._contentBox.h + "px");

		if(newSize){
			dojo.marginBox(this.domNode, newSize);
		}

		this._layoutChildren();
	},
	
	_trap: function(e){
		// summary: Trap stray events
		dojo.stopEvent(e);
	}

});

}

if(!dojo._hasResource["plugins.dojox.layout.ExpandoPane"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.dojox.layout.ExpandoPane"] = true;
dojo.provide("plugins.dojox.layout.ExpandoPane");



dojo.declare("plugins.dojox.layout.ExpandoPane",
	[ dojox.layout.ExpandoPane ],
{

	// summary: An adaptation of dojox.layout.ExpandoPane to allow the middle
	// 			pane to be shown/hidden, with corresponding adjustments to the
	//			width of the right pane
	//
	width : null,
	minWidth : 15,
	height : null,
	minHeight : 15,
	expand : false,
	
	//postCreate : function ()
	//{
	//	console.log("ExpandoPane.postCreate    plugins.dojox.layout.ExpandoPane.postCreate");
	//
	//	this.inherited(arguments);
	//	
	//	//this.expand = arguments.expand;		
	//	//console.log("ExpandoPane.postCreate    this.expand: " + this.expand);
	//	//console.log("ExpandoPane.postCreate    this.region: " + this.region);
	//
	//},

	resize : function(node, newSize){
		//console.log("ExpandoPane.resize    plugins.dojox.layout.ExpandoPane.resize(node, newSize)");

		if ( newSize )
		{
			//console.log("ExpandoPane.resize    this.region: " + this.region + ", newSize.w: " + newSize.w);
		}

		// summary: we aren't a layout widget, but need to act like one:
		var size = dojo.marginBox(this.domNode);
		var h = size.h - this._titleHeight;
		dojo.style(this.containerNode, "height", h + "px");

		if ( newSize && newSize.w )
		{
			dojo.style(this.domNode, "width", newSize.w + "px");
		}
		
		//this.inherited(arguments);

	},


	_showEnd : function()
	{
		//console.log("ExpandoPane._showEnd    plugins.dojox.layout.ExpandoPane._showEnd");
		//console.log("ExpandoPane._showEnd    this.width: " + this.width);

		// summary: Common animation onEnd code - "unclose"	
		dojo.style(this.cwrapper, { opacity: 0, visibility:"visible" });		
		dojo.fadeIn({ node:this.cwrapper, duration:227 }).play(1);
		dojo.removeClass(this.domNode, "dojoxExpandoClosed");
		
		////console.log("ExpandoPane._showEnd    AFTER dojo.hitch(this._container, 'layout', this.region, this), 15)");

		if (this.region)
		{
			switch (this.region)
			{
				case "left" : case "center" : case "right" :
					
					//console.log("ExpandoPane._showEnd    Setting this.domNode.style.width: " + this.width);
					//console.log("ExpandoPane._showEnd    BEFORE this.domNode.style.width: " + this.domNode.style.width);
					this.domNode.style.width = this.width + "px";
					//console.log("ExpandoPane._showEnd    AFTER this.domNode.style.width: " + this.domNode.style.width);
					break;
				case "top" : case "bottom" :
					this.domNode.style.height = this.height + "px";
					break;
			}
		}

		setTimeout(dojo.hitch(this._container, "layout", this.region, this, "show"), 15);
	},


	_hideEnd : function(){
		//console.log("ExpandoPane._hideEnd    plugins.dojox.layout.ExpandoPane._hideEnd()");
		//console.log("ExpandoPane._hideEnd    this.region: " + this.region);

		if (this.region)
		{
			switch (this.region)
			{
				case "left" : case "center" : case "right" :
					//console.log("ExpandoPane._hideEnd    BEFORE this.domNode.style.width: " + this.domNode.style.width);
					dojo.style(this.domNode, "width", this.minWidth + "px");
					//this.domNode.style.width = this.minWidth + "px";
					//console.log("ExpandoPane._hideEnd    AFTER this.domNode.style.width: " + this.domNode.style.width);
										break;
				case "top" : case "bottom" :
					dojo.style(this.domNode, "width", this.minHeight + "px");
					//this.domNode.style.height = this.minHeight + "px";
					break;
			}
		}

		setTimeout(dojo.hitch(this._container, "layout", this.region, this, "hide" ), 15);
	}

});

}

if(!dojo._hasResource["plugins.files.TitlePane"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.files.TitlePane"] = true;

dojo.provide("plugins.files.TitlePane");

// INHERITS



// HAS A


dojo.declare("plugins.files.TitlePane",
	[dijit.TitlePane, plugins.core.Common], {

// summary: A pane with a title on top, that can be opened or collapsed.

// className : String. Name of class
className: "filesTitlePane",

// title: String. Title of the pane
title: "",

// open: Boolean. Whether pane is opened or closed.
open: true,

// duration: Integer
//		Time in milliseconds to fade in/fade out
duration: dijit.defaultDuration,

// baseClass: String
//	The root className to use for the various states of this widget
baseClass: "filesTitlePane",

// templateString: String, set to null so that template is loaded from templatePath
templateString : null,

// templatePath: String, Path to html template
templateString:"<div dojoAttachPoint=\"containerNode\">\r\n\r\n\t\t<div dojoAttachEvent=\"onclick:toggle,onkeypress: _onTitleKey,onfocus:_handleFocus,onblur:_handleFocus\" tabindex=\"0\"\r\n\t\t\twaiRole=\"button\"\r\n\t\t\tclass=\"dijitTitlePaneTitle\" dojoAttachPoint=\"titleBarNode,focusNode\">\r\n\t\r\n\t\t\t<img src=\"${_blankGif}\" alt=\"\" dojoAttachPoint=\"arrowNode\" class=\"filesArrowNode\" waiRole=\"presentation\">\r\n\t\t\t\t<span dojoAttachPoint=\"arrowNodeInner\" class=\"dijitArrowNodeInner\"></span>\r\n\t\t\t\t<img src=\"${_blankGif}\" dojoAttachPoint=\"refresh\" class=\"refreshTitlePane\" dojoAttachEvent=\"onclick:reload\">\r\n\t\r\n\t\t\t<span dojoAttachPoint=\"titleNode\" class=\"dijitTitlePaneTextNode\">\r\n\t\t\t\t\r\n\t\t\t\t<table cellspacing=\"0\" cellpadding=\"0\" dojoAttachPoint='header' class='header'>\r\n\t\t\t\t\t<tr>\r\n\t\t\t\t\t\t<td dojoAttachPoint=\"ownerNode\" class='owner' title='Owner'></td>\r\n\t\t\t\t\t\t<td dojoAttachPoint=\"nameNode\" class='name'></td>\r\n\t\t\t\t\t\t<td dojoAttachPoint=\"locationNode\" class='location'></td>\r\n\t\t\t\t\t\t<td dojoAttachPoint=\"descriptionNode\" class='description' title='Description'></td>\r\n\t\t\t\t\t</tr>\r\n\t\t\t\t</table>\r\n\t\t\t\t\r\n\t\t\t</span>\r\n\t\t\t\r\n\t\t</div>\r\n\t\t<div class=\"dijitTitlePaneContentOuter\" dojoAttachPoint=\"hideNode\">\r\n\t\t\t<div class=\"dijitReset\" dojoAttachPoint=\"wipeNode\">\r\n\t\t\t\t<div class=\"dijitTitlePaneContentInner\" dojoAttachPoint=\"containerNode\" waiRole=\"region\" tabindex=\"-1\">\r\n\t\t\t\t\t<!-- nested divs because wipeIn()/wipeOut() doesn't work right on node w/padding etc.  Put padding on inner div. -->\r\n\t\t\t\t</div>\r\n\t\t\t</div>\r\n\t\t</div>\r\n</div>\r\n",

// ccsFiles: Array. Paths to CSS files
cssFiles: [ dojo.moduleUrl("plugins") + "/files/css/titlepane.css" ],

// reloadCallback : Function. Function to call when 'reload' button clicked
reloadCallback : null,

// core: Object. { files: XxxxxFiles object, folders: Folders object, etc. }
core : null,

// directory: String. Filesystem location
directory: "",

// name: String. Name of filesystem
name: "",

// owner: String. Owner of filesystem
owner: "",

// location: String. Description of filesystem
location: "",

// description: String. Description of filesystem
description: "",

//// ownerNode: DIV element, insert owner name into its innerHTML
//ownerNode : null,

// size: Integer. Size of icons and fonts in title
size: 'normal',

// type: String. Type of filesystem
type: "",

attributeMap: dojo.delegate(dijit.layout.ContentPane.prototype.attributeMap, {
	title: { node: "titleNode", type: "innerHTML" },
	number: { node: "numberNode", type: "innerHTML" },
	tooltip: {node: "focusNode", type: "attribute", attribute: "title"},	// focusNode spans the entire width, titleNode doesn't
	id:""
}),

/////}}}
constructor: function(args){
	//console.log("TitlePane.constructor    args:");
	//console.dir({args:args});

	this.title = args.title || '';
	this.size = args.size || '';
	this.name = args.name || '';
	this.owner = args.owner || '';
	this.location = args.location || '';
	this.description = args.description || '';
	this.core = args.core;
},
postCreate: function(){	
	//////console.log("TitlePane.postCreate    this.directory: " + dojo.toJson(this.directory));

	// LOAD CSS
	this.loadCSS(this.cssFiles);

	if ( this.owner ) this.ownerNode.innerHTML = this.owner;
	if ( this.name ) this.nameNode.innerHTML = this.name;
	if ( this.location ) this.locationNode.innerHTML = this.location;
	if ( this.description ) this.descriptionNode.innerHTML = this.description;
	
	// SET TITLE FOR FILESYSTEM TYPE
	var defaultName = "Type of filesystem";
	//if ( this.type != null ) defaultName = this.type;
	if ( ! this.name ) this.nameNode.setAttribute('title', defaultName);

	// ADJUST SIZE IF SPECIFIED	
	if ( this.size == 'large' )
	{
		////console.log("TitlePane.postCreate    Setting size to 'large'");
		this.arrowNode.setAttribute('class', 'largeFilesArrowNode');
	}
	
	if ( this.size == 'larger' )
	{
		////console.log("TitlePane.postCreate    Setting size to 'larger'");
		this.arrowNode.setAttribute('class', 'largerFilesArrowNode');
	}

	console.log("TitlePane.postCreate    BEFORE this.inherited(arguments)");
	this.inherited(arguments);

	console.log("TitlePane.postCreate    AFTER this.inherited(arguments)");
},
reload : function (event) {
// RELOAD FileDrag OBJECT INSIDE TITLE PANE	
	//console.log("TitlePane.reload    TitlePane.reload()");
	event.stopPropagation();

	//console.log("TitlePane.reload    this.directory: ");
	//console.dir({this_directory:this.directory});

	if ( this.reloadCallback != null ) {
		//console.log("TitlePane.reload    Doing this.reloadCallback()");
		this.reloadCallback();
		return;
	}

	// REMOVE EXISTING FILE DRAG
	this.clear();
	
	// CREATE FILE DRAG	
	var master = this.master;
	//console.log("TitlePane.reload    Doing this.core[" + master + "].createSourceFileDrag()");
	var fileDrag = this.core[master].createFileDrag(this.directory);
	
	// ADD fileDrag TO TITLE PANE
	this.containerNode.appendChild(fileDrag.domNode);	
},
clear : function () {
	while ( this.containerNode.firstChild ) {
		var fileDrag = dijit.getEnclosingWidget(this.containerNode.firstChild);
		//console.log("TitlePane.clear    Doing fileDrag.destroy():");
		//console.dir({fileDrag:fileDrag});
		fileDrag.destroy();
	}
},
_handleFocus: function(/*Event*/ e){
	// summary: handle blur and focus for this widget
	
	// add/removeClass is safe to call without hasClass in this case
	dojo[(e.type == "focus" ? "addClass" : "removeClass")](this.focusNode, this.baseClass + "Focused");
},

destroyRecursive : function () {
	//console.log("TitlePane.destroyRecursive    Doing this.inherited(arguments)");
	this.inherited(arguments);
}

});

}

if(!dojo._hasResource["dijit.layout.LayoutContainer"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.layout.LayoutContainer"] = true;
dojo.provide("dijit.layout.LayoutContainer");



dojo.declare("dijit.layout.LayoutContainer",
	dijit.layout._LayoutWidget,
	{
	// summary:
	//		Deprecated.  Use `dijit.layout.BorderContainer` instead.
	//
	// description:
	//		Provides Delphi-style panel layout semantics.
	//
	//		A LayoutContainer is a box with a specified size (like style="width: 500px; height: 500px;"),
	//		that contains children widgets marked with "layoutAlign" of "left", "right", "bottom", "top", and "client".
	//		It takes it's children marked as left/top/bottom/right, and lays them out along the edges of the box,
	//		and then it takes the child marked "client" and puts it into the remaining space in the middle.
	//
	//		Left/right positioning is similar to CSS's "float: left" and "float: right",
	//		and top/bottom positioning would be similar to "float: top" and "float: bottom", if there were such
	//		CSS.
	//
	//		Note that there can only be one client element, but there can be multiple left, right, top,
	//		or bottom elements.
	//
	// example:
	// |	<style>
	// |		html, body{ height: 100%; width: 100%; }
	// |	</style>
	// |	<div dojoType="dijit.layout.LayoutContainer" style="width: 100%; height: 100%">
	// |		<div dojoType="dijit.layout.ContentPane" layoutAlign="top">header text</div>
	// |		<div dojoType="dijit.layout.ContentPane" layoutAlign="left" style="width: 200px;">table of contents</div>
	// |		<div dojoType="dijit.layout.ContentPane" layoutAlign="client">client area</div>
	// |	</div>
	//
	//		Lays out each child in the natural order the children occur in.
	//		Basically each child is laid out into the "remaining space", where "remaining space" is initially
	//		the content area of this widget, but is reduced to a smaller rectangle each time a child is added.
	// tags:
	//		deprecated

	baseClass: "dijitLayoutContainer",

	constructor: function(){
		dojo.deprecated("dijit.layout.LayoutContainer is deprecated", "use BorderContainer instead", 2.0);
	},

	layout: function(){
		dijit.layout.layoutChildren(this.domNode, this._contentBox, this.getChildren());
	},

	addChild: function(/*dijit._Widget*/ child, /*Integer?*/ insertIndex){
		this.inherited(arguments);
		if(this._started){
			dijit.layout.layoutChildren(this.domNode, this._contentBox, this.getChildren());
		}
	},

	removeChild: function(/*dijit._Widget*/ widget){
		this.inherited(arguments);
		if(this._started){
			dijit.layout.layoutChildren(this.domNode, this._contentBox, this.getChildren());
		}
	}
});

// This argument can be specified for the children of a LayoutContainer.
// Since any widget can be specified as a LayoutContainer child, mix it
// into the base widget class.  (This is a hack, but it's effective.)
dojo.extend(dijit._Widget, {
	// layoutAlign: String
	//		"none", "left", "right", "bottom", "top", and "client".
	//		See the LayoutContainer description for details on this parameter.
	layoutAlign: 'none'
});

}

if(!dojo._hasResource["plugins.folders.Files"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.folders.Files"] = true;
dojo.provide("plugins.folders.Files");

/*
DISPLAY THE USER'S OWN PROJECTS DIRECTORY AND ALLOW
THE USER TO BROWSE AND MANIPULATE WORKFLOW FOLDERS
AND FILES

LATER FOR MENU: DYNAMICALLY ENABLE / DISABLE MENU ITEM
attr('disabled', bool) 
*/

if ( 1 ) {



// DnD
 // Source & Target




// TOOLTIP


// INHERITS


//HAS A



// INHERITS


// MENUS




// HAS A TITLE PANE IN ITS TEMPLATE.
// ALSO INSERTS TITLE PANES INTO this.rowsNode

}

dojo.declare( "plugins.folders.Files",
	[ dijit._Widget, dijit._Templated, plugins.core.Common ], {
//Path to the template of this widget. 
templateString:"<div dojoattachpoint=\"containerNode\">\n\n\t<div\n\t\tdojoAttachPoint=\"mainNode\">\n\t\n\t\t<div\n\t\t\tdojoAttachPoint=\"titlePane\"\n\t\t\tdojoType=\"plugins.files.TitlePane\"\n\t\t\tparentWidget=\"this\"\n\t\t\tsize=\"large\"\n\t\t\ttitle=\"${title}\"\n\t\t\topen=\"${open}\"\n\t\t\twidth=\"200\">\n\t\n\t\t\t<div\n\t\t\t\tdojoAttachPoint=\"rowsNode\"\n\t\t\t\tclass=\"directories\"\n\t\t\t\t>\n\t\t\t</div>\n\t\n\t\t</div>\n\n\t</div>\n\n</div>\n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

// PROJECT NAME 
project : null,

// DEFAULT TIME (milliseconds) TO SLEEP BETWEEN FILESYSTEM LOADS
sleep : 300,

// ARRAY OF PANE NAMES TO BE LOADED IN SEQUENCE [ name1, name2, ... ]
loadingPanes : null,

// STORE FILESYSTEM fileDrag OBJECTS
fileDrags : null,

// CSS FILES
cssFiles : [
	dojo.moduleUrl("plugins", "folders/css/dialog.css"),
	dojo.moduleUrl("plugins", "files/FileDrag/FileDrag.css"),
	dojo.moduleUrl("dojox", "widget/Dialog/Dialog.css")
],

// TYPE OR PURPOSE OF FILESYSTEM
title : "Workflow",

// core: object
// Contains refs to higher objects in hierarchy
// e.g., { folders: Folders object, files: XxxxxFiles object, ... }
core : null,

// open: bool
// Whether or not title pane is open on load
open : true,

// self: string (MUST BE DEFINED)
// Name used to represent this object in this.core
self : null,

// url: String
// URL FOR REMOTE DATABASE
url: null,

//////}}
constructor : function(args) {
	//console.group("projectFiles-" + this.id + "    constructor");
	//console.log("Files.constructor    plugins.folders.Files.constructor(args)");
	//console.dir({args:args});
	
	// SET ARGS
	if ( args.open )	this.open = args.open;
	if ( this.open == null )	this.open = false;
	this.core = args.core;
	this.attachNode = args.attachNode;
	//console.log("Files.constructor    this.titlePane: " + this.titlePane);
	//console.log("Files.constructor    this.parentWidget: " + this.parentWidget);
	//console.log("Files.constructor    this.attachNode: " + this.attachNode);
	//console.log("Files.constructor    this.open: " + this.open);

	// LOAD CSS
	//console.log("Files.constructor    Doing this.loadCSS()");
	if ( args.cssFiles != null ) this.cssFiles = args.cssFiles;
	this.loadCSS(this.cssFiles);

	//console.groupEnd("projectFiles-" + this.id + "    constructor");
},
postCreate: function() {
// DO STARTUP
	//console.log("Files.postCreate    plugins.folders.Project.postCreate()");
	//console.log("Files.postCreate    this.titlePane: " + this.titlePane);
	//console.log("Files.postCreate    this.title: " + this.title);

	// SET RELOAD CALLBACK
	this.titlePane.reloadCallback = dojo.hitch(this, "reload");
	//console.log("Files.postCreate    this.titlePane.reloadCallback: " + this.titlePane.reloadCallback);

	this.startup();
},
startup : function () {
	console.group("Files    " + this.id + "    startup");

	// SET UP THE ELEMENT OBJECTS AND THEIR VALUE FUNCTIONS
	console.log("Files.startup    BEFORE this.inherited(arguments)");
	this.inherited(arguments);
	console.log("Files.startup    AFTER this.inherited(arguments)");

	// ADD THE PANE TO THE TAB CONTAINER
	console.log("Files.startup    this.mainNode: " + this.mainNode);
	console.log("Files.startup    this.attachNode: " + this.attachNode);
	console.log("Files.startup    this.attachNode.addChild: " + this.attachNode.addChild);
	console.log("Files.startup    this.attachNode.appendChild: " + this.attachNode.appendChild);

	// ADD DIRECTLY TO TAB CONTAINER		
	if ( this.attachNode.addChild != null ) {
		
		var projectFilesContainer = new dijit.layout.LayoutContainer({ title: "Files" }, this.mainNode);
		console.log("Files.startup    projectFilesContainer: " + projectFilesContainer);
		projectFilesContainer.id = "projectFilesContainer";
		this.attachNode.addChild(projectFilesContainer);
	}
    // OTHERWISE, WE ARE TESTING SO APPEND TO DOC BODY
	else {
		this.attachNode.appendChild(this.mainNode);
	}
	console.log("Files.startup    AFTER this.attachNode.appendChild(this.mainNode)");

	// SET this.fileDrags
	this.fileDrags = [];

	// LOAD TITLEPANES
	this.load();

	console.groupEnd("Files    " + this.id + "    startup");
},
reload : function () {
// RELOAD ALL FileDrag OBJECTS
	this.clear();	
	this.load();
},
getDirectories : function () {
// GET DIRECTORIES TO SEARCH FOR FILES
// *** OVERRIDE THIS IN INHERITING CLASS ***
	//console.log("Files.getDirectories    plugins.folders.Project.getDirectories()");

	var projects = Agua.getProjects();
	//console.log("Files.getDirectories    projects: " + projects);
	
	return projects;
},
clear: function () {
	while ( this.rowsNode.firstChild ) {
		this.rowsNode.removeChild(this.rowsNode.firstChild);
	}
},
load : function () {
// LOAD FILESYSTEMS
	console.group("Files    " + this.id + "    load");
	var directories = this.getDirectories();

	if ( directories == null ) {
		//console.log("Files.load	   directories is null. Returning");
		return;
	}
	console.log("Files.load	   directories.length: " + directories.length);
	console.log("Files.load	   directories: ");
	console.dir({directories:directories});

	this.titlePanes = new Array;
	//for ( var i = 0; i < 1; i++ ) {
	for ( var i = 0; i < directories.length; i++ ) {
		var directory = dojo.clone(directories[i]);
		var titlePane = this.setTitlePane(directory);
		this.titlePanes.push(titlePane);
	}
	console.groupEnd("Files    " + this.id + "    load");
},
setTitlePane : function (directory) {
// GENERATE THE FILESYSTEM PANE FOR A PROJECT
	//console.log("Files.setTitlePane	   BEFORE directory: " );
	//console.dir({directory:directory});

	if ( ! directory.owner )
		directory.owner = directory.username;
	directory.description = directory.description || '';
	directory.open = this.open;
	directory.title = this.title;

	//console.log("Files.setTitlePane	   AFTER directory:");
	//console.dir({directory:directory});

	var titlePaneNode = document.createElement('div');
	this.rowsNode.appendChild(titlePaneNode);

	this.core[this.self] = this;
	
	// CREATE TITLE PANE			
	var titlePane = new plugins.files.TitlePane({
			owner 		: 	directory.owner,
			type 		: 	directory.type,
			name		: 	directory.name,
			location	: 	directory.location,
			description	: 	directory.description,
			open		: 	directory.open,
			directory 	: 	directory,
			core 		: 	this.core,
			master		:	this.self
		},
		titlePaneNode
	);
	
	return titlePane;
},
createFileDrag : function (directory) {
// SET THE FILE SYSTEM PANE
	//console.log("Files.createFileDrag	   this.id: " + this.id);
	//console.log("Files.createFileDrag	   directory: ");
	//console.dir({directory:directory});

	// CREATE STORE	
	var store = this.createStore(directory);
	//console.log("Files.createFileDrag	   store: ");
	//console.dir({store:store});
	
	// SET core.files
	this.core[this.self] = this;

	// GENERATE NEW FileDrag OBJECT
	var fileDrag = new plugins.files.FileDrag({
			style			: 	"height: auto; width: 100%; minHeight: 50px;",
			store			: 	store,
			fileMenu		: 	this.fileMenu,
			folderMenu		: 	this.folderMenu,
			workflowMenu	: 	this.workflowMenu,
			core			: 	this.core,
			parentWidget	:	this,
			owner			:	directory.owner,
			path			:	directory.name,
			description		:	directory.description || ''
		}
	);
	
	// ADD TO this.fileDrags
	this.fileDrags.push(fileDrag);	

	// START UP FileDrag
	fileDrag.startup();
	
	return fileDrag;
},
addChild : function (directory) {
	// CREATE TITLEPANE
	var titlePane = this.setTitlePane(directory);
	this.titlePanes.push(titlePane);
	
	// SET FILECACHE
	var name 		= directory.name;
	var username 	= directory.owner;
	var entry		 = {"name":name,"path":name,"total":"0","items":[]};
	Agua.setFileCache(username, name, entry);
	
	// LOAD FILEDRAG
	var event = { stopPropagation : function () {} };
	titlePane.reload(event);
},
removeChild : function (fileDrag) {
	//console.log("Files.removeChild    fileDrag:");
	//console.dir({fileDrag:fileDrag});
	
	if ( ! this.fileDrags ) return false;
	for ( var i = 0; i < this.fileDrags.length; i++ ) {
		if ( this.fileDrags[i] == fileDrag ) {
			this.fileDrags.splice(i, 1);
			//console.log("Files.removeChild    Doing destroyRecursive on child " + i);
			fileDrag.destroyRecursive();
			
			var panes = this.titlePanes.splice(i,1);
			var titlePane = panes[0];
			//console.log("Files.removeChild    titlePane: ");
			//console.dir({titlePane:titlePane});
			titlePane.destroyRecursive();
			
			return true;
		}
	}
	
	return false;
},
getPutData : function (directory) {
// **** OVERRIDE THIS IN SUBCLASS ****
	//console.log("Files.getPutData    this.id: " + this.id);
	//console.log("Files.getPutData    directory:");
	//console.dir({directory:directory});

	var putData = new Object;
	putData.mode 		= 	"fileSystem";
	putData.username 	= 	Agua.cookie('username');
	putData.sessionid	=	Agua.cookie('sessionid');
	putData.url			=	this.url;
	putData.path		=	directory.name;

	//console.log("Files.getPutData    putData: ");
	//console.dir({putData:putData});

	return putData;
},
createStore : function (directory) {
// CREATE STORE FOR FILE DRAG
	//console.log("Files.createStore     this.id: " + this.id);
	//console.log("Files.createStore	   directory:");
	//console.dir({directory:directory});
	
	// SET URL
	var url 	= this.url;
	var putData	= this.getPutData(directory);
	
	// CREATE STORE
	var store = new plugins.dojox.data.FileStore({
		url					: 	url,
		putData				: 	putData,
		pathAsQueryParam	: 	true,
		parentPath			: 	this.parentPath,
		path				: 	directory.name
	});
	
	// SET FILE STORE path TO project
	store.preamble = function() {
		//console.log("Files.load	   store.preamble	plugins.folders.Files.store.preamble()");
		//console.log("Files.load	   store.preamble	Setting this.store.path = this.arguments[0].path = " + this.arguments[0].path);
		this.store.path = this.arguments[0].path;                     	};

	return store;		
},
openLocation : function (location, username) {
    console.log("Files.openLocation    location: " + location);
    console.log("Files.openLocation    username: " + username);
    
    var folders = location.split(/\//);
    var projectName = folders[0];
    var fileDrag = this.getFileDragByProject(projectName);
    console.log("Files.openLocation    fileDrag: ");
    console.dir({fileDrag:fileDrag});
    if ( ! fileDrag ) {
        //console.log("Files.openLocation    fileDrag is NULL. RETURNING");
        return;
    }

    var dragPanes = fileDrag.getChildren();
    console.dir({dragPanes:dragPanes});
    if ( ! dragPanes )
        fileDrag.startup();
    dragPanes = fileDrag.getChildren();
    console.log("Files.openLocation    dragPanes.length: " + dragPanes.length);
    //console.dir({dragPanes:dragPanes});

    if ( folders.length < 2 )    return;

    console.log("Files.openLocation    Doing this.folderRoundRobin(" + location + ", 1)");
    this.folderRoundRobin(location, 1);    
},
folderRoundRobin : function (location, index) {
	console.log("Files.folderRoundRobin    location: " + location);
	console.log("Files.folderRoundRobin    index: " + index);
	console.log("Files.folderRoundRobin    caller: " + this.folderRoundRobin.caller.nom);
	
	// SET FOLDERS
	var folders = location.split(/\//);
	console.log("Files.folderRoundRobin    folders.length: " + folders.length);
	
	// GET DRAG PANES
	var projectName = folders[0];
	var fileDrag = this.getFileDragByProject(projectName);
	console.dir({fileDrag:fileDrag});    
	var dragPanes = fileDrag.getChildren();
	console.log("Files.folderRoundRobin    dragPanes.length: " + dragPanes.length);

	// REMOVE dojo.connect ON PREVIOUS DRAG PANE
	if ( index > 1 ) {
		console.log("Files.folderRoundRobin    Removing connection for previous dragPane");
		var previousDragPane = dragPanes[index - 1];	
		if ( previousDragPane._connection )
			dojo.disconnect(previousDragPane._connection);
	}

	// SET CALLBACK
	var callback = dojo.hitch(this, "connectRoundRobin", fileDrag, location, index + 1);	

	// OPEN PANE IF NOT OPEN
	var thisObject;
	if ( dragPanes.length < index + 1 ) {
		if ( (index + 1) <= folders.length ) {
			this.openFolder(dragPanes[index - 1], folders[index], callback);
		}
	}
	else {
		// REOPEN PANE IF WRONG FOLDER IS OPEN
		var dragPane = dragPanes[index];
		console.log("Files.folderRoundRobin    dragPane " + index + ": " + dragPane);
		var path = dragPane.path;
		console.log("Files.folderRoundRobin    Doing folder " + index + " path: " + path);
		var folderPath = this.folderPathByIndex(folders, index);
		console.log("Files.folderRoundRobin    Doing folder " + index + " folderPath: " + folderPath);
		
		if ( folderPath != path )
			this.openFolder(dragPanes[index - 1], folders[index], callback);
	}
},
openFolder : function (dragPane, name, callback) {
	//console.log("Files.openFolder    dragPane: " + dragPane);
	//console.log("Files.openFolder    name: " + name);
	
	// REMOVE 'SELECTED' STYLE ON ANY SELECTED ITEMS
	dragPane._dragSource._removeSelection();
	
	var itemIndex = this.getItemIndexByName(dragPane, name);
	//console.log("Files.openFolder    itemIndex: " + itemIndex);
	if ( itemIndex < 0 )	return;
	
	var items = dragPane._dragSource.getAllNodes();
	//console.log("Files.openFolder    items:");
	//console.dir({items:items});
	
	// ADD CLASS dojoDndItemAnchor TO OPENED FOLDER
	//console.log("Files.openFolder    Adding class 'dojoDndItemAnchor' to item " + itemIndex);
	dojo.addClass(items[itemIndex], 'dojoDndItemAnchor');
	
    var item = items[itemIndex].item;
    var event = { target: { item: item } };
	//console.log("Files.openFolder    event:");
	//console.dir({event:event});

	//console.log("Files.openFolder    BEFORE this._connection:");
	//console.dir({this_connection:this._connection});
	if ( this._connection )
		dojo.disconnect(this._connection);
	//console.log("Files.openFolder    AFTER this._connection:");
	//console.dir({this_connection:this._connection});

	delete this._connection;
	this._connection = dojo.connect(dragPane.parentWidget, "addChild", dojo.hitch(this, callback));
	
    dragPane.onclickHandler(event);	
},
testCallback : function (itemPane, index, fileDrag) {
	//console.log("Files.testCallback    fileDrag: " + fileDrag);

},
connectRoundRobin : function (fileDrag, location, index) {
	//console.log("Files.connectRoundRobin    fileDrag:");
	//console.dir({fileDrag:fileDrag});
	//console.log("Files.connectRoundRobin    location: " + location);
	//console.log("Files.connectRoundRobin    index: " + index);

	var dragPanes = fileDrag.getChildren();
	var dragPane = dragPanes[dragPanes.length - 1];
	//console.log("Files.connectRoundRobin    dragPane:");
	//console.dir({dragPane:dragPane});
	
	dragPane._connection = dojo.connect(dragPane, "onLoad", dojo.hitch(this, "folderRoundRobin", location, index));
},
getFileDragByProject : function (projectName) {
	//console.log("Files.getFileDragByProject    projectName: " + projectName);
	//console.log("Files.getFileDragByProject    this.fileDrags.length: " + this.fileDrags.length);
	//console.log("Files.getFileDragByProject    this.fileDrags:");
	//console.dir({this_fileDrags:this.fileDrags});

	for ( var i = 0; i < this.fileDrags.length; i++ ) {
		var fileDrag = this.fileDrags[i];
		//console.log("Files.getFileDragByProject    Checking fileDrag.path " + i + ": " + fileDrag.path);

		if ( fileDrag.path == projectName ) {
			//console.log("Files.getFileDragByProject    Returning fileDrag for project: " + projectName);
			return fileDrag;
		}
	}
	
	return null;
},
refreshFileDrags : function () {
    var projects = Agua.getProjects();
    //console.dir({projects:projects});

	var fileDragNodes = dojo.query(".dojoxFileDrag");
	this.fileDrags = [];
	for ( var i = 0; i < fileDragNodes.length; i++ ) {
		this.fileDrags.push(dijit.byNode(fileDragNodes[i]));
	}
	//console.log("Files.refreshFileDrags    this.fileDrags: ");
	//console.dir({this_fileDrags:this.fileDrags}); 
},
getItemIndexByName : function (dragPane, name) {
	//console.log("Files.getItemIndexByName    dragPane: " + dragPane);
	//console.log("Files.getItemIndexByName    name: " + name);
	var dndItems = dragPane._dragSource.getAllNodes();
	//console.log("Files.getItemIndexByName    dndItems.length: " + dndItems.length);
	//console.dir({dndItems:dndItems});
	for ( var i = 0; i < dndItems.length; i++ ) {
		////console.log("Files.getItemIndexByName    dndItems[" + i + "].item.name: " + dndItems[i].item.name);
		if ( dndItems[i].item.name == name )
			return i;
	}

	return -1;
},
folderPathByIndex : function (folders, index) {
	if ( index > folders.length - 1)	return;

	var path = '';
	for ( var i = 0; i < index + 1; i++ ) {
		if ( i > 0 )
			path += "/";
		path += folders[i];
	}
	
	return path;
}
});


}

if(!dojo._hasResource["plugins.folders.ProjectFiles"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.folders.ProjectFiles"] = true;
dojo.provide("plugins.folders.ProjectFiles");
/*
DISPLAY THE USER'S OWN PROJECTS DIRECTORY AND ALLOW
THE USER TO BROWSE AND MANIPULATE WORKFLOW FOLDERS
AND FILES

LATER FOR MENU: DYNAMICALLY ENABLE / DISABLE MENU ITEM
attr('disabled', bool) 
*/

if ( 1 ) {

}

dojo.declare( "plugins.folders.ProjectFiles",
	[ plugins.folders.Files ], {
//Path to the template of this widget. 
templateString:"<div dojoattachpoint=\"containerNode\">\n\n\t<div\n\t\tdojoAttachPoint=\"mainNode\">\n\t\n\t\t<div\n\t\t\tdojoAttachPoint=\"titlePane\"\n\t\t\tdojoType=\"plugins.files.TitlePane\"\n\t\t\tparentWidget=\"this\"\n\t\t\tsize=\"large\"\n\t\t\ttitle=\"${title}\"\n\t\t\topen=\"${open}\"\n\t\t\twidth=\"200\">\n\t\n\t\t\t<div\n\t\t\t\tdojoAttachPoint=\"rowsNode\"\n\t\t\t\tclass=\"directories\"\n\t\t\t\t>\n\t\t\t</div>\n\t\n\t\t</div>\n\n\t</div>\n\n</div>\n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

// PROJECT NAME 
project : null,

// DEFAULT TIME (milliseconds) TO SLEEP BETWEEN FILESYSTEM LOADS
sleep : 300,

// ARRAY OF PANE NAMES TO BE LOADED IN SEQUENCE [ name1, name2, ... ]
loadingPanes : null,

// STORE FILESYSTEM fileDrag OBJECTS
fileDrags : null,

// CSS FILES
cssFiles : [
	dojo.moduleUrl("plugins", "folders/css/dialog.css"),
//	dojo.moduleUrl("plugins", "files/FileDrag/FileDrag.css"),
	dojo.moduleUrl("dojox", "widget/Dialog/Dialog.css")
],

// TYPE OR PURPOSE OF FILESYSTEM
title : "Workflow",

// open: bool
// Whether or not title pane is open on load
open : true,

// self: string
// Name used to represent this object in this.core
self : "projectfiles"


});

}

if(!dojo._hasResource["plugins.folders.SourceFiles"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.folders.SourceFiles"] = true;
dojo.provide("plugins.folders.SourceFiles");
/*
DISPLAY THE USER'S OWN SOURCES DIRECTORY AND ALLOW
THE USER TO BROWSE AND MANIPULATE FOLDERS AND FILES

LATER FOR MENU: DYNAMICALLY ENABLE / DISABLE MENU ITEM
attr('disabled', bool) 
*/

// INHERITS



dojo.declare( "plugins.folders.SourceFiles",
	[ plugins.folders.Files ], {
//Path to the template of this widget. 
templateString:"<div dojoattachpoint=\"containerNode\">\n\n\t<div\n\t\tdojoAttachPoint=\"mainNode\">\n\t\n\t\t<div\n\t\t\tdojoAttachPoint=\"titlePane\"\n\t\t\tdojoType=\"plugins.files.TitlePane\"\n\t\t\tparentWidget=\"this\"\n\t\t\tsize=\"large\"\n\t\t\ttitle=\"${title}\"\n\t\t\topen=\"${open}\"\n\t\t\twidth=\"200\">\n\t\n\t\t\t<div\n\t\t\t\tdojoAttachPoint=\"rowsNode\"\n\t\t\t\tclass=\"directories\"\n\t\t\t\t>\n\t\t\t</div>\n\t\n\t\t</div>\n\n\t</div>\n\n</div>\n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

// core: Object. { files: XxxxxFiles object, folders: Folders object, etc. }
core : null,

// PROJECT NAME AND WORKFLOW NAME IF AVAILABLE
project : null,

// DEFAULT TIME (milliseconds) TO SLEEP BETWEEN FILESYSTEM LOADS
sleep : 250,

// open: bool
// Whether or not title pane is open on load
open : false,

// self: string
// Name used to represent this object in this.core
self : "sourcefiles",

/////}}}

// CONSTRUCTOR	
constructor : function(args) {
	//console.group("sourceFiles-" + this.id + "    constructor");

	////console.log("SourceFiles.constructor    plugins.folders.SourceFiles.constructor(args)");
	
	// SET PANE ID
	this.paneId = args.paneId;

	// SET ARGS
	this.project 	= args.project;
	this.core 		= args.core;
	this.attachNode = args.attachNode;
	////console.log("SourceFiles.constructor    this.parentWidget: " + this.parentWidget);
	////console.log("SourceFiles.constructor    this.attachNode: " + this.attachNode);
	////console.log("SourceFiles.constructor    this.project: " + this.project);

	// LOAD CSS
	////console.log("SourceFiles.constructor    Doing this.loadCSS()");
	this.loadCSS();

	//console.groupEnd("sourceFiles-" + this.id + "    constructor");
},

postCreate: function() {
	////console.log("SourceFiles.postCreate    plugins.folders.Project.postCreate()");

	this.startup();
},


startup : function () {
// START MENUS
	////console.log("SourceFiles.startup    plugins.folders.Project.startup()");

	// SET UP THE ELEMENT OBJECTS AND THEIR VALUE FUNCTIONS
	this.inherited(arguments);
},

load: function () {
	//console.group("sourceFiles-" + this.id + "    load");

	this.inherited(arguments);
	
	//console.groupEnd("sourceFiles-" + this.id + "    load");
},

getDirectories : function () {
// GET DIRECTORIES TO SEARCH FOR FILES
	return Agua.getSources();
},

createFileDrag : function (directory) {
// SET THE FILE SYSTEM PANE
	//console.log("SourceFiles.createFileDrag	   plugins.folders.ProjectFiles.createFileDrag(directory)");	   
	//console.log("SourceFiles.createFileDrag	   directory: ");
	//console.dir({directory:directory});

	// CREATE STORE	
	var store = this.createSourceStore(directory);

	// SET core
	this.core[this.self] = this;

	// GENERATE NEW FileDrag OBJECT
	var fileDrag = new plugins.files.FileDrag(
		{
			style			: 	"height: auto; width: 100%; minHeight: 50px;",
			store			: 	store,
			fileMenu		: 	this.fileMenu,
			folderMenu		: 	this.folderMenu,
			workflowMenu	: 	this.workflowMenu,
			core			: 	this.core,
			parentWidget	:	this,
			owner			: 	directory.owner,
			path			:	'',
			description		:	directory.description || ''
		}
	);
	
	// ADD TO this.fileDrags
	this.fileDrags.push(fileDrag);	

	// START UP FileDrag
	fileDrag.startup();
	
	return fileDrag;
},

createSourceStore : function (directory) {
// CREATE STORE FOR FILE DRAG
	//console.log("ProjectFiles.createStore     this.id: " + this.id);
	//console.log("ProjectFiles.createStore	   directory:");
	//console.dir({directory:directory});
	
	// SET URL
	var url 	= this.url;
	var putData	= this.getSourcePutData(directory);
	
	// CREATE STORE
	var store = new plugins.dojox.data.FileStore({
		url					: 	url,
		putData				: 	putData,
		pathAsQueryParam	: 	true,
		parentPath			: 	this.parentPath,
		path				: 	directory.name
	});
	
	return store;		
},

getSourcePutData : function (directory) {
// CREATE DATA OBJECT FOR xhrPut
	//console.log("SourceFiles.getPutData    this.id: " + this.id);
	//console.log("SourceFiles.getPutData    directory:");
	//console.dir({directory:directory});

	var putData = new Object;
	putData.mode 		= 	"fileSystem";
	putData.username 	= 	Agua.cookie('username');
	putData.sessionid	=	Agua.cookie('sessionid');
	putData.location	=	directory.location;
	putData.url			=	Agua.cgiUrl + "folders.cgi?";

	//console.log("SourceFiles.getPutData    putData: ");
	//console.dir({putData:putData});

	return putData;
}

	
});


/*
 
 setFileDrag : function (directory) {
	//console.log("SourceFiles.setFileDrag	   plugins.folders.SourceFiles.setFileDrag(directory)");	   
	//console.log("SourceFiles.setFileDrag	   directory: ");
	//console.dir({directory:directory});

	var owner = directory.username;
	var name = directory.name;
	var description = directory.description;
	var location = directory.location;
	if ( ! description ) { description = '' };
		
	var titlePane = this.createTitlePane(
	{
		owner: owner,
		name: name,
		description: description,
		location: location,
		open: this.open
	});

	// REMOVE NAME TO SET QUERY AS ''
	var thisStore = this.createStore(directory);
	
	// GENERATE NEW FileDrag OBJECT
	var fileDrag = new plugins.files.FileDrag(
		{
			style: "height: auto; width: 100%; minHeight: 50px;",
			store: thisStore,
			fileMenu: this.fileMenu,
			folderMenu: this.folderMenu,
			workflowMenu: this.workflowMenu,
			owner: owner,
			parentWidget: this
		}
	);
	
	// SET PATH AS LOCATION
	////console.log("SourceFiles.setFileDrag	   BEFORE replace directory.location: **" + directory.location + "**");
	directory.location = directory.location.replace(/\s+/g, '');
	//console.log("SourceFiles.setFileDrag	   AFTER replace directory.location: **" + directory.location + "**");

	fileDrag.path = directory.location;                    
	
	// START UP FileDrag
	fileDrag.startup();

//////console.log("SourceFiles.load	   ////console.dir(fileDrag): " + fileDrag);
//////console.dir(fileDrag);
	
	// ADD fileDrag TO TITLE PANE
	titlePane.containerNode.appendChild(fileDrag.domNode);
},

 */

}

if(!dojo._hasResource["plugins.folders.SharedProjectFiles"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.folders.SharedProjectFiles"] = true;
dojo.provide("plugins.folders.SharedProjectFiles");

// **********************
// *** LOAD SHARED PROJECTS  ****
// **********************

// LATER FOR MENU: DYNAMICALLY ENABLE / DISABLE MENU ITEM
// attr('disabled', bool) 

// DISPLAY THE SHARED PROJECT DIRECTORIES AND ALLOW
// THE USER TO BROWSE AND COPY FILES AND WORKFLOWS

// INHERITS


dojo.declare( "plugins.folders.SharedProjectFiles",
	[ plugins.folders.Files ], {

// open: bool
// Whether or not title pane is open on load
open : true,

// self: string
// Name used to represent this object in this.core
self : "sharedprojectfiles",

////}}}}}

load : function () {
// *** LOAD FILESYSTEM ****
	console.group("sharedProjectFiles    " + this.id + "    load");

	this.titlePanes = new Array;
	
	var usernames = Agua.getSharedUsernames();
	//console.log("SharedProjectFiles.loadSharedProjects	   usernames: ");
	//console.dir({usernames:usernames});
	for ( var j = 0; j < usernames.length; j++ )
	//for ( var j = 0; j < 1; j++ )
	{
		//console.log("SharedProjectFiles.loadSharedProjects	   usernames[" + j + "] : " + dojo.toJson(usernames[j]));
		
		if ( usernames[j] == "agua" ) {
			//console.log("SharedProjectFiles.loadSharedProjects	   user is 'agua'. Doing 'continue'");
			continue;
		}

		var directories = Agua.getSharedProjectsByUsername(usernames[j]);
		////console.log("SharedProjectFiles.loadSharedProjects	   directories: " + dojo.toJson(directories));

		for ( var i = 0; i < directories.length; i++ )
		{
			//console.log("SharedProjectFiles.loadSharedProjects	   directory " + i + " : ")
			//console.dir({directory:directories[i]});

			var directory 	= dojo.clone(directories[i]);
			directory.open	=	this.open;
			this.titlePanes.push(this.setTitlePane(directory));
		
		} // shares

	} // usernames

	console.groupEnd("sharedProjectFiles    " + this.id + "    load");
},

createFileDrag : function (directory) {
	console.log("SharedProjectFiles.createFileDrag    directory: ");
	console.dir({directory:directory});

	var store = this.createStore(directory);

	// GENERATE NEW FileDrag OBJECT
	var fileDrag = new plugins.files.FileDrag(
		{
			style		: 	"height: auto; width: 100%; minHeight: 50px;",
			store		: 	store,
			fileMenu	: 	this.fileMenu,
			folderMenu	: 	this.folderMenu,
			workflowMenu: 	this.workflowMenu,
			owner		: 	directory.owner,
			parentWidget: 	this,
			core		:	this.core
		}
	);

	// SET PATH FOR THIS SHARE
	//console.log("SharedProjectFiles.createFileDrag    Setting fileDrag.path = directory.name = " + directory.name);
	fileDrag.path = directory.name;                    
	
	// START UP FileDrag
	fileDrag.startup();

	return fileDrag;
},

getPutData : function (directory) {
	console.log("folders.SharedProjectFiles    directory:");
	console.dir({directory:directory});
	
	var putData = new Object;
	putData.mode 		= 	"fileSystem";
	putData.sessionid	=	Agua.cookie('sessionid');
	putData.url			=	Agua.cgiUrl + "folders.cgi?";
	putData.requestor	=	Agua.cookie('username');
	putData.username	=	directory.owner;
	putData.groupname	=	directory.groupname;

	//console.log("ProjectFiles.getPutData    putData: ");
	//console.dir({putData:putData});

	return putData;
}

});

}

if(!dojo._hasResource["plugins.folders.SharedSourceFiles"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.folders.SharedSourceFiles"] = true;
dojo.provide("plugins.folders.SharedSourceFiles");

// DISPLAY THE USER'S OWN SOURCES DIRECTORY AND ALLOW
// THE USER TO BROWSE AND MANIPULATE FOLDERS AND FILES

// LATER FOR MENU: HOW TO DYNAMICALLY
// ENABLE / DISABLE MENU ITEM
// attr('disabled', bool) 

// INHERITS


dojo.declare( "plugins.folders.SharedSourceFiles",
	[ plugins.folders.Files ], {
//Path to the template of this widget. 
templateString:"<div dojoattachpoint=\"containerNode\">\n\n\t<div\n\t\tdojoAttachPoint=\"mainNode\">\n\t\n\t\t<div\n\t\t\tdojoAttachPoint=\"titlePane\"\n\t\t\tdojoType=\"plugins.files.TitlePane\"\n\t\t\tparentWidget=\"this\"\n\t\t\tsize=\"large\"\n\t\t\ttitle=\"${title}\"\n\t\t\topen=\"${open}\"\n\t\t\twidth=\"200\">\n\t\n\t\t\t<div\n\t\t\t\tdojoAttachPoint=\"rowsNode\"\n\t\t\t\tclass=\"directories\"\n\t\t\t\t>\n\t\t\t</div>\n\t\n\t\t</div>\n\n\t</div>\n\n</div>\n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

// PARENT WIDGET
parentWidget : null,

// PROJECT NAME AND WORKFLOW NAME IF AVAILABLE
project : null,

// DEFAULT TIME (milliseconds) TO SLEEP BETWEEN FILESYSTEM LOADS
sleep : 250,

// title : string
// Label of title pane
title : "Shared Sources",

// open: bool
// Whether or not title pane is open on load
open : true,


// titlePanes: array
// List of title pane widgets belonging to this pane
titlePanes : null,

self : "sourcefiles",

/////}}}

// CONSTRUCTOR	
constructor : function(args) {
	////console.log("SharedSourceFiles.constructor    plugins.folders.SharedSourceFiles.constructor(args)");
	
	// SET PANE ID
	this.paneId = args.paneId;

	// SET ARGS
	this.project 	= args.project;
	this.core 		= args.core;
	this.attachNode = args.attachNode;
	////console.log("SharedSourceFiles.constructor    this.parentWidget: " + this.parentWidget);
	////console.log("SharedSourceFiles.constructor    this.attachNode: " + this.attachNode);
	////console.log("SharedSourceFiles.constructor    this.project: " + this.project);

	// LOAD CSS
	////console.log("SharedSourceFiles.constructor    Doing this.loadCSS()");
	this.loadCSS();
},

postCreate: function() {
	////console.log("SharedSourceFiles.postCreate    plugins.folders.SharedSourceFiles.postCreate()");

	this.startup();
},

startup : function () {
// START MENUS
	////console.log("SharedSourceFiles.startup    plugins.folders.SharedSourceFiles.startup()");

	// SET UP THE ELEMENT OBJECTS AND THEIR VALUE FUNCTIONS
	this.inherited(arguments);
},


load : function () {
// *** LOAD FILESYSTEM ****
	//console.group("sharedSourceFiles-" + this.id + "    load");

	var usernames = Agua.getSharedUsernames();
	//console.log("SharedSourceFiles.loadSharedSourceFiles	   usernames: ");
	//console.dir({usernames:usernames});
	if ( ! usernames )	{
		//console.log("SharedSourceFiles.loadSharedSourceFiles	   usernames is null. Returning");
		//console.groupEnd("sharedSourceFiles-" + this.id + "    load");
		return;
	}

	this.titlePanes = new Array;
	for ( var j = 0; j < usernames.length; j++ )
	//for ( var j = 0; j < 1; j++ )
	{
		//console.group("sharedSourceFiles-" + this.id + "    load username: " + usernames[j]);

		//console.log("SharedSourceFiles.loadSharedSourceFiles	   usernames[" + j + "] : " + dojo.toJson(usernames[j]));
		
		if ( usernames[j] == "agua" ) {
			//console.log("SharedSourceFiles.loadSharedSourceFiles	   user is 'agua'. Doing 'continue'");
			//console.groupEnd("sharedSourceFiles-" + this.id + "    load username: " + usernames[j]);
			continue;
		}

		var directories = Agua.getSharedSourcesByUsername(usernames[j]);
		//console.log("SharedSourceFiles.loadSharedSourceFiles	   username " + usernames[j] + " directories: ");
		//console.dir({directories:directories});
		
		if ( ! directories ) {
			//console.log("SharedSourceFiles.loadSharedSourceFiles	   directories is null. Doing 'continue'");
			continue;
		}
		
		for ( var i = 0; i < directories.length; i++ )
		{
			//console.log("SharedSourceFiles.loadSharedSourceFiles	   directory " + i + " : ")
			//console.dir({directory:directories[i]});

			var directory 	= dojo.clone(directories[i]);
			directory.open	=	this.open;
			this.titlePanes.push(this.setTitlePane(directory));
			
		
			////console.log("SharedSourceFiles.load    BEFORE this.createStore(directories[i]). directory: ");
			////console.dir({directory:directory});
			//var store = this.createStore(directory);
			//
			//// GENERATE NEW FileDrag OBJECT
			//var fileDrag = new plugins.files.FileDrag({
			//	style			: 	"height: auto; width: 100%; minHeight: 50px;",
			//	store			: 	store,
			//	fileMenu		: 	this.fileMenu,
			//	folderMenu		: 	this.folderMenu,
			//	workflowMenu	: 	this.workflowMenu,
			//	owner			: 	directory.owner,
			//	parentWidget	: 	this,
			//	core			:	this.core
			//});
			//
			//// SET PATH FOR THIS SHARE
			////console.log("SharedSourceFiles.load    Setting fileDrag.path = directory.location = " + directory.location);
			//fileDrag.path = directory.location;                    
			//
			//// START UP FileDrag
			//fileDrag.startup();
			//
			//// ADD directoryDrag TO TITLE PANE
			//titlePane.containerNode.appendChild(fileDrag.domNode);

			////console.log("SharedSourceFiles.load    BREAK");
//break;

		} // shares

		//console.groupEnd("sharedSourceFiles-" + this.id + "    load username: " + usernames[j]);

	} // usernames

	//console.groupEnd("sharedSourceFiles-" + this.id + "    load");
},

getDirectories : function () {
// GET DIRECTORIES TO SEARCH FOR FILES
	return Agua.getSharedSources();
},


createFileDrag : function (directory) {
	////console.log("SharedSourceFiles.setFileDrag	   plugins.folders.SharedSourceFiles.setFileDrag(directory)");
	//console.log("SharedSourceFiles.createFileDrag	   directory: ");
	//console.dir({directory:directory});
	
	var store = this.createStore(directory);
	
	// GENERATE NEW FileDrag OBJECT
	var fileDrag = new plugins.files.FileDrag({
		style			: 	"height: auto; width: 100%; minHeight: 50px;",	
		store			: 	store,
		fileMenu		: 	this.fileMenu,
		folderMenu		: 	this.folderMenu,
		workflowMenu	: 	this.workflowMenu,
		owner			: 	directory.owner,
		parentWidget	: 	this,
		core			:	this.core
	});
	
	// SET PATH AS LOCATION
	fileDrag.path = directory.location;                    
	
	// ADD TO this.fileDrags
	this.fileDrags.push(fileDrag);	

	// START UP FileDrag
	fileDrag.startup();
	
	// ADD fileDrag TO TITLE PANE
	return fileDrag;
},

getPutData : function (directory) {
// CREATE DATA OBJECT FOR xhrPut

	//console.log("SharedSourceFiles.getPutData    directory:");
	//console.dir({directory:directory});

	var putData = new Object;
	putData.mode 		= 	"fileSystem";
	putData.requestor 	= 	Agua.cookie('username');
	putData.sessionid	=	Agua.cookie('sessionid');
	putData.location	=	directory.location;
	putData.url			=	Agua.cgiUrl + "folders.cgi?";
	putData.username	=	directory.owner;
	putData.owner		=	directory.owner;
	putData.location	=	directory.location;
	putData.groupname	=	directory.groupname;

	//console.log("SharedSourceFiles.getPutData    putData: ");
	//console.dir({putData:putData});

	return putData;
}

//,

//createStore : function (directory) {
//// CREATE STORE FOR FILE DRAG
//	////console.log("SharedSourceFiles.createStore     plugins.folders.SharedSourceFiles.createStore(directory)");
//	////console.log("SharedSourceFiles.createStore     directory: " + dojo.toJson(directory, true));
//	
//	
//	// SET URL
//	var url = this.url;
//	
//	// CREATE STORE
//	var store = new dojox.data.FileStore(
//		{
//			//id: paneNodeId + "-fileStore",
//			url: url,
//			pathAsQueryParam: true
//		}
//	);
//	
//	// SET FILE STORE path TO project
//	store.preamble = function()
//	{
//		////console.log("SharedSourceFiles.load	   store.preamble	plugins.folders.SharedSourceFiles.store.preamble()");
//		this.store.path = this.arguments[0].path;                        
//	};
//
//	return store;		
//},

//setTitlePane : function (directory) {
//// CREATE TITLE PANE
//	//console.log("SharedSourceFiles.setTitlePane	   BEFORE directory: " );
//	//console.dir({directory:directory});
//
//	directory.owner = directory.username;
//	directory.description = directory.description || '';
//	directory.open = this.open;
//	directory.title = this.title;
//
//	//console.log("SharedSourceFiles.setTitlePane	   AFTER directory:");
//	//console.dir({directory:directory});
//
//	var titlePaneNode = document.createElement('div');
//	this.rowsNode.appendChild(titlePaneNode);
//
//	// CREATE TITLE PANE			
//	var titlePane = new plugins.files.TitlePane({
//			owner 			: directory.owner,
//			type 			: directory.type,
//			name			: directory.name,
//			description		: directory.description,
//			open			: this.open,
//			//reloadCallback : callback,
//			directory 		: directory,
//			parentWidget 	: this,
//			core			:	this.core
//		},
//		titlePaneNode
//	);
//
//
//	return titlePane;
//}

	

});


}

if(!dojo._hasResource["plugins.files.FileManager"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.files.FileManager"] = true;
dojo.provide("plugins.files.FileManager");

/*
DISPLAY THE USER'S PROJECTS DIRECTORY AND ALLOW
THE USER TO BROWSE FILES AND MANIPULATE WORKFLOW
FOLDERS AND FILES   
*/

// EXTERNAL MODULES
if ( 1 ) {



// DIALOG FLOATING PANE


 // Source & Target






// INTERNAL MODULES








}

dojo.declare( "plugins.files.FileManager",
	[ dijit._Widget, dijit._Templated, plugins.core.Common ], {

//Path to the template of this widget. 
templateString:"<div dojoAttachPoint=\"containerNode\">\n\n\t<div\n\t\tdojoAttachPoint=\"mainTab\"\n\t\tclass=\"folders\"\n\t\ticonClass=\"dijitEditorIcon dijitEditorIconProject\"\n\t\tminWidth=\"1000\"\n\t\tstyle=\"position: relative; min-width: auto !important; width: 100% !important; height: auto !important; padding: 0px; background: #FFF; overflow-y: scroll\"\n\t\tclosable=\"true\"\n\t\tscrollbar=\"true\"\n\t\tdojoType=\"dijit.layout.ContentPane\"\n\t>\n\t\t\n\t\t<div\n\t\t\tdojoAttachPoint=\"projectsNode\"\n\t\t\t>\n\t\t</div>\n\n\t\t<div\n\t\t\tdojoAttachPoint=\"sourcesNode\"\n\t\t\t>\n\t\t</div>\n\n\t\t<div\n\t\t\tdojoAttachPoint=\"sharedProjectsNode\"\n\t\t\t>\n\t\t</div>\n\n\t\t<div\n\t\t\tdojoAttachPoint=\"sharedSourcesNode\"\n\t\t\t>\n\t\t</div>\n\n    </div>\n\n</div>\n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

// STORE DND SOURCE ID AND DND TARGET ID
sourceId: '',

// OWNER workflowObject
workflowObject : null,

// ID FOR THIS FILE MANAGER DIALOG PANE
dialogId : null,

// CSS FILES
cssFiles : [
	dojo.moduleUrl("plugins", "files/css/filemanager.css"),
	dojo.moduleUrl("dojox", "layout/resources/FloatingPane.css")
	//, dojo.moduleUrl("plugins", "folders/css/folders.css")
],

// callback FUNCTION AND DATA FROM OBJECT THAT GENERATED THE FileManager
callback : null,

// CORE WORKFLOW OBJECTS
core : null,

// CORE WORKFLOW OBJECTS:
// 	dialog:		DIALOGUE TO DISPLAY FILE MANAGER
//	nodes:		CONTAINER NODES FOR PROJECTS, SOURCES, ETC. 
// 	widgets:	ARRAY OF WIDGETS FOR PROJECTS, SOURCES, ETC.
dialog : null,
	
atomic : {},
////}}}

preamble: function(){
	//console.log("FileManager.preamble	plugins.files.FileManager.preamble()");
	this.callback = arguments[0].callback;
},
constructor : function(args) {
	console.log("XXXXXX FileManager.constructor	args:");
	console.dir({args:args});

	// LOAD CSS
	this.loadCSS();

	// SET MENUS
	this.setMenus();

	// SET CORE
	this.core = new Object;
	this.core.folders = this;
},
postCreate : function() {
	//console.log("Controller.postCreate    plugins.files.Controller.postCreate()");
	this.startup();
},
startup : function () {
// INSTANTIATE AND POPULATE FILE MANAGER DIALOG

	console.log("FileManager.startup	plugins.files.FileManager.startup()");

	// COMPLETE CONSTRUCTION OF OBJECT
	console.log("FileManager.startup	BEFORE this.inherited(arguments)");
	this.inherited(arguments);	 
	console.log("FileManager.startup	AFTER this.inherited(arguments)");

console.log("startup, this.core: ");
console.log(this.core);


	// INSTANTIATE this.atomic.dialog
	this.createDialog();
	console.log("FileManager.startup	AFTER this.createDialog()");

	// SET ATOMIC
	this.setAtomic();

	//// SET REFRESH BUTTONS
	//this.setRefreshButtons();
	
	// SET NODES
	this.setNodes();

	// LOAD CONTENT (PROJECTS, SOURCES, ...)
	this.loadPanes();

	// START UP DIALOG ???
	this.atomic.dialog.startup();

	// SUBSCRIBE TO UPDATES
	Agua.updater.subscribe(this, "updateProjects");

	// SUBSCRIBE TO UPDATES
	Agua.updater.subscribe(this, "updateSources");
},
updateProjects : function (args) {
// RELOAD PROJECT PANES
	console.log("FileManager.updateProjects    Cluster.updateProjects()");
	console.log("FileManager.updateProjects    this: " + this);

	// SET DRAG SOURCE
	console.log("FileManager.updateProjects    Calling this.loadPanes()");
	this.loadProjects();
},
updateWorkflows : function (args) {
	//console.warn("Workflows.updateWorkflows    project.Workflows.updateWorkflows(args)");
	//console.warn("Workflows.updateWorkflows    args:");
	//console.dir(args);

	// REDO PARAMETER TABLE
	if ( args != null && args.originator == this )
	{
		if ( args.reload == false )	return;
	}

	//console.warn("Workflows.updateWorkflows    Calling this.loadWorkflows()");
	this.loadWorkflows;
},
updateSources : function (args) {
// RELOAD SOURCE PANES
	console.log("FileManager.updateSources    Cluster.updateSources()");
	console.log("FileManager.updateSources    this: " + this);

	// SET DRAG SOURCE
	console.log("FileManager.updateSources    Calling this.loadSourceTab()");
	this.loadSources();	
},
setMenus : function () {
	//console.log("FileManager.setMenus     plugins.project.Project.setMenus()");

	this.fileMenu = new plugins.files.FileMenu({parentWidget : this});
	this.folderMenu = new plugins.files.FolderMenu({parentWidget : this});
	this.workflowMenu = new plugins.files.WorkflowMenu({parentWidget : this});
	
	//// STOP PROPAGATION TO NORMAL RIGHTCLICK CONTEXT MENU
	//dojo.connect(this.folderMenu.menu.domNode, "oncontextmenu", function (event)
	//{
	//	event.stopPropagation();
	//});
	//
	//// STOP PROPAGATION TO NORMAL RIGHTCLICK CONTEXT MENU
	//dojo.connect(this.workflowMenu.menu.domNode, "oncontextmenu", function (event)
	//{
	//	event.stopPropagation();
	//});
},
createDialog : function () {
	console.log("FileManager.createDialog    plugins.files.FileManager.createDialog()");

	var dialogId = dojo.dnd.getUniqueId();		
	this.dialogId = dialogId;
	var node = dojo.create('div');
	document.body.appendChild(node);

	// CREATE DIALOGUE
	this.atomic.dialog = new plugins.dojox.layout.FloatingPane ({

		id			: 	dialogId,

		draggable	: 	true,
		showTitle	: 	true,
		title		: 	"File Manager",
	
		region		:	"bottom",
		dockable	:	"true",
		duration	:	"10",
		height		:	"500px",
		width		:	"900px",

		resizable	:	"true",
		maxable		:	"false",
		closable	:	"false",
		
		dockClass	:	"filesDockNode"
		
	}, node);		

	// MAKE SURE DIALOG IS MINIMIZED ON startup
	dojo.style(this.atomic.dialog.domNode, "display", "none");
	dojo.style(this.atomic.dialog.domNode, "visibility", "hidden");

	// STARTUP
	this.atomic.dialog.startup();
	
	// MAXIMISE ON SHOW
	dojo.connect(this.atomic.dialog, "_onShow", this.atomic.dialog, "maximize");
	console.log("FileManager.createDialog    AFTER create dialog");

	// SET CLASS FOR STYLE OF INSERTED PANE
	console.log("FileManager.createDialog    Doing set class 'folders dijitDialog'");
	dojo.attr(dojo.byId(dialogId), 'class', 'folders dijitDialog');

	// SET DOM NODE POSITION
	console.log("FileManager.createDialog    Doing set style.top");
	this.atomic.dialog.domNode.style.top='100px';
	
	// SET DOM NODE CLASS
	console.log("FileManager.createDialog    Doing add class 'folders'");
	dojo.addClass(this.atomic.dialog.domNode, 'folders');

	// SET FILE MANAGER DIALOGUE CONTENT TO PANE NODE
	console.log("FileManager.createDialog     Doing this.atomic.dialog.content = this.mainTab.containerNode");
	console.log("FileManager.createDialog     this.mainTab.containerNode: " + this.mainTab.containerNode);

	dojo.connect(this.atomic.dialog, "minimize", this, "disableMenuSelect");
	dojo.connect(this.atomic.dialog, "minimize", this, "disableMenuAdd");
	
	this.atomic.dialog.containerNode.appendChild(this.mainTab.containerNode);	
},
setAtomic : function () {
	this.atomic.nodes = new Object;
	this.atomic.widgets = new Object;
},
setRefreshButtons : function () {
	console.log("FileManager.setRefreshButtons    FileManager.setRefreshButtons()");

	var commands = [
		{
			titleNode: this.projectsTitle.focusNode,
			title : "Refresh Projects",
			onclick : "loadProjects"
		},
		{
			titleNode: this.sharedProjectsTitle.focusNode,
			title : "Refresh Shared Projects",
			onclick : "loadSharedProjects"
		},
		{
			titleNode: this.sourcesTitle.focusNode,
			title : "Refresh Sources",
			onclick : "loadSources"
		},
		{
			titleNode: this.sharedSourcesTitle.focusNode,
			title : "Refresh Shared Sources",
			onclick : "loadSharedSources"
		}
	];
	
	var thisObject = this;
	dojo.forEach(commands, dojo.hitch(thisObject, function(command) {
		console.log("FileManager.setRefreshButtons    FileManager.setRefreshButtons(command)");
		console.log("FileManager.setRefreshButtons    command: ");
		console.dir(command);
		var node = document.createElement('div');
		command.titleNode.appendChild(node);
		dojo.attr(node, 'title', command.title);
		dojo.addClass(node, "refreshButton");
		dojo.connect(node, "onclick", this, command.onclick);
	}));
},
setNodes : function () {
	console.log("FileManager.setNodes    workflow.FileManager.setNodes()");
	// CREATE PANE NODE TO HOLD CONTENT
	var paneNode = document.createElement('div');
	dojo.addClass(paneNode, 'folders');
	this.paneNode = paneNode;
	
	var nodeNames = ["projects", "sharedProjects", "sources", "sharedSources"];
	var thisObject = this;
	dojo.forEach(nodeNames, function(nodeName) {
		console.log("FileManager.setNodes    thisObject[" + nodeName + "Node]: " + thisObject[nodeName + "Node"]);
		//var node = document.createElement('div');
		thisObject.atomic.nodes[nodeName] = thisObject[nodeName + "Node"];
		//paneNode.appendChild(node);
		//console.log("FileManager.remove     node: " + node);

		thisObject.atomic.widgets[nodeName] = new Array;
	});
},
loadPanes : function () {
	console.log("FileManager.loadPanes	   plugins.files.FileManager.loadPanes()");

	this.titlePanes = [];
	this.titlePanes = this.concatArrays(this.titlePanes, this.loadProjects());
	this.titlePanes = this.concatArrays(this.titlePanes, this.loadSources());
	this.titlePanes = this.concatArrays(this.titlePanes, this.loadSharedProjects());
	this.titlePanes = this.concatArrays(this.titlePanes, this.loadSharedSources());

	console.log("Folders.loadPanes    this.titlePanes.length: " + this.titlePanes.length);

	// DO ROUND ROBIN LOADING OF LEVEL 1
	this.roundRobin();
},
loadProjects : function () {
	//console.log("FileManager.loadProjects     plugins.folders.Folders.loadProjects()");
	this.remove("projectsNode", this.projectFiles);	

	this.projectFiles = new plugins.folders.ProjectFiles({
		open: 			false,
		title: 			'Projects',
		type: 			'Project',
		attachNode: 	this.projectsNode,
		fileMenu: 		this.fileMenu,
		folderMenu: 	this.folderMenu,
		workflowMenu: 	this.workflowMenu,
		core: 			this.core
	});
	//console.log("FileManager.loadProjects     AFTER NEW plugins.folders.ProjectFiles()");
	
	return this.projectFiles.titlePanes;
},
loadSources : function () {
// LOAD SOURCE FILE PANES
	//console.log("FileManager.loadSources     plugins.folders.Folders.loadSources()");

	// REMOVE EXISTING TITLE PANES
	while ( this.sourcesNode.firstChild ) {
		this.sourcesNode.removeChild(this.sourcesNode.firstChild);
	}

	this.sourceFiles = new plugins.folders.SourceFiles({
		open: 			false,
		title: 			'Sources',
		type: 			'Source',
		attachNode: 	this.sourcesNode,
		project: 		this.project,
		fileMenu: 		this.fileMenu,
		folderMenu: 	this.folderMenu,
		workflowMenu: 	this.workflowMenu,
		core: 			this.core
	});
	//console.log("FileManager.loadSources     AFTER NEW plugins.folders.SourceFiles()");
	return this.sourceFiles.titlePanes;
},
loadSharedProjects : function () {
	//console.log("FileManager.loadSharedProjects     plugins.folders.Folders.loadSharedProjects()");
	this.sharedProjectFiles = new plugins.folders.SharedProjectFiles({
		open: 			false,
		title: 			'Shared Projects',
		type: 			'Shared Project',
		attachNode: 	this.sharedProjectsNode,
		fileMenu: 		this.fileMenu,
		folderMenu: 	this.folderMenu,
		workflowMenu: 	this.workflowMenu,
		core: 			this.core
	});
	//console.log("FileManager.loadSharedProjects     AFTER NEW plugins.folders.SharedProjectFiles()");
	
	return this.sharedProjectFiles.titlePanes;
},
loadSharedSources : function () {
	//console.log("FileManager.loadSharedSources     plugins.folders.Folders.loadSharedSources()");
	this.sharedSourceFiles = new plugins.folders.SharedSourceFiles({
		open: 			false,
		title: 			'SharedSources',
		type: 			'Shared Source',
		attachNode: 	this.sharedSourcesNode,
		project: 		this.project,
		fileMenu: 		this.fileMenu,
		folderMenu: 	this.folderMenu,
		workflowMenu: 	this.workflowMenu,
		core : 			this.core
	});
	//console.log("FileManager.loadSharedSources     AFTER NEW plugins.folders.SharedSourceFiles()");
	
	return this.sharedSourceFiles.titlePanes;
},
roundRobin : function () {
	console.group("FileManager-" + this.id + "    roundRobin");
	console.log("FileManager.roundRobin    caller: " + this.roundRobin.caller.nom);
	console.log("FileManager.roundRobin    this.titlePanes.length: " + this.titlePanes.length);
	if ( ! this.titlePanes || this.titlePanes.length < 1 )	return;
	var array = this.titlePanes.splice(0, 1);
	var titlePane = array[0];
	console.log("FileManager.roundRobin    titlePane.name:" + titlePane.name);
	console.dir({titlePane:titlePane});
	var fakeEvent = {
		stopPropagation : function() {
			console.log("FileManager.roundRobin    fakeEvent.stopPropagation()");
		}
	}
	titlePane.reload(fakeEvent);
},
remove : function (nodeName, widget) {
// REMOVE EXISTING TITLE PANES
	console.log("FileManager.remove     nodeName: " + nodeName);
	console.log("FileManager.remove     widget: " + widget);

	while ( this[nodeName].firstChild )	{
		this[nodeName].removeChild(this[nodeName].firstChild);
	}

	if ( widget )	widget.destroy();
},
hide : function () {
	console.log("FileManager.hide    Doing this.atomic.dialog.minimize()");
	this.atomic.dialog.minimize();
},
show : function (parameterWidget) {
	console.log("FileManager.show    parameterWidget:");
	console.dir({parameterWidget:parameterWidget});

	// SET this.parameterWidget AND IN MENUS
	this.parameterWidget = parameterWidget;
	this.fileMenu.parameterWidget = parameterWidget;
	this.folderMenu.parameterWidget = parameterWidget;
	this.workflowMenu.parameterWidget = parameterWidget;

	// SHOW
	this.atomic.dialog.show();
	
	// OPEN PROJECT IF DEFINED
	var project = this.parameterWidget.project;
	var workflow = this.parameterWidget.workflow;
	console.log("FileManager.show    project: " + project);
	console.log("FileManager.show    workflow: " + workflow);
	
	this.openProjectLocation(project, workflow);
},
openProjectLocation : function (project, workflow) {
	var location = project;
	if ( workflow ) location += "/" + workflow;
	var username = Agua.cookie('username');
	
	var projectFiles = this.projectFiles;
	console.log("projectFiles: ");
	console.dir({projectFiles:projectFiles});
	projectFiles.openLocation(location, username);
},
openProject : function (project, workflow) {
	// OPEN THE TITLE PANE FOR THIS PROJECT
	console.log("FileManager.show	project: " + project);
	console.log("FileManager.show	workflow: " + workflow);

	var projectTitlePanes= this.atomic.nodes.projects;
	for ( var i = 0; i < projectTitlePanes.length; i++ )
	{
		var titlePane = this.projectTitlePanes[i];
		if ( titlePane.title == project )
		{
			console.log("FileManager.show	titlePane fo project '" + project + "': " + titlePane);
			// OPEN PROJECT PANE
			titlePane.open = false;
			titlePane.toggle();
			console.log("FileManager.show    AFTER titlePane.toggle()");
			console.log("FileManager.show    titlePane.fileSelector: " + titlePane.fileSelector);
			
			// SELECT WORKFLOW IF DEFINED
			if ( workflow != null && workflow )
				titlePane.fileSelector.selectChild(workflow);
			console.log("FileManager.show    AFTER titlePane.fileSelector.selectChild(" + workflow + ")");

/*
			//// SELECT DESIGNATED
			//setTimeout(function() {
			//	try {
			//
			//		console.log("FileManager.show    copyFile    Doing timeout groupDragPane.onclickHandler(event)");
			//		var fileDrag = projectFiles.fileDrag
			//		var children = fileDrag.getChildren();
			//		var groupDragPane = children[0];
			//		var item = groupDragPane.items[0];
			//		var event = { target: { item: item } };
			//		console.log("event: " + dojo.toJson(event));
			//		groupDragPane.onclickHandler(event);
			//
			//	} catch(e) {
			//	  console.log("FileManager.show    setTimeout error: " + dojo.toJson(e));
			//	}
			//}, 10000);
*/


		}
	}
},
openWorkflow : function (project, workflow) {
},
enableMenus : function () {
	console.log("FileManager.enableMenus     plugins.files.FileManager.enableMenus()");	
	this.fileMenu.enable();
	this.folderMenu.enable();
	this.workflowMenu.enable();
},
enableMenuSelect: function () {
	console.log("FileManager.enableMenuSelect     plugins.files.FileManager.enableMenuSelect()");	
	this.fileMenu.enableMenuItem("select");
	this.folderMenu.enableMenuItem("select");
	this.workflowMenu.enableMenuItem("select");
},
enableMenuAdd: function () {
	console.log("FileManager.enableMenuAdd     plugins.files.FileManager.enableMenuAdd()");	
	this.fileMenu.enableMenuItem("add");
	this.folderMenu.enableMenuItem("add");
	this.workflowMenu.enableMenuItem("add");
},
disableMenus : function () {
	console.log("FileManager.disableMenus     plugins.files.FileManager.disableMenus()");
	this.fileMenu.disable();
	this.folderMenu.disable();
	this.workflowMenu.disable();
},
disableMenuSelect: function () {
	this.fileMenu.disableMenuItem("select");
	this.folderMenu.disableMenuItem("select");
	this.workflowMenu.disableMenuItem("select");
},
disableMenuAdd: function () {
	this.fileMenu.disableMenuItem("add");
	this.folderMenu.disableMenuItem("add");
	this.workflowMenu.disableMenuItem("add");
},
concatArrays : function(array1, array2) {
	//console.log("FileManager.concatArrays    array1: ");
	//console.dir({array1:array1});
	//console.log("FileManager.concatArrays    array2: ");
	//console.dir({array2:array2});
	for ( var i = 0; i < array2.length; i++ ) {
		array1.push(array2[i]);
	}
	
	return array1;
}




}); 

}

if(!dojo._hasResource["plugins.files.Controller"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.files.Controller"] = true;
dojo.provide("plugins.files.Controller");

// OBJECT:  plugins.files.Controller
// PURPOSE: GENERATE AND MANAGE Workflow PANES

// INHERITS


// HAS


dojo.declare( "plugins.files.Controller",
	[ plugins.core.Common ], {

name: "plugins.files.Controller",
version : "0.01",
url : '',
description : "Load the floating pane File Manager",

dependencies :[
	{	name: "plugins.core.Agua", version: 0.01	}
],


//Path to the template of this widget. 
templateString:"<div dojoAttachPoint=\"containerNode\" class=\"workflow\">\n    <button\n        dojoType=\"dijit.form.Button\"\n        dojoAttachPoint=\"menuButton\"\n        class=\"menuButton\"\n        iconClass=\"workflowIcon\"\n        type=\"button\"\n        label=\"Workflow\"\n        ></button>\n</div>\n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

// CSS FILE FOR BUTTON STYLING
cssFiles : [
	dojo.moduleUrl("plugins") + "workflow/css/controller.css",
	dojo.moduleUrl("plugins") + "workflow/css/workflow.css"
],

// ARRAY OF TAB PANES
tabPanes : [],

////}}}
constructor : function(args) {
	// LOAD CSS FOR BUTTON
	this.loadCSS();
},
postCreate : function() {
	this.startup();
},
startup : function () {
	////console.log("Controller.startup    plugins.files.Controller.startup()");
	////console.log("Controller.startup    Agua: " + Agua);

	this.inherited(arguments);

},
createFileManager : function () {
	//console.log("files.Controller.createFileManager    plugins.files.Controller.createFileManager()");
},
postLoad : function () {
		console.log("plugins.files.Controller.postLoad    DOING new plugins.files.FileManager");
		
// OPEN FILE MANAGER ONCE PLUGIN HAS LOADED
	Agua.fileManager = new plugins.files.FileManager({
		paneId: "fileManager" + this.paneId,
		tabsNodeId: "tabs"
	});	
}


}); // end of Controller

dojo.addOnLoad( function() {

});

}

if(!dojo._hasResource["plugins.folders.Folders"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.folders.Folders"] = true;
dojo.provide("plugins.folders.Folders");

/* SUMMARY: 

	DISPLAY THE USER'S PROJECTS DIRECTORY AND ALLOW
	
	THE USER TO BROWSE FILES AND MANIPULATE WORKFLOW
	
	FOLDERS AND FILES

	USAGE SCENARIO 1: LOAD NEW 'FOLDERS' TAB
	
	Folders->loadPanes (populate this.titlePanes)
		ProjectFiles -> load (returns array of titlePanes)
			projectFiles -> setTitlePane
				
				
		SourceFiles -> load (returns array of titlePanes)
			... inherits from ProjectFiles ...

	Folders->roundRobin
		this.titlePanes[0] -> reload
			ProjectFiles (or SourceFiles) -> createFileDrag
				ProjectFiles -> createStore
					fileDrag.path = directory.name
				new plugins.files.FileDrag
					FileDrag -> startup
						fileDrag -> _getPaneForItem
							fileDrag -> getPaneForItem
								new plugins.files._GroupDragPane
									_GroupDragPane -> _load
										_GroupDragPane -> _doQuery 
											FileStore -> fetch({query: ...})
											
			Folders -> roundRobin
				... UNTIL this.titlePanes IS EMPTY
	
	
	USAGE SCENARIO 2: USE CLICKS ON A FOLDER
	
	Folders->loadPanes (populate this.titlePanes)
	
	
	
*/

if ( 1 ) {
// FILE DRAG




// DnD
 // Source & Target




// LAYOUT




// TOOLTIP


// INHERITS


// HAS A





// MENUS




// INHERITS

}

dojo.declare( "plugins.folders.Folders",
	[ dijit._Widget, dijit._Templated, plugins.core.Common ], {
//Path to the template of this widget. 
templateString:"<div dojoAttachPoint=\"containerNode\">\n\n\t<!-- PROJECT TAB -->\n\t<div\n\t\tdojoAttachPoint=\"mainTab\"\n\t\tclass=\"folders\"\n\t\ticonClass=\"foldersIcon\"\n\t\tminWidth=\"1000\"\n\t\tstyle=\"position: relative; min-width: 1140px !important; width: 100% !important; min-height: 770px !important; height: 100% !important; padding: 0px; background: #FFF; overflow-y: scroll\"\n\t\tclosable=\"true\"\n\t\tscrollbar=\"true\"\n\t\tdojoType=\"dijit.layout.ContentPane\"\n\t\ttitle=\"Folders\" >\n\t\t\n\t\t<div\n\t\t\tdojoAttachPoint=\"projectsNode\"\n\t\t\t>\n\t\t</div>\n\n\t\t<div\n\t\t\tdojoAttachPoint=\"sourcesNode\"\n\t\t\t>\n\t\t</div>\n\n\t\t<div\n\t\t\tdojoAttachPoint=\"sharedProjectsNode\"\n\t\t\t>\n\t\t</div>\n\n\t\t<div\n\t\t\tdojoAttachPoint=\"sharedSourcesNode\"\n\t\t\t>\n\t\t</div>\n\n\t</div>\n\t<!-- END OF PROJECT TAB -->\n\n<!--</div>-->\n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

// PARENT NODE, I.E., TABS NODE
parentWidget : null,

// core: Object.
// { files: XxxxxFiles object, folders: Folders object, etc. }
core : null,

// PROJECT NAME AND WORKFLOW NAME IF AVAILABLE
project : null,

// POLL SERVER FOR WORKFLOW STATUS
polling : false,

// INSERT TEXT BREAKS WIDTH, CORRESPONDS TO CSS WIDTH OF INPUT 'value' TABLE ELEMENT
textBreakWidth : 22,

// CSS FILES
cssFiles : [
	dojo.moduleUrl("plugins") + "folders/css/folders.css"
],

// XxxxxFiles: object
// Reference to components file groups
projectFiles 		: 	null,
sourceFiles 		: 	null,
sharedProjectFiles 	: 	null,
sharedSourceFiles 	:	null,

// callback : Function reference
// Call this after module has loaded
callback : null,

// url: String
// URL FOR REMOTE DATABASE
url: null,

//////}}
constructor : function(args) {		
	console.log("Folders.constructor    args:");
	console.dir({args:args});
	
	if ( ! args )	return;
	
	// GET ARGS
	this.callback = args.callback;
	this.project = args.project;

	this.attachWidget = Agua.tabs;	
	
	// SET CORE
	this.core = new Object;
	this.core.folders = this;

	// SET url
	if ( Agua.cgiUrl )	this.url = Agua.cgiUrl + "/folders.cgi";

	// LOAD CSS
	////console.log("Folders.constructor    Doing this.loadCSS()");
	this.loadCSS();
},
postCreate: function() {
	////console.log("Folders.postCreate    plugins.folders.Folders.postCreate()");
	this.startup();
},
startup : function () {
	//console.log("Folders.startup    plugins.folders.Folders.startup()");

	if ( ! this.attachWidget ) {
		//console.log("Folders.startup    this.attachWidget is null. Returning");
		return;
	}
	
	// SET UP THE ELEMENT OBJECTS AND THEIR VALUE FUNCTIONS
	this.inherited(arguments);

	// ADD THE PANE TO THE TAB CONTAINER
	////console.log("Folders.startup    this.mainTab: " + this.mainTab);
	if ( this.attachWidget.addChild )
	{
		this.attachWidget.addChild(this.mainTab);
		this.attachWidget.selectChild(this.mainTab);
	}
	if ( this.attachWidget.appendChild )
	{
		this.attachWidget.appendChild(this.mainTab.domNode);
	}
	// SET MENUS
	this.setMenus();

	// SUBSCRIBE TO UPDATES
	Agua.updater.subscribe(this, "updateProjects");
	Agua.updater.subscribe(this, "updateWorkflows");
	Agua.updater.subscribe(this, "updateSources");

	// LOAD APPLICATIONS DND SOURCE AND TARGET INTO FRAMEWORK
	this.loadPanes();
	
	// DO CALLBACK IF COMPLETED
},
updateProjects : function (args) {
	////console.warn("Projects.updateProjects    project.Projects.updateProjects(args)");
	////console.warn("Projects.updateProjects    args:");
	////console.dir(args);

	// REDO PARAMETER TABLE
	if ( args != null && args.originator == this )
	{
		if ( args.reload == false )	return;
	}

	////console.warn("Projects.updateProjects    Calling this.loadProjects()");
	this.loadProjects;
},
updateWorkflows : function (args) {
	////console.warn("Workflows.updateWorkflows    project.Workflows.updateWorkflows(args)");
	////console.warn("Workflows.updateWorkflows    args:");
	////console.dir(args);

	// REDO PARAMETER TABLE
	if ( args != null && args.originator == this )
	{
		if ( args.reload == false )	return;
	}

	////console.warn("Workflows.updateWorkflows    Calling this.loadWorkflows()");
	this.loadWorkflows;
},
updateSources : function (args) {
	////console.warn("Sources.updateSources    project.Sources.updateSources(args)");
	////console.warn("Sources.updateSources    args:");
	////console.dir(args);

	// REDO PARAMETER TABLE
	if ( args != null && args.originator == this )
	{
		if ( args.reload == false )	return;
	}

	////console.warn("Sources.updateSources    Calling this.loadSources()");
	this.loadSources;
},
setMenus : function () {
	////console.log("Folders.setMenus     plugins.folders.Folders.setMenus()"); 	
	this.fileMenu = new plugins.files.FileMenu({parentWidget : this});
	this.folderMenu = new plugins.files.FolderMenu({parentWidget : this});
	this.workflowMenu = new plugins.files.WorkflowMenu({parentWidget : this});
	////console.log("Folders.setMenus     this.workflowMenu: " + this.workflowMenu);
	
	// STOP PROPAGATION TO NORMAL RIGHTCLICK CONTEXT MENU
	dojo.connect(this.folderMenu.menu.domNode, "oncontextmenu", function (event)
	{
		event.stopPropagation();
	});
	
	// STOP PROPAGATION TO NORMAL RIGHTCLICK CONTEXT MENU
	dojo.connect(this.workflowMenu.menu, "oncontextmenu", function (event)
	{
		event.stopPropagation();
	});
},
loadPanes : function ()	{
	////console.log("Folders.loadPanes     plugins.folders.Folders.loadPanes");
	this.titlePanes = [];
	this.titlePanes = this.concatArrays(this.titlePanes, this.loadProjects());
	this.titlePanes = this.concatArrays(this.titlePanes, this.loadSources());
	this.titlePanes = this.concatArrays(this.titlePanes, this.loadSharedProjects());
	this.titlePanes = this.concatArrays(this.titlePanes, this.loadSharedSources());
	
	//console.log("Folders.loadPanes    this.titlePanes.length: " + this.titlePanes.length);

	this.roundRobin();
},
concatArrays : function(array1, array2) {
	for ( var i = 0; i < array2.length; i++ ) {
		array1.push(array2[i]);
	}
	
	return array1;
},
roundRobin : function () {
	//console.log("Folders.roundRobin    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX caller: " + this.roundRobin.caller.nom);
	//console.log("Folders.roundRobin    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX this.titlePanes.length: " + this.titlePanes.length);

	// DO CALLBACK IF LAST TITLE PANE
	if ( ! this.titlePanes || this.titlePanes.length < 1 )	{
		console.log("Folders.roundRobin    Doing this.callback if defined: " + this.callback);
		if ( this.callback )	this.callback();
		return;
	}
	
	var array = this.titlePanes.splice(0, 1);
	var titlePane = array[0];
	//console.log("Folders.roundRobin    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX titlePane.name:" + titlePane.name);
	//console.dir({titlePane:titlePane});
	var fakeEvent = {
		stopPropagation : function() {
			//console.log("Folders.roundRobin    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX fakeEvent.stopPropagation()");
		}
	}
	titlePane.reload(fakeEvent);
	
},
loadProjects : function () {
	////console.log("Folders.loadProjects     plugins.folders.Folders.loadProjects()");
	this.remove("projectsNode", this.projectFiles);	

	this.projectFiles = new plugins.folders.ProjectFiles(
	{
		open			:	true,
		title			:	'Projects',
		type			:	'Project',
		attachNode		:	this.projectsNode,
		fileMenu		:	this.fileMenu,
		folderMenu		:	this.folderMenu,
		workflowMenu	:	this.workflowMenu,
		core			:	this.core,
		url				:	this.url
	});
	////console.log("Folders.loadProjects     AFTER NEW plugins.folders.ProjectFiles()");
	
	return this.projectFiles.titlePanes;
},
loadSources : function () {
// LOAD SOURCE FILE PANES
	////console.log("Folders.loadSources     plugins.folders.Folders.loadSources()");

	// REMOVE EXISTING TITLE PANES
	while ( this.sourcesNode.firstChild ) {
		this.sourcesNode.removeChild(this.sourcesNode.firstChild);
	}

	this.sourceFiles = new plugins.folders.SourceFiles(
	{
		open			:	true,
		title			: 	'Sources',
		type			: 	'Source',
		attachNode		: 	this.sourcesNode,
		project			: 	this.project,
		fileMenu		: 	this.fileMenu,
		folderMenu		: 	this.folderMenu,
		workflowMenu	: 	this.workflowMenu,
		core			:	this.core,
		url				:	this.url
	});
	////console.log("Folders.loadSources     AFTER NEW plugins.folders.SourceFiles()");
	return this.sourceFiles.titlePanes;
},
loadSharedProjects : function () {
	////console.log("FileManager.loadSharedProjects     plugins.folders.Folders.loadSharedProjects()");
	this.sharedProjectFiles = new plugins.folders.SharedProjectFiles({
		open			:	false,
		title			:	'Shared Projects',
		type			:	'Shared Project',
		attachNode		:	this.sharedProjectsNode,
		fileMenu		:	this.fileMenu,
		folderMenu		:	this.folderMenu,
		workflowMenu	:	this.workflowMenu,
		core			:	this.core,
		url				:	this.url
	});
	////console.log("FileManager.loadSharedProjects     AFTER NEW plugins.folders.SharedProjectFiles()");
	
	return this.sharedProjectFiles.titlePanes;
},
loadSharedSources : function () {
	////console.log("FileManager.loadSharedSources     plugins.folders.Folders.loadSharedSources()");
	this.sharedSourceFiles = new plugins.folders.SharedSourceFiles({
		open			:	false,
		title			:	'SharedSources',
		type			:	'Shared Source',
		attachNode		:	this.sharedSourcesNode,
		project			:	this.project,
		fileMenu		:	this.fileMenu,
		folderMenu		:	this.folderMenu,
		workflowMenu	:	this.workflowMenu,
		core 			:	this.core,
		url				:	this.url
	});
	////console.log("FileManager.loadSharedSources     AFTER NEW plugins.folders.SharedSourceFiles()");
	
	return this.sharedSourceFiles.titlePanes;
},
remove : function (nodeName, widget) {
	////console.log("Folders.remove     project.Project.remove(nodeName, widget)");
	////console.log("Folders.remove     nodeName: " + nodeName);
	////console.log("Folders.remove     widget: " + widget);

	// REMOVE EXISTING TITLE PANES
	while ( this[nodeName].firstChild )
	{
		this[nodeName].removeChild(this[nodeName].firstChild);
	}

	if ( widget != null )	widget.destroy();
},
destroyRecursive : function () {
	console.log("Folders.destroyRecursive    this.mainTab: ");
	console.dir({this_mainTab:this.mainTab});
	if ( Agua && Agua.tabs )
		Agua.tabs.removeChild(this.mainTab);
	
	this.inherited(arguments);
}

}); // end of plugins.folders.Folders

}

if(!dojo._hasResource["plugins.folders.Controller"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.folders.Controller"] = true;
dojo.provide("plugins.folders.Controller");

// OBJECT:  plugins.folders.Controller
// PURPOSE: GENERATE AND MANAGE Project PANES

// INHERITS


// HAS


dojo.declare( "plugins.folders.Controller",
	[ plugins.core.PluginController ],
{
// PANE ID 
paneId : null,

//Path to the template of this widget. 
templateString:"<div dojoAttachPoint=\"containerNode\" class=\"folders\">\n    <button\n        dojoType=\"dijit.form.Button\"\n        dojoAttachPoint=\"menuButton\"\n        class=\"foldersButton\"\n        iconClass=\"foldersIcon\"\n        type=\"button\"\n        label=\"Folders\"\n        ></button>\n</div>\n        \n",

// CSS FILES
cssFiles : [ dojo.moduleUrl("plugins") + "/folders/css/controller.css" ],

// TAB CLASS
tabClass : "plugins.folders.Folders",

////}}}}

}); // end of Controller

dojo.addOnLoad(
function()
{
	// CREATE TAB
	//Agua.controllers["folders"].createTab();		
}
);

}

if(!dojo._hasResource["dojox.io.windowName"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.io.windowName"] = true;
dojo.provide("dojox.io.windowName");
// Implements the window.name transport

dojox.io.windowName = {
	send: function(/*String*/ method, /*dojo.__IoArgs*/ args){
		// summary:
		//		Provides secure cross-domain request capability.
		// 		Sends a request using an iframe (POST or GET) and reads the response through the
		// 		frame's window.name.
		//
		//	method:
		//		The method to use to send the request, GET or POST
		//
		//	args:
		//		See dojo.xhr
		//
		//	args.authElement: DOMNode?
		//		By providing an authElement, this indicates that windowName should use the
		// 		authorized window.name protocol, relying on
		//		the loaded XD resource to return to the provided return URL on completion
		//		of authorization/authentication. The provided authElement will be used to place
		//		the iframe in, so the user can interact with the server resource for authentication
		//		and/or authorization to access the resource.
		//
		//	args.onAuthLoad: Function?
		//		When using authorized access to resources, this function will be called when the
		// 		authorization page has been loaded. (When authorization is actually completed,
		// 		the deferred callback function is called with the result). The primary use for this
		// 		is to make the authElement visible to the user once the resource has loaded
		// 		(this can be preferable to showing the iframe while the resource is loading
		// 		since it may not require authorization, it may simply return the resource).
		//
		//	description:
		//		In order to provide a windowname transport accessible resources/web services, a server
		// 		should check for the presence of a parameter window.name=true and if a request includes
		// 		such a parameter, it should respond to the request with an HTML
		// 		document that sets it's window.name to the string that is to be
		// 		delivered to the client. For example, if a client makes a window.name request like:
		// 	|	http://othersite.com/greeting?windowname=true
		// 		And server wants to respond to the client with "Hello", it should return an html page:
		// |	<html><script type="text/javascript">
		// |	window.name="Hello";
		// |	</script></html>
		// 		One can provide XML or JSON data by simply quoting the data as a string, and parsing the data
		// 		on the client.
		//		If you use the authorization window.name protocol, the requester should include an
		// 		authElement element in the args, and a request will be created like:
		// 	|	http://othersite.com/greeting?windowname=auth
		// 		And the server can respond like this:
		// |	<html><script type="text/javascript">
		// |	var loc = window.name;
		// |	authorizationButton.onclick = function(){
		// |		window.name="Hello";
		// |		location = loc;
		// |	};
		// |	</script></html>
		//		When using windowName from a XD Dojo build, make sure to set the
		// 		dojo.dojoBlankHtmlUrl property to a local URL.
		args.url += (args.url.match(/\?/) ? '&' : '?') + "windowname=" + (args.authElement ? "auth" : true); // indicate our desire for window.name communication
		var authElement = args.authElement;
		var cleanup = function(result){
			try{
				// we have to do this to stop the wait cursor in FF
				var innerDoc = dfd.ioArgs.frame.contentWindow.document;
				innerDoc.write(" ");
				innerDoc.close();
			}catch(e){}
			(authElement || dojo.body()).removeChild(dfd.ioArgs.outerFrame); // clean up
			return result;
		}
		var dfd = dojo._ioSetArgs(args,cleanup,cleanup,cleanup);
		if(args.timeout){
			setTimeout(function(){
					if(dfd.fired == -1){
						dfd.callback(new Error("Timeout"));
					}
				},
				args.timeout
			);
		}
		var self = dojox.io.windowName;
		if(dojo.body()){
			// the DOM is ready
			self._send(dfd, method, authElement, args.onAuthLoad);
		}else{
			// we will wait for the DOM to be ready to proceed
			dojo.addOnLoad(function(){
				self._send(dfd, method, authElement, args.onAuthLoad);
			});
		}
		return dfd;
	},
	_send: function(dfd, method, authTarget, onAuthLoad){

		var ioArgs = dfd.ioArgs;
		var frameNum = dojox.io.windowName._frameNum++;
		var sameDomainUrl = (dojo.config.dojoBlankHtmlUrl||dojo.config.dojoCallbackUrl||dojo.moduleUrl("dojo", "resources/blank.html")) + "#" + frameNum;
		var frameName = new dojo._Url(window.location, sameDomainUrl);
		var doc = dojo.doc;
		var frameContainer = authTarget || dojo.body();
		function styleFrame(frame){
			frame.style.width="100%";
			frame.style.height="100%";
			frame.style.border="0px";
		}
		if(dojo.isMoz && ![].reduce){
			// FF2 allows unsafe sibling frame modification,
			// the fix for this is to create nested frames with getters and setters to protect access
			var outerFrame = doc.createElement("iframe");
			styleFrame(outerFrame);
			if(!authTarget){
				outerFrame.style.display='none';
			}
			frameContainer.appendChild(outerFrame);
			
			var firstWindow = outerFrame.contentWindow;
			doc = firstWindow.document;
			doc.write("<html><body margin='0px'><iframe style='width:100%;height:100%;border:0px' name='protectedFrame'></iframe></body></html>");
			doc.close();
			var secondWindow = firstWindow[0];
			firstWindow.__defineGetter__(0,function(){});
			firstWindow.__defineGetter__("protectedFrame",function(){});
			doc = secondWindow.document;
			doc.write("<html><body margin='0px'></body></html>");
			doc.close();
			frameContainer = doc.body;
		}
		var frame;
		if(dojo.isIE){
			var div = doc.createElement("div");
			div.innerHTML = '<iframe name="' + frameName + '" onload="dojox.io.windowName['+frameNum+']()">';
			frame = div.firstChild;
		}else{
			frame = doc.createElement('iframe');
		}
		ioArgs.frame = frame;
		styleFrame(frame);
		ioArgs.outerFrame = outerFrame = outerFrame || frame;
		if(!authTarget){
			outerFrame.style.display='none';
		}
		var state = 0;
		function getData(){
			var data = frame.contentWindow.name;
			if(typeof data == 'string'){
				if(data != frameName){
					state = 2; // we are done now
					dfd.ioArgs.hash = frame.contentWindow.location.hash;
					dfd.callback(data);
				}
			}
		}
		dojox.io.windowName[frameNum] = frame.onload = function(){
			try{
				if(!dojo.isMoz && frame.contentWindow.location =='about:blank'){
					// opera and safari will do an onload for about:blank first, we can ignore this first onload
					return;
				}
			}catch(e){
				// if we are in the target domain, frame.contentWindow.location will throw an ignorable error
			}
			if(!state){
				// we have loaded the target resource, now time to navigate back to our domain so we can read the frame name
				state=1;
				if(authTarget){
					// call the callback so it can make it visible
					if(onAuthLoad){
						onAuthLoad();
					}
				}else{
					// we are doing a synchronous capture, go directly to our same domain URL and retrieve the resource
					frame.contentWindow.location = sameDomainUrl;
				}
			}
			// back to our domain, we should be able to access the frame name now
			try{
				if(state<2){
					getData();
				}
			}
			catch(e){
			}
			
		};
		frame.name = frameName;
		if(method.match(/GET/i)){
			// if it is a GET we can just the iframe our src url
			dojo._ioAddQueryToUrl(ioArgs);
			frame.src = ioArgs.url;
			frameContainer.appendChild(frame);
			if(frame.contentWindow){
				frame.contentWindow.location.replace(ioArgs.url);
			}
		}else if(method.match(/POST/i)){
			// if it is a POST we will build a form to post it
			frameContainer.appendChild(frame);
			var form = dojo.doc.createElement("form");
			dojo.body().appendChild(form);
			var query = dojo.queryToObject(ioArgs.query);
			for(var i in query){
				var values = query[i];
				values = values instanceof Array ? values : [values];
				for(var j = 0; j < values.length; j++){
					// create hidden inputs for all the parameters
					var input = doc.createElement("input");
					input.type = 'hidden';
					input.name = i;
					input.value = values[j];
					form.appendChild(input);
				}
			}
			form.method = 'POST';
			form.action = ioArgs.url;
			form.target = frameName;// connect the form to the iframe
			
			form.submit();
			form.parentNode.removeChild(form);
		}else{
			throw new Error("Method " + method + " not supported with the windowName transport");
		}
		if(frame.contentWindow){
			frame.contentWindow.name = frameName; // IE likes it afterwards
		}
	},
	_frameNum: 0
	
}

}

if(!dojo._hasResource["dojox.fx.easing"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.fx.easing"] = true;
dojo.provide("dojox.fx.easing");
dojo.deprecated("dojox.fx.easing","Upgraded to Core, use dojo.fx.easing instead","2.0");

/*=====
	dojox.fx.easing = {
		// summary:
		//		An Alias to `dojo.fx.easing`. Moved to Core in Dojo 1.2.
	};
=====*/
dojox.fx.easing = dojo.fx.easing;

}

if(!dojo._hasResource["plugins.home.Home"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.home.Home"] = true;
dojo.provide("plugins.home.Home");

if ( 1 ) {
// BASIC LAYOUT










// UPGRADE LOG


// PACKAGE COMBOBOX



// DIALOG WITH COMBOBOX


// NO UPGRADES DIALOG


// INHERITS

	
}

dojo.declare( "plugins.home.Home", 
	[ dijit._Widget, dijit._Templated, plugins.core.Common ], {

//Path to the template of this widget. 
templateString:"<div dojoAttachPoint=\"containerNode\">\n\n\t<div\n\t\tdojoAttachPoint=\"mainTab\"\n\t\tclass=\"home\"\n\t\ticonClass=\"homeIcon\"\n\t\tstyle=\"min-width: 1000px !important; width: 100% !important; height:inherit !important; padding: 0px; background: #FFF;\"\n\t\ttitle=\"Home\"\n\t\tclosable=\"true\"\n\t\tdojoType=\"dijit.layout.BorderContainer\"\n\t\t>\n\n\t\t<div\n\t\t\tclass=\"homeContainer\"\n\t\t\tdojoType=\"dijit.layout.ContentPane\"\n\t\t\tregion=\"top\">\n\t\t\t\n\t\t\t<table width=\"100%\">\n\t\t\t\t<tr>\n\t\t\t\t\t<td>\n\t\t\t\t\t\t<table class=\"navigationTable\">\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t\tUse\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td class=\"leftArrow\">\n\t\t\t\t\t\t\t\t\tALT +\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t\tand\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td class=\"rightArrow\">\n\t\t\t\t\t\t\t\t\tALT +\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td class=\"navigationInfo\">\n\t\t\t\t\t\t\t\t\tto Navigate\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t</table>\n\t\t\t\t\t</td>\n\t\t\t\t\t\n\t\t\t\t\t<td align=\"right\">\n\t\t\t\t\t\t<table class=\"packageTable\">\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td class=packageTitle>Package</td>\n\t\t\t\t\t\t\t\t<td class=packageTitle title=\"Current installed version\">Version</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\t\tdojoType=\"dijit.form.ComboBox\"\n\t\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"packageCombo\"\n\t\t\t\t\t\t\t\t\t\tdojoAttachEvent='onChange:showCurrentVersion'\n\t\t\t\t\t\t\t\t\t\tclass=\"packageCombo\"\n\t\t\t\t\t\t\t\t\t\tautocomplete=\"false\"\n\t\t\t\t\t\t\t\t\t\tdisabled=\"false\"\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\t\tclass=\"currentVersion\"\n\t\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"currentVersion\"\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t</table>\n\t\t\t\t\t</td>\n\t\t\t\t\t<td>\n\t\t\t\t\t\t<button\n\t\t\t\t\t\t\tclass=\"checkVersion\"\n\t\t\t\t\t\t\tdojoAttachPoint=\"checkVersion\"\n\t\t\t\t\t\t\tdojoAttachEvent=\"onclick:showUpgrades\"\n\t\t\t\t\t\t>Check For Upgrades</button>\n\t\t\t\t\t</td>\n\t\t\t\t\t<td width=\"400\">\n\t\t\t\t\t</td>\n\t\t\t\t</tr>\n\t\t\t</table>\n\n\t\t\t<div\n\t\t\t\tid=\"authTarget\"\n\t\t\t\tdojoAttachPoint=\"bottomPane\"\n\t\t\t\tclass=\"bottomPane\"\n\t\t\t\talt=\"Agua Home Page\"\n\t\t\t>\n\t\t\t</div>\n\t\t\n\t\t</div>\n\t\t\n\t\t<div\n\t\t\tclass=\"progressPane\"\n\t\t\tdojoAttachPoint=\"progressPane\"\n\t\t\tdojoType=\"plugins.dojox.layout.FloatingPane\"\n\t\t\tregion=\"top\"\n\t\t\tresizable=\"false\"\n\t\t\tmoveable=\"false\"\n\t\t\tdockable=\"true\"\n\t\t\tmaxable=\"false\"\n\t\t\tclosable=\"false\"\n\t\t\tduration=\"1500\"\n\t\t\theight=\"500px\"\n\t\t\twidth=\"900px\"\n\t\t\ttitle=\"Upgrade Log\"\n\t\t\tdockClass=\"homeDockNode\"\n\t\t\t> \n\t\t</div>\n\t</div>\n\t\t\t\n</div>\n",

cssFiles : [
    dojo.moduleUrl("plugins", "home/css/home.css"),
    dojo.moduleUrl("dojox", "layout/resources/ResizeHandle.css"),
	dojo.moduleUrl("dojox", "layout/resources/FloatingPane.css"),
	dojo.moduleUrl("dojox", "widget/Dialog/Dialog.css")
],

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

// PANE WIDGETS
paneWidgets : null,

// AGUA WIKI
url : "http://www.aguadev.org/confluence/display/home/Home",

// UPGRADE PROGRESS DIALOG
progressPane : null,

// timerInterval
// Number of milliseconds between calls to onTick
// timerInterval : Integer
timerInterval : 30000,

////}}}}

constructor : function(args) {	
	// LOAD CSS
	this.loadCSS();		
},
postCreate : function() {
	console.log("Home.postCreate    plugins.home.Home.postCreate()");

	this.startup();
},
startup : function () {
	console.log("Home.startup    plugins.home.Home.startup()");

	this.inherited(arguments);

	// ADD ADMIN TAB TO TAB CONTAINER		
	Agua.tabs.addChild(this.mainTab);

	Agua.tabs.selectChild(this.mainTab);

	// LOAD PANE 
	this.loadPane();

	// HIDE 'CHECK FOR UPGRADES' IF NOT ADMIN USER
	this.disableUpgrade();
	
	// SET VERSION COMBO
	this.setPackageCombo();

	// SET CHECK UPGRADE DIALOG
	this.setSelectiveDialog();

	// SET SIMPLE MESSAGE DIALOG
	this.setSimpleDialog();

	// SET TIMER
	this.setTimer();
	
	// SET PROGRESS PANE (FLOATING PANE) BEHAVIOUR
	this.setProgressPane();

	// SUBSCRIBE TO UPDATES
	Agua.updater.subscribe(this, "updatePackages");

	// CONNECT WINDOW AND PROGRESS PANE RESIZE
	dojo.connect(window, "onresize", dojo.hitch(this, "resizeProgress"));
},
updatePackages : function (args) {
// RELOAD GROUP COMBO AND DRAG SOURCE AFTER CHANGES
// TO SOURCES OR GROUPS DATA IN OTHER TABS

	console.log("Home.updatePackages    Home.updatePackages(args)");
	console.dir({args:args});
	

	// SET DRAG SOURCE
	if ( args && ! args.reload )	return;

	if ( args.originator && args.originator == this )	return;
	
	console.log("Home.updatePackages    Calling setPackageCombo()");
	this.setPackageCombo();
},
disableUpgrade : function () {
	var packages = Agua.getPackages();
	console.log("plugins.home.Home.disableUpgrade    packages: ");
	console.dir({packages:packages});
	
	// DISABLE 'CHECK FOR UPGRADES' BUTTON IF packages IS EMPTY
	if ( packages == null || packages.length == 0 ) {
		console.log("plugins.home.Home.disableUpgrade    version is empty. Returning");
		dojo.removeClass(this.checkVersion, 'checkVersion');
		dojo.addClass(this.checkVersion, 'hidden');
		dojo.addClass(this.packageCombo, 'hidden');
	}
},
loadPane : function () {
	var url = this.url;
	console.log("Home.loadPane    url: " + url);

	var auth = true;
	var authTarget = this.bottomPane;
	if ( this.bottomPane.id == null )
		this.bottomPane.id = this.id + "_windowName";
	this.windowDeferred = dojox.io.windowName.send(
		"GET",
		{
			url: url,
			handleAs:"text",
			authElement: authTarget,
			onAuthLoad: auth && function () {
				authTarget.style.display='block';
				console.log("Changed authTarget style.display to 'block'");
			}
		}
	);
	
	this.windowDeferred.addBoth(function(result){
		console.dir({result: result});
		auth && (authTarget.style.display='none');
		alert(result)
	});
},
// SETTERS
setPackageCombo : function (packageName) {
	console.log("Home.setPackageCombo    packageName: " + packageName);
	
	var packages = Agua.getPackages();
	console.log("Home.setPackageCombo    BEFORE FILTER packages: ");
	console.dir({packages:packages});

	var username = Agua.cookie('username');
	packages = this.filterByKeyValues(packages, ['username'], [username])
	console.log("Home.setPackageCombo    AFTER FILTER packages by username: " + username);
	console.dir({packages:packages});

	var packageNames = this.hashArrayKeyToArray(packages, "package");
	console.log("Home.setPackageCombo    packageNames: " + dojo.toJson(packageNames));
	
	// RETURN IF packages NOT DEFINED
	if ( ! packageNames )
	{
		console.log("Home.setPackageCombo    packageNames not defined. Returning.");
		return;
	}

	packageNames = packageNames.sort();
	
	// DO DATA ARRAY
	var data = {identifier: "name", items: []};
	for ( var i in packageNames )
	{
		data.items[i] = { name: packageNames[i]	};
	}

	// CREATE store
	var store = new dojo.data.ItemFileReadStore( {	data: data	} );
	this.packageCombo.store = store;	
	
	// SET DEFAULT
	if ( ! packageName )
		packageName = packageNames[packageNames.length - 1];

	console.log("Home.setPackageCombo    SETTING value packageName: " + packageName);
	this.packageCombo.set('value', packageName);			
},
setSelectiveDialog : function () {
	var enterCallback = function (){};
	var cancelCallback = function (){};
	
	console.log("Stages.setSelectiveDialog    plugins.files.Stages.setSelectiveDialog()");
	this.selectiveDialog = new plugins.dijit.SelectiveDialog(
		{
			title 				:	"",
			message 			:	"",
			enterLabel 			:	"Upgrade",
			cancelLabel 		:	"Cancel",
			parentWidget 		:	this,
			enterCallback 		:	enterCallback,
			cancelCallback 		:	cancelCallback
		}			
	);

	// SET CLASS
	dojo.addClass(this.selectiveDialog.dialog.domNode, 'home');
	dojo.addClass(this.selectiveDialog.dialog.domNode, 'progressPane');
	dojo.addClass(this.selectiveDialog.dialog.domNode, 'home progressPane dojoxDialog dijitDialog');

	//console.log("Stages.setSelectiveDialog    this.selectiveDialog: " + this.selectiveDialog);
},
setSimpleDialog : function () {
	this.simpleDialog = new dijit.Dialog({})
	dojo.addClass(this.simpleDialog.domNode, 'simpleDialog dijitDialog');
	dojo.addClass(this.simpleDialog.containerNode, 'simpleDialog dijitDialogPaneContent');
},
setTimer : function () {
	console.log("Home.setTimer    this.timerInterval: " + this.timerInterval);
	this.timer = new dojox.timing.Timer;
	console.log("Home.setTimer    Created this.timer: " + this.timer);
	this.timer.setInterval(this.timerInterval);
},
setProgressPane : function () {
	console.log("plugins.home.Home.setProgressPane");
	console.dir({progressPane:this.progressPane});

	// SET CLASS
	dojo.attr(this.progressPane.domNode, 'class', 'home progressPane dojoxDialog dijitDialog');

	var thisObject = this;

	this.progressPane.close = dojo.hitch(this, function() {
		console.log("plugins.home.Home.setProgressPane    this.progressPane.close");
		this.progressPane.minimize();
		this.timer.stop();
		dojo.attr(this.timer, 'isRunning', false);
	});
	
	this.progressPane.onDownloadError = dojo.hitch(this, function() {
		console.log("Home.setProgressPane    this.progressPane.onLoadError");
	});

	dojo.connect(this.progressPane, "_onShow", this, "_onShow");
},
// SHOWers
showCurrentVersion : function () {
	console.log("Home.showCurrentVersion    plugins.home.Home.showCurrentVersion()");
	var packageName = this.packageCombo.get('value');
	console.log("Home.showCurrentVersion    packageName: " + packageName);
	
	var packageObject = this.getPackageObject(packageName);
	console.log("Home.showCurrentVersion    AFTER packageObject: " + dojo.toJson(packageObject));
	
	this.currentVersion.innerHTML = packageObject.version;
},
showUpgrades : function () {
	console.log("Home.showUpgrades    plugins.home.Home.showUpgrades()");
	var packageName = this.packageCombo.get('value');
	console.log("Home.showUpgrades    packageName: " + packageName);
	
	var packageObject = this.getPackageObject(packageName);
	console.log("Home.showUpgrades    AFTER packageObject: " + dojo.toJson(packageObject));

	if ( ! packageObject.current ) {
		console.log("Home.showUpgrades    packageObject.current not defined. Returning");
		return;
	}
	
	if ( packageObject.current.length == 0 ) {
		this.showLatestInstalled(packageName, packageObject.version);
	}
	else {
		this.loadSelectiveDialog(packageObject);
	}
},
// UPGRADE
loadSelectiveDialog : function (packageObject) {
	console.log("Home.loadSelectiveDialog    plugins.files.Home.loadSelectiveDialog(packageObject)");
	console.log("Home.loadSelectiveDialog    packageObject: " + dojo.toJson(packageObject));
	
	// SET CALLBACKS
	var thisObject = this;
	var cancelCallback = function (){
		console.log("Home.loadSelectiveDialog    cancelCallback()");
	};
	var enterCallback = dojo.hitch(this, function (input, selected, checked, dialogWidget)
		{
			console.log("Home.loadSelectiveDialog    Doing enterCallback(input, selected, checked, dialogWidget)");
			console.log("Home.loadSelectiveDialog    input: " + input);
			console.log("Home.loadSelectiveDialog    selected: " + selected);
			console.log("Home.loadSelectiveDialog    checked: " + checked);
			console.log("Home.loadSelectiveDialog    dialogWidget: " + dialogWidget);
			
			// CLOSE DIALOG
			setTimeout(function(){
				dialogWidget.close();
			}, 100);
			
			// DO UPGRADE VERSION
			thisObject.runUpgrade(selected, packageObject);
		}
	);		

	// SHOW THE DIALOG
	this.selectiveDialog.load({
			title 				:	"Current " + packageObject["package"] + " version: " + packageObject.version,
			message 			:	"Select upgrade version",
			comboValues 		:	packageObject.current,
			comboMessage 		:	"Agua version",
			parentWidget 		:	this,
			enterCallback 		:	enterCallback,
			cancelCallback 		:	cancelCallback,
			enterLabel			:	"Upgrade",
			cancelLabel			:	"Cancel"
		}			
	);
},
runUpgrade : function (selectedVersion, packageObject) {
	console.log("Home.runUpgrade    selectedVersion: " + selectedVersion);
	console.log("Home.runUpgrade    packageObject: " + dojo.toJson(packageObject));

	console.log("plugins.home.Home.runUpgrade    Doing this.getStandby()");
	var standby = this.getStandby();
	console.log("plugins.home.Home.runUpgrade    standby: " + standby);

	// LAUNCH STANDBY
	standby.show();

	var thisObject = this;
	setTimeout(function(){
		thisObject.upgrade(selectedVersion, packageObject);
	}, 500);
},
upgrade : function (selectedVersion, packageObject) {
	
	packageObject.random = Math.floor(Math.random()*1000000000000);
	console.log("Home.upgrade    packageObject: " + dojo.toJson(packageObject));

	var url = Agua.cgiUrl + "workflow.cgi";
	var query = new Object;
	query.username = Agua.cookie('username');
	query.sessionid = Agua.cookie('sessionid');
	query["package"] = packageObject["package"];
	query.repository = packageObject["package"];
	query.version = selectedVersion;
	query.privacy = packageObject.privacy;
	query.owner = packageObject.owner;
	query.installdir = packageObject.installdir;
	query.mode = "upgrade";
	query.random = packageObject.random;
	console.log("packageObject" + dojo.toJson(packageObject));
	
	var thisObject = this;
	var xhrputReturn = dojo.xhrPut({
		url: url,
		contentType: "text",
		sync : false,
		handleAs: "json",
		putData: dojo.toJson(query),
		load: function(response, ioArgs) {
			if ( response.error != null ) {
				Agua.error("Home.runUpgrade    Error: " + response.error);
				thisObject.progressPane.hide();
				thisObject.progressPane.set('innerHTML', '');
				thisObject.stopProgress();
			}
			else {
				console.log("Home.runUpgrade    OK");

				// SHOW LOG
				var logfile = this.setLogFile(packageObject);
				var packageName = packageObject["package"];
				console.log("Home.upgrade    logfile: " + logfile);
				console.log("Home.upgrade    packageName: " + packageName);
				console.log("Home.upgrade    thisObject: " + thisObject);
				console.log("Home.upgrade    thisObject.progressPane: " + thisObject.progressPane);
				var title = thisObject(packageObject, version);
				console.log("Home.upgrade    title: " + title);
				thisObject.progressPane.set('title', title);
				thisObject.progressPane.set('href', logfile);
				thisObject.progressPane.show();
			
				// UPDATE PACKAGE IN AGUA DATA
				thisObject.updatePackage(packageObject);
				
				//// DISPLAY PROGRESS PAGE IN DIALOG
				//thisObject.showProgress(response.url, response.version);	
			}
			
			//// STOP STANDBY
			//thisObject.standby.hide();

		},
		error: function(response, ioArgs) {
			console.log("plugins.home.Home.runUpgrade    Error with JSON Post, response: " + dojo.toJson(response));
		}
	});	

	// DISPLAY PROGRESS PAGE IN DIALOG
	this.showProgress(packageObject, selectedVersion);	

	// STOP STANDBY
	this.standby.hide();
},
updatePackage : function (packageObject) {
	Agua.removePackage(packageObject);
	Agua.addPackage(packageObject);
	this.showCurrentVersion();
	
	if ( ! this.timer )	return;
	this.timer.stop();
	dojo.attr(this.timer, 'isRunning', false);
},
onClose : function() {
	console.log("Home.onClose    Home.onClose()");
	console.log("Home.onClose    ");
},
showProgress : function (packageObject, version) {
	console.log("Home.showProgress    packageObject: ");
	console.dir({packageObject:packageObject});
	console.log("Home.showProgress    version: " + version);

	// SET LOGFILE
	var logfile = this.setLogFile(packageObject);
	console.log("Home.showProgress    logfile: " + logfile);

	// SET TITLE
	var title = this.setTitle(packageObject, version);
	console.log("Home.showProgress    title: " + title);
	
	// SET PROGRESS PANE ATTRIBUTES AND SHOW
	this.progressPane.set('title', title);
	this.progressPane.set('href', logfile);
	this.progressPane.show();
	this.resizeProgress();

	this.pollProgress(logfile, version, packageObject);

	dojo.connect(this.progressPane, "close", dojo.hitch(this, "stopProgress"));
	dojo.connect(this.progressPane, "minimize", dojo.hitch(this, "stopProgress"));
	dojo.connect(this.progressPane, "resize", dojo.hitch(this, "startProgress"));
},
setLogFile : function (packageObject) {
	return "log/" + packageObject["package"] + "-upgradelog." + packageObject.random + ".html";
},
setTitle : function (packageObject, version) {
	var packageName = packageObject["package"];
	var title = packageName + " " + version + " upgrade log";

	return title;	
},
stopProgress : function () {
	console.log("Home.stopProgress    Home.stopProgress()");
	console.dir({timer:this.timer})
	if ( this.timer == null )	return;
	if ( dojo.attr(this.timer, 'isRunning') == false ) 	return;
	console.log("Home.stopProgress    Doing this.timer.stop()");
	dojo.attr(this.timer, 'isRunning', false);
	this.timer.stop();
	this.timer.interval = 999999999999;

	this.timer.onTick = function(){
		console.log("Home.stopProgress    timer.onTick()");
	}
	
	console.log("Home.stopProgress    Doing window.clearInterval(this.timer.timer)");
	window.clearInterval(this.timer.timer);
},
startProgress : function () {	
	// RESET TIMER INTERVAL
	this.timer.interval = this.timerInterval;
	console.log("Home.startProgress    timer:");
	console.dir({timer:this.timer})

	// RETURN IF TIMER isRunning
	if ( dojo.attr(this.timer, 'isRunning') == true ) 	return;
	console.log("Home.startProgress    Doing this.timer.start()");

	// SET TIMER isRunning
	dojo.attr(this.timer, 'isRunning', true);
	this.timer.start();
	this.resizeProgress();
},
resizeProgress : function () {
	if ( ! this.progressPane )	return;
	var node = this.progressPane.domNode;
	var viewport = dojo.window.getBox();
	var borderBox = dojo._getBorderBox(node);
	l = Math.floor(viewport.l + (viewport.w - borderBox.w) / 2);
	t = Math.floor(viewport.t + (viewport.h - borderBox.h) / 2);

	var dimensions = {
		left: l + "px",
		top: t + "px"
	};
	dojo.style(node, dimensions);
},
pollProgress : function (url, version, packageObject) {
	console.log("Home.pollProgress    Home.pollProgress(url, version)");
	console.log("Home.pollProgress    url: " + url);
	console.log("Home.pollProgress    version: " + version);
	
	// SET this.packageObject
	this.packageObject = packageObject;
	
	var thisObject = this;	
	this.timer.onTick = function() {
		console.log("Home.pollProgress    timer onTick: " + new Date().toTimeString());
		thisObject.progressPane.set('href', '');
		thisObject.progressPane.set('href', url);
		thisObject.progressPane.show();
	};	
	
	this.timer.start();
	dojo.attr(this.timer, 'isRunning', true);
},
reportedVersion : function() {
	console.log("Home.reportedVersion    plugins.home.Home.reportedVersion");
	var report = this.progressPane.containerNode.innerHTML;
	//console.dir({report:report});
	var version;
	var match = report.match(/Completed installation, version:\s*(\S+)/);
    if ( match ) {
	    version = match[1];
	}
	console.log("Home.reportedVersion    version: " + version);

	return version;
},
// PROGRESS PANE
_onShow : function () {
	console.log("Home.setProgressPane    this.progressPane._onShow");

	var thisObject = this;
	setTimeout ( function () {
		var report = thisObject.progressPane.containerNode.innerHTML;
		console.dir({report:report});
		var reportedVersion = thisObject.reportedVersion();
		//console.log("Home._onShow    reportedVersion: " + reportedVersion);
		if ( reportedVersion )  {
			console.log("Home._onShow    reportedVersion is defined: " + reportedVersion + ". Stopping timer");
			thisObject.stopProgress();
			
			thisObject.packageObject.version = reportedVersion;
			thisObject.setVersion(thisObject.packageObject);
	
			// RELOAD RELEVANT DISPLAYS
			Agua.updater.update("updatePackages", { originator: thisObject });	
		}
	},
	2000);
	
},
setVersion : function(packageObject) {
	console.log("Home.setVersion    packagObject: " + dojo.toJson(packageObject, true));	
	
	Agua.removePackage(packageObject);
	Agua.addPackage(packageObject);
	this.setPackageCombo(packageObject["package"]);
	this.showCurrentVersion();
},
getStandby : function () {
	console.log("Stages.getStandby    Stages.getStandby()");
	if ( this.standby == null ) {

		var id = dijit.getUniqueId("dojox_widget_Standby");
		this.standby = new dojox.widget.Standby (
			{
				target: this.bottomPane,
				onClick: "reload",
				text: "Running upgrade",
				id : id,
				url: "plugins/core/images/agua-biwave-24.png"
			}
		);
		document.body.appendChild(this.standby.domNode);
	}

	console.log("Stages.getStandby    this.standby: " + this.standby);

	return this.standby;
},
newWindow : function () {
// RELOAD AGUA
	console.log("plugins.home.Home.newWindow    Home.newWindow()");
	var url = window.location;
	window.open(location, '_blank', 'toolbar=1,location=0,directories=0,status=0,menubar=1,scrollbars=1,resizable=1,navigation=0'); 
	//window.location.newWindow();
},
parseVersion : function (version) {
    var versionObject = {};
    if ( ! version.match(/^(\d+)\.(\d+)\.(\d+)(-)?(\S+)?$/) ) {
        //console.log("version does not match: " + version);
		return;
    }
    else {
        versionObject.major = parseInt(version.match(/^(\d+)\.(\d+)\.(\d+)(-\S+)?(\+\S+)?$/)[1]);
        versionObject.minor = parseInt(version.match(/^(\d+)\.(\d+)\.(\d+)(-\S+)?(\+\S+)?$/)[2]);
        versionObject.patch = parseInt(version.match(/^(\d+)\.(\d+)\.(\d+)(-\S+)?(\+\S+)?$/)[3]);
        versionObject.release = version.match(/^(\d+)\.(\d+)\.(\d+)(-\S+)?(\+\S+)?$/)[4];
        versionObject.build = version.match(/^(\d+)\.(\d+)\.(\d+)(-\S+)?(\+\S+)?$/)[5];
		
		if ( versionObject.release )	versionObject.release = versionObject.release.replace(/^-/,'');
		if ( versionObject.build )	versionObject.build = versionObject.build.replace(/^\+/,'');
    }
	
    //console.log("major: " + versionObject.major);
    //console.log("minor: " + versionObject.minor);
    //console.log("patch: " + versionObject.patch);
    //console.log("release: " + versionObject.release);
    //console.log("build: " + versionObject.build);

    return versionObject;
},
returnValue : function (value) {
	//var caller = this.returnValue.caller.nom;
	//console.log(caller + " this.returnValue value: " + value);
	return value;
},
compareStringNumber : function (a, b) {
    if ( ! a.match(/^(\D+)(\d+)$/) && ! b.match(/^(\D+)(\d+)$/) ) {
		var compare = a.toLowerCase().localeCompare(b.toLowerCase());
		//console.log("compareStringNumber    compare: " + compare);
		return compare;
    }
	else {
		var aObject = this.splitStringNumber(a);
		var bObject = this.splitStringNumber(b);
		//console.dir({aObject:aObject});
		//console.dir({bObject:bObject});
		
		if ( aObject.string != bObject.string ) {
			var compare = a.toLowerCase().localeCompare(b.toLowerCase());
			//console.log("compareStringNumber    stringObject compare: " + compare);
			this.returnValue(compare);
		}
		else {
			//console.log("compareStringNumber    comparing numbers");

			if ( ! aObject.number && ! bObject.number ) {
				this.returnValue(0);
			}
			else if ( aObject.number && ! bObject.number ) {
				this.returnValue(1);
			}
			else if ( bObject.number && ! aObject.number ) {
				this.returnValue(-1);
			}
			else if ( parseInt(aObject.number) > parseInt(bObject.number) ) {
				//	console.log("a is larger than a");
				return 1;
			}
			else if ( parseInt(bObject.number) > parseInt(aObject.number) ) {
				//console.log("b is larger than a");
				return -1;
			}
			else {
				this.returnValue(0);
			}
		}
	}
	
	return null;
},
splitStringNumber : function (string) {
	//if ( ! string.match(/^(\D+)(\d+)$/) )	return;
	var stringObject = new Object;
	stringObject.string = string.match(/^(\D+)/)[1];
	if ( string.match(/^(\D+)(\d+)$/) )
		stringObject.number = string.match(/^(\D+)(\d+)$/)[2];
	return stringObject;
},
destroyRecursive : function () {
	console.log("Home.destroyRecursive    this.mainTab: ");
	console.dir({this_mainTab:this.mainTab});
	if ( Agua && Agua.tabs )
		Agua.tabs.removeChild(this.mainTab);
	
//	this.destroy();
//	this.inherited(arguments);
},
// UTILS
showLatestInstalled : function (packageName, version) {
	console.dir({simpleDialog:this.simpleDialog});
	this.simpleDialog.titleNode.innerHTML = "Latest version of " + packageName + " is installed (version " + version + ")";

	this.simpleDialog.show();
},
getPackageObject : function (packageName) {
	var packages = Agua.getPackages();
	//console.log("Home.getPackageObject    packages: ");
	console.dir({packages:packages});
	
	for ( var i = 0; i < packages.length; i++ ) {
		if ( packages[i]["package"] == packageName ) {
			return packages[i];
			break;
		}
	}
	
	return;
},
laterVersions : function (versions) {

	for ( var i = 0; i < versions.length; i++ ) {
		var version = versions[i].version;
		var versionarray = versions[i].current;
		for ( var k = 0; k < versionarray.length; k++ ) {
			
			console.log("laterVersions    versionarray[" + k + "]: " + versionarray[k]);

			if ( versionarray[k] == version ) {
				versionarray.splice(k, 1);
				break;
			}
			else {
				versionarray.splice(k, 1);
				k--;
			}
		}
	}

	return versions;
},
sortVersions : function (versions) {

	console.log("Home.sortVersions    versions: " + dojo.toJson(versions));
	var thisObject = this;
	var versionSort = function (a,b) {
		//console.log("a: " + a);
		//console.log("b: " + b);
	
		var aVersion = thisObject.parseVersion(a);
		var bVersion = thisObject.parseVersion(b);
	
		//console.log("aVersion.major: " + aVersion.major);
		//console.log("aVersion.minor: " + aVersion.minor);
		//console.log("aVersion.patch: " + aVersion.patch);
		//console.log("aVersion.release: " + aVersion.release);
		//console.log("aVersion.build: " + aVersion.build);
		//
		//console.log("bVersion.major: " + bVersion.major);
		//console.log("bVersion.minor: " + bVersion.minor);
		//console.log("bVersion.patch: " + bVersion.patch);
		//console.log("bVersion.release: " + bVersion.release);
		//console.log("bVersion.build: " + bVersion.build);
	
		if ( aVersion.major > bVersion.major )	return thisObject.returnValue(1);
		else if ( bVersion.major > aVersion.major ) return thisObject.returnValue(-1);
		if ( aVersion.minor > bVersion.minor )	return thisObject.returnValue(1);
		else if ( bVersion.minor > aVersion.minor ) return thisObject.returnValue(-1);
		if ( aVersion.patch > bVersion.patch )	return thisObject.returnValue(1);
		else if ( bVersion.patch > aVersion.patch ) return thisObject.returnValue(-1);
		if ( ! aVersion.release && ! bVersion.release
			&& ! aVersion.build && ! bVersion.build )	return thisObject.returnValue(0);
		
		if ( aVersion.release && ! bVersion.release )	return thisObject.returnValue(1);
		if ( bVersion.release && ! aVersion.release )	return thisObject.returnValue(-1);
		
		if ( aVersion.release && bVersion.release ) {
			return thisObject.compareStringNumber(aVersion.release, bVersion.release);
		}
		
		if ( aVersion.build && ! bVersion.build )	return thisObject.returnValue(1);
		if ( bVersion.build && ! aVersion.build )	return thisObject.returnValue(-1);
		if ( aVersion.build && bVersion.build ) {
			return thisObject.compareStringNumber(aVersion.build, bVersion.build);
		}
		
		return thisObject.returnValue(0);
	};

	versions = versions.sort(versionSort);

	//versions = versions.reverse();	
	return versions;
}


}); // end of plugins.home.Home

}

if(!dojo._hasResource["plugins.home.Controller"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.home.Controller"] = true;
dojo.provide("plugins.home.Controller");

// OBJECT:  plugins.home.Controller
// PURPOSE: GENERATE AND MANAGE Home PANES

// INHERITS


// HAS


dojo.declare( "plugins.home.Controller",
	[ dijit._Widget, dijit._Templated, plugins.core.Common ], {
//Path to the template of this widget. 
templateString:"<div dojoAttachPoint=\"containerNode\">\n    <button\n        dojoType=\"dijit.form.Button\"\n        dojoAttachPoint=\"menuButton\"\n        class=\"menuButton\"\n        iconClass=\"homeIcon\"\n        type=\"button\"\n        label=\"Home\"\n    >\n    </button>\n\n</div>\n        \n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

// CSS FILE FOR BUTTON STYLING
cssFiles : [ "plugins/home/css/controller.css" ],

// ARRAY OF TAB PANES
tabPanes : [],

////}}}
// CONSTRUCTOR	
constructor : function(args) {
	console.log("Controller.constructor     plugins.home.Controller.constructor");
	//console.log("Controller.args: " + dojo.toJson(args));
	// LOAD CSS FOR BUTTON
	this.loadCSS();
},
postCreate : function() {
	console.log("Controller.postCreate    plugins.home.Controller.postCreate()");

	this.startup();
},
startup : function () {
	console.log("Controller.startup    plugins.home.Controller.startup()");

	this.inherited(arguments);

	// ADD MENU BUTTON TO TOOLBAR
	Agua.toolbar.addChild(this.menuButton);

	// SET BUTTON PARENT WIDGET
	this.menuButton.parentWidget = this;
	
	// SET ADMIN BUTTON LISTENER
	var listener = dojo.connect(this.menuButton, "onClick", this, "createTab");
},
createTab : function (args) {
	console.log("Controller.createTab    plugins.home.Controller.createTab");
	
	if ( args == null ) args = new Object;
	args.attachWidget = Agua.tabs;

	// CREATE WIDGET	
	var widget = new plugins.home.Home(args);
	this.tabPanes.push(widget);

	// ADD TO _supportingWidgets FOR INCLUSION IN DESTROY	
	this._supportingWidgets.push(widget);
	
	return widget;
}

}); // end of Controller

dojo.addOnLoad( function() {
		// CREATE TAB
		//console.log("plugins.home.Controller    Doing Agua.controllers['home'].createTab()");
		//Agua.controllers["home"].createTab();		
	}
);

}

if(!dojo._hasResource["dijit.dijit"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.dijit"] = true;
dojo.provide("dijit.dijit");









/*=====
dijit.dijit = {
	// summary:
	//		A roll-up for common dijit methods
	// description:
	//	A rollup file for the build system including the core and common
	//	dijit files.
	//
	// example:
	// | <script type="text/javascript" src="js/dojo/dijit/dijit.js"></script>
	//
};
=====*/

// All the stuff in _base (these are the function that are guaranteed available without an explicit dojo.require)

// And some other stuff that we tend to pull in all the time anyway

}

if(!dojo._hasResource["dijit.form.HorizontalSlider"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.HorizontalSlider"] = true;
dojo.provide("dijit.form.HorizontalSlider");







dojo.declare(
	"dijit.form.HorizontalSlider",
	[dijit.form._FormValueWidget, dijit._Container],
{
	// summary:
	//		A form widget that allows one to select a value with a horizontally draggable handle

	templateString: dojo.cache("dijit.form", "templates/HorizontalSlider.html", "<table class=\"dijit dijitReset dijitSlider dijitSliderH\" cellspacing=\"0\" cellpadding=\"0\" border=\"0\" rules=\"none\" dojoAttachEvent=\"onkeypress:_onKeyPress,onkeyup:_onKeyUp\"\n\t><tr class=\"dijitReset\"\n\t\t><td class=\"dijitReset\" colspan=\"2\"></td\n\t\t><td dojoAttachPoint=\"topDecoration\" class=\"dijitReset dijitSliderDecoration dijitSliderDecorationT dijitSliderDecorationH\"></td\n\t\t><td class=\"dijitReset\" colspan=\"2\"></td\n\t></tr\n\t><tr class=\"dijitReset\"\n\t\t><td class=\"dijitReset dijitSliderButtonContainer dijitSliderButtonContainerH\"\n\t\t\t><div class=\"dijitSliderDecrementIconH\" style=\"display:none\" dojoAttachPoint=\"decrementButton\"><span class=\"dijitSliderButtonInner\">-</span></div\n\t\t></td\n\t\t><td class=\"dijitReset\"\n\t\t\t><div class=\"dijitSliderBar dijitSliderBumper dijitSliderBumperH dijitSliderLeftBumper\" dojoAttachEvent=\"onmousedown:_onClkDecBumper\"></div\n\t\t></td\n\t\t><td class=\"dijitReset\"\n\t\t\t><input dojoAttachPoint=\"valueNode\" type=\"hidden\" ${!nameAttrSetting}\n\t\t\t/><div class=\"dijitReset dijitSliderBarContainerH\" role=\"presentation\" dojoAttachPoint=\"sliderBarContainer\"\n\t\t\t\t><div role=\"presentation\" dojoAttachPoint=\"progressBar\" class=\"dijitSliderBar dijitSliderBarH dijitSliderProgressBar dijitSliderProgressBarH\" dojoAttachEvent=\"onmousedown:_onBarClick\"\n\t\t\t\t\t><div class=\"dijitSliderMoveable dijitSliderMoveableH\"\n\t\t\t\t\t\t><div dojoAttachPoint=\"sliderHandle,focusNode\" class=\"dijitSliderImageHandle dijitSliderImageHandleH\" dojoAttachEvent=\"onmousedown:_onHandleClick\" role=\"slider\" valuemin=\"${minimum}\" valuemax=\"${maximum}\"></div\n\t\t\t\t\t></div\n\t\t\t\t></div\n\t\t\t\t><div role=\"presentation\" dojoAttachPoint=\"remainingBar\" class=\"dijitSliderBar dijitSliderBarH dijitSliderRemainingBar dijitSliderRemainingBarH\" dojoAttachEvent=\"onmousedown:_onBarClick\"></div\n\t\t\t></div\n\t\t></td\n\t\t><td class=\"dijitReset\"\n\t\t\t><div class=\"dijitSliderBar dijitSliderBumper dijitSliderBumperH dijitSliderRightBumper\" dojoAttachEvent=\"onmousedown:_onClkIncBumper\"></div\n\t\t></td\n\t\t><td class=\"dijitReset dijitSliderButtonContainer dijitSliderButtonContainerH\"\n\t\t\t><div class=\"dijitSliderIncrementIconH\" style=\"display:none\" dojoAttachPoint=\"incrementButton\"><span class=\"dijitSliderButtonInner\">+</span></div\n\t\t></td\n\t></tr\n\t><tr class=\"dijitReset\"\n\t\t><td class=\"dijitReset\" colspan=\"2\"></td\n\t\t><td dojoAttachPoint=\"containerNode,bottomDecoration\" class=\"dijitReset dijitSliderDecoration dijitSliderDecorationB dijitSliderDecorationH\"></td\n\t\t><td class=\"dijitReset\" colspan=\"2\"></td\n\t></tr\n></table>\n"),

	// Overrides FormValueWidget.value to indicate numeric value
	value: 0,

	// showButtons: [const] Boolean
	//		Show increment/decrement buttons at the ends of the slider?
	showButtons: true,

	// minimum:: [const] Integer
	//		The minimum value the slider can be set to.
	minimum: 0,

	// maximum: [const] Integer
	//		The maximum value the slider can be set to.
	maximum: 100,

	// discreteValues: Integer
	//		If specified, indicates that the slider handle has only 'discreteValues' possible positions,
	//		and that after dragging the handle, it will snap to the nearest possible position.
	//		Thus, the slider has only 'discreteValues' possible values.
	//
	//		For example, if minimum=10, maxiumum=30, and discreteValues=3, then the slider handle has
	//		three possible positions, representing values 10, 20, or 30.
	//
	//		If discreteValues is not specified or if it's value is higher than the number of pixels
	//		in the slider bar, then the slider handle can be moved freely, and the slider's value will be
	//		computed/reported based on pixel position (in this case it will likely be fractional,
	//		such as 123.456789).
	discreteValues: Infinity,

	// pageIncrement: Integer
	//		If discreteValues is also specified, this indicates the amount of clicks (ie, snap positions)
	//		that the slider handle is moved via pageup/pagedown keys.
	//		If discreteValues is not specified, it indicates the number of pixels.
	pageIncrement: 2,

	// clickSelect: Boolean
	//		If clicking the slider bar changes the value or not
	clickSelect: true,

	// slideDuration: Number
	//		The time in ms to take to animate the slider handle from 0% to 100%,
	//		when clicking the slider bar to make the handle move.
	slideDuration: dijit.defaultDuration,

	// Flag to _Templated  (TODO: why is this here?  I see no widgets in the template.)
	widgetsInTemplate: true,

	attributeMap: dojo.delegate(dijit.form._FormWidget.prototype.attributeMap, {
		id: ""
	}),

	baseClass: "dijitSlider",

	// Apply CSS classes to up/down arrows and handle per mouse state
	cssStateNodes: {
		incrementButton: "dijitSliderIncrementButton",
		decrementButton: "dijitSliderDecrementButton",
		focusNode: "dijitSliderThumb"
	},

	_mousePixelCoord: "pageX",
	_pixelCount: "w",
	_startingPixelCoord: "x",
	_startingPixelCount: "l",
	_handleOffsetCoord: "left",
	_progressPixelSize: "width",

	_onKeyUp: function(/*Event*/ e){
		if(this.disabled || this.readOnly || e.altKey || e.ctrlKey || e.metaKey){ return; }
		this._setValueAttr(this.value, true);
	},

	_onKeyPress: function(/*Event*/ e){
		if(this.disabled || this.readOnly || e.altKey || e.ctrlKey || e.metaKey){ return; }
		switch(e.charOrCode){
			case dojo.keys.HOME:
				this._setValueAttr(this.minimum, false);
				break;
			case dojo.keys.END:
				this._setValueAttr(this.maximum, false);
				break;
			// this._descending === false: if ascending vertical (min on top)
			// (this._descending || this.isLeftToRight()): if left-to-right horizontal or descending vertical
			case ((this._descending || this.isLeftToRight()) ? dojo.keys.RIGHT_ARROW : dojo.keys.LEFT_ARROW):
			case (this._descending === false ? dojo.keys.DOWN_ARROW : dojo.keys.UP_ARROW):
			case (this._descending === false ? dojo.keys.PAGE_DOWN : dojo.keys.PAGE_UP):
				this.increment(e);
				break;
			case ((this._descending || this.isLeftToRight()) ? dojo.keys.LEFT_ARROW : dojo.keys.RIGHT_ARROW):
			case (this._descending === false ? dojo.keys.UP_ARROW : dojo.keys.DOWN_ARROW):
			case (this._descending === false ? dojo.keys.PAGE_UP : dojo.keys.PAGE_DOWN):
				this.decrement(e);
				break;
			default:
				return;
		}
		dojo.stopEvent(e);
	},

	_onHandleClick: function(e){
		if(this.disabled || this.readOnly){ return; }
		if(!dojo.isIE){
			// make sure you get focus when dragging the handle
			// (but don't do on IE because it causes a flicker on mouse up (due to blur then focus)
			dijit.focus(this.sliderHandle);
		}
		dojo.stopEvent(e);
	},

	_isReversed: function(){
		// summary:
		//		Returns true if direction is from right to left
		// tags:
		//		protected extension
		return !this.isLeftToRight();
	},

	_onBarClick: function(e){
		if(this.disabled || this.readOnly || !this.clickSelect){ return; }
		dijit.focus(this.sliderHandle);
		dojo.stopEvent(e);
		var abspos = dojo.position(this.sliderBarContainer, true);
		var pixelValue = e[this._mousePixelCoord] - abspos[this._startingPixelCoord];
		this._setPixelValue(this._isReversed() ? (abspos[this._pixelCount] - pixelValue) : pixelValue, abspos[this._pixelCount], true);
		this._movable.onMouseDown(e);
	},

	_setPixelValue: function(/*Number*/ pixelValue, /*Number*/ maxPixels, /*Boolean?*/ priorityChange){
		if(this.disabled || this.readOnly){ return; }
		pixelValue = pixelValue < 0 ? 0 : maxPixels < pixelValue ? maxPixels : pixelValue;
		var count = this.discreteValues;
		if(count <= 1 || count == Infinity){ count = maxPixels; }
		count--;
		var pixelsPerValue = maxPixels / count;
		var wholeIncrements = Math.round(pixelValue / pixelsPerValue);
		this._setValueAttr((this.maximum-this.minimum)*wholeIncrements/count + this.minimum, priorityChange);
	},

	_setValueAttr: function(/*Number*/ value, /*Boolean?*/ priorityChange){
		// summary:
		//		Hook so set('value', value) works.
		this._set("value", value);
		this.valueNode.value = value;
		dijit.setWaiState(this.focusNode, "valuenow", value);
		this.inherited(arguments);
		var percent = (value - this.minimum) / (this.maximum - this.minimum);
		var progressBar = (this._descending === false) ? this.remainingBar : this.progressBar;
		var remainingBar = (this._descending === false) ? this.progressBar : this.remainingBar;
		if(this._inProgressAnim && this._inProgressAnim.status != "stopped"){
			this._inProgressAnim.stop(true);
		}
		if(priorityChange && this.slideDuration > 0 && progressBar.style[this._progressPixelSize]){
			// animate the slider
			var _this = this;
			var props = {};
			var start = parseFloat(progressBar.style[this._progressPixelSize]);
			var duration = this.slideDuration * (percent-start/100);
			if(duration == 0){ return; }
			if(duration < 0){ duration = 0 - duration; }
			props[this._progressPixelSize] = { start: start, end: percent*100, units:"%" };
			this._inProgressAnim = dojo.animateProperty({ node: progressBar, duration: duration,
				onAnimate: function(v){ remainingBar.style[_this._progressPixelSize] = (100-parseFloat(v[_this._progressPixelSize])) + "%"; },
				onEnd: function(){ delete _this._inProgressAnim; },
				properties: props
			})
			this._inProgressAnim.play();
		}else{
			progressBar.style[this._progressPixelSize] = (percent*100) + "%";
			remainingBar.style[this._progressPixelSize] = ((1-percent)*100) + "%";
		}
	},

	_bumpValue: function(signedChange, /*Boolean?*/ priorityChange){
		if(this.disabled || this.readOnly){ return; }
		var s = dojo.getComputedStyle(this.sliderBarContainer);
		var c = dojo._getContentBox(this.sliderBarContainer, s);
		var count = this.discreteValues;
		if(count <= 1 || count == Infinity){ count = c[this._pixelCount]; }
		count--;
		var value = (this.value - this.minimum) * count / (this.maximum - this.minimum) + signedChange;
		if(value < 0){ value = 0; }
		if(value > count){ value = count; }
		value = value * (this.maximum - this.minimum) / count + this.minimum;
		this._setValueAttr(value, priorityChange);
	},

	_onClkBumper: function(val){
		if(this.disabled || this.readOnly || !this.clickSelect){ return; }
		this._setValueAttr(val, true);
	},

	_onClkIncBumper: function(){
		this._onClkBumper(this._descending === false ? this.minimum : this.maximum);
	},

	_onClkDecBumper: function(){
		this._onClkBumper(this._descending === false ? this.maximum : this.minimum);
	},

	decrement: function(/*Event*/ e){
		// summary:
		//		Decrement slider
		// tags:
		//		private
		this._bumpValue(e.charOrCode == dojo.keys.PAGE_DOWN ? -this.pageIncrement : -1);
	},

	increment: function(/*Event*/ e){
		// summary:
		//		Increment slider
		// tags:
		//		private
		this._bumpValue(e.charOrCode == dojo.keys.PAGE_UP ? this.pageIncrement : 1);
	},

	_mouseWheeled: function(/*Event*/ evt){
		// summary:
		//		Event handler for mousewheel where supported
		dojo.stopEvent(evt);
		var janky = !dojo.isMozilla;
		var scroll = evt[(janky ? "wheelDelta" : "detail")] * (janky ? 1 : -1);
		this._bumpValue(scroll < 0 ? -1 : 1, true); // negative scroll acts like a decrement
	},

	startup: function(){
		if(this._started){ return; }

		dojo.forEach(this.getChildren(), function(child){
			if(this[child.container] != this.containerNode){
				this[child.container].appendChild(child.domNode);
			}
		}, this);

		this.inherited(arguments);
	},

	_typematicCallback: function(/*Number*/ count, /*Object*/ button, /*Event*/ e){
		if(count == -1){
			this._setValueAttr(this.value, true);
		}else{
			this[(button == (this._descending? this.incrementButton : this.decrementButton)) ? "decrement" : "increment"](e);
		}
	},

	buildRendering: function(){
		this.inherited(arguments);
		if(this.showButtons){
			this.incrementButton.style.display="";
			this.decrementButton.style.display="";
		}

		// find any associated label element and add to slider focusnode.
		var label = dojo.query('label[for="'+this.id+'"]');
		if(label.length){
			label[0].id = (this.id+"_label");
			dijit.setWaiState(this.focusNode, "labelledby", label[0].id);
		}

		dijit.setWaiState(this.focusNode, "valuemin", this.minimum);
		dijit.setWaiState(this.focusNode, "valuemax", this.maximum);
	},

	postCreate: function(){
		this.inherited(arguments);

		if(this.showButtons){
			this._connects.push(dijit.typematic.addMouseListener(
				this.decrementButton, this, "_typematicCallback", 25, 500));
			this._connects.push(dijit.typematic.addMouseListener(
				this.incrementButton, this, "_typematicCallback", 25, 500));
		}
		this.connect(this.domNode, !dojo.isMozilla ? "onmousewheel" : "DOMMouseScroll", "_mouseWheeled");

		// define a custom constructor for a SliderMover that points back to me
		var mover = dojo.declare(dijit.form._SliderMover, {
			widget: this
		});
		this._movable = new dojo.dnd.Moveable(this.sliderHandle, {mover: mover});

		this._layoutHackIE7();
	},

	destroy: function(){
		this._movable.destroy();
		if(this._inProgressAnim && this._inProgressAnim.status != "stopped"){
			this._inProgressAnim.stop(true);
		}
		this._supportingWidgets = dijit.findWidgets(this.domNode); // tells destroy about pseudo-child widgets (ruler/labels)
		this.inherited(arguments);
	}
});

dojo.declare("dijit.form._SliderMover",
	dojo.dnd.Mover,
{
	onMouseMove: function(e){
		var widget = this.widget;
		var abspos = widget._abspos;
		if(!abspos){
			abspos = widget._abspos = dojo.position(widget.sliderBarContainer, true);
			widget._setPixelValue_ = dojo.hitch(widget, "_setPixelValue");
			widget._isReversed_ = widget._isReversed();
		}
		var coordEvent = e.touches ? e.touches[0] : e, // if multitouch take first touch for coords
			pixelValue = coordEvent[widget._mousePixelCoord] - abspos[widget._startingPixelCoord];
		widget._setPixelValue_(widget._isReversed_ ? (abspos[widget._pixelCount]-pixelValue) : pixelValue, abspos[widget._pixelCount], false);
	},

	destroy: function(e){
		dojo.dnd.Mover.prototype.destroy.apply(this, arguments);
		var widget = this.widget;
		widget._abspos = null;
		widget._setValueAttr(widget.value, true);
	}
});

}

if(!dojo._hasResource["plugins.init.Init"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.init.Init"] = true;
dojo.provide("plugins.init.Init");

// INITIALISE AGUA - MOUNT DATA VOLUMES AND STORE ADMIN KEYS

// INHERITS






 // optimize: load dijit layer
	// scan page for widgets and instantiate them



// FORM VALIDATION



dojo.declare("plugins.init.Init",
	[ dijit._Widget, dijit._Templated, plugins.core.Common ], {

//Path to the template of this widget. 
templateString:"<div dojoattachpoint=\"containerNode\">\n\n\t<!-- init TAB -->\n\t<div\n\t\tdojoAttachPoint=\"initTab\"\n\t\tclass=\"init\"\n\t\tdojoType=\"dijit.layout.ContentPane\"\n\t\ttitle=\"Settings\"\n\t\tstyle=\"text-align: center; max-height: auto !important; min-width: 100% !important; padding: 0 !important;\"\n\t\t>\n\n\t\t<table class=\"mainTable\">\n\t\t\t<tr class=\"aguaIconBackground\">\n\t\t\t\t<td align=\"center\" class=\"aguaIcon\"></td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td class=\"title\"> Input user information and 'Save' to load data and user volumes </div>\n\t\t\t</tr>\n\t\t\t\n\t\t\t<tr align=\"center\" width=\"100%\">\n\t\t\t\t<td width=\"100%\">\n\t\t\t\t\t<div\n\t\t\t\t\t\tdojoAttachPoint=\"initTable\"\n\t\t\t\t\t\tclass=\"initTable\"\n\t\t\t\t\t\tstyle=\"height: 800px; \"\n\t\t\t\t\t>\n\t\t\t\t\t\t<table width=\"840px\" align=\"center\">\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td\n\t\t\t\t\t\t\t\t\tcolspan=\"3\"\n\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"progressButton\"\n\t\t\t\t\t\t\t\t\tclass=\"progressButton\"\n\t\t\t\t\t\t\t\t\tdojoAttachEvent=\"onclick:openProgressLog\"\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\tProgress Log\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td\n\t\t\t\t\t\t\t\t\tcolspan=\"3\"\n\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"saveButton\"\n\t\t\t\t\t\t\t\t\tclass=\"saveButton\"\n\t\t\t\t\t\t\t\t\tdojoAttachEvent=\"onclick:save\"\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\tSave\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td colspan=\"3\" align=\"center\">\n\t\t\t\t\t\t\t\t\t<table>\n\t\t\t\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t\t\t\t<td class=\"sublabel\">Admin User</td>\n\t\t\t\t\t\t\t\t\t\t\t<td colspan=\"2\">\n\t\t\t\t\t\t\t\t\t\t\t\t<input\n\t\t\t\t\t\t\t\t\t\t\t\t\tclass=\"adminUser\"\n\t\t\t\t\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"adminuser\"\n\t\t\t\t\t\t\t\t\t\t\t\t\ttype=\"text\"\n\t\t\t\t\t\t\t\t\t\t\t\t\tdojoType=\"dijit.form.ValidationTextBox\"\n\t\t\t\t\t\t\t\t\t\t\t\t\tmaxlength=\"20\"\n\t\t\t\t\t\t\t\t\t\t\t\t\tvalue=\"admin\"\n\t\t\t\t\t\t\t\t\t\t\t\t\tregExpGen=\"return '[a-z]{5,20}'\"\n\t\t\t\t\t\t\t\t\t\t\t\t\tinvalidMessage=\"Lowercase letters (5-20)\"\n\t\t\t\t\t\t\t\t\t\t\t\t\tpromptMessage=\"Lowercase letters (5-20)\"\n\t\t\t\t\t\t\t\t\t\t\t\t\trequired=\"false\"\n\t\t\t\t\t\t\t\t\t\t\t\t/> \n\t\t\t\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t\t\t\t<td class=\"sublabel\">Admin Password</td>\n\t\t\t\t\t\t\t\t\t\t\t<td colspan=\"2\">\n\t\t\t\t\t\t\t\t\t\t\t\t<input\n\t\t\t\t\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"password\"\n\t\t\t\t\t\t\t\t\t\t\t\t\tdojoType=\"plugins.dijit.form.ValidationTextBox\"\n\t\t\t\t\t\t\t\t\t\t\t\t\trequired=\"true\"\n\t\t\t\t\t\t\t\t\t\t\t\t\tinvalidMessage=\"Passwords don't match\"\n\t\t\t\t\t\t\t\t\t\t\t\t\tclass=\"password\"\n\t\t\t\t\t\t\t\t\t\t\t\t\ttype=\"password\"\n\t\t\t\t\t\t\t\t\t\t\t\t\ttooltipPosition=\"below\"\n\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t\t\t\t<td class=\"sublabel\">Confirm Password</td>\n\t\t\t\t\t\t\t\t\t\t\t<td colspan=\"2\">\n\t\t\t\t\t\t\t\t\t\t\t\t<input\n\t\t\t\t\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"confirmPassword\"\n\t\t\t\t\t\t\t\t\t\t\t\t\tdojoType=\"plugins.dijit.form.ValidationTextBox\"\n\t\t\t\t\t\t\t\t\t\t\t\t\trequired=\"true\"\n\t\t\t\t\t\t\t\t\t\t\t\t\tinvalidMessage=\"Passwords don't match\"\n\t\t\t\t\t\t\t\t\t\t\t\t\tclass=\"confirmPassword\"\n\t\t\t\t\t\t\t\t\t\t\t\t\ttype=\"password\"\n\t\t\t\t\t\t\t\t\t\t\t\t\ttooltipPosition=\"below\"\n\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t</td>\t\n\t\t\t\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t\t\t</table>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td align=\"center\"\n\t\t\t\t\t\t\t\t\tcolspan=\"3\"\n\t\t\t\t\t\t\t\t\tclass=\"sublabel\"\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\tData Volume\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td colspan=\"1\"\n\t\t\t\t\t\t\t\t\tclass=\"dataVolumeContainer\"\n\t\t\t\t\t\t\t\t\talign=\"right\"\n\t\t\t\t\t\t\t\t\ttitle=\"REQUIRED: Input snapshot ID (to copy) or volume ID (to mount).\nDEFAULT    : Data snapshot for the current version of Agua\"\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t<input\n\t\t\t\t\t\t\t\t\t\tclass=\"dataVolume\"\n\t\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"datavolume\"\n\t\t\t\t\t\t\t\t\t\ttype=\"text\"\n\t\t\t\t\t\t\t\t\t\tdojoType=\"dijit.form.ValidationTextBox\"\n\t\t\t\t\t\t\t\t\t\tmaxlength=\"13\" \n\t\t\t\t\t\t\t\t\t\tvalue=\"snap-6341b301\"\n\t\t\t\t\t\t\t\t\t\tregExpGen=\"return '^(snap|vol)\\-[A-F0-9a-f]{8}'\"\n\t\t\t\t\t\t\t\t\t\tinvalidMessage=\"Required format: 'snap-abcdef09' or 'vol-abcdef09'\"\n\t\t\t\t\t\t\t\t\t\tpromptMessage=\"Enter snapshot or volume ID\"\n\t\t\t\t\t\t\t\t\t\trequired=\"true\"\n\t\t\t\t\t\t\t\t\t/> \n\t\t\t\t\t\t\t\t</td>\n\n\t\t\t\t\t\t\t\t<td colspan=\"1\"\n\t\t\t\t\t\t\t\t\talign=\"left\"\n\t\t\t\t\t\t\t\t\tclass=\"dataVolumeSizeContainer\"\n\t\t\t\t\t\t\t\t\ttitle=\"Size of data volume (10-1000 GB)\"\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t<input\n\t\t\t\t\t\t\t\t\t\tclass=\"dataVolumeSize\"\n\t\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"datavolumesize\"\n\t\t\t\t\t\t\t\t\t\ttype=\"text\"\n\t\t\t\t\t\t\t\t\t\tdojoType=\"dijit.form.NumberTextBox\"\n\t\t\t\t\t\t\t\t\t\tname=\"elevation\"\n\t\t\t\t\t\t\t\t\t\tvalue=\"200\"\n\t\t\t\t\t\t\t\t\t\tconstraints=\"{min:200,max:1000,places:0}\"\n\t\t\t\t\t\t\t\t\t\trequired=\"true\"\n\t\t\t\t\t\t\t\t\t\tinvalidMessage=\"Valid range: 200-1000 GB\"\n\t\t\t\t\t\t\t\t\t\tpromptMessage=\"Valid range: 200-1000 GB\"\n\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t</td>\n\n\t\t\t\t\t\t\t\t<td align=\"left\"\n\t\t\t\t\t\t\t\t\tclass=\"dataVolumeSliderContainer\"\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"datavolumeslider\"\n\t\t\t\t\t\t\t\t\t\tdojoType=\"dijit.form.HorizontalSlider\" \n\t\t\t\t\t\t\t\t\t\tvalue=\"200\"\n\t\t\t\t\t\t\t\t\t\tmaximum=\"1000\"\n\t\t\t\t\t\t\t\t\t\tminimum=\"200\"\n\t\t\t\t\t\t\t\t\t\tpageIncrement=\"10\"\n\t\t\t\t\t\t\t\t\t\tshowButtons=\"true\"\n\t\t\t\t\t\t\t\t\t\tintermediateChanges=\"true\"\n\t\t\t\t\t\t\t\t\t\tslideDuration=\"200\"\n\t\t\t\t\t\t\t\t\t\tdisabled=\"false\"\n\t\t\t\t\t\t\t\t\t\tstyle=\"width: 150px;\"\n\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td align=\"center\"\n\t\t\t\t\t\t\t\t\tcolspan=\"3\"\n\t\t\t\t\t\t\t\t\tclass=\"sublabel\">\n\t\t\t\t\t\t\t\t\tUser Volume\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td colspan=\"1\"\n\t\t\t\t\t\t\t\t\tclass=\"userVolumeContainer\"\n\t\t\t\t\t\t\t\t\talign=\"right\"\n\t\t\t\t\t\t\t\t\ttitle=\"OPTIONAL: Input snapshot ID (to copy) or volume ID (to mount).\nDEFAULT    : Create a new, empty volume\"\n\t\t\t\t\t\t\t\t\tdojoAttachEvent=\"onclick:toggleUserVolume\"\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t<input\n\t\t\t\t\t\t\t\t\t\tclass=\"userVolume\"\n\t\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"uservolume\"\n\t\t\t\t\t\t\t\t\t\ttype=\"text\"\n\t\t\t\t\t\t\t\t\t\tdojoType=\"dijit.form.ValidationTextBox\"\n\t\t\t\t\t\t\t\t\t\tmaxlength=\"13\"\n\t\t\t\t\t\t\t\t\t\tvalue=\"\"\n\t\t\t\t\t\t\t\t\t\tregExpGen=\"return '(snap|vol)\\-[A-F0-9a-f]{8}'\"\n\t\t\t\t\t\t\t\t\t\tinvalidMessage=\"Required format: 'snap-abcdef09' or 'vol-abcdef09'\"\n\t\t\t\t\t\t\t\t\t\tpromptMessage=\"Required format: 'snap-abcdef09' or 'vol-abcdef09'\"\n\t\t\t\t\t\t\t\t\t\trequired=\"false\"\n\t\t\t\t\t\t\t\t\t/> \n\t\t\t\t\t\t\t\t</td>\n\n\t\t\t\t\t\t\t\t<td colspan=\"1\"\n\t\t\t\t\t\t\t\t\talign=\"left\"\n\t\t\t\t\t\t\t\t\tclass=\"userVolumeSizeContainer\">\n\t\t\t\t\t\t\t\t\t<input\n\t\t\t\t\t\t\t\t\t\tclass=\"userVolumeSize\"\n\t\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"uservolumesize\"\n\t\t\t\t\t\t\t\t\t\ttype=\"text\"\n\t\t\t\t\t\t\t\t\t\tdojoType=\"dijit.form.NumberTextBox\"\n\t\t\t\t\t\t\t\t\t\tname=\"elevation\"\n\t\t\t\t\t\t\t\t\t\tvalue=\"100\"\n\t\t\t\t\t\t\t\t\t\tconstraints=\"{min:10,max:1000,places:0}\"\n\t\t\t\t\t\t\t\t\t\trequired=\"true\"\n\t\t\t\t\t\t\t\t\t\tinvalidMessage=\"Valid range: 10-1000 GB\"\n\t\t\t\t\t\t\t\t\t\tpromptMessage=\"Valid range: 10-1000 GB\"\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t</td>\n\n\t\t\t\t\t\t\t\t<td align=\"left\">\n\t\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"uservolumeslider\"\n\t\t\t\t\t\t\t\t\t\tdojoType=\"dijit.form.HorizontalSlider\" \n\t\t\t\t\t\t\t\t\t\tvalue=\"10\"\n\t\t\t\t\t\t\t\t\t\tmaximum=\"1000\"\n\t\t\t\t\t\t\t\t\t\tminimum=\"10\"\n\t\t\t\t\t\t\t\t\t\tpageIncrement=\"10\"\n\t\t\t\t\t\t\t\t\t\tshowButtons=\"true\"\n\t\t\t\t\t\t\t\t\t\tintermediateChanges=\"true\"\n\t\t\t\t\t\t\t\t\t\tslideDuration=\"200\"\n\t\t\t\t\t\t\t\t\t\tdisabled=\"false\"\n\t\t\t\t\t\t\t\t\t\tstyle=\"width: 150px;\"\n\t\t\t\t\t\t\t\t\t\tclass=\"userVolumeSlider\"\n\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\n\t\t\t\t\t\t\t</tr>\n\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td align=\"center\"\n\t\t\t\t\t\t\t\t\tcolspan=\"3\"\n\t\t\t\t\t\t\t\t\tclass=\"sublabel\">\n\t\t\t\t\t\t\t\t\tAmazon User ID\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td colspan=\"3\">\n\t\t\t\t\t\t\t\t\t<input\n\t\t\t\t\t\t\t\t\t\tclass=\"amazonUserId\"\n\t\t\t\t\t\t\t\t\t\tsize=\"200\"\n\t\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"amazonuserid\"\n\t\t\t\t\t\t\t\t\t\tstyle=\"width:100%; font-weight: bolder; font-family: Verdana;\";\n\t\t\t\t\t\t\t\t\t\tdojoType=\"dijit.form.ValidationTextBox\"\n\t\t\t\t\t\t\t\t\t\tregExp=\"^\\d{12}$\"\n\t\t\t\t\t\t\t\t\t\tmaxlength=\"12\" \n\t\t\t\t\t\t\t\t\t\tpromptMessage=\"Enter your 12-digit Amazon User ID (numbers only)\" \n\t\t\t\t\t\t\t\t\t\tinvalidMessage=\"Invalid User ID (Must be 12-digits, numbers only).\"\n\t\t\t\t\t\t\t\t\t\tvalue=\"\"\n\t\t\t\t\t\t\t\t\t\trequired=\"true\"\n\t\t\t\t\t\t\t\t\t\twrap=\"off\"\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td align=\"center\"\n\t\t\t\t\t\t\t\t\tcolspan=\"3\"\n\t\t\t\t\t\t\t\t\tclass=\"sublabel\"\n\t\t\t\t\t\t\t\t\t>AWS Access Key ID\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td colspan=\"3\">\n\t\t\t\t\t\t\t\t\t<input\n\t\t\t\t\t\t\t\t\t\tclass=\"awsAccessKeyId\"\n\t\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"awsaccesskeyid\"\n\t\t\t\t\t\t\t\t\t\tdojoType=\"dijit.form.ValidationTextBox\"\n\t\t\t\t\t\t\t\t\t\tvalue=\"\"\n\t\t\t\t\t\t\t\t\t\ttype=\"text\"\n\t\t\t\t\t\t\t\t\t\tmaxlength=\"20\"\n\t\t\t\t\t\t\t\t\t\tuppercase=\"true\"\n\t\t\t\t\t\t\t\t\t\tregExpGen=\"return '[A-Z0-9]{16,24}'\"\n\t\t\t\t\t\t\t\t\t\tinvalidMessage=\"20 characters: capital letters or numbers\"\n\t\t\t\t\t\t\t\t\t\tpromptMessage=\"20 characters: capital letters or numbers\"\n\t\t\t\t\t\t\t\t\t\trequired=\"true\"\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td align=\"center\"\n\t\t\t\t\t\t\t\t\tcolspan=\"3\"\n\t\t\t\t\t\t\t\t\tclass=\"sublabel\">Secret Access Key\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td colspan=\"3\">\n\t\t\t\t\t\t\t\t\t<input\n\t\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"awssecretaccesskey\"\n\t\t\t\t\t\t\t\t\t\tclass=\"secretAccessKey\"\n\t\t\t\t\t\t\t\t\t\tvalue=\"\"\n\t\t\t\t\t\t\t\t\t\tdojoType=\"dijit.form.ValidationTextBox\"\n\t\t\t\t\t\t\t\t\t\ttype=\"text\"\n\t\t\t\t\t\t\t\t\t\tmaxlength=\"40\"\n\t\t\t\t\t\t\t\t\t\tregExpGen=\"return '.{35,45}'\"\n\t\t\t\t\t\t\t\t\t\tinvalidMessage=\"40 characters\"\n\t\t\t\t\t\t\t\t\t\tpromptMessage=\"40 characters\"\n\t\t\t\t\t\t\t\t\t\trequired=\"true\"\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td align=\"center\"\n\t\t\t\t\t\t\t\t\tcolspan=\"3\"\n\t\t\t\t\t\t\t\t\tclass=\"sublabel\">EC2 Private Key</td>\n\t\t\t\t\t\t\t</tr>\n\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td colspan=\"3\">\n\t\t\t\t\t\t\t\t\t<textarea\n\t\t\t\t\t\t\t\t\t\tpromptMessage=\"-----BEGIN PRIVATE KEY---- ... -----END PRIVATE KEY-----\" \n\t\t\t\t\t\t\t\t\t\tdojoType=\"plugins.form.ValidationTextarea\"\n\t\t\t\t\t\t\t\t\t\trequired=\"true\"\n\t\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"ec2privatekey\"\n\t\t\t\t\t\t\t\t\t\tclass=\"ec2privatekey\"\n\t\t\t\t\t\t\t\t\t\tstyle=\"width:100%; font-size: 10px; font-weight: bolder; font-family: Verdana;\";\n\t\t\t\t\t\t\t\t\t\tcols=\"40\"\n\t\t\t\t\t\t\t\t\t\trows=\"14\"\n\t\t\t\t\t\t\t\t\t></textarea>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td align=\"center\"\n\t\t\t\t\t\t\t\t\tcolspan=\"3\"\n\t\t\t\t\t\t\t\t\tclass=\"sublabel\">EC2 Public Certificate</td>\n\t\t\t\t\t\t\t</tr>\n\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td colspan=\"3\">\n\t\t\t\t\t\t\t\t\t<textarea\n\t\t\t\t\t\t\t\t\t\tdojoType=\"plugins.form.ValidationTextarea\"\n\t\t\t\t\t\t\t\t\t\tpromptMessage=\"-----BEGIN CERTIFICATE----- ... -----END CERTIFICATE-----\"\n\t\t\t\t\t\t\t\t\t\trequired=\"true\"\n\t\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"ec2publiccert\"\n\t\t\t\t\t\t\t\t\t\tclass=\"ec2publiccert\"\n\t\t\t\t\t\t\t\t\t\tstyle=\"width:100%; font-size: 10px; font-weight: bolder; font-family: Verdana;\";\n\t\t\t\t\t\t\t\t\t\tcols=\"40\"\n\t\t\t\t\t\t\t\t\t\trows=\"14\"\n\t\t\t\t\t\t\t\t\t></textarea>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t</table>\n\t\t\n\t\t\t\t\t</div>\n\t\t\t\t</td>\n\t\t\t</tr>\n\t\t\n\t\t</table>\n\n\t</div>\n\t<!-- END init TAB -->\n\t\n</div> \n\n\n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

//addingUser STATE
addingUser : false,

// OR USE @import IN HTML TEMPLATE
cssFiles : [ "plugins/init/css/init.css" ],

// PARENT WIDGET
parentWidget : null,

// DEFAULT DATA VOLUME
defaultDataVolume : null,

/////}}
constructor : function(args) {
	// LOAD CSS
	this.loadCSS();		

	this.defaultDataVolume = args.dataVolume;
	console.log("Init.constructor    this.defaultDataVolume: " + this.defaultDataVolume);
},
postCreate : function() {
	console.log("Controller.postCreate    plugins.init.Controller.postCreate()");

	this.startup();
},
startup : function () {
	console.log("Init.startup    plugins.init.GroupInit.startup()");

	// COMPLETE CONSTRUCTION OF OBJECT
	this.inherited(arguments);

	console.log("Init.startup    this.defaultDataVolume: " + this.defaultDataVolume);
	this.datavolume.set("value", this.defaultDataVolume);

	dijit.Tooltip.defaultPosition = ['above', 'below'];
	
	// ADD ADMIN TAB TO TAB CONTAINER		
	console.log("Init.startup    BEFORE appendChild(this.initTab.domNode)");
	dojo.byId("attachPoint").appendChild(this.initTab.domNode);
	console.log("Init.startup    AFTER appendChild(this.initTab.domNode)");

	// DISABLE PROGRESS BUTTON
	this.disableProgressButton();
	
	// SET SAVE BUTTON
	dojo.connect(this.saveButton, "onClick", dojo.hitch(this, "save"));

	// SET SLIDERS
	this.setDataVolumeSlider();
	this.setUserVolumeSlider();
	
	// SET RANDOM ADMIN PASSWORD
	this.setPasswordMatcher();

	// SET TOASTER
	this.setToaster();
},
// SAVE
save : function (event) {
	console.log("Init.save    event: " + event);
	
	if ( this.saving == true ) {
		console.log("Init.save    this.saving: " + this.saving + ". Returning.");
		return;
	}
	this.saving = true;
	
	var parameters = ["confirmPassword", "amazonuserid", "datavolume", "uservolume", "datavolumesize", "uservolumesize", "awsaccesskeyid", "awssecretaccesskey", "ec2publiccert", "ec2privatekey" ];
	var isValid = true;
	for ( var i = 0; i < parameters.length; i++ ) {
		var parameter = parameters[i];
		console.log("Init.save    parameter: " + parameter);
		console.log("Init.save    this[" + parameter + "]: ");
		console.dir({this_parameter:this[parameter]});
		var valid = this[parameter].isValid(this[parameter].textbox.value);
		console.log("Init.save    this[" + parameter + "] valid: " + valid);
		if ( valid ) {
			console.log("Init.save    VALID!!");
			this[parameter].state = "Incomplete";
			this[parameter]._setStateClass();
		}
		else {
			// SET ERROR STATE AND CSS CLASSES IF NOT VALID
			console.log("Init.save    NOT VALID. Setting 'Error' state");
			this[parameter].state = "Error";
			this[parameter]._setStateClass();
			isValid = false;
		}
		
		// SET password ERROR STATE TO SAME AS confirmPassword
		if ( parameter == "confirmPassword" ) {
			if ( valid ) {
				console.log("Init.save    DOING _setStateClass 'Incomplete' for 'password'");
				this["password"].state = "Incomplete";
				this["password"]._setStateClass();
			}
			else {
				console.log("Init.save    DOING _setStateClass 'Error' for 'password'");
				this["password"].state = "Error";
				this["password"]._setStateClass();
			}
		}
	}
	if ( ! valid )	{
		console.log("Init.save    One or more inputs not valid. Returning");
		this.saving = false;
		return;
	}

	var uservolume = this.uservolume.value;
	if ( uservolume.match(/New volume/) )	uservolume = '';
	
	// CLEAN UP WHITESPACE AND SUBSTITUTE NON-JSON SAFE CHARACTERS
	var aws = new Object;
	aws.username 		= this.adminuser.value;
	aws.password 		= this.password.value;
	aws.amazonuserid 	= this.cleanEdges(this.amazonuserid.value);
	aws.datavolume 		= this.datavolume.value;
	aws.uservolume 		= uservolume;
	aws.datavolumesize 	= this.datavolumesize.value;
	aws.uservolumesize 	= this.uservolumesize.value;
	aws.ec2publiccert 	= this.cleanEdges(this.ec2publiccert.value);
	aws.ec2privatekey 	= this.cleanEdges(this.ec2privatekey.value);
	aws.awsaccesskeyid 	= this.cleanEdges(this.awsaccesskeyid.value);
	aws.awssecretaccesskey = this.cleanEdges(this.awssecretaccesskey.value);

	var url = this.cgiUrl + "/init.cgi?";
	console.log("Init.saveStore     url: " + url);		

	// CREATE JSON QUERY
	var query = new Object;
	query.username = "agua";
	query.mode = "init";
	query.data = aws;
	console.log("Init.save    query: " + dojo.toJson(query));
	console.dir({query:query});


	this.enableProgressButton();
	
	// SEND TO SERVER
	var thisObj = this;
	dojo.xhrPut(
		{
			url: url,
			contentType: "text",
			putData: dojo.toJson(query),
			load: function(response, ioArgs) {
				console.log("Init.save    response:");
				console.dir({response:response});
				thisObj.handleSave(response);
			},
			error: function(response, ioArgs) {
				console.log("Init.save    Error with JSON Post, response: ");
				console.dir({response:response});
			}
		}
	);

	this.saving = false;
},
handleSave : function (response) {
	console.log("Init.handleSave    response: ");
	console.dir({response:response});
	if ( ! response ) {
		this.toast({error:"No response from server. If problem persists, restart instance"})
		return;
	}
	this.toast(response);
},
openProgressLog : function () {
	if ( dojo.hasClass(this.progressButton, 'disabled') ) {
		console.log("Init.openProgressLog    DISABLED. returning");
		return;
	}
	
	window.open('log/initlog.html',
		'_blank',
		'toolbar=1,location=0,directories=0,status=0,menubar=1,scrollbars=1,resizable=1,navigation=0');
},
disableProgressButton : function () {
	dojo.addClass(this.progressButton, 'disabled');
},
enableProgressButton : function () {
	dojo.removeClass(this.progressButton, 'disabled');
},
// SETTERS
setTable : function () {
	console.log("Init.setTable     plugins.init.GroupInit.setTable()");

	// DELETE EXISTING TABLE CONTENT
	while ( this.initTable.firstChild )
	{
		this.initTable.removeChild(this.initTable.firstChild);
	}
},
setDataVolumeSlider : function () {
// INITIALISE SLIDER TO SELECT BOUNDARIES OF RESULTS RANGE
	console.log("Init.setDataVolumeSlider     plugins.init.Init.setDataVolumeSlider()");

	// ONMOUSEUP
	var thisObject = this;
	dojo.connect(this.datavolumeslider, "onMouseUp", dojo.hitch(this, function(e) {
		console.log("Init.setDataVolumeSlider    onMouseUp fired");
		var size = parseInt(this.datavolumeslider.getValue());
		console.log("Init.setDataVolumeSlider    size: " + size);
		thisObject.datavolumesize.set('value', size);
	}));
},
setUserVolumeSlider : function () {
// INITIALISE SLIDER TO SELECT BOUNDARIES OF RESULTS RANGE
	console.log("Init.setUserVolumeSlider     plugins.init.Init.setUserVolumeSlider()");

	// ONMOUSEUP
	var thisObject = this;
	dojo.connect(this.uservolumeslider, "onMouseUp", dojo.hitch(this, function(e) {
		console.log("Init.setUserVolumeSlider    onMouseUp fired");
		var size = parseInt(this.uservolumeslider.getValue());
		console.log("Init.setUserVolumeSlider    size: " + size);
		thisObject.uservolumesize.set('value', size);
	}));
},
setPasswordMatcher : function () {
	console.log("Init.setPasswordMatcher    this.confirmPassword: " + this.confirmPassword);
	this.confirmPassword.parentWidget = this;
	this.password.parentWidget = this;
	this.password.target = this.confirmPassword;	
	this.confirmPassword.source = this.password;
},
// PASSWORD
passwordsMatch : function () {
	var password = this.password.textbox.value;
	console.log("Settings.confirmPassword    password: " + password);
	var confirmPassword = this.confirmPassword.textbox.value;
	console.log("Settings.confirmPassword    confirmPassword: " + confirmPassword);
	
	if ( ! password ) return false;
	
	return password == confirmPassword;
},
setAdminPassword : function () {
	var length = 9;
	var password = this.createRandomHexString(length);
	console.log("Init.setAdminPassword    password: " + password);
	//this.	
	
},
createRandomHexString : function (length) {
var string = '';
	for ( var i = 0; i < length; i++ ) {
		var random = parseInt(Math.random()*16);    
		var hex = this.decimalToHex(random);
		if ( hex == 10 )    hex = 0;
		//console.log("random " +  i + ": " + random);
		//console.log("hex " +  hex);
		string += hex;
	}

	return string;
},
decimalToHex : function (decimal) {
	return Number(decimal).toString(16);
},
cleanEdges : function (string) {
// REMOVE WHITESPACE FROM EDGES OF TEXT
	if ( string == null )	{ 	return null; }
	string = string.replace(/^\s+/, '');
	string = string.replace(/\s+$/, '');
	return string;
},
// TOGGLE
toggleUserVolume : function (event) {
	console.log("Init.toggleUserVolume    this.userVolumeToggled: " + this.userVolumeToggled);
	if ( this.userVolumeToggled ) 	return;
	this.userVolumeToggled = true;

	this.uservolume.set("disabled", false);
	dojo.addClass(this.uservolume.textbox, "enabled");
	this.uservolume.textbox.value = "";
	//this.uservolume.textbox.focus();
},
toggleDataVolume : function (event) {
	console.log("Init.toggleUserVolume    this.dataVolumeToggled: " + this.dataVolumeToggled);
	if ( this.dataVolumeToggled ) 	return;
	this.dataVolumeToggled = true;

	this.datavolume.set("disabled", false);
	dojo.addClass(this.datavolume.textbox, "enabled");
	//this.datavolume.textbox.value = "";
	//this.datavolume.textbox.focus();
}

}); // end of Init


}

if(!dojo._hasResource["dijit.ProgressBar"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.ProgressBar"] = true;
dojo.provide("dijit.ProgressBar");






dojo.declare("dijit.ProgressBar", [dijit._Widget, dijit._Templated], {
	// summary:
	//		A progress indication widget, showing the amount completed
	//		(often the percentage completed) of a task.
	//
	// example:
	// |	<div dojoType="ProgressBar"
	// |		 places="0"
	// |		 value="..." maximum="...">
	// |	</div>

	// progress: [const] String (Percentage or Number)
	//		Number or percentage indicating amount of task completed.
	// 		Deprecated.   Use "value" instead.
	progress: "0",

	// value: String (Percentage or Number)
	//		Number or percentage indicating amount of task completed.
	// 		With "%": percentage value, 0% <= progress <= 100%, or
	// 		without "%": absolute value, 0 <= progress <= maximum.
	//		Infinity means that the progress bar is indeterminate.
	value: "",

	// maximum: [const] Float
	//		Max sample number
	maximum: 100,

	// places: [const] Number
	//		Number of places to show in values; 0 by default
	places: 0,

	// indeterminate: [const] Boolean
	// 		If false: show progress value (number or percentage).
	// 		If true: show that a process is underway but that the amount completed is unknown.
	// 		Deprecated.   Use "value" instead.
	indeterminate: false,

	// label: String?
	//		Label on progress bar.   Defaults to percentage for determinate progress bar and
	//		blank for indeterminate progress bar.
	label:"",

	// name: String
	//		this is the field name (for a form) if set. This needs to be set if you want to use
	//		this widget in a dijit.form.Form widget (such as dijit.Dialog)
	name: '',

	templateString: dojo.cache("dijit", "templates/ProgressBar.html", "<div class=\"dijitProgressBar dijitProgressBarEmpty\" role=\"progressbar\"\n\t><div  dojoAttachPoint=\"internalProgress\" class=\"dijitProgressBarFull\"\n\t\t><div class=\"dijitProgressBarTile\" role=\"presentation\"></div\n\t\t><span style=\"visibility:hidden\">&nbsp;</span\n\t></div\n\t><div dojoAttachPoint=\"labelNode\" class=\"dijitProgressBarLabel\" id=\"${id}_label\"></div\n\t><img dojoAttachPoint=\"indeterminateHighContrastImage\" class=\"dijitProgressBarIndeterminateHighContrastImage\" alt=\"\"\n/></div>\n"),

	// _indeterminateHighContrastImagePath: [private] dojo._URL
	//		URL to image to use for indeterminate progress bar when display is in high contrast mode
	_indeterminateHighContrastImagePath:
		dojo.moduleUrl("dijit", "themes/a11y/indeterminate_progress.gif"),

	postMixInProperties: function(){
		this.inherited(arguments);
		if(!("value" in this.params)){
			this.value = this.indeterminate ? Infinity : this.progress;
		}
	},

	buildRendering: function(){
		this.inherited(arguments);
		this.indeterminateHighContrastImage.setAttribute("src",
			this._indeterminateHighContrastImagePath.toString());
		this.update();
	},

	update: function(/*Object?*/attributes){
		// summary:
		//		Internal method to change attributes of ProgressBar, similar to set(hash).  Users should call
		//		set("value", ...) rather than calling this method directly.
		// attributes:
		//		May provide progress and/or maximum properties on this parameter;
		//		see attribute specs for details.
		// example:
		//	|	myProgressBar.update({'indeterminate': true});
		//	|	myProgressBar.update({'progress': 80});
		//	|	myProgressBar.update({'indeterminate': true, label:"Loading ..." })
		// tags:
		//		private

		// TODO: deprecate this method and use set() instead

		dojo.mixin(this, attributes || {});
		var tip = this.internalProgress, ap = this.domNode;
		var percent = 1;
		if(this.indeterminate){
			dijit.removeWaiState(ap, "valuenow");
			dijit.removeWaiState(ap, "valuemin");
			dijit.removeWaiState(ap, "valuemax");
		}else{
			if(String(this.progress).indexOf("%") != -1){
				percent = Math.min(parseFloat(this.progress)/100, 1);
				this.progress = percent * this.maximum;
			}else{
				this.progress = Math.min(this.progress, this.maximum);
				percent = this.progress / this.maximum;
			}

			dijit.setWaiState(ap, "describedby", this.labelNode.id);
			dijit.setWaiState(ap, "valuenow", this.progress);
			dijit.setWaiState(ap, "valuemin", 0);
			dijit.setWaiState(ap, "valuemax", this.maximum);
		}
		this.labelNode.innerHTML = this.report(percent);

		dojo.toggleClass(this.domNode, "dijitProgressBarIndeterminate", this.indeterminate);
		tip.style.width = (percent * 100) + "%";
		this.onChange();
	},

	_setValueAttr: function(v){
		this._set("value", v);
		if(v == Infinity){
			this.update({indeterminate:true});
		}else{
			this.update({indeterminate:false, progress:v});
		}
	},

	_setLabelAttr: function(label){
		this._set("label", label);
		this.update();
	},

	_setIndeterminateAttr: function(indeterminate){
		// Deprecated, use set("value", ...) instead
		this.indeterminate = indeterminate;
		this.update();
	},

	report: function(/*float*/percent){
		// summary:
		//		Generates message to show inside progress bar (normally indicating amount of task completed).
		//		May be overridden.
		// tags:
		//		extension

		return this.label ? this.label :
				(this.indeterminate ? "&nbsp;" : dojo.number.format(percent, { type: "percent", places: this.places, locale: this.lang }));
	},

	onChange: function(){
		// summary:
		//		Callback fired when progress updates.
		// tags:
		//		extension
	}
});

}

if(!dojo._hasResource["plugins.login.LoginStatus"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.login.LoginStatus"] = true;
dojo.provide("plugins.login.LoginStatus");

// DISPLAY LOGIN STATUS AT RIGHT SIDE OF TOOLBAR

dojo.declare( "plugins.login.LoginStatus",
	[ dijit._Widget, dijit._Templated ], {

//Path to the template of this widget. 
templateString:"<span dojoAttachPoint=\"containerNode\" >\n\n    <table class=\"loginStatus\">\n\n        <tr>\n            <td>\n                <div\n                    dojoAttachPoint=\"launcher\"\n                    class=\"launcher\"\n                    >\n                    \n                </div>\n            </td>\n        </tr>\n        <tr>\n            <td>\n                <div\n                    dojoAttachPoint=\"username\"\n                    class=\"username\"\n                    >\n                </div>\n            </td>\n        </tr>\n    </table>\n    \n\n</span>\n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

/////}}}}}

constructor: function () {
	console.log("LoginStatus.constructor    plugins.login.LoginStatus.constructor()");

	this.loadCSS();
},
postMixInProperties: function() {
	console.log("LoginStatus.postMixInProperties    plugins.login.LoginStatus.postMixInProperties()");
},
postCreate : function() {
	console.log("LoginStatus.postCreate    plugins.login.LoginStatus.postCreate()");

	this.startup();
},
startup : function () {
	console.log("LoginStatus.startup    plugins.login.LoginStatus.startup()");

	this.inherited(arguments);
},
loadCSS : function () {
	console.log("LoginStatus.loadCSS    plugins.login.LoginStatus.loadCSS()");
	var cssFiles = [
		dojo.moduleUrl("plugins") + "login/css/loginstatus.css",
		dojo.moduleUrl("plugins") + "login/css/login.css"
	];
	for ( var i in cssFiles )
	{
		var cssFile = cssFiles[i];
		console.log("LoginStatus.loadCSS    cssFile: " + cssFile);

		var cssNode = document.createElement('link');
		cssNode.type = 'text/css';
		cssNode.rel = 'stylesheet';
		cssNode.href = cssFile;
		cssNode.media = 'screen';
		//cssNode.title = 'loginCSS';
		document.getElementsByTagName("head")[0].appendChild(cssNode);
	}
}

}); // end of plugins.login.LoginStatus

}

if(!dojo._hasResource["plugins.login.Login"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.login.Login"] = true;
dojo.provide("plugins.login.Login");

/*
  
	DISPLAY A LOGIN DIALOGUE WINDOW AND AUTHENTICATE

	WITH THE REMOTE DATABASE TO RETRIEVE A SESSION ID 

	AND STORE IT IN Agua.cookie("sessionid")

*/



// REQUIRED WIDGETS







// HAS A


dojo.declare( "plugins.login.Login",
	[ dijit._Widget, dijit._Templated, plugins.core.Common ], {

//Path to the template of this widget. 
templateString:"<div dojoAttachPoint=\"containerNode\" class=\"login\">\n\n    <div\n        dojoAttachPoint=\"loginDialogue\"\n        class=\"loginDialogue\"\n        label=\"Login\"\n        class=\"login\"\n        modal=\"true\"\n        dojoType=\"dojox.widget.Dialog\"\n        style=\"overflow: visible; position: absolute; top: 240px; left: 248px; opacity: 1; width: 300px; height: 300px; align: center;\"\n        title=\"Agua Login\"\n        >\n        \n        <table align=\"center\" width=\"100%\">\n\n            <tr align=\"center\" width=\"100%\">\n                <td colspan=\"2\" class=\"loginIcon\"></td>\n            </tr>\n\n            <tr\n                dojoAttachPoint=\"nameRow\"\n                align=\"center\">\n                <td align=\"right\">Username</td>\n                <td align=\"left\">\n                    <div\n                        dojoAttachPoint=\"username\"\n                        class=\"username\"\n                        value=\"\"\n                        dojoType=\"dijit.form.TextBox\"\n                        style=\"width: 100px\"\n                        value=\"testuser\"\n                        >testuser\n                    </div>\n                </td>\n            </tr>\n            <tr\n                dojoAttachPoint=\"passwordRow\"\n                align=\"center\">\n                <td align=\"right\">Password</td>\n                <td align=\"left\">\n                    <div\n                        dojoAttachPoint=\"password\"\n                        class=\"password\"\n                        value=\"\"\n                        type=\"password\"\n                        dojoType=\"dijit.form.TextBox\"\n                        style=\"width: 100px\"\n                        value=\"testuser\"\n                        >testuser\n                    </div>\n                </td>\n            </tr>\n            <tr\n                dojoAttachPoint=\"buttonRow\"\n                class=\"loginCenteredRow\">\n                <td align=\"center\" colspan=\"2\">\n                    <div\n                        dojoAttachPoint=\"loginButton\"\n                        dojoAttachEvent=\"onclick:login\"\n                        class=\"loginButton\"\n                        >Login</div>\n                </td>\n            </tr>\n            <tr class=\"loginCenteredRow\">\n                <td align=\"center\" colspan=\"2\">\n                    <div\n                        dojoAttachPoint=\"message\"\n                        colspan=\"2\">\n                    </div>\n                </td>\n            </tr>\n            <tr class=\"loginCenteredRow\">\n                <td align=\"center\" colspan=\"2\">\n                    <div\n                        dojoAttachPoint=\"progressBar\"\n                        class=\"progressBar\"\n                        dojoType=\"dijit.ProgressBar\"\n                        colspan=\"2\">\n                    </div>\n                </td>\n            </tr>\n        </table>\n    \n    </div>\n</div>\n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

loginMessage : "",

cssFiles: [
	dojo.moduleUrl("plugins") + "login/css/login.css",
	dojo.moduleUrl("dojox") + "widget/Dialog/Dialog.css",
	dojo.moduleUrl("dijit") + "themes/claro/claro.css"
],

// logging : Bool
// True if logging in, false otherwise
logging : false,

////}}}}
constructor : function () {
	console.log("Login.constructor    plugins.login.Login.constructor()");

	this.loadCSS();
	
	// GENERATE LOGIN STATUS TABLE IN RIGHT SIDE OF AGUA TOOLBAR
	this.statusBar = new plugins.login.LoginStatus();
	this.statusBar.launcher.innerHTML = "Log In";
	var listener = dojo.connect(this.statusBar.launcher, "onclick", this, "show");
	this.statusBar.launcher.listener = listener;
	document.getElementById("loginHolder").appendChild(this.statusBar.containerNode);
},
postCreate : function() {
	console.log("Login.postCreate    plugins.workflow.Login.postCreate()");
	this.startup();
},
startup : function () {
	console.log("Login.startup    plugins.workflow.Login.startup()");

	this.inherited(arguments);
	
	// ADD CLASS TO DIALOGUE
	dojo.addClass(this.domNode, 'login');

	// SET LISTENERS
	this.setDialogListeners();
	
	// SET PROGRESS BAR
	this.setProgressBar();
	
	var data = this.debug();
	if ( data ) {
		this.handleLogin(data, data.username);
		return;
	}
	
	// SHOW LOGIN WINDOW
	this.show();	
},
debug : function () {
	
	// GET USERNAME FROM URL IF PRESENT
	var url = window.location.href;
	console.log("Login.debug    url: " + url);
	if ( ! url.match(/(.+?)\?([^\?]+),([^,]+)/) )
	{
		console.log("Login.debug    Not debugging. Setting this.debugFlag to FALSE and returning");
		return false;
	}
	console.log("Login.debug    Debugging");

	var username = url.match(/(.+?)\?([^\?]+?),([^,]+)/)[2];
	var sessionid = url.match(/(.+?)\?([^\?]+?),([^,]+)/)[3];
	var plugins;
	if ( url.match(/(.+?)\?([^\?]+),([^,]+?),([^,]+)$/) )
	{
		plugins = url.match(/(.+?)\?([^\?]+),([^,]+),([^,]+)$/)[4];
	}
	console.log("Login.debug    plugins: " + dojo.toJson(plugins));

	if ( plugins != null )
	{
		var array = plugins.split(/\./);
		console.log("Login.debug    array: " + dojo.toJson(array));
		
		var pluginsList = new Array;
		var pluginsArgs = new Array;
		for ( var i = 0; i < array.length; i++ )
		{
			if ( ! array[i].match(/^[^\(]+/) )	continue;
			var pluginName = array[i].match(/^([^\(]+)/)[1];
			pluginsList[i] = "plugins.";
			pluginsList[i] += pluginName;
			pluginsList[i] += ".Controller";

			if ( array[i].match(/^[^\(]+\(([^\)]+)\)/) ) {
				var args = array[i].match(/^[^\(]+\(([^\)]+)\)/)[1];
				console.log("Login.debug    args: ");
				console.dir({args:args});
				pluginsArgs[i] = args;
			}
		}
		Agua.pluginsList = pluginsList;
		Agua.pluginsArgs = pluginsArgs;
	}
	console.log("Login.debug    this.pluginsList: " + dojo.toJson(Agua.pluginsList));

	// SET AGUA COOKIE
	var data = {};
	data.username = username;
	data.sessionid = sessionid;

	return data;	
},
setDialogListeners : function () {
	// FOCUS ON PASSWORD INPUT IF 'RETURN' KEY PRESSED WHILE IN USERNAME INPUT
	var thisObject = this;
	dojo.connect(this.username, "onKeyPress", function(event){
		var key = event.charOrCode;

		// STOP EVENT BUBBLING
		event.stopPropagation();   
	
		// JUMP TO PASSWORD INPUT IF 'RETURN' KEY PRESSED
		if ( key == 13 )
		{
			thisObject.password.focus();
		}
	});

	// DO LOGIN IF 'RETURN' KEY PRESSED WHILE IN PASSWORD INPUT
	var thisObject = this;
	dojo.connect(this.password, "onKeyPress", function(event) {
		var key = event.charOrCode;

		// STOP EVENT BUBBLING
		event.stopPropagation();   

		// LOGIN IF 'RETURN' KEY PRESSED
		if ( key == 13 )
		{
			thisObject.login();
		}

		// QUIT LOGIN WINDOW IF 'ESCAPE' KEY IS PRESSED
		if (key == dojo.keys.ESCAPE)
		{
			// FADE OUT LOGIN WINDOW
			dojo.fadeOut({ node: "loginDialogue", duration: 500 }).play();
			thisObject.loginDialogue.hide();
		}
	});	
},
setProgressBar : function () {
	this.hideProgressBar();
},
show : function () {
	console.log("Login.show    plugins.login.Login.show()");

	// SET THIS.LOGGING TO FALSE
	this.logging = false;
	
	// RESET STYLE TO DEFAULT
	dojo.removeClass(this.message, "error");
	dojo.removeClass(this.message, "accepted");

	// ADD CLASS
	dojo.addClass(this.loginDialogue.domNode, "login");

	// SET DEFAULT CSS CLASSES
	dojo.removeClass(this.message, "error");
	dojo.removeClass(this.message, "accepted");

	if ( this.loginDialogue == null ) {
		console.log("Login.show    this.loginDialogue == null. Returning.");
		return;
	}
	
	// SHOW INPUTS
	this.showInputs();
	
	// SET MESSAGE
	this.message.innerHTML = this.loginMessage;

	console.log("Login.show    DOING this.loginDialogue.show()");
	this.loginDialogue.show();
},
hide : function () {
// RESET STYLES TO DEFAULT AND HIDE DIALOGUE
	console.log("Login.hide     plugins.login.Login.hide()");

	// IMMEDIATE HIDE
	console.log("Login.hide    Doing dojo.style(this.domNode, opacity, 0)");
	dojo.style(this.domNode, "opacity", 0);
	
	console.log("Login.hide    HIDE DIALOGUE");
	this.loginDialogue.hide();
	
	console.log("Login.hide    RESETTING CSS to default");
	dojo.removeClass(this.message, "error");
	dojo.removeClass(this.message, "accepted");
	dojo.removeClass(this.message, "loading");
	
	console.log("Login.hide    RESETTING this.message to default");
	this.message.innerHTML = "Loaded";
},
login : function () {
// AUTHENTICATE USERNAME AND PASSWORD
	console.log("Login.login     this.logging: " + this.logging);
	
	if( this.logging ) {
		console.log("Login.login     Returning.");
		return;
	}

	console.log("Login.login    Setting this.logging to TRUE");
	this.logging = true;

	var username = this.username.get('value');
	var password = this.password.get('value');
	
	if ( password == null || password == '' )	return;
	
	// SET LOGIN STYLE AND PROGRESS BAR
	this.setLoginStyle();

	// SET SESSION ID AND USER NAME TO NULL	
	Agua.cookie("sessionid", null); 
	Agua.cookie("username", null); 
	
	// CREATE JSON QUERY
	var query = new Object;
	query.username = username;
	query.password = password;
	query.mode = "submitLogin";
	console.log("Login.login     query: " + dojo.toJson(query));
	
	var url = Agua.cgiUrl + "workflow.cgi";
	console.log("Login.login     url: " + url);		

	console.log("Login.login    BEFORE xhrPut");
	console.log("Login.login    Agua.cookie('username'): " + Agua.cookie('username'));
	console.log("Login.login    Agua.cookie('sessionid'): " + Agua.cookie('sessionid'));

	var thisObject = this;

	// DO xhrPut TO SERVER
	var deferred = dojo.xhrPut(
		{
			url: url,
			contentType: "json",
			handleAs: 'json',
			sync: true,
			putData: dojo.toJson(query),
			preventCache: true,
			handle: function(response) {
				if ( response.error ) {
					// SET this.logging TO FALSE
					console.log("Login.login    Error. Setting this.logging to FALSE");
					thisObject.logging = false;

					// SHOW ERROR STATUS ON LOGIN BUTTON
					dojo.addClass(thisObject.message, "error");
					thisObject.message.innerHTML = "Invalid username and password";

					// SHOW LOGIN INPUTS
					thisObject.showInputs();
				}
				else {
					thisObject.handleLogin(response, username);
				}
			},
			error: function (response, ioArgs) {
				console.log("Login.login    Response is NULL. Setting this.logging to FALSE");

				thisObject.logging = false;
			}
		}
	);
		
	console.log("Login.login    After xhrPut");
},
setLoginStyle : function () {
	// HIDE INPUTS
	this.hideInputs();
	
	// CHANGE MESSAGE
	dojo.removeClass(this.message, "error");
	dojo.removeClass(this.message, "accepted");
	this.message.innerHTML = "Authenticating...";
	
	console.log("Login.setLoginStyle    Doing progress bar removeClass 'inactive'"); 
    console.dir({login:this});       
    console.dir({progressBar:this.progressBar});       
},
showProgressBar : function () {	
	console.log("Login.showProgess    Doing progress bar removeClass 'inactive'");
    dojo.removeClass(this.progressBar.domNode, "inactive");
	this.message.innerHTML = "Loading Agua...";
},
hideProgressBar : function () {
	console.log("Login.hideProgess    Doing progress bar addClass 'inactive'");
    dojo.addClass(this.progressBar.domNode, "inactive");
},
showInputs : function () {	
	console.log("Login.showInputs    DOING dojo.addClass(this.xxxRow, 'hidden')");
	dojo.removeClass(this.nameRow, "hidden");
	dojo.removeClass(this.passwordRow, "hidden");
	dojo.removeClass(this.buttonRow, "hidden");

	dojo.removeClass(this.message, "loading");
},
hideInputs : function () {
	console.log("Login.hideInputs    DOING dojo.removeClass(this.xxxRow, 'hidden')");
	dojo.addClass(this.nameRow, "hidden");
	dojo.addClass(this.passwordRow, "hidden");
	dojo.addClass(this.buttonRow, "hidden");
},
setLogoutStyle : function () {
	console.log("Logout.setLogoutStyle    Getting ");
	
	// RESET LOGIN DIALOGUE
	this.message.innerHTML = this.loginMessage;
	dojo.removeClass(this.message, "error");
	dojo.removeClass(this.message, "accepted");

	// RESET LOGIN STATUS
	this.statusBar.username.innerHTML = 'Logged out';
	this.statusBar.launcher.innerHTML = 'Log In';
},
setLoading : function () {
	dojo.addClass(this.message, "loading");
	this.message.innerHTML = "Loading Agua";
},
handleLogin : function (data, username) {
	console.log("Login.handleLogin     xhrPut data Json: " + dojo.toJson(data));

	// SHOW PROGRESS BAR
	this.showProgressBar();
	
	// REMOVE PASSWORD
	this.password.set('value', '');

	// SHOW ERROR IF PRESENT AS data.error
	if ( data.error != null )
	{
		console.log("Login.handleLogin    Login error: " + data.error);

		console.log("Login.handleLogin    DOING this.showInputs()");
		this.showInputs();
		
		// SHOW ERROR STATUS ON LOGIN BUTTON
		dojo.addClass(this.message, "error");
		this.message.innerHTML = data.error;
	}
	
	// IF NO ERROR, PROCESS LOGIN
	else {
		console.log("Login.handleLogin    Successful login");
		console.log("Login.handleLogin    data: " + dojo.toJson(data));

		// SET sessionid AND username IN DOJO COOKIE
		// THE COOKIE WILL EXPIRE AT THE END OF THE SESSION
		Agua.cookie("sessionid", data.sessionid);
		Agua.cookie("username", username);

		console.log("Login.handleLogin    username: " + username);
		console.log("Login.handleLogin    sessionid: " + data.sessionid);
		
		// SHOW 'Accepted' IN GREEN
		dojo.removeClass(this.message, "error");
		dojo.addClass(this.message, "accepted");
		this.message.innerHTML = "Accepted";

		var thisObject;
		setTimeout( function(thisObj){
			console.log("Login.handleLogin    setTimeout    Setting message to 'Loading Agua'");
			thisObj.setLoading();
		}, 1000, this);

		// CHANGE LOGIN STATUS BAR TO 'username' AND 'Log Out'
		this.statusBar.username.innerHTML = "<span class='label'></span> " + username;
		this.statusBar.launcher.innerHTML = "Log Out";
		
		// REMOVE EXISTING 'login' LISTENER AND CREATE NEW 'logout' LISTENER
		dojo.disconnect(this.statusBar.launcher.listener);
		var listener = dojo.connect(this.statusBar.launcher, "onclick", this, "logout");
		this.statusBar.launcher.listener = listener;

		//// INITIALISE PLUGINS
		console.log("Login.handleLogin    DOING setTimeout( Agua.startPlugins(), 100)");
		
		setTimeout( function(thisObj){
			Agua.startPlugins();
			thisObj.hideProgressBar();
		}, 100, this);

		console.log("Login.login    Setting this.logging to FALSE");
		this.logging = false;
		
		// FADE OUT LOGIN WINDOW
		// SET this.logging TO FALSE
		setTimeout( function(thisObj){
			dojo.fadeOut({ node: thisObj.loginDialogue.domNode, duration: 10 }).play();
			thisObj.hide();
			thisObj.logging = false;
			},
			100,
			this
		);
	}					
},
logout : function (e) {
	// SET COOKIE sessionid TO NULL
	Agua.cookie('sessionid', null);
	Agua.cookie('username', null);

	// SET STYLE
	this.setLogoutStyle();
	
	// CREATE NEW LISTENER
	dojo.disconnect(this.statusBar.launcher.listener);
	var listener = dojo.connect(this.statusBar.launcher, "onclick", this, "show");
	this.statusBar.launcher.listener = listener;

	// REMOVE ALL PLUGIN BUTTONS AND TAB PANES
	Agua.logout();
}
}); // end of plugins.login.Login



}

if(!dojo._hasResource["plugins.login.Controller"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.login.Controller"] = true;
dojo.provide("plugins.login.Controller");

// HAS



dojo.declare( "plugins.login.Controller",  [], {		
	login : null,
////}}}}}
// CONSTRUCTOR	
constructor : function(args) {
	console.log("Controller.constructor     plugins.login.Controller.constructor");
	this.loadCSS();
},
loadCSS : function() {
	console.log("Controller.loadCSS    Loading CSS FILES");
	// LOAD CSS
	var cssFiles = [
		dojo.moduleUrl("plugins") + "login/css/login.css"
	];
	for ( var i in cssFiles )
	{
		var cssFile = cssFiles[i];
		var cssNode = document.createElement('link');
		cssNode.type = 'text/css';
		cssNode.rel = 'stylesheet';
		cssNode.href = cssFile;
		cssNode.media = 'screen';
		document.getElementsByTagName("head")[0].appendChild(cssNode);
	}
}
}); // end of Controller

dojo.addOnLoad(
function()
{
//		console.log("Controller.addOnLoad    plugins.login.Controller.addOnLoad");
}

);

}

if(!dojo._hasResource["plugins.sharing.AccessRow"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.sharing.AccessRow"] = true;
dojo.provide("plugins.sharing.AccessRow");


dojo.declare( "plugins.sharing.AccessRow",
	[ dijit._Widget, dijit._Templated ],
{
	////////}
//Path to the template of this widget. 
templateString:"<div dojoAttachPoint=\"containerNode\">\n\n<table>\n    \n    <tr dojoAttachPoint=\"row\">\n        <td \n            colspan=\"1\"\n            dojoAttachPoint=\"groupname\"\n            class=\"narrowColumn\"\n            title=\"Special file groupnames, e.g., FASTA, FASTQ\"\n        >${groupname}</td>\n        <td \n            colspan=\"1\"\n            dojoAttachPoint=\"groupwrite\"\n            dojoAttachEvent=\"onclick:toggle\"\n            class=\"narrowColumn\"\n            title=\"Special file groupwrites, e.g., FASTA, FASTQ\"\n            value=\"groupwrite\"\n        ></td>\n        <td\n            colspan=\"1\"\n            dojoAttachPoint=\"groupcopy\"\n            dojoAttachEvent=\"onclick:toggle\"\n            class=\"narrowColumn\"\n            title=\"User can groupcopy data and workflows in this group\"\n            value=\"groupcopy\"\n        ></td>\n        <td\n            colspan=\"1\"\n            dojoAttachPoint=\"groupview\"\n            dojoAttachEvent=\"onclick:toggle\"\n            class=\"narrowColumn\"\n            title=\"User can groupview data and workflows in this group\"\n            value=\"groupview\"\n        ></td>\n        <td \n            colspan=\"1\"\n            dojoAttachPoint=\"worldwrite\"\n            dojoAttachEvent=\"onclick:toggle\"\n            class=\"narrowColumn\"\n            title=\"Special file worldwrites, e.g., FASTA, FASTQ\"\n            value=\"worldwrite\"\n        ></td>\n        <td\n            colspan=\"1\"\n            dojoAttachPoint=\"worldcopy\"\n            dojoAttachEvent=\"onclick:toggle\"\n            class=\"narrowColumn\"\n            title=\"User can worldcopy data and workflows in this group\"\n            value=\"worldcopy\"\n        ></td>\n        <td\n            colspan=\"1\"\n            dojoAttachPoint=\"worldview\"\n            dojoAttachEvent=\"onclick:toggle\"\n            class=\"narrowColumn\"\n            title=\"User can worldview data and workflows in this group\"\n            value=\"worldview\"\n        ></td>\n    </tr>\n\n</table>\n\n</div>\n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

// PARENT plugins.sharing.Apps WIDGET
parentWidget : null,

// INSTANTIATION ARGUMENTS
args : null,

constructor : function(args) {
	this.args = args;
	////console.log("AccessRow.constructor    args: " + dojo.toJson(args));
},

postCreate : function() {
	////console.log("AccessRow.postCreate    plugins.workflow.AccessRow.postCreate()");
	this.rights = this.parentWidget.rights;
	this.startup();
},

startup : function () {
	//console.log("AccessRow.startup    plugins.workflow.AccessRow.startup()");
	//console.log("AccessRow.startup    this.groupname: " + this.groupname);
	this.inherited(arguments);

	for ( var index in this.rights )
	{
		var right = this.rights[index];

		//console.log("AccessRow.startup    right: " + right);
		if ( this.args[right] == 1 )
			dojo.addClass(this[right], 'allowed');
		else
			dojo.addClass(this[right], 'denied');
	}
	////console.log("AccessRow.startup    this: " + this);
},

toggle : function (event) {
// TOGGLE HIDDEN NODES
	////console.log("sharing.AccessRow.toggle    event.target: " + event.target);
	var value = dojo.attr(event.target, 'value');
	event.stopPropagation();	
	////console.log("sharing.AccessRow.toggle    value: " + value);

	var ownership = "group";
	if ( value.match(/^world/) )	ownership = "world";
	////console.log("sharing.AccessRow.toggle    ownership: " + ownership);

	var permission;
	if ( value.match(/^group/) ) permission = value.replace(/^group/, '');
	if ( value.match(/^world/) ) permission = value.replace(/^world/, '');
	////console.log("sharing.AccessRow.toggle    permission: " + permission);

	var setClass = "allowed";
	var unsetClass = "denied";
	if ( dojo.hasClass(this[value], "allowed") )
	{
		setClass = "denied";
		unsetClass = "allowed";
	}

	this.descendingOwnership(ownership, permission, setClass, unsetClass);
		
	if ( ownership == "world" && setClass == "allowed" )
	{
		var deniedOk = false;
		this.descendingOwnership("group", permission, setClass, unsetClass, deniedOk);
	}
},

descendingOwnership : function (ownership, permission, setClass, unsetClass, deniedOk) {
	if ( deniedOk == null )	deniedOk = true;
	////console.log("access.AccessRow.descendingOwnership    access.AccessRow.descendingOwnership(ownership, permission, setClass, unsetClass)");
	////console.log("access.AccessRow.descendingOwnership    ownership: " + ownership);
	////console.log("access.AccessRow.descendingOwnership    permission: " + permission);
	////console.log("access.AccessRow.descendingOwnership    setClass: " + setClass);
	////console.log("access.AccessRow.descendingOwnership    unsetClass: " + unsetClass);
	////console.log("access.AccessRow.descendingOwnership    deniedOk: " + deniedOk);

	if ( permission == "write" )
	{
		this.setClasses(ownership, "write", setClass, unsetClass);
		this.setClasses(ownership, "copy", setClass, unsetClass);	
		this.setClasses(ownership, "view", setClass, unsetClass);
	}

	if ( permission == "copy" )
	{
		this.setClasses(ownership, "view", setClass, unsetClass);
		this.setClasses(ownership, "copy", setClass, unsetClass);
		if ( setClass == "denied" )	
			this.setClasses(ownership, "write", setClass, unsetClass);
		else if ( deniedOk == true )
			this.setClasses(ownership, "write", unsetClass, setClass);
	}

	if ( permission == "view" )
	{
		this.setClasses(ownership, "view", setClass, unsetClass);
		if ( setClass == "denied" && deniedOk == true )	
		{
			this.setClasses(ownership, "write", setClass, unsetClass);	
			this.setClasses(ownership, "copy", setClass, unsetClass);	
		}
		else if ( deniedOk == true )
		{
			this.setClasses(ownership, "write", unsetClass, setClass);	
			this.setClasses(ownership, "copy", unsetClass, setClass);	
		}
	}
},

setClasses : function (ownership, permission, setClass, unsetClass) {
////console.log("sharing.AccessRow.setClasses    ownership: " + ownership + ", permission: " + permission + ", setClass: " + setClass);

	dojo.addClass(this[ownership + permission ], setClass);
	dojo.removeClass(this[ownership + permission], unsetClass);
}



});
	
////console.log("sharing.AccessRow loaded");

}

if(!dojo._hasResource["plugins.sharing.Access"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.sharing.Access"] = true;
dojo.provide("plugins.sharing.Access");

// ALLOW THE ADMIN USER TO ADD, REMOVE AND MODIFY USERS

// NEW USERS MUST HAVE username AND email

// // optimize: load dijit layer







// FORM VALIDATION


// HAS A


dojo.declare("plugins.sharing.Access",
	[ dijit._Widget, dijit._Templated, plugins.core.Common ],
{
		
//Path to the template of this widget. 
templateString:"<div dojoattachpoint=\"containerNode\">\n\n\t<!-- access TAB -->\n\t<div\n\t\tdojoAttachPoint=\"accessTab\"\n\t\tclass=\"access\"\n\t\tdojoType=\"dijit.layout.ContentPane\"\n\t\ttitle=\"Access\"\n\t\tstyle=\"height: 700px; max-height: auto !important; width: 390px !important; padding: 0 !important;\"\n\t\t>\n\t\t\n\t\t<table width=\"100%\">\n\t\t\t<tr valign=\"top\" width=\"100%\">\n\t\t\t\t<td colspan=\"7\" class=\"tabTitle\" align=\"center\"> Access </td>\n\t\t\t</tr>\n\t\t</table>\n\t\t<table class=\"saveButtonTable\">\n\t\t\t<tr>\n\t\t\t\t<td \n\t\t\t\t\tcolspan=\"11\"\n\t\t\t\t\talign=\"center\"\n\t\t\t\t\tclass=\"saveButton\"\n\t\t\t\t\tdojoAttachPoint=\"saveButton\"\n\t\t\t\t\tdojoAttachEvent=\"onclick:saveAccess\"\n\t\t\t\t>\n\t\t\t\t\tSave\n\t\t\t\t</td>\n\t\t\t</tr>\n\t\t</table>\n\n\t\t<div\n\t\t\tclass=\"dragSource\"\n\t\t\tstyle=\"height: 600px; width: 96%;\"\n\t\t>\n\t\t\t<table class=\"permissionsTable\"\n\t\t\t\t   dojoAttachPoint='table'>\n\t\t\t\t<tr class=\"header\">\n\t\t\t\t\t<td >Group</td>\n\t\t\t\t\t<td colspan=\"3\" class=\"headerBold\">Group</td>\n\t\t\t\t\t<td colspan=\"3\" class=\"headerBold\">World</td>\n\t\t\t\t</tr>\n\t\t\t\t<tr class=\"subheader\">\n\t\t\t\t\t<td class=\"narrowColumn\" colspan=\"1\"> </td>\n\t\t\t\t\t<td class=\"narrowColumn\">Write</td>\n\t\t\t\t\t<td class=\"narrowColumn\">Copy</td>\n\t\t\t\t\t<td class=\"narrowColumn\">View</td>\n\t\t\t\t\t<td class=\"narrowColumn\">Write</td>\n\t\t\t\t\t<td class=\"narrowColumn\">Copy</td>\n\t\t\t\t\t<td class=\"narrowColumn\">View</td>\n\t\t\t\t</tr>\n\t\t\t\t\n\t\t\t</table>\n\t\t</div>\t\t\n\n\t</div>\n\t<!-- END access TAB -->\n\t\n</div> \n\n\n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

// OR USE @import IN HTML TEMPLATE
cssFiles : [ dojo.moduleUrl("plugins") + "sharing/css/access.css" ],

// PARENT WIDGET
parentWidget : null,

// ROW WIDGETS
accessRows : new Array,

// PERMISSIONS
rights: [
	'groupwrite', 'groupcopy', 'groupview', 'worldwrite', 'worldcopy', 'worldview'
],

/////}}}
	
constructor : function (args) {
	////console.log("Access.constructor     plugins.sharing.Access.constructor()");

	////console.log("Access.constructor     this.accessRows: " + this.accessRows);

	// GET INFO FROM ARGS
	this.parentWidget = args.parentWidget;
	this.tabContainer = args.tabContainer;

	this.loadCSS();
	////console.log("Access.constructor     AFTER this.loadCSS()");
},

postMixInProperties: function() {
},

postCreate: function() {
	this.startup();
},

startup : function () {
	////console.log("Access.startup    plugins.sharing.Clusters.startup()");
	////console.log("Access.startup     this.accessRows: " + this.accessRows);

	// COMPLETE CONSTRUCTION OF OBJECT
	this.inherited(arguments);	 

	// ADD ADMIN TAB TO TAB CONTAINER		
	this.tabContainer.addChild(this.accessTab);
	this.tabContainer.selectChild(this.accessTab);

	//////////console.log("Access.++++ plugins.sharing.Access.postCreate()");
	this.buildTable();

	// SUBSCRIBE TO UPDATES
	Agua.updater.subscribe(this, "updateGroups");
},

updateGroups : function (args) {
// RELOAD RELEVANT DISPLAYS
	//console.log("sharing.Access.updateGroups    sharing.Access.updateGroups(args)");
	//console.log("sharing.Access.updateGroups    args:");
	//console.dir(args);

	this.buildTable();
},

buildTable : function () {
	//console.log("Access.buildTable     plugins.sharing.Access.buildTable()");
	//console.log("Access.buildTable     this.table: " + this.table);
	
	// GET ACCESS TABLE DATA
	var accessArray = Agua.getAccess();
	//console.log("Access.buildTable    accessArray: " + dojo.toJson(accessArray));	
	
	// CLEAN TABLE
	if ( this.table.childNodes )
	{
		while ( this.table.childNodes.length > 2 )
		{
			this.table.removeChild(this.table.childNodes[2]);
		}
	}

	// BUILD ROWS
	//console.log("Access.buildTable::groupTable     Doing group rows, accessArray.length: " + accessArray.length);
	this.tableRows = [];
	for ( var rowCounter = 0; rowCounter < accessArray.length; rowCounter++)
	{
	//console.log("Access.buildTable::groupTable     accessArray[" + rowCounter + "]: " + dojo.toJson(accessArray[rowCounter], true));
		accessArray[rowCounter].parentWidget = this;
		var accessRow = new plugins.sharing.AccessRow(accessArray[rowCounter]);
	//console.log("Access.buildTable::groupTable     Doing group rows, accessRow: " + accessRow);
	//console.log("Access.buildTable::groupTable     Doing group rows, accessRow.row: " + accessRow.row);
		this.table.appendChild(accessRow.row);
		this.tableRows.push(accessRow);
	}
	//console.log("Access.buildTable     Completed buildTable");
	
},	// buildTable

togglePermission : function (event) {
	var parentNode = event.target.parentNode;
	////console.log("Access.buildTable     parentNode: " + parentNode);
	
	var nodeClass = event.target.getAttribute('class');
	if ( nodeClass.match('allowed') )
	{
		dojo.removeClass(event.target,'allowed');
		dojo.addClass(event.target,'denied');
	}
	else
	{
		dojo.removeClass(event.target,'denied');
		dojo.addClass(event.target,'allowed');
	}
},

saveAccess : function () {
	////console.log("Access.saveAccess     plugins.sharing.Access.saveAccess()");
	////console.log("Access.saveAccess     this.tableRows.length: " + this.tableRows.length);

	// COLLECT DATA HERE
	var dataArray = new Array;
	for ( var i = 0; i < this.tableRows.length; i++ )
	{
		var data = new Object;
		data.owner 		= Agua.cookie('username');
		data.groupname	= this.tableRows[i].args.groupname;
		for ( var j = 1; j < this.rights.length; j++ )
		{
			data[this.rights[j]] = 0;
			if ( dojo.hasClass(this.tableRows[i][this.rights[j]], 'allowed') )
				data[this.rights[j]] = 1;
		}
		dataArray.push(data);
	}

	// CREATE JSON QUERY
	var url = Agua.cgiUrl + "sharing.cgi";
	var query = new Object;
	query.username = Agua.cookie('username');
	query.sessionid = Agua.cookie('sessionid');
	query.mode = "saveAccess";
	query.data = dataArray;
	////console.log("Access.saveAccess     query: " + dojo.toJson(query));
	
	// SEND TO SERVER
	dojo.xhrPut(
		{
			url: url,
			contentType: "text",
			putData: dojo.toJson(query),
			handle: function(response, ioArgs) {
				Agua.toast(response);
			}
		}
	);
}


}); // plugins.sharing.Access


}

if(!dojo._hasResource["plugins.sharing.Sharing"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.sharing.Sharing"] = true;
dojo.provide("plugins.sharing.Sharing");

// ALLOW USER TO MANAGE SHARED RESOURCES AND GROUPS


// DnD
 // Source & Target




// comboBox data store




// rightPane buttons


/*
// TEMPLATE MODULES
//LEFT PANE
dojo.require("plugins.sharing.Apps");

dojo.require("plugins.sharing.Settings");
dojo.require("plugins.sharing.Clusters");

// MIDDLE PANE
dojo.require("plugins.sharing.Parameter");




// RIGHT PANE




*/

dojo.declare( "plugins.sharing.Sharing", 
	[ dijit._Widget, dijit._Templated, plugins.core.Common ],
{
//Path to the template of this widget. 
templateString:"<div dojoAttachPoint=\"containerNode\">\n\n\t<!-- ADMIN TAB -->\n\t<div\n        dojoAttachPoint=\"mainTab\"\n        class=\"sharing\"\n\t\ticonClass=\"sharingIcon\"\n        style=\"min-width: 1140px !important; width: 100% !important; height:100% !important; max-height: auto !important; padding: 0px; background: #FFF;\"\n        dojoType=\"dijit.layout.BorderContainer\"\n\t\tclosable=\"true\"\t\t\n        title=\"Sharing\"\n        >\n        \n        <!-- LEFT PANE -->\n        <div\n            dojoAttachPoint=\"leftPane\"\n            class=\"leftPane\"\n\t\t\tlayoutAlign=\"left\" \n            dojoType=\"dijit.layout.ContentPane\" \n            style=\"position: absolute !important; width: 390px; height: 100% !important; max-height: auto !important; min-width: 25px; background: #FFF; padding: 0; border: none !important;\"\n            >\n\n            <!-- LEFT TAB CONTAINER-->\n            <div dojoAttachPoint=\"leftTabContainer\"\n                dojoType=\"dijit.layout.TabContainer\"\n                style=\"height: 100%; overflow: visible;\"\n                class=\"infoPane\">\n\n            </div>\n            <!-- END OF LEFT TAB CONTAINER-->\n\t\t\t\n        </div>\n        <!-- END OF LEFT PANE -->\n\n        <!-- MIDDLE PANE -->\n        <div\n            dojoAttachPoint=\"middlePane\"\n\t\t\tlayoutAlign=\"middle\" \n\t\t\tclass=\"middlePane\"\n            dojoType=\"dijit.layout.ContentPane\" \n            style=\"position: absolute !important; left: 390px !important; height: 100% !important; max-height: auto !important; width: 390px; min-width: 25px; background: #FFF; padding: 0; border: none !important;\"\n            >\n\n            <!-- MIDDLE TAB CONTAINER-->\n            <div\n                dojoAttachPoint=\"middleTabContainer\"\n                dojoType=\"dijit.layout.TabContainer\"\n                style=\"height: 100%; overflow: visible;\"\n                class=\"infoPane\">\n\n            </div>\n\n        </div>\n        <!-- END OF MIDDLE PANE -->\n\n\n        <!-- RIGHT PANE -->\n        <div\n            dojoAttachPoint=\"rightPane\" \n            class=\"rightPane\"\n\t\t\tlayoutAlign=\"right\"\n            dojoType=\"dijit.layout.ContentPane\" \n            style=\"position: absolute !important; left: 780px !important; height: 100% !important; max-height: auto !important; width: 370px !important; min-width: 25px; background: #FFF; padding: 0; border: none !important;\"\n            >\n\n            <!-- RIGHT TAB CONTAINER-->\n            <div dojoAttachPoint=\"rightTabContainer\"\n                dojoType=\"dijit.layout.TabContainer\"\n                style=\"height: 100%; overflow: visible; width: 370px !important; \"\n                class=\"infoPane\">\n\n            </div>\n            <!-- END OF RIGHT TAB CONTAINER-->\n\n        </div>\n        <!-- END OF RIGHT PANE -->\n\n\t</div>\n\t<!-- END OF ADMIN TAB -->\n\n</div>\n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

// PANE WIDGETS
paneWidgets : null,

// CORE WORKFLOW OBJECTS
core : new Object,

cssFiles : [
	dojo.moduleUrl("plugins", "sharing/css/sharing.css")
],

modules : {
// LEFT PANE
	"Apps"		: "plugins.sharing.Apps",
	"GroupProjects"	:	"plugins.sharing.GroupProjects",
	"Settings"	:	"plugins.sharing.Settings",
	"Clusters"	:	"plugins.sharing.Clusters",
	
	// MIDDLE PANE
	"Amis"		:	"plugins.sharing.Amis",
	"Parameters":	"plugins.sharing.Parameters",
	"Packages"	:	"plugins.sharing.Packages",
	"Groups"	:	"plugins.sharing.Groups",
	"Projects"	:	"plugins.sharing.Projects",
	"Access"	:	"plugins.sharing.Access",
	
	// RIGHT PANE
	"GroupSources"	:	"plugins.sharing.GroupSources",
	"GroupUsers":	"plugins.sharing.GroupUsers",
	"Sources"	:	"plugins.sharing.Sources",
	"Users"		:	"plugins.sharing.Users"
},
/////}}

constructor : function(args) {	
	// LOAD CSS
	this.loadCSS();		
},
postCreate : function() {
	////console.log("Controller.postCreate    plugins.sharing.Controller.postCreate()");

	this.startup();
},
startup : function () {
	//console.log("Controller.startup    plugins.sharing.Controller.startup()");

    // ADD THIS WIDGET TO Agua.widgets
    Agua.addWidget("sharing", this);

	// ADD ADMIN TAB TO TAB CONTAINER		
	Agua.tabs.addChild(this.mainTab);
	Agua.tabs.selectChild(this.mainTab);

	// CREATE HASH TO HOLD INSTANTIATED PANE WIDGETS
	this.paneWidgets = new Object;

	// LOAD HEADINGS FOR THIS USER
	this.headings = Agua.getSharingHeadings();
	
	// LOAD PANES
	this.loadPanes();
},

reload : function (target) {
// RELOAD A WIDGET, WIDGETS IN A PANE OR ALL WIDGETS
	////console.log("Sharing.reload     plugins.sharing.Sharing.reload(target)");
	////console.log("Sharing.reload     target: " + target);

	if ( target == "all" )
	{
		for ( var mainPane in this.headings )
		{
			for ( var i in this.headings[mainPane] )
			{
				this.reloadWidget(this.headings[mainPane][i]);
			}
		}
	}
	else if ( target == "leftPane"
			|| target == "middlePane"
			|| target == "rightPane" )
	{
		for ( var i in this.headings[target] )
		{
			this.reloadWidget(this.headings[target][i]);
		}
	}
	
	// OTHERWISE, THE target MUST BE A PANE NAME
	else
	{
		try {
			this.reloadWidget(target);
		}
		catch (e) {}
	}		
},
reloadWidget : function (paneName) {
// REINSTANTIATE A PANE WIDGET
	////console.log("Sharing.reloadWidget     Reloading pane: " + paneName);

	delete this.paneWidgets[paneName];

	var thisObject = this;
	this.paneWidgets[paneName] = new plugins.sharing[paneName](
		{
			parentWidget: thisObject,
			tabContainer : thisObject.leftTabContainer
		}
	);
},
loadPanes : function () {
	var panes = ["left", "middle", "right"];
	for ( var i = 0; i < panes.length; i++ )
	{
		this.loadPane(panes[i]);
	}
},
loadPane : function(side) {
	//console.log("Sharing.loadPane     plugins.sharing.Sharing.loadPane(side)");
	//console.log("Sharing.loadPane     side: " + dojo.toJson(side));
	var pane = side + "Pane";
	var tabContainer = side + "TabContainer";
	if ( this.headings == null || this.headings[pane] == null )	return;
	for ( var i = 0; i < this.headings[pane].length; i++ )
	{
		//console.log("Sharing.loadLeftPane     LOADING PANE this.headings[pane][" + i + "]: " + this.headings[pane][i]);

		var tabPaneName = this.headings[pane][i];
		console.log("Sharing.loadPane    dojo.require tabPaneName: " + tabPaneName);
		var moduleName = this.modules[tabPaneName];
		console.log("Sharing.loadPane    BEFORE dojo.require moduleName: " + moduleName);
		dojo["require"](moduleName);
		console.log("Sharing.loadPane    AFTER dojo.require moduleName: " + moduleName);
		
		var thisObject = this;
		var tabPane = new plugins["sharing"][tabPaneName](
			{
				parentWidget: thisObject,
				tabContainer : thisObject[tabContainer]
			}
		);
		
		// REGISTER THE NEW TAB PANE IN this.paneWidgets 
		if( this.paneWidgets[moduleName] == null )
			this.paneWidgets[moduleName] = new Array;
		this.paneWidgets[moduleName].push(tabPane);
	}
},
destroyRecursive : function () {
	console.log("Sharing.destroyRecursive    this.mainTab: ");
	console.dir({this_mainTab:this.mainTab});

	if ( Agua && Agua.tabs )
		Agua.tabs.removeChild(this.mainTab);
	
	this.inherited(arguments);
}


}); // end of plugins.sharing.Sharing


}

if(!dojo._hasResource["plugins.sharing.Controller"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.sharing.Controller"] = true;
dojo.provide("plugins.sharing.Controller");

// OBJECT:  plugins.sharing.Controller
// PURPOSE: GENERATE AND MANAGE Sharing PANES

// CONTAINER


// GLOBAL ADMIN CONTROLLER VARIABLE
var sharingController;

// HAS


dojo.declare( "plugins.sharing.Controller",
	[ dijit._Widget, dijit._Templated ],
{
// PANE ID 
paneId : null,

//Path to the template of this widget. 
templateString:"<div dojoAttachPoint=\"containerNode\" class=\"sharing\">\n    <button\n        dojoType=\"dijit.form.Button\"\n        dojoAttachPoint=\"menuButton\"\n        class=\"menuButton\"\n        iconClass=\"sharingIcon\"\n        type=\"button\"\n        label=\"Sharing\"\n        ></button>\n</div>\n        \n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

// TAB PANES
tabPanes : [],

////}}}

// CONSTRUCTOR	
constructor : function(args) {
	// LOAD CSS FOR BUTTON
	this.loadCSS();		
},
postCreate : function() {
	this.startup();
},
startup : function () {
	////console.log("sharing.Controller.startup    plugins.sharing.Controller.startup()");

	this.inherited(arguments);

	// ADD MENU BUTTON TO TOOLBAR
	Agua.toolbar.addChild(this.menuButton);
	
	// SET BUTTON PARENT WIDGET
	this.menuButton.parentWidget = this;
	
	// SET ADMIN BUTTON LISTENER
	var listener = dojo.connect(this.menuButton, "onClick", this, "createTab");
},
createTab : function () {
	// CREATE WIDGET	
	var widget = new plugins.sharing.Sharing({});
	this.tabPanes.push(widget);

	// ADD TO _supportingWidgets FOR INCLUSION IN DESTROY	
	this._supportingWidgets.push(widget);
},
createMenu : function () {
// ADD PROGRAMMATIC CONTEXT MENU
	var dynamicMenu = new dijit.Menu( { id: "sharing" + this.paneId + 'dynamicMenuPopup'} );

	// ADD MENU TITLE
	dynamicMenu.addChild(new dijit.MenuItem( { label:"Application Menu", disabled:false} ));
	dynamicMenu.addChild(new dijit.MenuSeparator());

	//// ONE OF FOUR WAYS TO DO MENU CALLBACK WITH ACCESS TO THE MENU ITEM AND THE CURRENT TARGET 	
	// 4. dojo.connect CALL
	//	REQUIRES:
	//		ADDED menu.currentTarget SLOT TO dijit.menu
	var mItem1 = new dijit.MenuItem(
		{
			id: "sharing" + this.paneId + "remove",
			label: "Remove",
			disabled: false
		}
	);
	dynamicMenu.addChild(mItem1);
	dojo.connect(mItem1, "onClick", function()
		{
			//////////console.log("sharing.Controller.++++ dojo.connect mItem1, onClick");	
			var parentNode = dynamicMenu.currentTarget.parentNode;
			parentNode.removeChild(dynamicMenu.currentTarget);	
		}
	);

	// SEPARATOR
	dynamicMenu.addChild(new dijit.MenuSeparator());

	//	ADD run MENU ITEM
	var mItem2 = new dijit.MenuItem(
		{
			id: "sharing" + this.paneId + "run",
			label: "Run",
			disabled: false
		}
	);
	dynamicMenu.addChild(mItem2);	

	dojo.connect(mItem2, "onClick", function()
		{
			////////console.log("sharing.Controller.++++ 'Run' menu item onClick");
			var currentTarget = dynamicMenu.currentTarget; 
			var sharingList = currentTarget.parentNode;
		}
	);
		
	return dynamicMenu;
},
loadCSS : function() {
	// LOAD CSS
	var cssFiles = [ "plugins/sharing/css/controller.css" ];
	for ( var i in cssFiles )
	{
		var cssFile = cssFiles[i];
		var cssNode = document.createElement('link');
		cssNode.type = 'text/css';
		cssNode.rel = 'stylesheet';
		cssNode.href = cssFile;
		cssNode.media = 'screen';
		document.getElementsByTagName("head")[0].appendChild(cssNode);
	}
}

}); // end of Controller

dojo.addOnLoad(
	function() {
		//// CREATE TAB
		////console.log("sharing.Controller.addOnLoad    BEFORE createTab");
		//Agua.controllers["sharing"].createTab();		
		////console.log("sharing.Controller.addOnLoad    AFTER createTab");
	}
);


}

if(!dojo._hasResource["plugins.sharing.GroupProjectRow"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.sharing.GroupProjectRow"] = true;
dojo.provide("plugins.sharing.GroupProjectRow");


dojo.declare( "plugins.sharing.GroupProjectRow",
	[ dijit._Widget, dijit._Templated ],
{
	//Path to the template of this widget. 
	templateString:"<div dojoAttachPoint=\"containerNode\">\n    <table width=\"100%\" cellspacing=\"0px\">\n        <tr width=\"100%\">\n            <td\n                colspan=\"2\"\n                dojoAttachPoint=\"name\"\n                class=\"name\"\n                >\n                ${name}</td>\n        </tr>\n        <tr>\n            <td colspan=\"2\"\n                dojoAttachPoint=\"description\"\n                class=\"description\"\n                style=\"display: none;\"\n                >${description}</td>\n        </tr>\n    </table>\n</div>\n",

	// Calls dijit._Templated.widgetsInTemplate
	widgetsInTemplate : true,
	
	// PARENT plugins.sharing.Sources WIDGET
	parentWidget : null,
	
	constructor : function(args)
	{
		////////console.log("GroupProjectRow.constructor    plugins.workflow.GroupProjectRow.constructor()");

		this.parentWidget = args.parentWidget;
		//this.inherited(arguments);
	},

	postCreate : function()
	{
		////////console.log("GroupProjectRow.postCreate    plugins.workflow.GroupProjectRow.postCreate()");

		this.startup();
	},
	
	startup : function ()
	{
		//////console.log("GroupProjectRow.startup    plugins.workflow.GroupProjectRow.startup()");
		//////console.log("GroupProjectRow.startup    this.parentWidget: " + this.parentWidget);
		//////console.log("GroupProjectRow.startup    this.name: " + this.name);

		this.inherited(arguments);
		
		var groupProjectRowObject = this;
		dojo.connect( this.name, "onclick", function(event) {
			
			//////console.log("GroupProjectRow.startup    fired onclick");
			groupProjectRowObject.toggle();
			event.stopPropagation(); //Stop Event Bubbling 			
		});

		//// ADD 'EDIT' ONCLICK
		//var groupProjectRowObject = this;
		//dojo.connect(this.description, "onclick", function(event)
		//	{
		//		////////console.log("GroupProjectRow.startup    groupProjectRow.description clicked");
		//
		//		groupProjectRowObject.parentWidget.editGroupProjectRow(groupProjectRowObject, event.target);
		//		event.stopPropagation(); //Stop Event Bubbling 			
		//	}
		//);
		//
		//// ADD 'EDIT' ONCLICK
		//var groupProjectRowObject = this;
		//dojo.connect(this.location, "onclick", function(event)
		//	{
		//		////////console.log("GroupProjectRow.startup    groupProjectRow.location clicked");
		//
		//		groupProjectRowObject.parentWidget.editGroupProjectRow(groupProjectRowObject, event.target);
		//		event.stopPropagation(); //Stop Event Bubbling 			
		//	}
		//);
	},
	
	toggle : function ()
	{
		////////console.log("GroupProjectRow.toggle    plugins.workflow.GroupProjectRow.toggle()");

		if ( this.description.style.display == 'block' ) this.description.style.display='none';
		else this.description.style.display = 'block';
	}
});
	

}

if(!dojo._hasResource["dijit.form.VerticalSlider"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.VerticalSlider"] = true;
dojo.provide("dijit.form.VerticalSlider");



dojo.declare(
	"dijit.form.VerticalSlider",
	dijit.form.HorizontalSlider,
{
	// summary:
	//		A form widget that allows one to select a value with a vertically draggable handle

	templateString: dojo.cache("dijit.form", "templates/VerticalSlider.html", "<table class=\"dijit dijitReset dijitSlider dijitSliderV\" cellspacing=\"0\" cellpadding=\"0\" border=\"0\" rules=\"none\" dojoAttachEvent=\"onkeypress:_onKeyPress,onkeyup:_onKeyUp\"\n\t><tr class=\"dijitReset\"\n\t\t><td class=\"dijitReset\"></td\n\t\t><td class=\"dijitReset dijitSliderButtonContainer dijitSliderButtonContainerV\"\n\t\t\t><div class=\"dijitSliderIncrementIconV\" style=\"display:none\" dojoAttachPoint=\"decrementButton\"><span class=\"dijitSliderButtonInner\">+</span></div\n\t\t></td\n\t\t><td class=\"dijitReset\"></td\n\t></tr\n\t><tr class=\"dijitReset\"\n\t\t><td class=\"dijitReset\"></td\n\t\t><td class=\"dijitReset\"\n\t\t\t><center><div class=\"dijitSliderBar dijitSliderBumper dijitSliderBumperV dijitSliderTopBumper\" dojoAttachEvent=\"onmousedown:_onClkIncBumper\"></div></center\n\t\t></td\n\t\t><td class=\"dijitReset\"></td\n\t></tr\n\t><tr class=\"dijitReset\"\n\t\t><td dojoAttachPoint=\"leftDecoration\" class=\"dijitReset dijitSliderDecoration dijitSliderDecorationL dijitSliderDecorationV\"></td\n\t\t><td class=\"dijitReset dijitSliderDecorationC\" style=\"height:100%;\"\n\t\t\t><input dojoAttachPoint=\"valueNode\" type=\"hidden\" ${!nameAttrSetting}\n\t\t\t/><center class=\"dijitReset dijitSliderBarContainerV\" role=\"presentation\" dojoAttachPoint=\"sliderBarContainer\"\n\t\t\t\t><div role=\"presentation\" dojoAttachPoint=\"remainingBar\" class=\"dijitSliderBar dijitSliderBarV dijitSliderRemainingBar dijitSliderRemainingBarV\" dojoAttachEvent=\"onmousedown:_onBarClick\"><!--#5629--></div\n\t\t\t\t><div role=\"presentation\" dojoAttachPoint=\"progressBar\" class=\"dijitSliderBar dijitSliderBarV dijitSliderProgressBar dijitSliderProgressBarV\" dojoAttachEvent=\"onmousedown:_onBarClick\"\n\t\t\t\t\t><div class=\"dijitSliderMoveable dijitSliderMoveableV\" style=\"vertical-align:top;\"\n\t\t\t\t\t\t><div dojoAttachPoint=\"sliderHandle,focusNode\" class=\"dijitSliderImageHandle dijitSliderImageHandleV\" dojoAttachEvent=\"onmousedown:_onHandleClick\" role=\"slider\" valuemin=\"${minimum}\" valuemax=\"${maximum}\"></div\n\t\t\t\t\t></div\n\t\t\t\t></div\n\t\t\t></center\n\t\t></td\n\t\t><td dojoAttachPoint=\"containerNode,rightDecoration\" class=\"dijitReset dijitSliderDecoration dijitSliderDecorationR dijitSliderDecorationV\"></td\n\t></tr\n\t><tr class=\"dijitReset\"\n\t\t><td class=\"dijitReset\"></td\n\t\t><td class=\"dijitReset\"\n\t\t\t><center><div class=\"dijitSliderBar dijitSliderBumper dijitSliderBumperV dijitSliderBottomBumper\" dojoAttachEvent=\"onmousedown:_onClkDecBumper\"></div></center\n\t\t></td\n\t\t><td class=\"dijitReset\"></td\n\t></tr\n\t><tr class=\"dijitReset\"\n\t\t><td class=\"dijitReset\"></td\n\t\t><td class=\"dijitReset dijitSliderButtonContainer dijitSliderButtonContainerV\"\n\t\t\t><div class=\"dijitSliderDecrementIconV\" style=\"display:none\" dojoAttachPoint=\"incrementButton\"><span class=\"dijitSliderButtonInner\">-</span></div\n\t\t></td\n\t\t><td class=\"dijitReset\"></td\n\t></tr\n></table>\n"),
	_mousePixelCoord: "pageY",
	_pixelCount: "h",
	_startingPixelCoord: "y",
	_startingPixelCount: "t",
	_handleOffsetCoord: "top",
	_progressPixelSize: "height",

	// _descending: Boolean
	//		Specifies if the slider values go from high-on-top (true), or low-on-top (false)
	//		TODO: expose this in 1.2 - the css progress/remaining bar classes need to be reversed
	_descending: true,

	_isReversed: function(){
		// summary:
		//		Overrides HorizontalSlider._isReversed.
		//		Indicates if values are high on top (with low numbers on the bottom).
		return this._descending;
	}
});

}

if(!dojo._hasResource["dijit.form.HorizontalRule"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.HorizontalRule"] = true;
dojo.provide("dijit.form.HorizontalRule");




dojo.declare("dijit.form.HorizontalRule", [dijit._Widget, dijit._Templated],
{
	// summary:
	//		Hash marks for `dijit.form.HorizontalSlider`

	templateString: '<div class="dijitRuleContainer dijitRuleContainerH"></div>',

	// count: Integer
	//		Number of hash marks to generate
	count: 3,

	// container: String
	//		For HorizontalSlider, this is either "topDecoration" or "bottomDecoration",
	//		and indicates whether this rule goes above or below the slider.
	container: "containerNode",

	// ruleStyle: String
	//		CSS style to apply to individual hash marks
	ruleStyle: "",

	_positionPrefix: '<div class="dijitRuleMark dijitRuleMarkH" style="left:',
	_positionSuffix: '%;',
	_suffix: '"></div>',

	_genHTML: function(pos, ndx){
		return this._positionPrefix + pos + this._positionSuffix + this.ruleStyle + this._suffix;
	},

	// _isHorizontal: [protected extension] Boolean
	//		VerticalRule will override this...
	_isHorizontal: true,

	buildRendering: function(){
		this.inherited(arguments);

		var innerHTML;
		if(this.count == 1){
			innerHTML = this._genHTML(50, 0);
		}else{
			var i;
			var interval = 100 / (this.count-1);
			if(!this._isHorizontal || this.isLeftToRight()){
				innerHTML = this._genHTML(0, 0);
				for(i=1; i < this.count-1; i++){
					innerHTML += this._genHTML(interval*i, i);
				}
				innerHTML += this._genHTML(100, this.count-1);
			}else{
				innerHTML = this._genHTML(100, 0);
				for(i=1; i < this.count-1; i++){
					innerHTML += this._genHTML(100-interval*i, i);
				}
				innerHTML += this._genHTML(0, this.count-1);
			}
		}
		this.domNode.innerHTML = innerHTML;
	}
});

}

if(!dojo._hasResource["dijit.form.VerticalRule"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.VerticalRule"] = true;
dojo.provide("dijit.form.VerticalRule");



dojo.declare("dijit.form.VerticalRule", dijit.form.HorizontalRule,
{
	// summary:
	//		Hash marks for the `dijit.form.VerticalSlider`

	templateString: '<div class="dijitRuleContainer dijitRuleContainerV"></div>',
	_positionPrefix: '<div class="dijitRuleMark dijitRuleMarkV" style="top:',

/*=====
	// container: String
	//		This is either "leftDecoration" or "rightDecoration",
	//		to indicate whether this rule goes to the left or to the right of the slider.
	//		Note that on RTL system, "leftDecoration" would actually go to the right, and vice-versa.
	container: "",
=====*/

	// Overrides HorizontalRule._isHorizontal
	_isHorizontal: false

});

}

if(!dojo._hasResource["dijit.form.HorizontalRuleLabels"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.HorizontalRuleLabels"] = true;
dojo.provide("dijit.form.HorizontalRuleLabels");



dojo.declare("dijit.form.HorizontalRuleLabels", dijit.form.HorizontalRule,
{
	// summary:
	//		Labels for `dijit.form.HorizontalSlider`

	templateString: '<div class="dijitRuleContainer dijitRuleContainerH dijitRuleLabelsContainer dijitRuleLabelsContainerH"></div>',

	// labelStyle: String
	//		CSS style to apply to individual text labels
	labelStyle: "",

	// labels: String[]?
	//		Array of text labels to render - evenly spaced from left-to-right or bottom-to-top.
	//		Alternately, minimum and maximum can be specified, to get numeric labels.
	labels: [],

	// numericMargin: Integer
	//		Number of generated numeric labels that should be rendered as '' on the ends when labels[] are not specified
	numericMargin: 0,

	// numericMinimum: Integer
	//		Leftmost label value for generated numeric labels when labels[] are not specified
	minimum: 0,

	// numericMaximum: Integer
	//		Rightmost label value for generated numeric labels when labels[] are not specified
	maximum: 1,

	// constraints: Object
	//		pattern, places, lang, et al (see dojo.number) for generated numeric labels when labels[] are not specified
	constraints: {pattern:"#%"},

	_positionPrefix: '<div class="dijitRuleLabelContainer dijitRuleLabelContainerH" style="left:',
	_labelPrefix: '"><div class="dijitRuleLabel dijitRuleLabelH">',
	_suffix: '</div></div>',

	_calcPosition: function(pos){
		// summary:
		//		Returns the value to be used in HTML for the label as part of the left: attribute
		// tags:
		//		protected extension
		return pos;
	},

	_genHTML: function(pos, ndx){
		return this._positionPrefix + this._calcPosition(pos) + this._positionSuffix + this.labelStyle + this._labelPrefix + this.labels[ndx] + this._suffix;
	},

	getLabels: function(){
		// summary:
		//		Overridable function to return array of labels to use for this slider.
		//		Can specify a getLabels() method instead of a labels[] array, or min/max attributes.
		// tags:
		//		protected extension

		// if the labels array was not specified directly, then see if <li> children were
		var labels = this.labels;
		if(!labels.length){
			// for markup creation, labels are specified as child elements
			labels = dojo.query("> li", this.srcNodeRef).map(function(node){
				return String(node.innerHTML);
			});
		}
		this.srcNodeRef.innerHTML = '';
		// if the labels were not specified directly and not as <li> children, then calculate numeric labels
		if(!labels.length && this.count > 1){
			var start = this.minimum;
			var inc = (this.maximum - start) / (this.count-1);
			for(var i=0; i < this.count; i++){
				labels.push((i < this.numericMargin || i >= (this.count-this.numericMargin)) ? '' : dojo.number.format(start, this.constraints));
				start += inc;
			}
		}
		return labels;
	},

	postMixInProperties: function(){
		this.inherited(arguments);
		this.labels = this.getLabels();
		this.count = this.labels.length;
	}
});

}

if(!dojo._hasResource["dijit.form.VerticalRuleLabels"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.VerticalRuleLabels"] = true;
dojo.provide("dijit.form.VerticalRuleLabels");



dojo.declare("dijit.form.VerticalRuleLabels", dijit.form.HorizontalRuleLabels,
{
	// summary:
	//		Labels for the `dijit.form.VerticalSlider`

	templateString: '<div class="dijitRuleContainer dijitRuleContainerV dijitRuleLabelsContainer dijitRuleLabelsContainerV"></div>',

	_positionPrefix: '<div class="dijitRuleLabelContainer dijitRuleLabelContainerV" style="top:',
	_labelPrefix: '"><span class="dijitRuleLabel dijitRuleLabelV">',

	_calcPosition: function(pos){
		// Overrides HorizontalRuleLabel._calcPosition()
		return 100-pos;
	},

	// needed to prevent labels from being reversed in RTL mode
	_isHorizontal: false
});

}

if(!dojo._hasResource["dijit.form.Slider"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.Slider"] = true;
dojo.provide("dijit.form.Slider");








dojo.deprecated("Call require() for HorizontalSlider / VerticalRule, explicitly rather than 'dijit.form.Slider' itself", "", "2.0");

// For back-compat, remove for 2.0

}

if(!dojo._hasResource["plugins.sharing.GroupProjects"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.sharing.GroupProjects"] = true;
dojo.provide("plugins.sharing.GroupProjects");


 // optimize: load dijit layer


// GENERAL FORM MODULES





// DRAG N DROP


// TOOLTIP
//

// SLIDER


// PARSE


// INHERITS


// HAS A



dojo.declare("plugins.sharing.GroupProjects",

	[ dijit._Widget, dijit._Templated, plugins.core.Common ],
{
//Path to the template of this widget. 
templateString:"<div dojoattachpoint=\"containerNode\">\n\n\t<!-- groupprojects TAB -->\n\t<div\n\t\tdojoAttachPoint=\"groupprojectsTab\"\n\t\tclass=\"groupprojects\"\n\t\tdojoType=\"dijit.layout.ContentPane\"\n\t\ttitle=\"Group Projects\"\n\t\tstyle=\"height: 100% !important; max-height: auto !important; width: 390px !important; padding: 0 !important;\"\n\t\t>\n\n\t\t<table width=\"100%\">\n\t\t\t<tr>\n\t\t\t\t<td colspan=\"2\" class=\"tabTitle\" align=\"center\"> Group Projects </td>\n\t\t\t</tr>\n\t\t\t<tr valign=\"top\">\n\t\t\t\t<td width=\"50%\">\n\t\t\t\t\t<table width=\"100%\">\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td align=\"center\">\n\n\t\t\t\t\t\t\t\t<!-- GROUP COMBO -->\n\t\t\t\t\t\t\t\t<div class=\"comboLabel\"> Groups </div>\n\t\t\t\t\t\t\t\t<div dojoAttachPoint=\"groupCombo\"\n\t\t\t\t\t\t\t\t\t\tdojoType=\"dijit.form.ComboBox\"\n\t\t\t\t\t\t\t\t\t\tclass=\"groupCombo\"\n\t\t\t\t\t\t\t\t\t\tpopupClass=\"groupprojects groupCombo dijitReset dijitMenu\"\n\t\t\t\t\t\t\t\t\t\tautocomplete=\"true\"\n\t\t\t\t\t\t\t\t\t\thasDownArrow=\"true\"\n\t\t\t\t\t\t\t\t\t\tdisabled=\"false\"\n\t\t\t\t\t\t\t\t\t\tstyle=\"width: 150px;\"\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td align=\"center\">\n\n\t\t\t\t\t\t\t\t<!-- DROP TARGET CONTAINER -->\n\t\t\t\t\t\t\t\t<div class=\"comboLabel\"> Group Projects </div>\n\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"dropTargetContainer\"\n\t\t\t\t\t\t\t\t\tclass=\"dropTarget\"\n\t\t\t\t\t\t\t\t\tstyle=\"height: 615px; width: 180px;\"\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t</table>\n\t\t\t\t</td>\n\t\t\t\t<td width=\"50%\">\n\t\t\t\t\t<table width=\"100%\">\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td align=\"center\">\n\t\t\t\t\t\t\t\t<div class=\"comboLabel\"> Projects </div>\n\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"dragSourceSlider\"\n\t\t\t\t\t\t\t\t\tdojoType=\"dijit.form.HorizontalSlider\" \n\t\t\t\t\t\t\t\t\tvalue=\"0\"\n\t\t\t\t\t\t\t\t\tmaximum=\"100\"\n\t\t\t\t\t\t\t\t\tminimum=\"0\"\n\t\t\t\t\t\t\t\t\tpageIncrement=\"100\"\n\t\t\t\t\t\t\t\t\tshowButtons=\"true\"\n\t\t\t\t\t\t\t\t\tintermediateChanges=\"true\"\n\t\t\t\t\t\t\t\t\tslideDuration=\"200\"\n\t\t\t\t\t\t\t\t\tstyle=\"width: 150px;\"\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td align=\"center\">\n\n\t\t\t\t\t\t\t\t<!-- DRAG SOURCE CONTAINER -->\n\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"dragSourceContainer\"\n\t\t\t\t\t\t\t\t\tclass=\"dragSource\"\n\t\t\t\t\t\t\t\t\tstyle=\"height: 553px; width: 150px;\"\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t<tr align=\"center\">\n\t\t\t\t\t\t\t<td align=\"center\">\n\n\t\t\t\t\t\t\t\t<!-- TRASH CONTAINER -->\n\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"trashContainer\"\n\t\t\t\t\t\t\t\t\tclass=\"trash\"\n\t\t\t\t\t\t\t\t\tstyle=\"height: 60px; width: 150px; align: center;\" \n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"trashIcon\"\n\t\t\t\t\t\t\t\t\t\tclass=\"trashIcon\"\n\t\t\t\t\t\t\t\t\t\tstyle=\"height: 60px; width: 60px;\"\n\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t</table>\n\t\t\t\t</td>\n\t\t\t</tr>\n\t\t</table>\n\n\t</div>\n\t<!-- END groupprojects TAB -->\n\t\n</div> \n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,
	
//addingSource STATE
addingSource : false,

// OR USE @import IN HTML TEMPLATE
cssFiles : [ "plugins/sharing/css/groupprojects.css" ],

// PARENT WIDGET
parentWidget : null,

/////}}}

// CONSTRUCTOR	
constructor : function(args) {
	// LOAD CSS
	this.loadCSS();		
},

postCreate : function() {
	this.startup();
},

startup : function () {
	//////console.log("GroupProjects.startup    plugins.sharing.GroupProjects.start()");

	// COMPLETE CONSTRUCTION OF OBJECT
	this.inherited(arguments);	 

	// ADD ADMIN TAB TO TAB CONTAINER		
	this.tabContainer.addChild(this.groupprojectsTab);
	this.tabContainer.selectChild(this.groupprojectsTab);

	// SET GROUP COMBO
	this.setGroupCombo();

	// SET DRAG SOURCE - LIST OF SOURCES
	this.setDragSource();

	// SET DRAG SOURCE SLIDER
	this.setDragSourceSlider();
	
	// SET DROP TARGET - SOURCES ALREADY IN THE GROUP
	this.setDropTarget();
	
	// SET TRASH DROP TARGET
	this.setTrash();
	
	// SUBSCRIBE TO UPDATES
	Agua.updater.subscribe(this, "updateGroups");

	// SUBSCRIBE TO UPDATES
	Agua.updater.subscribe(this, "updateProjects");
},

updateGroups : function (args) {
	//console.log("sharing.GroupProjects.updateGroups    sharing.GroupProjects.updateGroups(args)");
	//console.log("sharing.GroupProjects.updateGroups    args:");
	//console.dir(args);
	this.reload();
},

updateProjects : function (args) {
// RELOAD THE GROUP COMBO AND DRAG SOURCE
// (CALLED AFTER CHANGES TO SOURCES OR GROUPS DATA IN OTHER TABS)
	//console.log("sharing.GroupProjects.updateProjects    sharing.GroupProjects.updateProjects(args)");
	//console.log("sharing.GroupProjects.updateProjects    args:");
	//console.dir(args);
	this.reload();
},

reload : function () {
	//console.log("sharing.GroupProjects.reload    sharing.GroupProjects.reload()");
	// SET GROUP COMBO
	this.setGroupCombo();

	// SET DRAG SOURCE - LIST OF SOURCES
	this.setDragSource();

	// SET DROP TARGET - SOURCES ALREADY IN THE GROUP
	this.setDropTarget();
},

// SET GROUP COMBO BOX
setGroupCombo : function () {
	//////console.log("GroupProjects.setGroupCombo     plugins.sharing.GroupProjects.setGroupCombo()");
	// GET GROUP NAMES		
	var groupNames = Agua.getGroupNames();

	// SET STORE
	var data = {identifier: "name", items: []};
	for ( var i = 0; i < groupNames.length; i++ )
	{
		data.items[i] = { name: groupNames[i]	};
	}

	var store = new dojo.data.ItemFileWriteStore(	{	data: data	}	);

	this.groupCombo.popupClass = "groupprojects groupCombo dijitReset dijitMenu";
	this.groupCombo.wrapperClass = "groupprojects dijitPopup";
	this.groupCombo.itemHeight = 30;
	
	// SET COMBO
	this.groupCombo.store = store;
	this.groupCombo.startup();

	// SET COMBO VALUE
	var firstValue = groupNames[0];
	this.groupCombo.setValue(firstValue);
	//////console.log("GroupProjects.setGroupCombo::setCombo     AFTER this.groupCombo.setValue(firstValue)");

	// CONNECT ONCLICK WITH dojo.connect TO BUILD TABLE
	var groupProjectsObjects = this;
	dojo.connect(this.groupCombo, "onChange", function(event) {
		groupProjectsObjects.setDropTarget();
	});
},



setDragSource : function (position) {
	//////console.log("GroupProjects.setDragSource     plugins.sharing.GroupProjects.setDragSource(position)");
	////////console.log("GroupProjects.setDragSource     position: " + position);

	// REMOVE ALL EXISTING CONTENT
	while ( this.dragSourceContainer.firstChild )
	{
		if ( dijit.byNode(this.dragSourceContainer)
			&& dijit.byNode(this.dragSourceContainer).destroy )
		{
			dijit.byNode(this.dragSourceContainer).destroy();
		}
		this.dragSourceContainer.removeChild(this.dragSourceContainer.firstChild);
	}

	// SET position IF NOT DEFINED
	if ( position == null )	position = 0;

	// RETURN IF USER ARRAY IS NULL OR EMPTY
	if ( Agua.getProjects() == null || Agua.getProjects().length == 0 )
	{
		//////console.log("GroupProjects.setDragSource     Agua.getProjects() is null or empty. Returning.");
		return;
	}

	var projectArray = Agua.getProjects();
	//////console.log("GroupProjects.setDragSource     projectArray: " + dojo.toJson(projectArray));
	//////console.log("GroupProjects.setDragSource     projectArray.length: " + projectArray.length);

	// GENERATE USER DATA TO INSERT INTO DND USER TABLE
	var MAXUSERS = this.maxDisplayedProjects;
	var MULTIPLE = ( projectArray.length - MAXUSERS ) / 100;
			MULTIPLE = MULTIPLE ? MULTIPLE : 1;

	var start = parseInt(position * MULTIPLE);
	var end = parseInt( (position * MULTIPLE) + MAXUSERS );
	if ( ! end || end > projectArray.length )	end = projectArray.length;

	//////console.log("GroupProjects.setDragSource     start: " + start);
	//////console.log("GroupProjects.setDragSource     end: " + end);

	// SORT PROJECT ARRAY

	// GENERATE USER DATA TO INSERT INTO DND USER TABLE
	var dataArray = new Array;
	for ( var j = start; j < end; j++ )
	{
		var data = projectArray[j];				
		data.toString = function () { return this.name; }
		dataArray.push( { data: data, type: ["draggableItem"] } );
	}

	// GENERATE DND SOURCE
	var dragSource = new dojo.dnd.Source(
		this.dragSourceContainer,
		{
			copyOnly: true,
			selfAccept: false,
			accept : [ "none" ]
		}
	);
	dragSource.insertNodes(false, dataArray);

	// projects TABLE QUERY:
	// SELECT DISTINCT projectname, firstname, lastname, email, description FROM projects ORDER BY projectname};
	// SET TABLE ROW STYLE IN dojDndItems
	var allNodes = dragSource.getAllNodes();
	for ( var k = 0; k < allNodes.length; k++ )
	{
		//////console.log("GroupProjects.setDragSource     Setting node " + k + " with data: " + dojo.toJson(dataArray[k].data));

		// ADD CLASS FROM type TO NODE
		var node = allNodes[k];

		// SET NODE name AND description
		node.name = dataArray[k].data.name;
		node.description = dataArray[k].data.description;
		if ( node.description == null ) node.description = '';
		
		// CHECK ATTRIBUTES ARE NOT NULL
		if ( node.description == null )
			node.description = '';

		if ( node.name != null && node.name != '' )
		{
			var project = {
				name : node.name,
				description : node.description
			};
			//////console.log("GroupProjects.setDragSource     project: " + dojo.toJson(project));
			project.parentWidget = this;			

			var groupProjectRow = new plugins.sharing.GroupProjectRow(project);
			//groupProjectRow.toggle();
			////////console.log("GroupProjects.setDragSource     groupProjectRow: " + groupProjectRow);
			node.innerHTML = '';
			node.appendChild(groupProjectRow.domNode);
		}
	}

	var sourceObject = this;
	dragSource.creator = function (item, hint)
	{
		//////console.log("GroupProjects.setDragSource dragSource.creator         item: " + dojo.toJson(item));
		//////console.log("GroupProjects.setDragSource dragSource.creator         item: " + dojo.toJson(item));
		////////console.log("GroupProjects.setDragSource dragSource.creator         hint: " + hint);

		var node = dojo.doc.createElement("div");
		node.name = item.name;
		node.description = item.description;

		node.id = dojo.dnd.getUniqueId();
		node.className = "dojoDndItem";

		//////console.log("GroupProjects.setDragSource dragSource.creator         node.name: " + node.name);
		//////console.log("GroupProjects.setDragSource dragSource.creator         node.description: " + node.description);

		// SET FANCY FORMAT IN NODE INNERHTML
		node.innerHTML = "<table> <tr><td> <img src='http://localhost/agua/plugins/sharing/images/users-18.png' <strong style='color: darkred'>" + node.name + "</strong></td></tr><tr><td> " + node.description + "</td></tr></table>";
		////////console.log("GroupProjects.setDragSource dragSource.creator         node: " + node);

		return {node: node, data: item, type: ["text"]};
	};
},

setDragSourceSlider : function () {
	//////console.log("GroupProjects.setDragSourceSlider     plugins.sharing.GroupProjects.setDragSourceSlider()");
	//////console.log("GroupProjects.dragSourceSourceSlider     this.dragSourceSlider: " + this.dragSourceSlider);

	// ONMOUSEUP
	var groupProjectsObject = this;
	dojo.connect(this.dragSourceSlider, "onMouseUp", dojo.hitch(this, function(e)
	{
		var position = parseInt(this.dragSourceSlider.getValue());
		this.setDragSource(position);
	}));
},

setDropTarget : function () {
	//////console.log("GroupProjects.setDropTarget     plugins.sharing.GroupProjects.setDropTarget()");

	// DELETE EXISTING CONTENTS OF DROP TARGET
	while ( this.dropTargetContainer.firstChild )
	{
		this.dropTargetContainer.removeChild(this.dropTargetContainer.firstChild);
	}

	//// GET THE SOURCES IN THIS GROUP
	var groupname = this.groupCombo.getValue();
	var projectArray = Agua.getProjectsByGroup(groupname);
	if ( projectArray == null )
	{
		//////console.log("GroupProjects.setDropTarget     projectArray is null or empty. Returning.");
		return;
	}		
	//////console.log("GroupProjects.setDropTarget     projectArray: " + dojo.toJson(projectArray));

	var dataArray = new Array;
	for ( var j = 0; j < projectArray.length; j++ )
	{
		var data = projectArray[j];				
		data.toString = function () { return this.name; }
		var description = projectArray[j].description;

		dataArray.push( { data: data, type: ["draggableItem"], description: description  } );
	}
	////////console.log("GroupProjects.setDropTarget     dataArray: " + dojo.toJson(dataArray));
	//////console.log("GroupProjects.setDropTarget     dataArray.length: " + dataArray.length);

	// GENERATE DROP TARGET
	var dropTarget = new dojo.dnd.Source(
		this.dropTargetContainer,
		{
			//copyOnly: true,
			//selfAccept: false
			//,
			accept : [ "draggableItem" ]
		}
	);
	dropTarget.insertNodes(false, dataArray );
	//////console.log("GroupProjects.setDropTarget     dropTarget: " + dropTarget);

	// SET TABLE ROW STYLE IN dojDndItems
	var allNodes = dropTarget.getAllNodes();
	//////console.log("GroupProjects.setDropTarget     Sources.setDropTarget    allNodes.length: " + allNodes.length);
	for ( var k = 0; k < allNodes.length; k++ )
	{
		//////console.log("GroupProjects.setDropTarget     Sources.setDropTarget    dataArray[" + k + "]: " + dojo.toJson(dataArray[k]));

		// ADD CLASS FROM type TO NODE
		var node = allNodes[k];
		var nodeClass = dataArray[k].type;
		//////console.log("GroupProjects.setDropTarget     Sources.setDropTarget    nodeClass: " + nodeClass);
		dojo.addClass(node, nodeClass);

		// SET NODE ATTRIBUTES
		node.name = dataArray[k].data.name;
		node.description = dataArray[k].data.description;

		var project = {
			name : node.name,
			description : node.description
		};
		//////console.log("GroupProjects.setDropTarget     project: " + dojo.toJson(project));
		project.parentWidget = this;			

		var groupProjectRow = new plugins.sharing.GroupProjectRow(project);
		//////console.log("GroupProjects.setDropTarget     groupProjectRow: " + groupProjectRow);
		node.innerHTML = '';
		node.appendChild(groupProjectRow.domNode);
	}
	

	// ADD SPECIAL DRAG AVATAR
	var groupProjectsObject = this;
	dropTarget.creator = function (item, hint)
	{
		//////console.log("GroupProjects.setDropTarget dropTarget.creator(item, hint)");
		////////console.log("GroupProjects.setDropTarget dropTarget.creator         item: " + dojo.toJson(item));
		////////console.log("GroupProjects.setDropTarget dropTarget.creator         hint: " + hint);
		
		// item CAN COME FROM THE DRAG SOURCE OR THE DROP TARGET ITSELF
		var name = item.projectname ? item.projectname : item.name;
		var description = item.projectdesc ? item.projectdesc : item.description;

		if ( name == null || name == '' )
		{
			//////console.log("GroupProjects.setDropTarget dropTarget.creator    name is null or empty! Returning.");
			return;
		}
		if ( description == null ) description = '';
		
		// ADD VALUES TO NODE SO THAT THEY GET PASSED TO this.addToGroup
		var node = dojo.doc.createElement("div");
		node.name = name;
		node.description = description;
		node.id = dojo.dnd.getUniqueId();
		node.className = "dojoDndItem";

		var project = {
			name : name,
			description : description
		};
		//////console.log("GroupProjects.setDropTarget    dropTarget.creator    project: " + dojo.toJson(project));
		project.parentWidget = this;			

		var groupProjectRow = new plugins.sharing.GroupProjectRow(project);
		//////console.log("GroupProjects.setDropTarget    dropTarget.creator    groupProjectRow: " + groupProjectRow);
		node.innerHTML = '';
		node.appendChild(groupProjectRow.domNode);

		// ACCEPTABLE NODE DROPPED ONTO SELF --> ADD TO USER GROUP.
		if ( hint != 'avatar' )
		{
			groupProjectsObject.addToGroup(node.name, node.description, node.name);
		}

		return {node: node, data: item, type: ["draggableItem"]};
	};
	

	// ADD NODE IF DROPPED FROM OTHER SOURCE, DELETE IF DROPPED FROM SELF
	dojo.connect(dropTarget, "onDndDrop", function(source, nodes, copy, target)
	{
		// NODE DROPPED FROM SELF --> DELETE NODE
		if ( source == this && target != this )
		{
			for ( var i = 0; i < nodes.length; i++ )
			{
				var node = nodes[i];
				groupProjectsObject.removeFromGroup(node.name, node.description, node.location);
			}
		}			
		else
		{
			// DO NOTHING IF NODE WAS DROPPED FROM DRAG SOURCE
			// ( IT HAS ALREADY BEEN GENERATED BY dropTarget.creator() )
		}			
		
		// REMOVE DUPLICATE NODES
		var currentNodes = dropTarget.getAllNodes();
		if ( currentNodes == null || ! currentNodes )
		{
			console.log("GroupProjects.setDropTarget dojo.connect onDndDrop    currentNodes is null or empty. Returning");
			return;
		}

		// DELETE DUPLICATE NODES
		var names = new Object;
		console.log("GroupProjects.setDropTarget dojo.connect onDndDrop    Checking for duplicate nodes");
		for ( var i = 0; i < currentNodes.length; i++ )
		{
			var node = currentNodes[i];
			if ( ! names[node.name] )
			{
				names[node.name] = 1;
			}
			else
			{
				// HACK TO AVOID THIS ERROR: node.parentNode is null
				try {
					console.log("GroupProjects.setDropTarget dojo.connect onDndDrop    Removing duplicate node: " + node.name );
					node.parentNode.removeChild(node)
					
					// NB: THIS HAS NO EFFECT ON NODES IN dnd.Source
					//currentNodes.splice(i, 1); 
				}
				catch (e) {}
			}
		}
	});
},

addToGroup : function (name, description, location ) {
	//////console.log("GroupProjects.addToGroup    plugins.sharing.GroupProjects.addToGroup(name, description, location)");
	//////console.log("GroupProjects.addToGroup    name: " + name);
	//////console.log("GroupProjects.addToGroup    description: " + description);
	//////console.log("GroupProjects.addToGroup    location: " + location);
	
	var groupObject = new Object;
	groupObject.username = Agua.cookie('username');
	groupObject.name = name;
	groupObject.description = description;
	groupObject.location = location;
	groupObject.username = Agua.cookie('username');
	
	// ADD SOURCE OBJECT TO THE SOURCES IN THIS GROUP
	var groupName = this.groupCombo.getValue();
	//////console.log("GroupProjects.addToGroup     groupName: " + groupName);

	var success = Agua.addProjectToGroup(groupName, groupObject);
	//////console.log("GroupProjects.addToGroup     Agua.addProjectToGroup success: " + success);
	if ( success == false )
	{
		//////console.log("GroupProjects.addToGroup     Failed to add project to group: " + groupObject.name + ". Returning.");
		return;
	}

	// ADD THE SOURCE INTO THE groupprojects TABLE ON THE SERVER
	var data = new Object;
	data.name = name;
	data.description = description;
	data.location = location;
	data.groupname = groupName;
	data.type = "project";
	
	var url = Agua.cgiUrl + "sharing.cgi";
	var query = new Object;
	query.username = Agua.cookie('username');
	query.sessionid = Agua.cookie('sessionid');
	query.data = data;
	query.mode = "addToGroup";

	var queryString = dojo.toJson(query).replace(/undefined/g, '""');
	////////console.log("GroupProjects.addToGroup    queryString: " + queryString);

	// SEND TO SERVER
	dojo.xhrPut(
		{
			url: url,
			contentType: "text",
			sync : false,
			handleAs: "json",
			putData: queryString,
			timeout: 15000,
			load: function(data)
			{
				//////console.log("GroupProjects.addToGroup    JSON loaded okay");
				//////console.log("GroupProjects.addToGroup    data: " + dojo.toJson(data));		
			},
			error: function(response, ioArgs) {
				//////console.log("GroupProjects.addToGroup    Error with JSON Post, response: " + response + ", ioArgs: " + ioArgs);
				return response;
			}
		}
	);
},

removeFromGroup : function (name, description, location ) {
	//////console.log("GroupProjects.removeFromGroup    plugins.sharing.GroupProjects.removeFromGroup(name, description, location)");
	//////console.log("GroupProjects.removeFromGroup    name: " + name);
	////////console.log("GroupProjects.removeFromGroup    description: " + description);
	////////console.log("GroupProjects.removeFromGroup    location: " + location);

	// REMOVE SOURCE FROM THE SOURCES IN THIS GROUP
	var groupName = this.groupCombo.getValue();
	//////console.log("GroupProjects.removeFromGroup     groupName: " + groupName);

	var groupObject = new Object;
	groupObject.name = name;
	groupObject.description = description;
	groupObject.location = location;
	groupObject.username = Agua.cookie('username');
	//////console.log("GroupProjects.removeFromGroup     groupObject: " + dojo.toJson(groupObject));

	if ( Agua.removeProjectFromGroup(groupName, groupObject) == false )
	{
		//////console.log("GroupProjects.removeFromGroup     Failed to remove project from group: " + groupObject.name + ". Returning.");
		return;
	}

	// REMOVE THE SOURCE FROM THE groupprojects TABLE ON THE SERVER
	var data = new Object;
	data.name = String(name);
	data.description = description;
	data.location = location;
	data.groupname = groupName;
	data.type = "project";
	
	var url = Agua.cgiUrl + "sharing.cgi";
	var query = new Object;
	query.username = Agua.cookie('username');
	query.sessionid = Agua.cookie('sessionid');
	query.data = data;
	query.mode = "removeFromGroup";

	var queryString = dojo.toJson(query).replace(/undefined/g, '""');
	////////console.log("GroupProjects.removeFromGroup    queryString: " + queryString);

	// SEND TO SERVER
	dojo.xhrPut(
		{
			url: url,
			contentType: "text",
			sync : false,
			handleAs: "json",
			putData: queryString,
			timeout: 15000,
			load: function(data)
			{
				//////console.log("GroupProjects.removeFromGroup    JSON loaded okay");
				//////console.log("GroupProjects.removeFromGroup    data: " + dojo.toJson(data));		
			},
			error: function(response, ioArgs) {
				//////console.log("GroupProjects.removeFromGroup    Error with JSON Post, response: " + response + ", ioArgs: " + ioArgs);
				return response;
			}
		}
	);
},

setTrash : function () {
//	DELETE NODE IF DROPPED INTO TRASH. ACTUAL REMOVAL FROM THE
//	DATA IS ACCOMPLISHED IN THE onDndDrop LISTENER OF THE SOURCE
	
	//////console.log("GroupProjects.setTrash     plugins.sharing.GroupProjects.setTrash()");

	var trash = new dojo.dnd.Source(
		this.trashContainer,
		{
			accept : [ "draggableItem" ]
		}
	);
	//////console.log("GroupProjects.setTrash     trash: " + trash);
	//////console.log("GroupProjects.setTrash.domNode     trash.domNode: " + trash.domNode);

	// REMOVE DUPLICATE NODES
	dojo.connect(trash, "onDndDrop", function(source, nodes, copy, target){
		
		//////console.log("GroupProjects.setTrash dojo.connect(onDndDrop)    Checking if target == this.");
		////////console.log("GroupProjects.setTrash dojo.connect(onDndDrop)    source: " + source);
		////////console.log("GroupProjects.setTrash dojo.connect(onDndDrop)    nodes: " + nodes);
		////////console.log("GroupProjects.setTrash dojo.connect(onDndDrop)    copy: " + copy);
		////////console.log("GroupProjects.setTrash dojo.connect(onDndDrop)    target: " + target);
		
		// NODE DROPPED ON SELF --> DELETE THE NODE
		if ( target == this )
		{
			//////console.log("GroupProjects.setTrash dojo.connect(onDndDrop)    target == this. Removing dropped nodes");
			var currentNodes = trash.getAllNodes();
			for ( var i = 0; i < currentNodes.length; i++ )
			{
				var node = currentNodes[i];
				// HACK TO AVOID THIS ERROR: node.parentNode is null
				try {
					node.parentNode.removeChild(node)
				}
				catch (e) {
				}
			}
		}
	});
}

}); // plugins.sharing.GroupProjects

}

if(!dojo._hasResource["plugins.sharing.GroupRow"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.sharing.GroupRow"] = true;
dojo.provide("plugins.sharing.GroupRow");


dojo.declare( "plugins.sharing.GroupRow",
	[ dijit._Widget, dijit._Templated ],
{
//Path to the template of this widget. 
templateString:"<div dojoAttachPoint=\"containerNode\">\n    <table width=\"100%\">\n        <tr>\n            <td\n                dojoAttachPoint=\"groupname\"\n                class=\"groupname\"\n                >\n                ${groupname}</td>\n        </tr>\n        <tr>\n            <td\n                dojoAttachPoint=\"description\"\n                class='description'\n                style=\"display: none;\" >${description}</td>\n        </tr>\n        <tr>\n            <td\n                dojoAttachPoint=\"notes\"\n                class='notes'\n                style=\"display: none;\">${notes}</td>\n        </tr>\n    </table>\n</div>\n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

// PARENT plugins.sharing.Groups WIDGET
parentWidget : null,

////}}}}

constructor : function(args) {
	//////console.log("GroupRow.constructor    plugins.workflow.GroupRow.constructor()");
	this.parentWidget = args.parentWidget;
},


postCreate : function() {
	////////console.log("GroupRow.postCreate    plugins.workflow.GroupRow.postCreate()");
	this.formInputs = this.parentWidget.formInputs;
	this.startup();
},

startup : function () {
	//////console.log("GroupRow.startup    plugins.workflow.GroupRow.startup()");
	//////console.log("GroupRow.startup    this.parentWidget: " + this.parentWidget);
	this.inherited(arguments);
	
	var thisObject = this;
	dojo.connect( this.groupname, "onclick", function(event) {
		thisObject.toggle();
		event.stopPropagation(); //Stop Event Bubbling 			
	});

	// DESCRIPTION
	dojo.connect(this.description, "onclick", function(event)
		{
			//////console.log("GroupRow.startup    groupRow.description clicked");
			thisObject.parentWidget.editRow(thisObject, event.target);
		}
	);

	// NOTES
	dojo.connect(this.notes, "onclick", function(event)
		{
			//////console.log("GroupRow.startup    groupRow.notes clicked");
			thisObject.parentWidget.editRow(thisObject, event.target);
		}
	);
},

toggle : function () {
	//////console.log("GroupRow.toggle    plugins.workflow.GroupRow.toggle()");
	if ( this.description.style.display == 'block' ) this.description.style.display='none';
	else this.description.style.display = 'block';
	if ( this.notes.style.display == 'block' ) this.notes.style.display='none';
	else this.notes.style.display = 'block';
}

});
	

}

if(!dojo._hasResource["plugins.sharing.GroupSourceRow"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.sharing.GroupSourceRow"] = true;
dojo.provide("plugins.sharing.GroupSourceRow");


dojo.declare( "plugins.sharing.GroupSourceRow",
	[ dijit._Widget, dijit._Templated ],
{
	//Path to the template of this widget. 
	templateString:"<div dojoAttachPoint=\"containerNode\">\n    <table width=\"100%\" cellspacing=\"0px\">\n        <tr>\n            <td colspan=\"2\"\n                dojoAttachPoint=\"name\"\n                class=\"name\"\n                >\n                ${name}</td>\n        </tr>\n        <tr>\n            <td colspan=\"2\"\n                dojoAttachPoint=\"description\"\n                class=\"description\"\n                style=\"display: none;\"\n                >${description}</td>\n        </tr>\n        <!--<tr>-->\n        <!--    <td-->\n        <!--        dojoAttachPoint=\"location\"-->\n        <!--        class='location'-->\n        <!--        style=\"display: block;\"-->\n        <!--        >${location}</td>-->\n        <!--</tr>-->\n\n    </table>\n</div>\n",

	// Calls dijit._Templated.widgetsInTemplate
	widgetsInTemplate : true,
	
	// PARENT plugins.sharing.Sources WIDGET
	parentWidget : null,
	
	constructor : function(args)
	{
		console.log("GroupSourceRow.constructor    args:");
		console.dir({args:args});	
		
		this.parentWidget = args.parentWidget;
		//this.inherited(arguments);
	},

	postCreate : function()
	{
		////////console.log("GroupSourceRow.postCreate    plugins.workflow.GroupSourceRow.postCreate()");

		this.startup();
	},
	
	startup : function ()
	{
		////////console.log("GroupSourceRow.startup    plugins.workflow.GroupSourceRow.startup()");
		////////console.log("GroupSourceRow.startup    this.parentWidget: " + this.parentWidget);

		this.inherited(arguments);
		
		var groupSourceRowObject = this;
		dojo.connect( this.name, "onclick", function(event) {
			groupSourceRowObject.toggle();
			event.stopPropagation(); //Stop Event Bubbling 			
		});

		//// ADD 'EDIT' ONCLICK
		//var groupSourceRowObject = this;
		//dojo.connect(this.description, "onclick", function(event)
		//	{
		//		////////console.log("GroupSourceRow.startup    groupSourceRow.description clicked");
		//
		//		groupSourceRowObject.parentWidget.editGroupSourceRow(groupSourceRowObject, event.target);
		//		event.stopPropagation(); //Stop Event Bubbling 			
		//	}
		//);
		//
		//// ADD 'EDIT' ONCLICK
		//var groupSourceRowObject = this;
		//dojo.connect(this.location, "onclick", function(event)
		//	{
		//		////////console.log("GroupSourceRow.startup    groupSourceRow.location clicked");
		//
		//		groupSourceRowObject.parentWidget.editGroupSourceRow(groupSourceRowObject, event.target);
		//		event.stopPropagation(); //Stop Event Bubbling 			
		//	}
		//);
	},
	
	toggle : function ()
	{
		////////console.log("GroupSourceRow.toggle    plugins.workflow.GroupSourceRow.toggle()");

		//if ( this.location.style.display == 'block' ) this.location.style.display='none';
		//else this.location.style.display = 'block';
		if ( this.description.style.display == 'block' ) this.description.style.display='none';
		else this.description.style.display = 'block';
	}
});
	

}

if(!dojo._hasResource["plugins.sharing.GroupSources"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.sharing.GroupSources"] = true;
dojo.provide("plugins.sharing.GroupSources");

 // optimize: load dijit layer







// TOOLTIP





// HAS A


dojo.declare("plugins.sharing.GroupSources",

	[ dijit._Widget, dijit._Templated, plugins.core.Common ],
{
//Path to the template of this widget. 
templateString:"<div dojoattachpoint=\"containerNode\">\n\n\t<!-- SOURCES TAB -->\n\t<div\n\t\tdojoAttachPoint=\"sourcesTab\"\n\t\tclass=\"groupsources\"\n\t\tdojoType=\"dijit.layout.ContentPane\"\n\t\ttitle=\"Group Sources\"\n\t\tstyle=\"height: 100% !important; max-height: auto !important; width: 370px !important; padding: 0 !important;\"\n\t\t>\n\n\t\t<table width=\"100%\">\n\t\t\t<tr valign=\"top\" width=\"370\">\n\t\t\t\t<td colspan=\"2\" class=\"tabTitle\" align=\"center\"> Group Sources </td>\n\t\t\t</tr>\n\t\t\t<tr valign=\"top\" width=\"95%\">\n\t\t\t\t<td width=\"50%\">\n\t\t\t\t\t<table width=\"100%\">\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td align=\"center\">\n\n\t\t\t\t\t\t\t\t<!-- GROUP COMBO -->\n\t\t\t\t\t\t\t\t<div class=\"comboLabel\"> Groups </div>\n\t\t\t\t\t\t\t\t<div dojoAttachPoint=\"groupCombo\"\n\t\t\t\t\t\t\t\t\t\tdojoType=\"dijit.form.ComboBox\"\n\t\t\t\t\t\t\t\t\t\tclass=\"groupCombo\"\n\t\t\t\t\t\t\t\t\t\tpopupClass=\"sources groupCombo dijitReset dijitMenu\"\n\t\t\t\t\t\t\t\t\t\tautocomplete=\"true\"\n\t\t\t\t\t\t\t\t\t\thasDownArrow=\"true\"\n\t\t\t\t\t\t\t\t\t\tdisabled=\"false\"\n\t\t\t\t\t\t\t\t\t\tstyle=\"width: 150px;\"\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td align=\"center\">\n\n\t\t\t\t\t\t\t\t<!-- DROP TARGET CONTAINER -->\n\t\t\t\t\t\t\t\t<div class=\"comboLabel\"> Group Sources </div>\n\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"dropTargetContainer\"\n\t\t\t\t\t\t\t\t\tclass=\"dropTarget\"\n\t\t\t\t\t\t\t\t\tstyle=\"height: 622px; width: 160px;\"\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t</table>\n\t\t\t\t</td>\n\t\t\t\t<td width=\"50%\">\n\t\t\t\t\t<table width=\"100%\">\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td align=\"center\">\n\n\t\t\t\t\t\t\t\t<!-- DRAG SOURCE CONTAINER -->\n\t\t\t\t\t\t\t\t<div class=\"comboLabel\"> Sources </div>\n\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"dragSourceContainer\"\n\t\t\t\t\t\t\t\t\tclass=\"dragSource\"\n\t\t\t\t\t\t\t\t\tstyle=\"height: 580px; width: 160px;\"\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t<tr align=\"center\">\n\t\t\t\t\t\t\t<td align=\"center\">\n\n\t\t\t\t\t\t\t\t<!-- TRASH CONTAINER -->\n\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"trashContainer\"\n\t\t\t\t\t\t\t\t\tclass=\"trash\"\n\t\t\t\t\t\t\t\t\tstyle=\"height: 60px; width: 150px; align: center;\" \n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"trashIcon\"\n\t\t\t\t\t\t\t\t\t\tclass=\"trashIcon\"\n\t\t\t\t\t\t\t\t\t\tstyle=\"height: 60px; width: 60px;\"\n\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t</table>\n\t\t\t\t</td>\n\t\t\t</tr>\n\t\t</table>\n\n\t</div>\n\t<!-- END SOURCES TAB -->\n\t\n</div> \n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,
	
//addingSource STATE
addingSource : false,

// OR USE @import IN HTML TEMPLATE
cssFiles : [ "plugins/sharing/css/groupsources.css" ],

// PARENT WIDGET
parentWidget : null,

////}}}

constructor : function(args) {
	// LOAD CSS
	this.loadCSS();		
},
postCreate : function() {
	this.startup();
},
startup : function () {
	console.log("GroupSources.startup    plugins.sharing.GroupSources.start()");

	// COMPLETE CONSTRUCTION OF OBJECT
	this.inherited(arguments);	 

	// ADD ADMIN TAB TO TAB CONTAINER		
	this.tabContainer.addChild(this.sourcesTab);
	//this.tabContainer.selectChild(this.sourcesTab);

	// SET GROUP COMBO
	this.setGroupCombo();

	// SET DRAG SOURCE - LIST OF SOURCES
	this.setDragSource();
	
	// CREATE DROP TARGET
	this.createDropTarget();
	
	// SET DROP TARGET - SOURCES ALREADY IN THE GROUP
	this.setDropTarget();
	
	// SET TRASH DROP TARGET
	this.setTrash();
	
	// SUBSCRIBE TO UPDATES
	Agua.updater.subscribe(this, "updateGroups");

	// SUBSCRIBE TO UPDATES
	Agua.updater.subscribe(this, "updateSources");
},
updateGroups : function (args) {
	console.log("sharing.GroupSources.updateGroups    sharing.GroupSources.updateGroups(args)");
	console.log("sharing.GroupSources.updateGroups    args:");
	console.dir(args);
	this.reload();
},
updateSources : function (args) {
	console.log("sharing.GroupSources.updateSources    sharing.GroupSources.updateSources(args)");
	console.log("sharing.GroupSources.updateSources    args:");
	console.dir(args);
	this.reload();
},
reload : function () {
// RELOAD THE GROUP COMBO AND DRAG SOURCE
// (CALLED AFTER CHANGES TO SOURCES OR GROUPS DATA IN OTHER TABS)
	console.log("sharing.GroupSources.reload    sharing.GroupSources.reload()");

	// SET GROUP COMBO
	this.setGroupCombo();

	// SET DRAG SOURCE - LIST OF SOURCES
	this.setDragSource();

	// SET DROP TARGET - SOURCES ALREADY IN THE GROUP
	this.setDropTarget();
},
setGroupCombo : function () {
	console.log("GroupSources.setGroupCombo     plugins.sharing.GroupSources.setGroupCombo()");

	// GET GROUP NAMES		
	var groupNames = Agua.getGroupNames();
	console.log("GroupSources.setGroupCombo     groupNames: " + dojo.toJson(groupNames));

	// SET STORE
	var data = {identifier: "name", items: []};
	for ( var i = 0; i < groupNames.length; i++ )
	{
		data.items[i] = { name: groupNames[i]	};
	}
	console.log("GroupSources.setGroupCombo     data: " + dojo.toJson(data));
	var store = new dojo.data.ItemFileWriteStore(	{	data: data	}	);

	this.groupCombo.popupClass = "groupsources groupCombo dijitReset dijitMenu";
	this.groupCombo.wrapperClass = "groupsources dijitPopup";
	this.groupCombo.itemHeight = 30;
	
	// SET COMBO
	this.groupCombo.store = store;
	this.groupCombo.startup();
	console.log("GroupSources.setGroupCombo::setCombo     AFTER this.groupCombo.startup()");

	// SET COMBO VALUE
	var firstValue = groupNames[0];
	this.groupCombo.setValue(firstValue);
	console.log("GroupSources.setGroupCombo::setCombo     AFTER this.groupCombo.setValue(firstValue)");

	// CONNECT ONCLICK WITH dojo.connect TO BUILD TABLE
	var sharingSources = this;
	dojo.connect(this.groupCombo, "onChange", function(event) {
		sharingSources.setDropTarget();
	});
},
setDragSource : function () {
	console.log("GroupSources.setDragSource     plugins.sharing.GroupSources.setDragSource()");
	// REMOVE ALL EXISTING CONTENT
	while ( this.dragSourceContainer.firstChild )
	{
		if ( dijit.byNode(this.dragSourceContainer)
			&& dijit.byNode(this.dragSourceContainer).destroy )
		{
			dijit.byNode(this.dragSourceContainer).destroy();
		}
		this.dragSourceContainer.removeChild(this.dragSourceContainer.firstChild);
	}

	var dataArray = new Array;
	var sourceArray = Agua.getSources();
	console.log("GroupSources.setDragSource     sourceArray: ");
	console.dir({sourceArray:sourceArray});
	//console.log("GroupSources.setDragSource     sourceArray.length: " + sourceArray.length);


	if ( sourceArray == null || ! sourceArray )
	{
		console.log("GroupSources.setDragSource     sourceArray is null or empty. Returning.");
		return;
	}

	for ( var j = 0; j < sourceArray.length; j++ )
	{
		var data = sourceArray[j];				
		data.toString = function () { return this.name; }
		dataArray.push( { data: data, type: ["draggableItem"] } );
	}

	// GENERATE DND SOURCE
	var dragSource = new dojo.dnd.Source(
		this.dragSourceContainer,
		{
			copyOnly: true,
			selfAccept: false,
			accept : [ "none" ]
		}
	);
	dragSource.insertNodes(false, dataArray);
	//console.log("GroupSources.setDragSource     dragSource: " + dragSource);
	//console.log("GroupSources.setDragSource     dragSource.domNode: " + dragSource.domNode);

	// SET TABLE ROW STYLE IN dojDndItems
	var allNodes = dragSource.getAllNodes();
	//console.log("GroupSources.setDragSource     After insertNodes. allNodes.length: " + allNodes.length);
	for ( var k = 0; k < allNodes.length; k++ )
	{
		// ADD CLASS FROM type TO NODE
		var node = allNodes[k];

		//console.log("GroupSources.setDragSource     Setting node " + k + " data: " + dojo.toJson(dataArray[k]));

		// SET NODE name AND description
		node.name = dataArray[k].data.name;
		node.description = dataArray[k].data.description;
		node.location = dataArray[k].data.location;

		var source = {
			name : node.name,
			location : node.location,
			description : node.description
		};

		//console.log("Sources.setDropTarget    dropTarget.creator    source: " + dojo.toJson(source));
		source.parentWidget = this;			

		var groupSourceRow = new plugins.sharing.GroupSourceRow(source);
		//console.log("Sources.setDropTarget    dropTarget.creator    groupSourceRow: " + groupSourceRow);
		node.innerHTML = '';
		node.appendChild(groupSourceRow.domNode);
	}

	var groupObject = this;
	dragSource.creator = function (item, hint)
	{
		console.log("GroupSources.setDragSource dragSource.creator         item: " + dojo.toJson(item));
		//console.log("GroupSources.setDragSource dragSource.creator         item: " + item);
		//console.log("GroupSources.setDragSource dragSource.creator         hint: " + hint);

		var node = dojo.doc.createElement("div");
		node.name = item.name;
		node.description = item.description;
		node.location = item.location;
		node.id = dojo.dnd.getUniqueId();
		node.className = "dojoDndItem";

		//console.log("GroupSources.setDragSource dragSource.creator         node.name: " + node.name);
		//console.log("GroupSources.setDragSource dragSource.creator         node.description: " + node.description);

		// SET FANCY FORMAT IN NODE INNERHTML
		node.innerHTML = "<table> <tr><td><strong style='color: darkred'>" + item.name + "</strong></td></tr><tr><td> " + item.description + "</td></tr></table>";
		//console.log("GroupSources.setDragSource dragSource.creator         node: " + node);

		return {node: node, data: item, type: ["text"]};
	};
},
createDropTarget : function () {
	// GENERATE DROP TARGET
	this.dropTarget = new dojo.dnd.Source(
		this.dropTargetContainer,
		{
			accept : [ "draggableItem" ]
		}
	);

	var thisObject = this;

	this.dropTarget.creator = function (item, hint)
	{
		console.log("GroupSources.createDropTarget this.dropTarget.creator         item: ");
		console.dir({item:item});
		console.log("GroupSources.createDropTarget this.dropTarget.creator         hint: " + hint);

		var data			= item;
		if ( item.data )	data = item.data;
		var name 			= data.name;
		var description	 	= data.description;
		var location 		= data.location;

		// ADD VALUES TO NODE SO THAT THEY GET PASSED TO this.addToGroup
		var node = dojo.doc.createElement("div");
		node.name 			= name;
		node.description 	= description;
		node.location 		= location;
		node.id 			= dojo.dnd.getUniqueId();
		node.className 		= "dojoDndItem";

		var source = {
			name : name,
			description : description,
			location : location
		}; 
		console.log("GroupUsers.createDropTarget    this.dropTarget.creator    source: ");
		console.dir({source:source});

		source.parentWidget = this;			

		var groupSourceRow = new plugins.sharing.GroupSourceRow(source);
		//console.log("GroupUsers.createDropTarget    this.dropTarget.creator    groupUserRow: " + groupUserRow);
		node.innerHTML = '';
		node.appendChild(groupSourceRow.domNode);


		if ( hint != 'avatar' )
		{
			thisObject.addToGroup(node.name, node.description, node.location);
		}

		return {node: node, data: item, type: ["draggableItem"]};
	};
	

	dojo.connect(this.dropTarget, "onDndDrop", function(source, nodes, copy, target){
		console.log("GroupSources.createDropTarget dojo.connect onDndDrop    AFTER this.dropTarget.onDndDrop");

		if ( source == this )
		{
			console.log("GroupSources.createDropTarget dojo.connect(onDndDrop)    Node has been moved to trash.");
			for ( var i = 0; i < nodes.length; i++ )
			{
				var node = nodes[i];
				//console.log("GroupSources.createDropTarget dojo.connect(onDndDrop)    node.name: " + node.name);
				//console.log("GroupSources.createDropTarget dojo.connect(onDndDrop)    node.item: " + node.item);
				//console.log("GroupSources.createDropTarget dojo.connect(onDndDrop)    node.description: " + node.description);
				
				//console.log("GroupSources.createDropTarget dojo.connect(onDndDrop)    Doing thisObject.removeFromGroup(node.name, node.description, node.location)");
				thisObject.removeFromGroup(node.name, node.description, node.location);
			}
		}
		
		// REMOVE DUPLICATE NODES
		var currentNodes = thisObject.dropTarget.getAllNodes();
		if ( currentNodes == null || ! currentNodes )
		{
			console.log("GroupSources.createDropTarget dojo.connect onDndDrop    currentNodes is null or empty. Returning");
			return;
		}
		
		var names = new Object;
		for ( var i = 0; i < currentNodes.length; i++ )
		{
			var node = currentNodes[i];
			//console.log("GroupSources.createDropTarget dojo.connect onDndDrop    Checking if node.name " + i + ": " + node.name + " already in nodes");
			if ( ! names[node.name] )
			{
				names[node.name] = 1;
			}
			else
			{
				// HACK TO AVOID THIS ERROR: node.parentNode is null
				try {
					node.parentNode.removeChild(node)

					// NB: this has no effect on nodes in dnd.Source
					//currentNodes.splice(i, 1); 
					//i--;
				}
				catch (e) {
					//console.log("GroupSources.createDropTarget dojo.connect onDndDrop    INSIDE catch");
				}
			}
		}
	});
},
setDropTarget : function () {
	console.log("GroupSources.setDropTarget     plugins.sharing.GroupSources.setDropTarget()");

	// DELETE EXISTING CONTENTS OF DROP TARGET
	while ( this.dropTargetContainer.firstChild )
	{
		console.log("GroupSources.setDropTarget     REMOVING firstChild");
		this.dropTargetContainer.removeChild(this.dropTargetContainer.firstChild);
	}

	//// GET THE SOURCES IN THIS GROUP
	var groupname = this.groupCombo.getValue();
	var sourceArray = Agua.getSourcesByGroup(groupname);
	if ( sourceArray == null )
	{
		console.log("GroupSources.setDropTarget     sourceArray is null or empty. Returning.");
		return;
	}		
	console.log("GroupSources.setDropTarget     sourceArray: " + dojo.toJson(sourceArray, true));

	if ( sourceArray == null || sourceArray.length == 0 )	return;

	var dataArray = new Array;
	for ( var j = 0; j < sourceArray.length; j++ )
	{
		var data = sourceArray[j];				
		data.toString = function () { return this.name; }
		var description = sourceArray[j].description;

		dataArray.push( { data: data, type: ["draggableItem"], description: description  } );
	}
	console.log("GroupSources.setDropTarget     dataArray: ");
	console.dir({dataArray:dataArray});
	//console.log("GroupSources.setDropTarget     dataArray.length: " + dataArray.length);

	this.dropTarget.insertNodes(false, dataArray );
	//console.log("GroupSources.setDropTarget     dropTarget: " + this.dropTarget);
	//console.log("GroupSources.setDropTarget     this.dropTarget.domNode: " + this.dropTarget.domNode);

	// SET TABLE ROW STYLE IN dojDndItems
	var allNodes = this.dropTarget.getAllNodes();
	console.log("GroupSources.setDropTarget     allNodes.length: " + allNodes.length);
	for ( var k = 0; k < allNodes.length; k++ )
	{
		// ADD CLASS FROM type TO NODE
		var node = allNodes[k];
		var nodeClass = dataArray[k].type;
		dojo.addClass(node, nodeClass);

		//console.log("GroupSources.setDropTarget     dataArray[" + k + "].data: " + dojo.toJson(dataArray[k].data));

		// SET APPLICATION FOR NODE
		node.description = dataArray[k].description;
		node.location = dataArray[k].location;

		var name = dataArray[k].data;
		node.name = name;

		// SET NODE name AND description
		node.name = dataArray[k].data.name;
		node.description = dataArray[k].data.description;
		node.location = dataArray[k].data.location;

		var source = {
			name : node.name,
			location : node.location,
			description : node.description
		};
		//console.log("Sources.setDropTarget    this.dropTarget.creator    source: " + dojo.toJson(source));
		source.parentWidget = this;			

		var groupSourceRow = new plugins.sharing.GroupSourceRow(source);
		node.innerHTML = '';
		node.appendChild(groupSourceRow.domNode);
		//console.log("Sources.setDropTarget    this.dropTarget.creator    groupSourceRow: " + groupSourceRow);
	}

	//var thisObject = this;
	//this.dropTarget.creator = function (item, hint)
	//{
	//	console.log("GroupSources.setDropTarget this.dropTarget.creator         item: " + dojo.toJson(item));
	//	console.log("GroupSources.setDropTarget this.dropTarget.creator         item: " + item);
	//	console.log("GroupSources.setDropTarget this.dropTarget.creator         hint: " + hint);
	//
	//	var name = item.name;
	//	var description = item.description;
	//
	//	// ADD VALUES TO NODE SO THAT THEY GET PASSED TO this.addToGroup
	//	var node = dojo.doc.createElement("div");
	//	node.name = item.name;
	//	node.description = item.description;
	//	node.location = item.location;
	//	node.id = dojo.dnd.getUniqueId();
	//	node.className = "dojoDndItem";
	//
	//	// SET FANCY FORMAT IN NODE INNERHTML
	//	//node.innerHTML = "<table> <tr><td><strong style='color: darkred'>" + name + "</strong></td></tr><tr><td> " + description + "</td></tr></table>";
	//
	//	var source = {
	//		name : node.name,
	//		description : node.description,
	//		location : node.location
	//	};
	//
	//	//console.log("GroupUsers.setDropTarget    this.dropTarget.creator    user: " + dojo.toJson(user));
	//	source.parentWidget = this;			
	//
	//	var groupSourceRow = new plugins.sharing.GroupSourceRow(source);
	//	//console.log("GroupUsers.setDropTarget    this.dropTarget.creator    groupUserRow: " + groupUserRow);
	//	node.innerHTML = '';
	//	node.appendChild(groupSourceRow.domNode);
	//
	//
	//	if ( hint != 'avatar' )
	//	{
	//		thisObject.addToGroup(node.name, node.description, node.location);
	//	}
	//
	//	return {node: node, data: item, type: ["draggableItem"]};
	//};
	

},
addToGroup : function (name, description, location ) {
	console.log("GroupSources.addToGroup    plugins.sharing.GroupSources.addToGroup(name, description, location)");
	console.log("GroupSources.addToGroup    name: " + name);
	//console.log("GroupSources.addToGroup    description: " + description);
	//console.log("GroupSources.addToGroup    location: " + location);
	
	var groupObject = new Object;
	groupObject.username = Agua.cookie('username');
	groupObject.name = name;
	groupObject.description = description;
	groupObject.location = location;
	
	// ADD SOURCE OBJECT TO THE SOURCES IN THIS GROUP
	var groupName = this.groupCombo.getValue();
	console.log("GroupSources.addToGroup     groupName: " + groupName);
	
	if ( Agua.addSourceToGroup(groupName, groupObject) == false )
	{
		console.log("GroupSources.addToGroup     Failed to add source to group: " + groupObject.name + ". Returning.");
		return;
	}

	// ADD THE SOURCE INTO THE groupusers TABLE ON THE SERVER
	var data = new Object;
	data.name = name;
	data.description = description;
	data.location = location;
	data.groupname = groupName;
	data.type = "source";
	
	var url = Agua.cgiUrl + "sharing.cgi";
	var query = new Object;
	query.username = Agua.cookie('username');
	query.sessionid = Agua.cookie('sessionid');
	query.data = data;
	query.mode = "addToGroup";

	var queryString = dojo.toJson(query).replace(/undefined/g, '""');
	//console.log("SourceManager.addToGroup    queryString: " + queryString);

	// SEND TO SERVER
	dojo.xhrPut(
		{
			url: url,
			contentType: "text",
			sync : false,
			handleAs: "json",
			putData: queryString,
			timeout: 15000,
			load: function(data)
			{
				console.log("SourceManager.addToGroup    JSON loaded okay");
				console.log("SourceManager.addToGroup    data: " + dojo.toJson(data));		
			},
			error: function(response, ioArgs) {
				console.log("SourceManager.addToGroup    Error with JSON Post, response: " + response + ", ioArgs: " + ioArgs);
				return response;
			}
		}
	);
},
removeFromGroup : function (name, description, location ) {
	console.log("GroupSources.removeFromGroup    plugins.sharing.GroupSources.removeFromGroup(name, description, location)");
	console.log("GroupSources.removeFromGroup    name: " + name);
	//console.log("GroupSources.removeFromGroup    description: " + description);
	//console.log("GroupSources.removeFromGroup    location: " + location);

	// REMOVE SOURCE FROM THE SOURCES IN THIS GROUP
	var groupName = this.groupCombo.getValue();
	console.log("GroupSources.removeFromGroup     groupName: " + groupName);

	var sourceObject = new Object;
	sourceObject.name = name;
	sourceObject.description = description;
	sourceObject.location = location;
	//console.log("GroupSources.addToGroup     sourceObject: " + dojo.toJson(sourceObject));

	if ( Agua.removeSourceFromGroup(groupName, sourceObject) == false )
	{
		console.log("GroupSources.removeFromGroup     Failed to remove source from group: " + sourceObject.name + ". Returning.");
		return;
	}

	// REMOVE THE SOURCE FROM THE groupusers TABLE ON THE SERVER
	var data = new Object;
	data.name = String(name);
	data.description = description;
	data.location = location;
	data.groupname = groupName;
	data.type = "source";
	
	var url = Agua.cgiUrl + "sharing.cgi";
	var query = new Object;
	query.username = Agua.cookie('username');
	query.sessionid = Agua.cookie('sessionid');
	query.data = data;
	query.mode = "removeFromGroup";

	var queryString = dojo.toJson(query).replace(/undefined/g, '""');
	//console.log("SourceManager.removeFromGroup    queryString: " + queryString);

	// SEND TO SERVER
	dojo.xhrPut(
		{
			url: url,
			contentType: "text",
			sync : false,
			handleAs: "json",
			putData: queryString,
			timeout: 15000,
			load: function(data)
			{
				console.log("SourceManager.removeFromGroup    JSON loaded okay");
				console.log("SourceManager.removeFromGroup    data: " + dojo.toJson(data));		
			},
			error: function(response, ioArgs) {
				console.log("SourceManager.removeFromGroup    Error with JSON Post, response: " + response + ", ioArgs: " + ioArgs);
				return response;
			}
		}
	);
},
setTrash : function () {
	console.log("GroupSources.setTrash     plugins.sharing.GroupSources.setTrash()");

	var trash = new dojo.dnd.Source(
		this.trashContainer,
		{
			accept : [ "draggableItem" ]
		}
	);

	// REMOVE DUPLICATE NODES
	dojo.connect(trash, "onDndDrop", function(source, nodes, copy, target){
		console.log("GroupSources.setTrash    dojo.connect(onDndDrop)    Checking if target == this");
		console.log("GroupSources.setTrash    target:");
		console.dir({target:target});
		console.log("GroupSources.setTrash    this:");
		
		// NODE DROPPED ON SELF --> DELETE THE NODE
		if ( target == this )
		{
			console.log("GroupSources.setTrash    dojo.connect(onDndDrop)    target == this. Removing dropped nodes");
			var currentNodes = trash.getAllNodes();

			for ( var i = 0; i < currentNodes.length; i++ )
			{
				var node = currentNodes[i];
				console.log("GroupSources.setTrash    dojo.connect(onDndDrop)    target == this. Removing dropped nodes");


				// HACK TO AVOID THIS ERROR: node.parentNode is null
				try {
					node.parentNode.removeChild(node)
				}
				catch (e) {
				}
			}
		}
	});
}


}

); // plugins.sharing.GroupSources


}

if(!dojo._hasResource["plugins.sharing.GroupUserRow"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.sharing.GroupUserRow"] = true;
dojo.provide("plugins.sharing.GroupUserRow");


dojo.declare( "plugins.sharing.GroupUserRow",
	[ dijit._Widget, dijit._Templated ],
{
//Path to the template of this widget. 
templateString:"<div dojoAttachPoint=\"containerNode\">\n    <table width=\"100%\" cellspacing=\"0px\">\n        <tr>\n            <td colspan=\"2\"\n                dojoAttachPoint=\"username\"\n                class=\"username\"\n                width=\"100%\"\n                >\n                ${username}</td>\n        </tr>\n        <tr class=\"email\">\n            <td colspan=\"2\"\n                dojoAttachPoint=\"email\"\n                style=\"display: none;\"\n                width=\"100%\"\n                >\n                ${email}</td>\n        </tr>\n        <tr dojoAttachPoint=\"fullname\"\n            style=\"display: none\"\n            class=\"fullname\"\n            >\n            <td dojoAttachPoint=\"firstname\"\n                class=\"firstname\"\n                style=\"display: inline\"\n                width=\"100%\"\n                >${firstname}</td>\n            <td dojoAttachPoint=\"lastname\"\n                class=\"lastname\"\n                style=\"display: inline\"\n                width=\"100%\"\n                >${lastname}</td>\n        </tr>\n        <tr>\n            <td colspan=\"2\"\n                dojoAttachPoint=\"description\"\n                class=\"description\"\n                style=\"display: none;\"\n                width=\"100%\"\n                >${description}</td>\n        </tr>\n    </table>\n</div>\n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

// PARENT plugins.sharing.Sources WIDGET
parentWidget : null,

////}}}

constructor : function(args) {
	////////console.log("GroupUserRow.constructor    plugins.workflow.GroupUserRow.constructor()");
	this.parentWidget = args.parentWidget;
},

postCreate : function() {
	this.startup();
},

startup : function () {
	////////console.log("GroupUserRow.startup    plugins.workflow.GroupUserRow.startup()");
	this.inherited(arguments);
	
	var groupUserRowObject = this;
	dojo.connect( this.username, "onclick", function(event) {
		groupUserRowObject.toggle();
		event.stopPropagation(); //Stop Event Bubbling 			
	});
},

toggle : function () {
	////////console.log("GroupUserRow.toggle    plugins.workflow.GroupUserRow.toggle()");

	if ( this.email.style.display == 'block' ) this.email.style.display='none';
	else this.email.style.display = 'block';
	if ( this.fullname.style.display == 'block' ) this.fullname.style.display='none';
	else this.fullname.style.display = 'block';
	if ( this.description.style.display == 'block' ) this.description.style.display='none';
	else this.description.style.display = 'block';
}
});
	

}

if(!dojo._hasResource["plugins.sharing.GroupUsers"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.sharing.GroupUsers"] = true;
dojo.provide("plugins.sharing.GroupUsers");

 // optimize: load dijit layer

// GENERAL FORM MODULES





// DRAG N DROP


// SLIDER


// PARSE


// INHERITS


// HAS A



dojo.declare("plugins.sharing.GroupUsers",

	[ dijit._Widget, dijit._Templated, plugins.core.Common ],
{
//Path to the template of this widget. 
templateString:"<div dojoattachpoint=\"containerNode\">\n\n\t<!-- groupusers TAB -->\n\t<div\n\t\tdojoAttachPoint=\"groupusersTab\"\n\t\tclass=\"groupusers\"\n\t\tdojoType=\"dijit.layout.ContentPane\"\n\t\ttitle=\"Group Users\"\n\t\tstyle=\"height: 100% !important; max-height: auto !important; width: 370px !important; padding: 0 !important;\"\n\t>\n\n\t\t<table width=\"100%\">\n\t\t\t<tr valign=\"top\" width=\"370\">\n\t\t\t\t<td colspan=\"2\" class=\"tabTitle\" align=\"center\"> Group Users </td>\n\t\t\t</tr>\n\t\t\t<tr valign=\"top\" width=\"95%\">\n\t\t\t\t<td width=\"50%\">\n\t\t\t\t\t<table width=\"100%\">\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td align=\"center\">\n\n\t\t\t\t\t\t\t\t<!-- GROUP COMBO -->\n\t\t\t\t\t\t\t\t<div class=\"comboLabel\"> Groups </div>\n\t\t\t\t\t\t\t\t<div dojoAttachPoint=\"groupCombo\"\n\t\t\t\t\t\t\t\t\t\tdojoType=\"dijit.form.ComboBox\"\n\t\t\t\t\t\t\t\t\t\tclass=\"groupCombo\"\n\t\t\t\t\t\t\t\t\t\tpopupClass=\"groupusers groupCombo dijitReset dijitMenu\"\n\t\t\t\t\t\t\t\t\t\tautocomplete=\"true\"\n\t\t\t\t\t\t\t\t\t\thasDownArrow=\"true\"\n\t\t\t\t\t\t\t\t\t\tdisabled=\"false\"\n\t\t\t\t\t\t\t\t\t\tstyle=\"width: 150px;\"\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td align=\"center\">\n\n\t\t\t\t\t\t\t\t<!-- DROP TARGET CONTAINER -->\n\t\t\t\t\t\t\t\t<div class=\"comboLabel\"> Group Users </div>\n\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"dropTargetContainer\"\n\t\t\t\t\t\t\t\t\tclass=\"dropTarget\"\n\t\t\t\t\t\t\t\t\tstyle=\"height: 622px; width: 170px;\"\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t</table>\n\t\t\t\t</td>\n\t\t\t\t<td width=\"50%\">\n\t\t\t\t\t<table width=\"100%\">\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td align=\"center\">\n\t\t\t\t\t\t\t\t<div class=\"comboLabel\"> Users </div>\n\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"dragSourceSlider\"\n\t\t\t\t\t\t\t\t\tdojoType=\"dijit.form.HorizontalSlider\" \n\t\t\t\t\t\t\t\t\tvalue=\"0\"\n\t\t\t\t\t\t\t\t\tmaximum=\"100\"\n\t\t\t\t\t\t\t\t\tminimum=\"0\"\n\t\t\t\t\t\t\t\t\tpageIncrement=\"100\"\n\t\t\t\t\t\t\t\t\tshowButtons=\"true\"\n\t\t\t\t\t\t\t\t\tintermediateChanges=\"true\"\n\t\t\t\t\t\t\t\t\tslideDuration=\"200\"\n\t\t\t\t\t\t\t\t\tstyle=\"width: 150px;\"\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td align=\"center\">\n\n\t\t\t\t\t\t\t\t<!-- DRAG SOURCE CONTAINER -->\n\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"dragSourceContainer\"\n\t\t\t\t\t\t\t\t\tclass=\"dragSource\"\n\t\t\t\t\t\t\t\t\tstyle=\"height: 560px; width: 150px;\"\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t<tr align=\"center\">\n\t\t\t\t\t\t\t<td align=\"center\">\n\n\t\t\t\t\t\t\t\t<!-- TRASH CONTAINER -->\n\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"trashContainer\"\n\t\t\t\t\t\t\t\t\tclass=\"trash\"\n\t\t\t\t\t\t\t\t\tstyle=\"height: 60px; width: 150px; align: center;\" \n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"trashIcon\"\n\t\t\t\t\t\t\t\t\t\tclass=\"trashIcon\"\n\t\t\t\t\t\t\t\t\t\tstyle=\"height: 60px; width: 60px;\"\n\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t</table>\n\t\t\t\t</td>\n\t\t\t</tr>\n\t\t</table>\n\n\t</div>\n\t<!-- END groupusers TAB -->\n\t\n</div> \n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,
	
//addingSource STATE
addingSource : false,

// OR USE @import IN HTML TEMPLATE
cssFiles : [ "plugins/sharing/css/groupusers.css" ],

// PARENT WIDGET
parentWidget : null,

// MAX. NO. OF USERS TO DISPLAY AT ANY ONE TIME IN DRAG SOURCE
maxDisplayedUsers : 24,

/////}}}

constructor : function(args) {
	// LOAD CSS
	this.loadCSS();		
},

postCreate : function() {
	this.startup();
},
startup : function () {
	//console.log("GroupUsers.startup    plugins.sharing.GroupUsers.start()");

	// COMPLETE CONSTRUCTION OF OBJECT
	this.inherited(arguments);	 

	// ADD ADMIN TAB TO TAB CONTAINER
	this.tabContainer.addChild(this.groupusersTab);
	this.tabContainer.selectChild(this.groupusersTab);

	// SET GROUP COMBO
	this.setGroupCombo();

	// SET DRAG SOURCE - LIST OF SOURCES
	this.setDragSource();

	// SET DRAG SOURCE SLIDER
	this.setDragSourceSlider();
	
	// SET DROP TARGET - SOURCES ALREADY IN THE GROUP
	this.setDropTarget();
	
	// SET TRASH DROP TARGET
	this.setTrash();
	
	// SUBSCRIBE TO UPDATES
	Agua.updater.subscribe(this, "updateGroups");

	// SUBSCRIBE TO UPDATES
	Agua.updater.subscribe(this, "updateUsers");
},

updateGroups : function (args) {
	//console.log("sharing.GroupUsers.updateGroups    sharing.GroupUsers.updateGroups(args)");
	//console.log("sharing.GroupUsers.updateGroups    args:");
	//console.dir(args);
	this.reload();
},

updateUsers : function (args) {
	//console.log("sharing.GroupUsers.updateUsers    sharing.GroupUsers.updateUsers(args)");
	//console.log("sharing.GroupUsers.updateUsers    args:");
	//console.dir(args);
	this.reload();
},

reload : function () {
// RELOAD THE GROUP COMBO AND DRAG SOURCE
// (CALLED AFTER CHANGES TO SOURCES OR GROUPS DATA IN OTHER TABS)

	//console.log("sharing.GroupUsers.reload    sharing.GroupUsers.reload()");

	// SET GROUP COMBO
	this.setGroupCombo();

	// SET DRAG SOURCE - LIST OF USERS
	this.setDragSource();

	// SET DROP TARGET - USERS ALREADY IN THE GROUP
	this.setDropTarget();
},

setGroupCombo : function () {
	//console.log("GroupUsers.setGroupCombo     plugins.sharing.GroupUsers.setGroupCombo()");
	// GET GROUP NAMES		
	var groupNames = Agua.getGroupNames();
	//console.log("GroupUsers.setGroupCombo     groupNames: " + dojo.toJson(groupNames));

	// SET STORE
	var data = {identifier: "name", items: []};
	for ( var i = 0; i < groupNames.length; i++ )
	{
		//console.log("GroupUsers.setGroupCombo     Adding to data: " + groupNames[i]);
		data.items[i] = { name: groupNames[i]	};
	}
	//console.log("GroupUsers.setGroupCombo     data: " + dojo.toJson(data));
	var store = new dojo.data.ItemFileWriteStore(	{	data: data	}	);
	//console.log("GroupUsers.setGroupCombo     store: " + store);

	//this.groupCombo.popupClass = "groupusers groupCombo dijitReset dijitMenu";
	//this.groupCombo.wrapperClass = "groupusers dijitPopup";
	//this.groupCombo.itemHeight = 30;
	
	// SET COMBO
	this.groupCombo.store = store;
	this.groupCombo.startup();
	//console.log("GroupUsers.setGroupCombo::setCombo     AFTER this.groupCombo.startup()");

	// SET COMBO VALUE
	var firstValue = groupNames[0];
	this.groupCombo.setValue(firstValue);
	//console.log("GroupUsers.setGroupCombo::setCombo     AFTER this.groupCombo.setValue(firstValue)");

	// CONNECT ONCLICK WITH dojo.connect TO BUILD TABLE
	var thisObject = this;
	dojo.connect(this.groupCombo, "onChange", function(event) {
		thisObject.setDropTarget();
	});
},

setDragSource : function (position) {
	//console.log("GroupUsers.setDragSource     plugins.sharing.GroupUsers.setDragSource(position)");
	//console.log("GroupUsers.setDragSource     position: " + position);

	// REMOVE ALL EXISTING CONTENT
	while ( this.dragSourceContainer.firstChild )
	{
		if ( dijit.byNode(this.dragSourceContainer)
			&& dijit.byNode(this.dragSourceContainer).destroy )
		{
			dijit.byNode(this.dragSourceContainer).destroy();
		}
		this.dragSourceContainer.removeChild(this.dragSourceContainer.firstChild);
	}

	// SET position IF NOT DEFINED
	if ( position == null )	position = 0;

	var dataArray = new Array;
	var userArray = Agua.getUsers();
	//console.log("GroupUsers.setDragSource     userArray: " + dojo.toJson(userArray));
	//console.log("GroupUsers.setDragSource     userArray.length: " + userArray.length);

	// RETURN IF USER ARRAY IS NULL OR EMPTY
	if ( userArray == null || userArray.length == 0 )
	{
		//console.log("GroupUsers.setDragSource     userArray is null or empty. Returning.");
		return;
	}

	var MAXUSERS = this.maxDisplayedUsers;
	var MULTIPLE = ( userArray.length - MAXUSERS ) / 100;
	MULTIPLE = MULTIPLE ? MULTIPLE : 1;
	var start = parseInt(position * MULTIPLE);
	var end = parseInt( (position * MULTIPLE) + MAXUSERS );
	if ( ! end || end > userArray.length )	end = userArray.length;
	if ( ! start || start < 0 )	start = 0;
	//console.log("GroupUsers.setDragSource     start: " + start);
	//console.log("GroupUsers.setDragSource     end: " + end);

	// GENERATE USER DATA TO INSERT INTO DND USER TABLE
	for ( var j = start; j < end; j++ )
	{
		var data = userArray[j];				
		dataArray.push( { data: data, type: ["draggableUser"] } );
	}
	//console.log("GroupUsers.setDragSource     dataArray: " + dojo.toJson(dataArray));

	// GENERATE DND SOURCE
	var dragSource = new dojo.dnd.Source(
		this.dragSourceContainer,
		{
			copyOnly: true,
			selfAccept: false,
			accept : [ "none" ]
		}
	);
	dragSource.insertNodes(false, dataArray);
	//console.log("GroupUsers.setDragSource     dragSource: " + dragSource);

	// users TABLE QUERY:
	// SELECT DISTINCT username, firstname, lastname, email, description FROM users ORDER BY username};

	// SET TABLE ROW STYLE IN dojDndItems
	var allNodes = dragSource.getAllNodes();
	for ( var k = 0; k < allNodes.length; k++ )
	{
		//console.dir({datarrayK:dataArray[k]});
		
		// ADD CLASS FROM type TO NODE
		var node = allNodes[k];

		// SET NODE name AND description
		node.username = dataArray[k].data["username"] ? dataArray[k].data["username"]: '';
		node.firstname = dataArray[k].data["firstname"] ? dataArray[k].data["firstname"]: '';
		node.lastname = dataArray[k].data["lastname"] ? dataArray[k].data["lastname"]: '';
		node.email = dataArray[k].data["email"] ? dataArray[k].data["email"]: '';
		node.description = dataArray[k].data["description"] ? dataArray[k].data["description"]: '';
		node.firstname = this.firstLetterUpperCase(node.firstname);
		node.lastname = this.firstLetterUpperCase(node.lastname);

		// CHECK ATTRIBUTES ARE NOT NULL
		if ( node.description == null )
			node.description = '';

		if ( node.username != null && node.username != '' )
		{
			var user = {
				username 	: node.username,
				email 		: node.email,
				firstname 	: node.firstname,
				lastname 	: node.lastname,
				description : node.description
			};
			//console.log("GroupUsers.setDragSource     user: " + dojo.toJson(user));
			user.parentWidget = this;			

			var groupUserRow = new plugins.sharing.GroupUserRow(user);
			node.innerHTML = '';
			node.appendChild(groupUserRow.domNode);
		}
	}

	var groupObject = this;
	dragSource.creator = function (item, hint)
	{
		//console.log("GroupUsers.setDragSource dragSource.creator         item: " + dojo.toJson(item));
		var node = dojo.doc.createElement("div");
		node.username = item["username"];
		node.firstname = item["firstname"];
		node.lastname = item["lastname"];
		node.email = item["email"];
		node.description = item["description"];
		node.id = dojo.dnd.getUniqueId();
		node.className = "dojoDndItem";

		// SET FANCY FORMAT IN NODE INNERHTML
		node.innerHTML = "<table> <tr><td><strong style='color: darkred'>" + item["username"] + "</strong></td></tr><tr><td> " + item["email"] + "</td></tr></table>";
		//console.log("GroupUsers.setDragSource dragSource.creator         node: " + node);

		return {node: node, data: item, type: ["text"]};
	};
},

setDragSourceSlider : function () {
	//console.log("GroupUsers.setDragSourceSlider     plugins.sharing.GroupUsers.setDragSourceSlider()");
	//console.log("GroupUsers.dragSourceSourceSlider     this.dragSourceSlider: " + this.dragSourceSlider);

	// ONMOUSEUP
	dojo.connect(this.dragSourceSlider, "onMouseUp", dojo.hitch(this, function(e)
	{
		var position = parseInt(this.dragSourceSlider.getValue());
		this.setDragSource(position);
	}));
},


setDropTarget : function () {
	//console.log("GroupUsers.setDropTarget     plugins.sharing.GroupUsers.setDropTarget()");

	// DELETE EXISTING CONTENTS OF DROP TARGET
	while ( this.dropTargetContainer.firstChild )
	{
		this.dropTargetContainer.removeChild(this.dropTargetContainer.firstChild);
	}
	//console.log("GroupUsers.setDropTarget     AFTER removeChild");

	//// GET THE SOURCES IN THIS GROUP
	var groupname = this.groupCombo.get('value');
	var sourceArray = Agua.getGroupUsers();
	//console.log("GroupUsers.setDropTarget     sourceArray: " + dojo.toJson(sourceArray));
	//console.log("GroupUsers.setDropTarget     groupname: " + groupname);
	sourceArray = this.filterByKeyValues(sourceArray, ["groupname"], [groupname]);
	sourceArray = this.filterByKeyValues(sourceArray, ["groupname"], [groupname]);
	//console.log("GroupUsers.setDropTarget     sourceArray: " + dojo.toJson(sourceArray));
	//sourceArray = this.sortHasharray(sourceArray, "name");
	
	if ( sourceArray == null )
	{
		//console.log("GroupUsers.setDropTarget     sourceArray is null or empty. Returning.");
		return;
	}		

	var dataArray = new Array;
	for ( var j = 0; j < sourceArray.length; j++ )
	{
		var data = sourceArray[j];				
		var description = sourceArray[j].description;
		dataArray.push( { data: data, type: ["draggableUser"], description: description  } );
	}
	//console.log("GroupUsers.setDropTarget     dataArray: " + dojo.toJson(dataArray));
	//console.log("GroupUsers.setDropTarget     dataArray.length: " + dataArray.length);

	// GENERATE DROP TARGET
	var dropTarget = new dojo.dnd.Source(
		this.dropTargetContainer,
		{
			accept : ["draggableUser"]
		}
	);
	dropTarget.insertNodes(false, dataArray );

	// SET TABLE ROW STYLE IN dojDndItems
	var allNodes = dropTarget.getAllNodes();
	for ( var k = 0; k < allNodes.length; k++ )
	{
		//console.log("GroupUsers.setDropTarget     GroupUsers.setDropTarget    dataArray[" + k + "]: " + dojo.toJson(dataArray[k]));

		// ADD CLASS FROM type TO NODE
		var node = allNodes[k];
		var nodeClass = dataArray[k].type;
		dojo.addClass(node, nodeClass);

		// SET NODE ATTRIBUTES
		node.username = dataArray[k].data.name;
		node.description = dataArray[k].data.description;

		// SWAP OUT location FOR email
		node.email = dataArray[k].data.location;

		var user = {
			username 	: node.username,
			email 		: node.email,
			firstname 	: '',
			lastname 	: '',
			description : node.description
		};
		//console.log("GroupUsers.setDropTarget     user: " + dojo.toJson(user));
		user.parentWidget = this;			

		var groupUserRow = new plugins.sharing.GroupUserRow(user);
		node.innerHTML = '';
		node.appendChild(groupUserRow.domNode);
	}
	
	var thisObject = this;
	dropTarget.creator = function (item, hint)
	{
		//console.log("GroupUsers.setDropTarget dropTarget.creator(item, hint)");
		//console.log("GroupUsers.setDropTarget dropTarget.creator         item: " + dojo.toJson(item));
		//console.log("GroupUsers.setDropTarget dropTarget.creator         hint: " + hint);

		// ADD VALUES TO NODE SO THAT THEY GET PASSED TO
		// this.addToGroup
		// NB: CONVERT name TO username
		var node = dojo.doc.createElement("div");
		node.name 			= item.username || item.name; 
		node.username 		= item.username || item.name;
		node.description 	= item.description || '';
		node.email 			= item.email || item.location;
		node.id 			= dojo.dnd.getUniqueId();
		node.className = "dojoDndItem";

		var user = {
			username 	: item.username || item.name,
			email 		: item.email || item.location,
			firstname 	: '',
			lastname 	: '',
			description : ''
		};
		//console.log("GroupUsers.setDropTarget    dropTarget.creator    user: " + dojo.toJson(user));
		user.parentWidget = this;			
		var groupUserRow = new plugins.sharing.GroupUserRow(user);

		//console.log("GroupUsers.setDropTarget    dropTarget.creator    groupUserRow: " + groupUserRow);
		node.innerHTML = '';
		node.appendChild(groupUserRow.domNode);

		// ACCEPTABLE NODE DROPPED ONTO SELF --> ADD TO USER GROUP.
		if ( hint != 'avatar' )
		{
			thisObject.addToGroup(node.username, node.description, node.email);
		}

		return {node: node, data: item, type: ["draggableUser"]};
	};
	
	// ADD NODE IF DROPPED FROM OTHER SOURCE, DELETE IF DROPPED FROM SELF
	dojo.connect(dropTarget, "onDndDrop", function(source, nodes, copy, target){
		//console.log("GroupUsers.setDropTarget dojo.connect onDndDrop    Checking if source == this && target != this");
		
		// NODE DROPPED FROM SELF --> DELETE NODE
		if ( source == this && target != this )
		{
			//console.log("GroupUsers.setDropTarget dojo.connect(onDndDrop)    source == this && target != this. Node has been moved to trash. Remove the user from the group object.");
			for ( var i = 0; i < nodes.length; i++ )
			{
				var node = nodes[i];
				thisObject.removeFromGroup(node.username, node.description, node.email);
			}
		}
		else {
			// DO NOTHING IF NODE WAS DROPPED FROM DRAG SOURCE
			// ( IT HAS ALREADY BEEN GENERATED BY dropTarget.creator() )
		}
		
		// REMOVE DUPLICATE NODES
		var currentNodes = dropTarget.getAllNodes();
		//console.log("GroupUsers.setDropTarget dojo.connect onDndDrop    currentNodes: " + currentNodes);
		if ( currentNodes == null || ! currentNodes )
		{
			//console.log("GroupUsers.setDropTarget dojo.connect onDndDrop    currentNodes is null or empty. Returning");
			return;
		}

		// DELETE DUPLICATE NODES
		var names = new Object;
		//console.log("GroupUsers.setDropTarget dojo.connect onDndDrop    Checking for duplicate nodes");
		for ( var i = 0; i < currentNodes.length; i++ )
		{
			var node = currentNodes[i];
			if ( ! names[node.username] )
			{
				names[node.username] = 1;
			}
			else
			{
				//console.log("GroupUsers.setDropTarget dojo.connect onDndDrop    Node " + node.username + " already in nodes. Removing.");
				
				// HACK TO AVOID THIS ERROR: node.parentNode is null
				try {
					//console.log("GroupUsers.setDropTarget dojo.connect onDndDrop    Removing duplicate node: " + node.username );
					node.parentNode.removeChild(node)
				}
				catch (e) {
					//console.log("GroupUsers.setDropTarget dojo.connect onDndDrop    INSIDE catch");
				}
			}

		}
	});
},

addToGroup : function (name, description, email ) {
	//console.log("GroupUsers.addToGroup    plugins.sharing.GroupUsers.addToGroup(name, description, email)");
	//console.log("GroupUsers.addToGroup    name: " + name);
	//console.log("GroupUsers.addToGroup    description: " + description);
	//console.log("GroupUsers.addToGroup    email: " + email);
	
	var groupObject = new Object;
	groupObject.username = Agua.cookie('username');
	groupObject.name = name;
	groupObject.description = description;
	groupObject.location = email;
	
	// ADD SOURCE OBJECT TO THE SOURCES IN THIS GROUP
	var groupName = this.groupCombo.get('value');
	//console.log("GroupUsers.addToGroup     groupName: " + groupName);

	if ( Agua.addUserToGroup(groupName, groupObject) == false )
	{
		//console.log("GroupUsers.addToGroup     Failed to add source to group: " + groupObject.name + ". Returning.");
		return;
	}

	// ADD THE SOURCE INTO THE groupusers TABLE ON THE SERVER
	var data = new Object;
	data.name 			= name;
	data.description 	= description	|| '';;
	data.location 		= email			|| '';
	data.groupname 		= groupName		|| '';
	data.type 			= "user";
	
	var url = Agua.cgiUrl + "sharing.cgi";
	var query = new Object;
	query.username = Agua.cookie('username');
	query.sessionid = Agua.cookie('sessionid');
	query.data = data;
	query.mode = "addToGroup";

	//var queryString = dojo.toJson(query).replace(/undefined/g, '""');
	//console.log("GroupUsers.addToGroup    queryString: " + queryString);

	this.doPut({ url: url, query: query, sync: false, timeout: 15000 });
},

removeFromGroup : function (name, description, email ) {
	//console.log("GroupUsers.removeFromGroup    plugins.sharing.GroupUsers.removeFromGroup(name, description, email)");
	//console.log("GroupUsers.removeFromGroup    name: " + name);
	//console.log("GroupUsers.removeFromGroup    description: " + description);
	//console.log("GroupUsers.removeFromGroup    email: " + email);

	// REMOVE SOURCE FROM THE SOURCES IN THIS GROUP
	var groupName = this.groupCombo.get('value');
	//console.log("GroupUsers.removeFromGroup     groupName: " + groupName);

	var groupObject = new Object;
	groupObject.name = name;
	groupObject.description = description;
	groupObject.email = email;
	//console.log("GroupUsers.addToGroup     groupObject: " + dojo.toJson(groupObject));

	if ( Agua.removeUserFromGroup(groupName, groupObject) == false )
	{
		//console.log("GroupUsers.removeFromGroup     Failed to remove source from group: " + groupObject.name + ". Returning.");
		return;
	}

	// REMOVE THE SOURCE FROM THE groupusers TABLE ON THE SERVER
	var data = new Object;
	data.name 			= String(name)	|| '';
	data.description 	= description	|| '';
	data.email 			= email			|| '';
	data.groupname 		= groupName		|| '';
	data.type 			= "user";
	
	var url = Agua.cgiUrl + "sharing.cgi";
	var query = new Object;
	query.username = Agua.cookie('username');
	query.sessionid = Agua.cookie('sessionid');
	query.data = data;
	query.mode = "removeFromGroup";

	this.doPut({ url: url, query: query, sync: false, timeout: 15000 });
},


setTrash : function () {
//	DELETE NODE IF DROPPED INTO TRASH. 
//	REMOVAL OF DATA IS ACCOMPLISHED IN THE
// onDndDrop LISTENER OF THE SOURCE
//console.log("GroupUsers.setTrash     plugins.sharing.GroupUsers.setTrash()");

	var trash = new dojo.dnd.Source(
		this.trashContainer,
		{
			accept : [ "draggableUser" ]
		}
	);

	// REMOVE DUPLICATE NODES
	dojo.connect(trash, "onDndDrop", function(source, nodes, copy, target){
		// NODE DROPPED ON SELF --> DELETE THE NODE
		if ( target == this )
		{
			var currentNodes = trash.getAllNodes();
			for ( var i = 0; i < currentNodes.length; i++ )
			{
				var node = currentNodes[i];
				// HACK TO AVOID THIS ERROR: node.parentNode is null
				try {
					node.parentNode.removeChild(node)
				}
				catch (e) {
				}
			}
		}
	});
}


}); // plugins.sharing.GroupUsers

}

if(!dojo._hasResource["plugins.sharing.Groups"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.sharing.Groups"] = true;
dojo.provide("plugins.sharing.Groups");

// ALLOW THE USER TO ADD, REMOVE AND MODIFY GROUPS

// EXTERNAL MODULES






// INTERNAL MODULES



// HAS A


dojo.declare("plugins.sharing.Groups",
	[ dijit._Widget, dijit._Templated, plugins.core.Common, plugins.form.EditForm ],
{
//Path to the template of this widget. 
templateString:"<div dojoattachpoint=\"containerNode\">\n\n\t<!-- SOURCES TAB -->\n\t<div\n\t\tdojoAttachPoint=\"groupsTab\"\n\t\tclass=\"groups\"\n\t\tdojoType=\"dijit.layout.ContentPane\"\n\t\ttitle=\"Groups\"\n\t\tstyle=\"height: 100% !important; max-height: auto !important; width: 390px !important; padding: 0 !important;\"\n\t\t>\n\n<table width=\"100%\">\n\t<tr valign=\"top\" width=\"100%\">\n\t\t<td colspan=\"2\" class=\"tabTitle\" align=\"center\"> Groups </td>\n\t</tr>\n\n\t<tr valign=\"top\" width=\"95%\">\n\t\t<td>\n\t\t\t<div class=\"label\"> New Group </div>\n\t\t\t<table>\n\t\t\t\t<tr>\n\t\t\t\t\t<td>\n\t\t\t\t\t\t<textarea\n\t\t\t\t\t\t\tspellcheck=\"false\"\n\t\t\t\t\t\t\tdojoAttachPoint=\"groupname\"\n\t\t\t\t\t\t\tclass=\"groupname\"\n\t\t\t\t\t\t\tstyle=\"width:100%; font-weight: bolder; font-family: Verdana;\";\n\t\t\t\t\t\t\tcols=\"30\"\n\t\t\t\t\t\t\trows=\"1\"\n\t\t\t\t\t\t\t>Groupname</textarea>\n\t\t\t\t\t</td>\n\t\t\t\t\t<td>\n\t\t\t\t\t\t<div\n\t\t\t\t\t\t\tdojoAttachPoint=\"addGroupButton\"\n\t\t\t\t\t\t\tclass=\"addGroupButton\"\n\t\t\t\t\t\t\tdojoType=\"dijit.form.Button\"\n\t\t\t\t\t\t\tlabel=\"Save\"\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</td>\n\t\t\t\t</tr>\n\t\t\t\t<tr>\n\t\t\t\t\t<td colspan=\"2\">\n\t\t\t\t\t\t<textarea\n\t\t\t\t\t\t\tspellcheck=\"false\"\n\t\t\t\t\t\t\tdojoAttachPoint=\"description\"\n\t\t\t\t\t\t\tclass=\"description\"\n\t\t\t\t\t\t\tstyle=\"width:100%; font-weight: bolder; font-family: Verdana;\";\n\t\t\t\t\t\t\tcols=\"40\"\n\t\t\t\t\t\t\trows=\"1\"\n\t\t\t\t\t\t\t>Description</textarea>\n\t\t\t\t\t</td>\n\t\t\t\t</tr>\n\t\t\t\t<tr>\n\t\t\t\t\t<td colspan=\"2\">\n\t\t\t\t\t\t<textarea\n\t\t\t\t\t\t\tspellcheck=\"false\"\n\t\t\t\t\t\t\tdojoAttachPoint=\"notes\"\n\t\t\t\t\t\t\tclass=\"notes\"\n\t\t\t\t\t\t\tvalue=\"Notes\"\n\t\t\t\t\t\t\tstyle=\"width:100%; font-weight: bolder; font-family: Verdana;\";\n\t\t\t\t\t\t\tcols=\"40\"\n\t\t\t\t\t\t\trows=\"1\"\n\t\t\t\t\t\t\t>Notes</textarea>\n\t\t\t\t\t</td>\n\t\t\t\t</tr>\n\t\t\t</table>\n\t\t</td>\n\t</tr>\n\t\n\t<tr valign=\"top\" width=\"95%\">\n\t\t<td width=\"95%\">\n\t\t\t<div class=\"label\">Groups</div>\n\t\t\t<div\n\t\t\t\tdojoAttachPoint=\"dragSourceNode\"\n\t\t\t\tclass=\"dragSource\"\n\t\t\t\tstyle=\"height: 467px; width: 95%;\"\n\t\t\t>\n\t\t\t</div>\n\t\t</td>\n\t</tr>\n\n\t<tr align=\"center\">\n\t\t<td align=\"center\">\n\n\t\t\t<!-- TRASH CONTAINER -->\n\t\t\t<div\n\t\t\t\tdojoAttachPoint=\"trashContainer\"\n\t\t\t\tclass=\"trash\"\n\t\t\t\tstyle=\"height: 60px; width: 150px; align: center;\" \n\t\t\t\t>\n\t\t\t\t<div\n\t\t\t\t\tdojoAttachPoint=\"trashIcon\"\n\t\t\t\t\tclass=\"trashIcon\"\n\t\t\t\t\tstyle=\"height: 60px; width: 60px;\"\n\t\t\t\t\t>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</td>\n\t</tr>\n</table>\n\n\n\n\t</div>\n\t<!-- END SOURCES TAB -->\n\t\n</div> \n\n\n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

//addingGroup STATE
addingGroup : false,

// OR USE @import IN HTML TEMPLATE
cssFiles : [ "plugins/sharing/css/groups.css" ],

// PARENT WIDGET
parentWidget : null,

formInputs : {
// FORM INPUTS AND TYPES (word|phrase)
	groupname	:	"word",
	description	:	"phrase",
	notes		:	"phrase"
},

defaultInputs : {
// DEFAULT INPUTS
	groupname	:	"Groupname",
	description	:	"Description",
	notes		:	"Notes"
},

requiredInputs : {
// REQUIRED INPUTS CANNOT BE ''
// combo INPUTS ARE AUTOMATICALLY NOT ''
	groupname 	: 1
},

invalidInputs : {
// THESE INPUTS ARE INVALID
	groupname	:	"Groupname",
	description	:	"Description",
	notes		:	"Notes"
},

dataFields : [
	"groupname"
],

avatarItems : [
	"groupname",
	"description"
],

rowClass : "plugins.sharing.GroupRow",

/////}}}}

constructor : function(args) {
	////console.log("Groups.constructor     plugins.sharing.Groups.constructor");			
	// GET INFO FROM ARGS
	this.parentWidget = args.parentWidget;
	this.groups = args.parentWidget.groups;
-
	// LOAD CSS
	this.loadCSS();		
},

postCreate : function() {
	////console.log("Controller.postCreate    plugins.sharing.Controller.postCreate()");

	this.startup();
},


startup : function () {
	////console.log("Groups.startup    plugins.sharing.Groups.startup()");

	// COMPLETE CONSTRUCTION OF OBJECT
	this.inherited(arguments);	 

	// ADD TO TAB CONTAINER		
	this.tabContainer.addChild(this.groupsTab);
	this.tabContainer.selectChild(this.groupsTab);

	// SET DRAG GROUP - LIST OF GROUPS
	this.setDragSource();

	// SET NEW GROUP FORM
	this.setForm();

	// SUBSCRIBE TO UPDATES
	Agua.updater.subscribe(this, "updateGroups");

	// SET TRASH
	this.setTrash(this.dataFields);	
},

updateGroups : function (args) {
// RELOAD THE COMBO AND DRAG SOURCE AFTER CHANGES
// TO DATA IN OTHER TABS
	//console.log("Groups.updateGroups(args)");
	//console.log("Groups.updateGroups    args: " );
	//console.dir(args);
	
	// SET DRAG SOURCE
	if ( args == null || args.reload != false )
	{
		//console.log("Groups.updateGroups    Calling setDragSource()");
		this.setDragSource();
	}
},

setForm : function () {
// SET 'ADD NEW GROUP' FORM
	////console.log("Groups.setForm    plugins.sharing.Groups.setForm()");

	// SET ADD GROUP ONCLICK
	dojo.connect(this.addGroupButton, "onClick", dojo.hitch(this, "saveInputs", null, null));

	// SET ONCLICK TO CANCEL INVALID TEXT
	this.setClearValues();

	// CHAIN TOGETHER INPUTS ON 'RETURN' KEYPRESS
	this.chainInputs(["groupname", "description", "notes", "addGroupButton"]);
},

getItemArray : function () {
	var itemArray = Agua.getGroups();
	//console.log("Groups.getItemArray    itemArray: " + dojo.toJson(itemArray));
	return this.sortHasharray(itemArray, 'groupname');
},

deleteItem : function (groupObject) {
	////console.log("Groups.deleteItem    plugins.sharing.Groups.deleteItem(groupname)");
	////console.log("Groups.deleteItem    groupname: " + groupname);

	// REMOVE GROUP FROM Agua.groups
	Agua.removeGroup(groupObject)

	// RELOAD RELEVANT DISPLAYS
	Agua.updater.update("updateGroups");

}, // Groups.deleteItem


addItem : function (groupObject, formAdd) {
	//console.log("Groups.addItem    plugins.sharing.Groups.addItem(groupObject)");
	//console.log("Groups.addItem    groupObject:");
	//console.dir(groupObject);

	if ( this.savingGroup == true )	return;
	this.savingGroup = true;
	
	Agua.addGroup(groupObject);

	this.savingGroup = false;

	// RELOAD RELEVANT DISPLAYS
	Agua.updater.update("updateGroups");

} // Groups.addItem


}); // plugins.sharing.Groups


}

if(!dojo._hasResource["plugins.sharing.ProjectRow"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.sharing.ProjectRow"] = true;
dojo.provide("plugins.sharing.ProjectRow");


dojo.declare( "plugins.sharing.ProjectRow",
	[ dijit._Widget, dijit._Templated ],
{
//Path to the template of this widget. 
templateString:"<div dojoAttachPoint=\"containerNode\">\n    <table width=\"100%\">\n        <tr>\n            <td\n                dojoAttachPoint=\"name\"\n                class=\"name\"\n                >${name}</td>\n        </tr>\n        <tr>\n            <td\n                dojoAttachPoint=\"description\"\n                class='description'\n                style=\"display: none;\" >${description}</td>\n        </tr>\n        <tr>\n            <td\n                dojoAttachPoint=\"notes\"\n                class='notes'\n                style=\"display: none;\">${notes}</td>\n        </tr>\n    </table>\n</div>\n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

// PARENT plugins.sharing.Projects WIDGET
parentWidget : null,

////}}}

constructor : function(args) {
	//////console.log("ProjectRow.constructor    plugins.workflow.ProjectRow.constructor()");
	this.parentWidget = args.parentWidget;	
},


postCreate : function() {
	////////console.log("ProjectRow.postCreate    plugins.workflow.ProjectRow.postCreate()");
	this.formInputs = this.parentWidget.formInputs;
	this.startup();
},

startup : function () {
	//////console.log("ProjectRow.startup    plugins.workflow.ProjectRow.startup()");
	//////console.log("ProjectRow.startup    this.parentWidget: " + this.parentWidget);
	this.inherited(arguments);
	
	var thisObject = this;
	dojo.connect( this.name, "onclick", function(event) {
		thisObject.toggle();
		event.stopPropagation(); //Stop Event Bubbling 			
	});

	// DESCRIPTION
	dojo.connect(this.description, "onclick", function(event)
		{
			//////console.log("ProjectRow.startup    projectRow.description clicked");
			thisObject.parentWidget.editRow(thisObject, event.target);
		}
	);

	// NOTES
	dojo.connect(this.notes, "onclick", function(event)
		{
			//////console.log("ProjectRow.startup    projectRow.notes clicked");
			thisObject.parentWidget.editRow(thisObject, event.target);
		}
	);
},

toggle : function () {
	//////console.log("ProjectRow.toggle    plugins.workflow.ProjectRow.toggle()");
	if ( this.description.style.display == 'block' ) this.description.style.display='none';
	else this.description.style.display = 'block';
	if ( this.notes.style.display == 'block' ) this.notes.style.display='none';
	else this.notes.style.display = 'block';
}

});
	

}

if(!dojo._hasResource["plugins.sharing.Projects"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.sharing.Projects"] = true;
dojo.provide("plugins.sharing.Projects");

// ALLOW THE USER TO ADD, REMOVE AND MODIFY PROJECTS

// EXTERNAL MODULES






// INTERNAL MODULES



// HAS A


dojo.declare("plugins.sharing.Projects",
	[ dijit._Widget, dijit._Templated, plugins.core.Common, plugins.form.EditForm ],
{

//Path to the template of this widget. 
templateString:"<div dojoattachpoint=\"containerNode\">\n\n\t<!-- SOURCES TAB -->\n\t<div\n\t\tdojoAttachPoint=\"projectsTab\"\n\t\tclass=\"projects\"\n\t\tdojoType=\"dijit.layout.ContentPane\"\n\t\ttitle=\"Projects\"\n\t\tstyle=\"height: 100% !important; max-height: auto !important; width: 390px !important; padding: 0 !important;\"\n\t\t>\n\n\t\t<table width=\"100%\">\n\t\t\t<tr valign=\"top\" width=\"100%\">\n\t\t\t\t<td colspan=\"2\" class=\"tabTitle\" align=\"center\"> Projects </td>\n\t\t\t</tr>\n\n\t\t\t<tr valign=\"top\" width=\"95%\">\n\t\t\t\t<td>\n\t\t\t\t\t<div class=\"label\"> New Project </div>\n\t\t\t\t\t<table>\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t<textarea\n\t\t\t\t\t\t\t\t\tspellcheck=\"false\"\n\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"name\"\n\t\t\t\t\t\t\t\t\tclass=\"name\"\n\t\t\t\t\t\t\t\t\tstyle=\"width:100%; font-weight: bolder; font-family: Verdana;\";\n\t\t\t\t\t\t\t\t\tcols=\"30\"\n\t\t\t\t\t\t\t\t\trows=\"1\"\n\t\t\t\t\t\t\t\t\t>Name</textarea>\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"addProjectButton\"\n\t\t\t\t\t\t\t\t\tclass=\"addProjectButton\"\n\t\t\t\t\t\t\t\t\tdojoType=\"dijit.form.Button\"\n\t\t\t\t\t\t\t\t\tlabel=\"Save\"\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td colspan=\"2\">\n\t\t\t\t\t\t\t\t<textarea\n\t\t\t\t\t\t\t\t\tspellcheck=\"false\"\n\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"description\"\n\t\t\t\t\t\t\t\t\tclass=\"description\"\n\t\t\t\t\t\t\t\t\tstyle=\"width:100%; font-weight: bolder; font-family: Verdana;\";\n\t\t\t\t\t\t\t\t\tcols=\"40\"\n\t\t\t\t\t\t\t\t\trows=\"1\"\n\t\t\t\t\t\t\t\t\t>Description</textarea>\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td colspan=\"2\">\n\t\t\t\t\t\t\t\t<textarea\n\t\t\t\t\t\t\t\t\tspellcheck=\"false\"\n\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"notes\"\n\t\t\t\t\t\t\t\t\tclass=\"notes\"\n\t\t\t\t\t\t\t\t\tvalue=\"Notes\"\n\t\t\t\t\t\t\t\t\tstyle=\"width:100%; font-weight: bolder; font-family: Verdana;\";\n\t\t\t\t\t\t\t\t\tcols=\"40\"\n\t\t\t\t\t\t\t\t\trows=\"1\"\n\t\t\t\t\t\t\t\t\t>Notes</textarea>\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t</table>\n\t\t\t\t</td>\n\t\t\t</tr>\n\t\t\t\n\t\t\t<tr valign=\"top\" width=\"95%\">\n\t\t\t\t<td width=\"95%\">\n\t\t\t\t\t<div class=\"label\"> Projects </div>\n\t\t\t\t\t<div\n\t\t\t\t\t\tdojoAttachPoint=\"dragSourceNode\"\n\t\t\t\t\t\tclass=\"dragSource\"\n\t\t\t\t\t\tstyle=\"height: 468px; width: 95%;\"\n\t\t\t\t\t>\n\t\t\t\t\t</div>\n\t\t\t\t</td>\n\t\t\t</tr>\n\n\t\t\t<tr align=\"center\">\n\t\t\t\t<td align=\"center\">\n\n\t\t\t\t\t<!-- TRASH CONTAINER -->\n\t\t\t\t\t<div\n\t\t\t\t\t\tdojoAttachPoint=\"trashContainer\"\n\t\t\t\t\t\tclass=\"trash\"\n\t\t\t\t\t\tstyle=\"height: 60px; width: 150px; align: center;\" \n\t\t\t\t\t\t>\n\t\t\t\t\t\t<div\n\t\t\t\t\t\t\tdojoAttachPoint=\"trashIcon\"\n\t\t\t\t\t\t\tclass=\"trashIcon\"\n\t\t\t\t\t\t\tstyle=\"height: 60px; width: 60px;\"\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</td>\n\t\t\t</tr>\n\t\t</table>\n\n\t</div>\n\t<!-- END SOURCES TAB -->\n\t\n</div> \n\n\n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

//adding STATE
adding : false,

// OR USE @import IN HTML TEMPLATE
cssFiles : [ "plugins/sharing/css/projects.css" ],

// PARENT WIDGET
parentWidget : null,

// FORM INPUTS AND TYPES (word|phrase)
formInputs : {
	name		: "word",
	description	: "phrase",
	notes		: "word"
},

defaultInputs : {
	name 		: "Name",
	description	: "Description",
	notes		: "Notes"
},
	
requiredInputs : {
// REQUIRED INPUTS CANNOT BE ''
	name 		: 1
},

invalidInputs : {
// INVALID INPUTS (e.g., DEFAULT INPUTS)
	name 		: "Name",
	description	: "Description",
	notes		: "Notes"
},

dataFields : [
	"name"
],

avatarItems : [
	"name",
	"description"
],

rowClass : "plugins.sharing.ProjectRow",

/////}}}

constructor : function(args) {
	//////console.log("Projects.constructor     plugins.sharing.Projects.constructor");			
	// GET INFO FROM ARGS
	this.parentWidget = args.parentWidget;
	this.projects = args.parentWidget.projects;

	// LOAD CSS
	this.loadCSS();		
},

postCreate : function() {
	//////console.log("Controller.postCreate    plugins.sharing.Controller.postCreate()");
	this.startup();
},

startup : function () {
	//////console.log("Projects.startup    plugins.sharing.Projects.startup()");

	// COMPLETE CONSTRUCTION OF OBJECT
	this.inherited(arguments);	 

	// ADD TO TAB CONTAINER		
	this.tabContainer.addChild(this.projectsTab);
	this.tabContainer.selectChild(this.projectsTab);

	// SET DRAG PROJECT - LIST OF PROJECTS
	this.setDragSource();

	// SET NEW PROJECT FORM
	this.setForm();

	// SUBSCRIBE TO UPDATES
	Agua.updater.subscribe(this, "updateProjects");

	// SUBSCRIBE TO UPDATES
	Agua.updater.subscribe(this, "updateWorkflows");

	// SET TRASH
	this.setTrash(this.dataFields);	
},

updateProjects : function (args) {
	//console.log("Projects.updateProjects    sharing.Projects.updateProjects(args)");
	//console.log("Projects.updateProjects    args:");
	//console.dir(args);

	// SET DRAG SOURCE
	if ( args == null || args.reload != false )
	{
		//console.log("Projects.updateProjects    Calling setDragSource()");
		this.setDragSource();
	}
},

setForm : function () {
	//console.log("Projects.setForm    plugins.sharing.Projects.setForm()");
	// SET ADD PROJECT ONCLICK
	dojo.connect(this.addProjectButton, "onClick", dojo.hitch(this, "saveInputs", null, null));
	
	// SET ONCLICK TO CANCEL INVALID TEXT
	this.setClearValues();

	// CHAIN TOGETHER INPUTS ON 'RETURN' KEYPRESS
	this.chainInputs(["name","description","notes", "addProjectButton"]);
},

getItemArray : function () {
	var dataArray = new Array;
	var itemArray = Agua.getProjects();
	//console.log("Projects.getItemArray    itemArray: " + dojo.toJson(itemArray));
	return this.sortHasharray(itemArray, 'name');	
},

deleteItem : function (itemObject) {
	//console.log("Projects.deleteItem    Projects.deleteItem(itemObject)");	
	//console.log("Projects.deleteItem    itemObject: " + dojo.toJson(itemObject));	

	if ( ! Agua.isProject(itemObject.name) )	return;

	// REMOVING PROJECT FROM Agua.projects
	Agua.removeProject(itemObject);

	// RELOAD RELEVANT DISPLAYS
	//console.log("Projects.deleteItem    Doing Agua.updater.update('updateProjects')");	
	Agua.updater.update("updateProjects");

}, // Projects.deleteItem

addItem : function (itemObject, formAdd) {
	//////console.log("Projects.addItem    plugins.sharing.Projects.addItem()");
	//console.log("Projects.addItem    plugins.sharing.Projects.addItem(itemObject)");
	//console.log("Projects.addItem    itemObject:");
	//console.dir(itemObject);

	if ( this.adding == true )	return;
	this.adding = true;
	
	if ( formAdd && Agua.isProject(itemObject.name) )
	{
		//console.log("Projects.addItem    project exists already. Returning");
		this.adding = false;
		return;
	}
	
	// ADD PROJECT TO Agua.projects ARRAY
	Agua.addProject(itemObject);
	
	this.adding = false;

	// RELOAD RELEVANT DISPLAYS
	Agua.updater.update("updateProjects");

} // Projects._addItem



}); // plugins.sharing.Projects

}

if(!dojo._hasResource["plugins.sharing.SourceRow"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.sharing.SourceRow"] = true;
dojo.provide("plugins.sharing.SourceRow");

dojo.declare( "plugins.sharing.SourceRow",
	[ dijit._Widget, dijit._Templated ],
{
		
//Path to the template of this widget. 
templateString:"<div dojoAttachPoint=\"containerNode\">\n    <table width=\"100%\">\n        <tr>\n            <td\n                dojoAttachPoint=\"name\"\n                class=\"name\"\n                >\n                ${name}</td>\n        </tr>\n        <tr>\n            <td dojoAttachPoint=\"description\" class='description' style=\"display: block;\" >${description}</td>\n        </tr>\n        <tr>\n            <td dojoAttachPoint=\"location\" class='location' style=\"display: block;\">${location}</td>\n        </tr>\n    </table>\n</div>\n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

// PARENT plugins.sharing.Sources WIDGET
parentWidget : null,

////}}}

constructor : function(args) {
	//////console.log("SourceRow.constructor    plugins.workflow.SourceRow.constructor()");
	this.parentWidget = args.parentWidget;
	//this.inherited(arguments);
},

postCreate : function() {
	////////console.log("SourceRow.postCreate    plugins.workflow.SourceRow.postCreate()");
	this.formInputs = this.parentWidget.formInputs;
	this.startup();
},

startup : function () {
	//////console.log("SourceRow.startup    plugins.workflow.SourceRow.startup()");
	//////console.log("SourceRow.startup    this.parentWidget: " + this.parentWidget);

	this.inherited(arguments);
	
	//dojo.connect( this.name, "onclick", this.toggle);
	var thisObject = this;
	dojo.connect( this.name, "onclick", function(event) {
		thisObject.toggle();
		event.stopPropagation(); //Stop Event Bubbling 			
	});

	// ADD 'EDIT' ONCLICK
	dojo.connect(this.description, "onclick", function(event)
		{
			//////console.log("SourceRow.startup    sourceRow.description clicked");
			thisObject.parentWidget.editRow(thisObject, event.target);
			event.stopPropagation(); //Stop Event Bubbling 			
		}
	);

	// ADD 'EDIT' ONCLICK
	dojo.connect(this.location, "onclick", function(event)
		{
			//////console.log("SourceRow.startup    sourceRow.location clicked");
			thisObject.parentWidget.editRow(thisObject, event.target);
			event.stopPropagation(); //Stop Event Bubbling 			
		}
	);
},

toggle : function () {
	//////console.log("SourceRow.toggle    plugins.workflow.SourceRow.toggle()");

	if ( this.description.style.display == 'block' ) this.description.style.display='none';
	else this.description.style.display = 'block';
	if ( this.location.style.display == 'block' ) this.location.style.display='none';
	else this.location.style.display = 'block';
}

});

}

if(!dojo._hasResource["plugins.sharing.Sources"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.sharing.Sources"] = true;
dojo.provide("plugins.sharing.Sources");

// ALLOW THE USER TO ADD, REMOVE AND MODIFY SOURCES

// EXTERNAL MODULES






// INTERNAL MODULES



// HAS A


dojo.declare("plugins.sharing.Sources",
	[ dijit._Widget, dijit._Templated, plugins.core.Common, plugins.form.EditForm ], {
//Path to the template of this widget. 
templateString:"<div dojoattachpoint=\"containerNode\">\n\n\t<!-- SOURCES TAB -->\n\t<div\n\t\tdojoAttachPoint=\"sourcesTab\"\n\t\tclass=\"sources\"\n\t\tdojoType=\"dijit.layout.ContentPane\"\n\t\ttitle=\"Sources\"\n\t\tstyle=\"height: 100% !important; max-height: auto !important; width: 390px !important; padding: 0 !important;\"\n\t\t>\n\n\t\t<table width=\"100%\">\n\t\t\t<tr valign=\"top\" width=\"370\">\n\t\t\t\t<td colspan=\"2\" class=\"tabTitle\" align=\"center\"> Sources </td>\n\t\t\t</tr>\n\n\t\t\t<tr valign=\"top\" width=\"95%\">\n\t\t\t\t<td>\n\t\t\t\t\t<div class=\"label\"> New Source </div>\n\t\t\t\t\t<table>\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t<textarea\n\t\t\t\t\t\t\t\t\tspellcheck=\"false\"\n\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"name\"\n\t\t\t\t\t\t\t\t\tclass=\"name\"\n\t\t\t\t\t\t\t\t\tstyle=\"width:100%; font-weight: bolder; font-family: Verdana;\";\n\t\t\t\t\t\t\t\t\tcols=\"30\"\n\t\t\t\t\t\t\t\t\trows=\"1\"\n\t\t\t\t\t\t\t\t\t>Name</textarea>\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"addSourceButton\"\n\t\t\t\t\t\t\t\t\tclass=\"addSourceButton\"\n\t\t\t\t\t\t\t\t\tdojoType=\"dijit.form.Button\"\n\t\t\t\t\t\t\t\t\tlabel=\"Save\"\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td colspan=\"2\">\n\t\t\t\t\t\t\t\t<textarea\n\t\t\t\t\t\t\t\t\tspellcheck=\"false\"\n\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"description\"\n\t\t\t\t\t\t\t\t\tclass=\"description\"\n\t\t\t\t\t\t\t\t\tstyle=\"width:100%; font-weight: bolder; font-family: Verdana;\";\n\t\t\t\t\t\t\t\t\tcols=\"40\"\n\t\t\t\t\t\t\t\t\trows=\"1\"\n\t\t\t\t\t\t\t\t\t>Description</textarea>\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td colspan=\"2\">\n\t\t\t\t\t\t\t\t<textarea\n\t\t\t\t\t\t\t\t\tspellcheck=\"false\"\n\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"location\"\n\t\t\t\t\t\t\t\t\tclass=\"location\"\n\t\t\t\t\t\t\t\t\tvalue=\"Location\"\n\t\t\t\t\t\t\t\t\tstyle=\"width:100%; font-weight: bolder; font-family: Verdana;\";\n\t\t\t\t\t\t\t\t\tcols=\"40\"\n\t\t\t\t\t\t\t\t\trows=\"1\"\n\t\t\t\t\t\t\t\t\t>Location</textarea>\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t</table>\n\t\t\t\t</td>\n\t\t\t</tr>\n\t\t\t\n\t\t\t<tr valign=\"top\" width=\"95%\">\n\t\t\t\t<td width=\"95%\">\n\t\t\t\t\t<div class=\"label\"> Sources </div>\n\t\t\t\t\t<div\n\t\t\t\t\t\tdojoAttachPoint=\"dragSourceNode\"\n\t\t\t\t\t\tclass=\"dragSource\"\n\t\t\t\t\t\tstyle=\"height: 468px; width: 95%;\"\n\t\t\t\t\t>\n\t\t\t\t\t</div>\n\t\t\t\t</td>\n\t\t\t</tr>\n\n\t\t\t<tr align=\"center\">\n\t\t\t\t<td align=\"center\">\n\n\t\t\t\t\t<!-- TRASH CONTAINER -->\n\t\t\t\t\t<div\n\t\t\t\t\t\tdojoAttachPoint=\"trashContainer\"\n\t\t\t\t\t\tclass=\"trash\"\n\t\t\t\t\t\tstyle=\"height: 60px; width: 150px; align: center;\" \n\t\t\t\t\t\t>\n\t\t\t\t\t\t<div\n\t\t\t\t\t\t\tdojoAttachPoint=\"trashIcon\"\n\t\t\t\t\t\t\tclass=\"trashIcon\"\n\t\t\t\t\t\t\tstyle=\"height: 60px; width: 60px;\"\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</td>\n\t\t\t</tr>\n\t\t</table>\n\n\t</div>\n\t<!-- END SOURCES TAB -->\n\t\n</div> \n\n\n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

//addingSource STATE
addingSource : false,

// OR USE @import IN HTML TEMPLATE
cssFiles : [ "plugins/sharing/css/sources.css" ],

// PARENT WIDGET
parentWidget : null,

// FORM INPUTS AND TYPES (word|phrase)
formInputs : {
	name		: "phrase",
	description	: "phrase",
	location	: "word"
},

defaultInputs : {
	name : "Name",
	description: "Description",
	location: "Location"
},
	
requiredInputs : {
// REQUIRED INPUTS CANNOT BE ''
	name : 1,
	location: 1
},

invalidInputs : {
// INVALID INPUTS (e.g., DEFAULT INPUTS)
	name : "Name",
	description: "Description",
	location: "Location"
},

// DATA ITEMS FOR ROW
dataFields : ["name", "description", "location"],

// AVATAR DISPLAYED DATA ITEMS
avatarItems : [ "name", "description", "location" ],

// ROW CLASS FOR DRAG SOURCE
rowClass : "plugins.sharing.SourceRow",

////}}}

constructor : function(args) {
	//////console.log("Sources.constructor     plugins.sharing.Sources.constructor");			
	// GET INFO FROM ARGS
	this.parentWidget = args.parentWidget;
	this.sources = args.parentWidget.sources;

	// LOAD CSS
	this.loadCSS();		
},

postCreate : function() {
	//////console.log("Controller.postCreate    plugins.sharing.Controller.postCreate()");

	this.startup();
},

startup : function () {
	//////console.log("Sources.startup    plugins.sharing.GroupSources.startup()");

	// COMPLETE CONSTRUCTION OF OBJECT
	this.inherited(arguments);	 

	// ADD ADMIN TAB TO TAB CONTAINER		
	this.tabContainer.addChild(this.sourcesTab);
	this.tabContainer.selectChild(this.sourcesTab);

	// SET DRAG SOURCE - LIST OF SOURCES
	this.setDragSource();

	// SET NEW SOURCE FORM
	this.setForm();

	// SUBSCRIBE TO UPDATES
	Agua.updater.subscribe(this, "updateSources");

	// SET TRASH
	this.setTrash(this.dataFields);	
},

updateSources : function (args) {
// RELOAD RELEVANT DISPLAYS
	//console.log("Sources.updateSources    sharing.Sources.updateSources(args)");
	//console.log("Sources.updateSources    args:");
	//console.dir(args);

	// REDO PARAMETER TABLE
	if ( args != null && args.originator == this )
	{
//		if ( args.reload == null )	return;
		if ( args.reload == false )	return;
	}

	//console.log("Sources.updateSources    Calling setDragSource()");
	this.setDragSource();
},

setForm : function () {
	//////console.log("Sources.setForm    plugins.sharing.GroupSources.setForm()");

	// SET ADD SOURCE ONCLICK
	dojo.connect(this.addSourceButton, "onClick", dojo.hitch(this, "saveInputs", null, null));
	
	// SET ONCLICK TO CANCEL INVALID TEXT
	this.setClearValues();
	
	// CHAIN TOGETHER INPUTS ON 'RETURN' KEYPRESS
	this.chainInputs(["name", "description", "location", "addSourceButton"]);
},

getItemArray : function () {
	var itemArray = Agua.getSources();
	itemArray = this.sortHasharray(itemArray, 'name');	

	console.log("Sources.getItemArray    Returning itemArray: ");
	console.dir({itemArray:itemArray});
	
	return itemArray;
},

deleteItem : function (itemObject) {
	//console.log("Sources.deleteItem    plugins.sharing.Sources.deleteItem(itemObject)");
	//console.log("Sources.deleteItem    itemObject: " + itemObject);

	// CLEAN UP WHITESPACE
	itemObject.name = itemObject.name.replace(/\s+$/,'');
	itemObject.name = itemObject.name.replace(/^\s+/,'');

	// REMOVING SOURCE FROM Agua.sources
	var success = Agua.removeSource(itemObject)
	//console.log("Sources.deleteItem    Agua.removeSource(itemObject) success: " + success);
	
	// RELOAD RELEVANT DISPLAYS
	Agua.updater.update("updateSources");

}, // Sources.deleteItem


addItem : function (sourceObject, reload) {
	//////console.log("Sources.addItem    plugins.sharing.Sources.addItem(source)");
	//////console.log("Sources.addItem    source: " + source);	
	if ( this.savingSource == true )	return;
	this.savingSource = true;

	Agua.addSource(sourceObject);

	this.savingSource = false;

	// RELOAD RELEVANT DISPLAYS
	Agua.updater.update("updateSources", reload);

} // Sources.addItem

}); // plugins.sharing.Sources


//setDragSource : function () {
//	console.log("Sources.setDragSource     plugins.sharing.GroupSources.setDragSource()");
//
//	var dataArray = new Array;
//	var sourceArray = Agua.getSources();
//
//	sourceArray = this.sortHasharray(sourceArray, 'name');
//
//	// CHECK sourceArray IS NOT NULL OR EMPTY
//	if ( sourceArray == null || sourceArray.length == 0 )
//	{
//		console.log("Sources.setDragSource     sourceArray is null or empty. Returning.");
//		return;
//	}
//
//	// GENERATE dataArray TO INSERT INTO DND SOURCE TABLE
//	for ( var j = 0; j < sourceArray.length; j++ )
//	{
//		var data = sourceArray[j];				
//		data.toString = function () { return this.name; }
//		dataArray.push( { data: data, type: ["draggableItem"] } );
//	}
//
//	// GENERATE DND SOURCE
//	var dragSource = new dojo.dnd.Source(
//		this.dragSourceNode,
//		{
//			copyOnly: true,
//			selfAccept: false,
//			accept : [ "none" ]
//		}
//	);
//	// SET THIS dragSourceWidget
//	this.dragSourceWidget = dragSource;
//
//	// INSERT NODES
//	dragSource.insertNodes(false, dataArray);
//
//	// SET TABLE ROW STYLE IN dojDndItems
//	var allNodes = dragSource.getAllNodes();
//	console.log("Sources.setDragSource     After insertNodes. allNodes.length: " + allNodes.length);
//	for ( var k = 0; k < allNodes.length; k++ )
//	{
//		// ADD CLASS FROM type TO NODE
//		var node = allNodes[k];
//
//		console.log("Sources.setDragSource     Setting node " + k + " data: " + dojo.toJson(dataArray[k]));
//
//		// SET NODE name AND description
//		node.name = dataArray[k].data.name;
//		node.description = dataArray[k].data.description;
//		node.location = dataArray[k].data.location;
//		if ( node.location == null )
//		{
//			node.location = '';
//		}
//
//		var sourceRow = new plugins.sharing.SourceRow({
//			name : node.name,
//			description : node.description,
//			location : node.location,
//			parentWidget : this
//		});
//		//console.log("Sources.setDragSource     sourceRow: " + sourceRow);
//		//console.log("Sources.setDragSource     sourceRow.description: " + sourceRow.description);
//
//		node.innerHTML = '';
//		node.appendChild(sourceRow.domNode);
//
//		//console.log("Sources.setDragSource     node.name: " + node.name);
//	}
//
//	dragSource.creator = function (item, hint)
//	{
//		console.log("Sources.setDragSource dragSource.creator         item: " + dojo.toJson(item));
//		//console.log("Sources.setDragSource dragSource.creator         item: " + item);
//		//console.log("Sources.setDragSource dragSource.creator         hint: " + hint);
//
//		var node = dojo.doc.createElement("div");
//		node.name = item.name;
//		node.description = item.description;
//		node.location = item.location;
//		node.id = dojo.dnd.getUniqueId();
//		node.className = "dojoDndItem";
//
//		//console.log("Sources.setDragSource dragSource.creator         node.name: " + node.name);
//		//console.log("Sources.setDragSource dragSource.creator         node.description: " + node.description);
//
//		// SET FANCY FORMAT IN NODE INNERHTML
//		node.innerHTML = "<table> <tr><td><strong style='color: darkred'>" + item.name + "</strong></td></tr><tr><td> " + item.description + "</td></tr></table>";
//
//		return {node: node, data: item, type: ["text"]};
//	};
//},


}

if(!dojo._hasResource["plugins.sharing.UserRow"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.sharing.UserRow"] = true;
dojo.provide("plugins.sharing.UserRow");


dojo.declare( "plugins.sharing.UserRow",
	[ dijit._Widget, dijit._Templated ],
{
//Path to the template of this widget. 
templateString:"<div dojoAttachPoint=\"containerNode\">\n    <table width=\"100%\">\n        <tr class=\"username\" width=\"100%\">\n            <td\n                width=\"100%\"\n                colspan=\"2\"\n                dojoAttachPoint=\"username\"\n                class=\"username\"\n            >${username}</td>\n        </tr>\n        <tr class='firstname' width=\"100%\">\n            <td \n                dojoAttachPoint=\"firstname\"\n                class='firstname'\n                style=\"display: none;\"\n                width=\"100%\" colspan=\"2\"\n            >${firstname}</td>\n        </tr>\n        <tr class='lastname' width=\"100%\">\n            <td \n                dojoAttachPoint=\"lastname\"\n                class='lastname'\n                style=\"display: none;\"\n                width=\"100%\" colspan=\"2\"\n            >${lastname}</td>\n        </tr>\n        <tr class=\"email\" width=\"100%\">\n            <td \n                dojoAttachPoint=\"email\"\n                class='email'\n                style=\"display: none;\"\n                width=\"100%\" colspan=\"2\"\n            >${email}</td>\n        </tr>\n        <tr class=\"password\" width=\"100%\">\n            <td \n                dojoAttachPoint=\"password\"\n                class='password'\n                style=\"display: none;\"\n                type=\"password\"\n                value=\"its-a-secret\"\n                width=\"100%\" colspan=\"2\"\n            >reset-password</td>\n        </tr>\n    </table>\n</div>\n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

// PARENT plugins.sharing.Users WIDGET
parentWidget : null,

////}}}

constructor : function(args) {
	//////console.log("UserRow.constructor    plugins.workflow.UserRow.constructor()");
	this.parentWidget = args.parentWidget;
},

postCreate : function() {
	////////console.log("UserRow.postCreate    plugins.workflow.UserRow.postCreate()");
	this.formInputs = this.parentWidget.formInputs;
	this.startup();
},

startup : function () {
	//////console.log("UserRow.startup    plugins.workflow.UserRow.startup()");
	//////console.log("UserRow.startup    this.parentWidget: " + this.parentWidget);

	this.inherited(arguments);
	
	var thisObject = this;

	dojo.connect( this.username, "onclick", function(event) {
		thisObject.toggle();
		event.stopPropagation(); //Stop Event Bubbling 			
	});

	// FIRSTNAME
	var thisObject = this;
	dojo.connect(this.firstname, "onclick", function(event)
		{
			//console.log("UserRow.startup    userRow.firstname clicked");
			thisObject.parentWidget.editRow(thisObject, event.target);
			event.stopPropagation(); //Stop Event Bubbling 			
		}
	);

	// LASTNAME
	dojo.connect(this.lastname, "onclick", function(event)
		{
			thisObject.parentWidget.editRow(thisObject, event.target);
			event.stopPropagation(); //Stop Event Bubbling 			
		}
	);

	// EMAIL
	dojo.connect(this.email, "onclick", function(event)
		{
			//////console.log("UserRow.startup    userRow.email clicked");

			thisObject.parentWidget.editRow(thisObject, event.target);
			event.stopPropagation(); //Stop Event Bubbling 			
		}
	);

	// PASSWORD
	dojo.connect(this.password, "onclick", function(event)
		{
			//console.log("UserRow.startup    userRow.password clicked");

			thisObject.clearValue(event.target);
			thisObject.parentWidget.editRow(thisObject, event.target);
			event.stopPropagation(); //Stop Event Bubbling 			
		}
	);
},

toggle : function () {
	//////console.log("UserRow.toggle    plugins.workflow.UserRow.toggle()");

	if ( this.firstname.style.display == 'block' ) this.firstname.style.display='none';
	else this.firstname.style.display = 'block';
	if ( this.lastname.style.display == 'block' ) this.lastname.style.display='none';
	else this.lastname.style.display = 'block';
	if ( this.email.style.display == 'block' ) this.email.style.display='none';
	else this.email.style.display = 'block';
	if ( this.password.style.display == 'block' ) this.password.style.display='none';
	else this.password.style.display = 'block';
},

clearValue : function (element) {
	//console.log("UserRow.clearValue    plugins.sharing.UserRow.clearValue(element)");
	//console.log("UserRow.clearValue    element.value: " + element.value);

	if ( element.clicked == true ) return;
	
	element.clicked = true;
	element.innerHTML = '';
	element.focus();
}


});

}

if(!dojo._hasResource["plugins.sharing.Users"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.sharing.Users"] = true;
dojo.provide("plugins.sharing.Users");

// ALLOW THE ADMIN USER TO ADD, REMOVE AND MODIFY USERS
// NEW USERS MUST HAVE username AND email

// EXTERNAL MODULES






// INTERNAL MODULES



// HAS A


dojo.declare("plugins.sharing.Users",
	[ dijit._Widget, dijit._Templated, plugins.core.Common, plugins.form.EditForm ],
{

//Path to the template of this widget. 
templateString:"<div dojoattachpoint=\"containerNode\">\n\n\t<!-- users TAB -->\n\t<div\n\t\tdojoAttachPoint=\"mainTab\"\n\t\tclass=\"users\"\n\t\tdojoType=\"dijit.layout.ContentPane\"\n\t\ttitle=\"Users\"\n\t\tstyle=\"height: 100% !important; max-height: auto !important; width: 370px !important; padding: 0 !important;\"\n\t\t>\n\n\t\t<table width=\"100%\">\n\t\t\t<tr valign=\"top\" width=\"370\">\n\t\t\t\t<td colspan=\"2\" class=\"tabTitle\" align=\"center\"> Users </td>\n\t\t\t</tr>\n\n\t\t\t<tr valign=\"top\" width=\"95%\">\n\n\t\t\t\t<td>\n\t\t\t\t\n\t\t\t\t\t<table>\n\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td colspan=\"3\">\n\t\t\t\t\t\t\t\t<div class=\"label\"> Create New User </div>\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\tUsername\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t<textarea\n\t\t\t\t\t\t\t\t\tspellcheck=\"false\"\n\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"username\"\n\t\t\t\t\t\t\t\t\tclass=\"username\"\n\t\t\t\t\t\t\t\t\tstyle=\"width:100%; height: 20px; font-weight: bolder; font-family: Verdana;\";\n\t\t\t\t\t\t\t\t\tcols=\"30\"\n\t\t\t\t\t\t\t\t\trows=\"1\"\n\t\t\t\t\t\t\t\t\ttitle=\"Username\"\n\t\t\t\t\t\t\t\t\t>Username</textarea>\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"addUserButton\"\n\t\t\t\t\t\t\t\t\tclass=\"addUserButton\"\n\t\t\t\t\t\t\t\t\tdojoType=\"dijit.form.Button\"\n\t\t\t\t\t\t\t\t\tlabel=\"Add\"\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\tFirst name\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t<td colspan=\"2\">\n\t\t\t\t\t\t\t\t<textarea\n\t\t\t\t\t\t\t\t\tspellcheck=\"false\"\n\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"firstname\"\n\t\t\t\t\t\t\t\t\tclass=\"firstname\"\n\t\t\t\t\t\t\t\t\tstyle=\"width:100%; height: 20px; font-weight: bolder; font-family: Verdana;\";\n\t\t\t\t\t\t\t\t\tcols=\"40\"\n\t\t\t\t\t\t\t\t\trows=\"1\"\n\t\t\t\t\t\t\t\t\ttitle=\"Firstname\"\n\t\t\t\t\t\t\t\t\t>Firstname</textarea>\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\tLast name\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t<td colspan=\"2\">\n\t\t\t\t\t\t\t\t<textarea\n\t\t\t\t\t\t\t\t\tspellcheck=\"false\"\n\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"lastname\"\n\t\t\t\t\t\t\t\t\tclass=\"lastname\"\n\t\t\t\t\t\t\t\t\tstyle=\"width:100%; height: 20px; font-weight: bolder; font-family: Verdana;\";\n\t\t\t\t\t\t\t\t\tcols=\"40\"\n\t\t\t\t\t\t\t\t\trows=\"1\"\n\t\t\t\t\t\t\t\t\ttitle=\"Lastname\"\n\t\t\t\t\t\t\t\t\t>Lastname</textarea>\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\tEmail\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t<td colspan=\"2\">\n\t\t\t\t\t\t\t\t<textarea\n\t\t\t\t\t\t\t\t\tspellcheck=\"false\"\n\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"email\"\n\t\t\t\t\t\t\t\t\tclass=\"email\"\n\t\t\t\t\t\t\t\t\tvalue=\"Email\"\n\t\t\t\t\t\t\t\t\tstyle=\"width:100%; height: 20px; font-weight: bolder; font-family: Verdana;\";\n\t\t\t\t\t\t\t\t\tcols=\"40\"\n\t\t\t\t\t\t\t\t\trows=\"1\"\n\t\t\t\t\t\t\t\t\ttitle=\"Email\"\n\t\t\t\t\t\t\t\t\t>Email</textarea>\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\tPassword\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t<td colspan=\"2\">\n\t\t\t\t\t\t\t\t<input\n\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"password\"\n\t\t\t\t\t\t\t\t\tclass=\"password\"\n\t\t\t\t\t\t\t\t\tvalue=\"\"\n\t\t\t\t\t\t\t\t\ttype=\"password\"\n\t\t\t\t\t\t\t\t\tstyle=\"width:100%; height: 20px; font-weight: bolder; font-family: Verdana;\";\n\t\t\t\t\t\t\t\t\tvalue=\"\"\n\t\t\t\t\t\t\t\t\ttitle=\"Password\"\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t</table>\n\t\t\t\t</td>\n\t\t\t</tr>\n\t\t\t\n\t\t\t<tr valign=\"top\" width=\"95%\">\n\t\t\t\t<td width=\"95%\">\n\t\t\t\t\t<div class=\"label\"> Users </div>\n\t\t\t\t\t<div\n\t\t\t\t\t\tdojoAttachPoint=\"dragSourceNode\"\n\t\t\t\t\t\tclass=\"dragSource\"\n\t\t\t\t\t\tstyle=\"height: 416px; width: 95%;\"\n\t\t\t\t\t>\n\t\t\t\t\t</div>\n\t\t\t\t</td>\n\t\t\t</tr>\n\n\t\t\t<tr align=\"center\">\n\t\t\t\t<td align=\"center\">\n\n\t\t\t\t\t<!-- TRASH CONTAINER -->\n\t\t\t\t\t<div\n\t\t\t\t\t\tdojoAttachPoint=\"trashContainer\"\n\t\t\t\t\t\tclass=\"trash\"\n\t\t\t\t\t\tstyle=\"height: 60px; width: 150px; align: center;\" \n\t\t\t\t\t\t>\n\t\t\t\t\t\t<div\n\t\t\t\t\t\t\tdojoAttachPoint=\"trashIcon\"\n\t\t\t\t\t\t\tclass=\"trashIcon\"\n\t\t\t\t\t\t\tstyle=\"height: 60px; width: 60px;\"\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</td>\n\t\t\t</tr>\n\t\t</table>\n\n\t</div>\n\t<!-- END users TAB -->\n\t\n</div> \n\n\n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

//addingUser STATE
addingUser : false,

// OR USE @import IN HTML TEMPLATE
cssFiles : [ "plugins/sharing/css/users.css" ],

// PARENT WIDGET
parentWidget : null,

formInputs : {
// FORM INPUTS AND TYPES (word|phrase)
	username	:	"word",
	firstname	:	"phrase",
	lastname	:	"phrase",
	email		:	"phrase",
	password	:	"phrase"
},

defaultInputs : {
// DEFAULT INPUTS
	username	:	"Username",
	firstname	:	"Firstname",
	lastname	:	"Lastname",
	email		:	"Email"
},

requiredInputs : {
// REQUIRED INPUTS CANNOT BE ''
// combo INPUTS ARE AUTOMATICALLY NOT ''
	username 	: 1,
	firstname	: 1,
	lastname	: 1,
	email		: 1
},

invalidInputs : {
// THESE INPUTS ARE INVALID
	username	:	"Username",
	firstname	:	"Firstname",
	lastname	:	"Lastname",
	email		:	"Email"
},

dataFields : [
	"username"
],

avatarItems : [
	"username",
	"email"
],

// MOTHBALLED WITH TWO-D ARRAYS
//fieldIndexes : [
//	"username",
//	"firstname",
//	"lastname",
//	"email"
//],

rowClass : "plugins.sharing.UserRow",

/////}}}

constructor : function(args) {
	//////console.log("Users.constructor     plugins.sharing.Users.constructor");			
	// GET INFO FROM ARGS
	this.parentWidget = args.parentWidget;
	this.users = args.parentWidget.users;

	// LOAD CSS
	this.loadCSS();		
},

postCreate : function() {
	//////console.log("Controller.postCreate    plugins.sharing.Controller.postCreate()");

	this.startup();
},

startup : function() {
	console.log("Users.startup    plugins.sharing.Users.startup()");

	// COMPLETE CONSTRUCTION OF OBJECT
	this.inherited(arguments);	 

	// ADD ADMIN TAB TO TAB CONTAINER		
	this.tabContainer.addChild(this.mainTab);
	this.tabContainer.selectChild(this.mainTab);

	// SET DRAG SOURCE - LIST OF USERS
	this.setDragSource();

	// SET NEW SOURCE FORM
	this.setForm();

	// SUBSCRIBE TO UPDATES
	Agua.updater.subscribe(this, "updateUsers");

	// SET TRASH
	this.setTrash(this.dataFields);	
},

updateUsers : function (args) {
	//console.log("Users.updateUsers    sharing.Users.updateUsers(args)");
	//console.log("Users.updateUsers    args:");
	//console.dir(args);

	// SET DRAG SOURCE
	if ( args == null || args.reload != false )
	{
		console.log("Users.updateUsers    Doing this.setDragSource()");
		this.setDragSource();
	}
},

setForm : function () {
	//////console.log("Users.setForm    plugins.sharing.Users.setForm()");

	// SET ADD SOURCE ONCLICK
	dojo.connect(this.addUserButton, "onClick", dojo.hitch(this, "saveInputs", null, null));

	// SET ONCLICK TO CANCEL INVALID TEXT
	this.setClearValues();

	// CHAIN TOGETHER INPUTS ON 'RETURN' KEYPRESS
	this.chainInputs(["username", "firstname", "lastname", "email", "password", "addUserButton"]);
},

getItemArray : function () {
	var dataArray = new Array;
	var itemArray = Agua.getUsers();

	//var userArray = Agua.getUsers();
	// MOTHBALLED WITH TWO-ARRAYS
	//var itemArray = new Array;
	////for( var i = 0; i < userArray.length; i++ )
	//for( var i = 0; i < 10; i++ )
	//{
	//	var itemObject = new Object;
	//	for( var j = 0; j < this.fieldIndexes.length; j++ )
	//	{
	//		itemObject[this.fieldIndexes[j]] = userArray[i][j];
	//	}
	//	itemArray.push(itemObject);
	//}
	////console.log("Users.getItemArray    itemArray[0]: " + dojo.toJson(itemArray[0]));

	return this.sortHasharray(itemArray, 'username');
},

deleteItem : function (itemObject) {
	//console.log("Users.deleteItem    plugins.sharing.Users.deleteItem(itemObject)");
	//console.log("Users.deleteItem    itemObject: " + dojo.toJson(itemObject));

	Agua.removeUser(itemObject);
	
	// RELOAD RELEVANT DISPLAYS
	Agua.updater.update("updateUsers");

}, // Users.deleteItem

addItem : function (itemObject, formAdd) {
	console.log("Users.addItem    itemObject: ");
	console.dir({itemObject:itemObject});
	
	// CLEAN UP WHITESPACE AND SUBSTITUTE NON-JSON SAFE CHARACTERS
	itemObject.originalName = this.jsonSafe(itemObject.originalName, 'toJson');
	itemObject.username = this.jsonSafe(itemObject.username, 'toJson');
	itemObject.firstname = this.jsonSafe(itemObject.firstname, 'toJson');
	itemObject.email = this.jsonSafe(itemObject.email, 'toJson');
	itemObject.password = this.jsonSafe(itemObject.password, 'toJson');

	if ( this.saving == true )	return;
	this.saving = true;

	if ( formAdd == true && Agua.isUser(itemObject) )	return;

	Agua.addUser(itemObject);

	this.saving = false;

	// RELOAD RELEVANT DISPLAYS
	Agua.updater.update("updateUsers");

}	// Users.addItem


}); // plugins.sharing.Users


}

if(!dojo._hasResource["plugins.dojox.timing.Sequence"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.dojox.timing.Sequence"] = true;
dojo.provide("plugins.dojox.timing.Sequence");



dojo.declare("plugins.dojox.timing.Sequence", [ dojox.timing.Sequence ], {
	// summary:
	// ADDED clear METHOD TO CLEAR _defsResolved SLOT
	// TO ALLOW A FRESH START WITH go METHOD

	clear: function () {
		//console.log("Sequence.clear()    plugins.dojox.timing.Sequence");

		this._defsResolved = [];
	}

});

}

if(!dojo._hasResource["dijit.layout.SplitContainer"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.layout.SplitContainer"] = true;
dojo.provide("dijit.layout.SplitContainer");




//
// FIXME: make it prettier
// FIXME: active dragging upwards doesn't always shift other bars (direction calculation is wrong in this case)
//


dojo.declare("dijit.layout.SplitContainer",
	dijit.layout._LayoutWidget,
	{
	// summary:
	//		Deprecated.  Use `dijit.layout.BorderContainer` instead.
	// description:
	//		A Container widget with sizing handles in-between each child.
	//		Contains multiple children widgets, all of which are displayed side by side
	//		(either horizontally or vertically); there's a bar between each of the children,
	//		and you can adjust the relative size of each child by dragging the bars.
	//
	//		You must specify a size (width and height) for the SplitContainer.
	// tags:
	//		deprecated

	constructor: function(){
		dojo.deprecated("dijit.layout.SplitContainer is deprecated", "use BorderContainer with splitter instead", 2.0);
	},

	// activeSizing: Boolean
	//		If true, the children's size changes as you drag the bar;
	//		otherwise, the sizes don't change until you drop the bar (by mouse-up)
	activeSizing: false,

	// sizerWidth: Integer
	//		Size in pixels of the bar between each child
	sizerWidth: 7, // FIXME: this should be a CSS attribute (at 7 because css wants it to be 7 until we fix to css)

	// orientation: String
	//		either 'horizontal' or vertical; indicates whether the children are
	//		arranged side-by-side or up/down.
	orientation: 'horizontal',

	// persist: Boolean
	//		Save splitter positions in a cookie
	persist: true,

	baseClass: "dijitSplitContainer",

	postMixInProperties: function(){
		this.inherited("postMixInProperties",arguments);
		this.isHorizontal = (this.orientation == 'horizontal');
	},

	postCreate: function(){
		this.inherited(arguments);
		this.sizers = [];

		// overflow has to be explicitly hidden for splitContainers using gekko (trac #1435)
		// to keep other combined css classes from inadvertantly making the overflow visible
		if(dojo.isMozilla){
			this.domNode.style.overflow = '-moz-scrollbars-none'; // hidden doesn't work
		}

		// create the fake dragger
		if(typeof this.sizerWidth == "object"){
			try{ //FIXME: do this without a try/catch
				this.sizerWidth = parseInt(this.sizerWidth.toString());
			}catch(e){ this.sizerWidth = 7; }
		}
		var sizer = dojo.doc.createElement('div');
		this.virtualSizer = sizer;
		sizer.style.position = 'relative';

		// #1681: work around the dreaded 'quirky percentages in IE' layout bug
		// If the splitcontainer's dimensions are specified in percentages, it
		// will be resized when the virtualsizer is displayed in _showSizingLine
		// (typically expanding its bounds unnecessarily). This happens because
		// we use position: relative for .dijitSplitContainer.
		// The workaround: instead of changing the display style attribute,
		// switch to changing the zIndex (bring to front/move to back)

		sizer.style.zIndex = 10;
		sizer.className = this.isHorizontal ? 'dijitSplitContainerVirtualSizerH' : 'dijitSplitContainerVirtualSizerV';
		this.domNode.appendChild(sizer);
		dojo.setSelectable(sizer, false);
	},

	destroy: function(){
		delete this.virtualSizer;
		dojo.forEach(this._ownconnects, dojo.disconnect);
		this.inherited(arguments);
	},
	startup: function(){
		if(this._started){ return; }

		dojo.forEach(this.getChildren(), function(child, i, children){
			// attach the children and create the draggers
			this._setupChild(child);

			if(i < children.length-1){
				this._addSizer();
			}
		}, this);

		if(this.persist){
			this._restoreState();
		}

		this.inherited(arguments);
	},

	_setupChild: function(/*dijit._Widget*/ child){
		this.inherited(arguments);
		child.domNode.style.position = "absolute";
		dojo.addClass(child.domNode, "dijitSplitPane");
	},

	_onSizerMouseDown: function(e){
		if(e.target.id){
			for(var i=0;i<this.sizers.length;i++){
				if(this.sizers[i].id == e.target.id){
					break;
				}
			}
			if(i<this.sizers.length){
				this.beginSizing(e,i);
			}
		}
	},
	_addSizer: function(index){
		index = index === undefined ? this.sizers.length : index;

		// TODO: use a template for this!!!
		var sizer = dojo.doc.createElement('div');
		sizer.id=dijit.getUniqueId('dijit_layout_SplitterContainer_Splitter');
		this.sizers.splice(index,0,sizer);
		this.domNode.appendChild(sizer);

		sizer.className = this.isHorizontal ? 'dijitSplitContainerSizerH' : 'dijitSplitContainerSizerV';

		// add the thumb div
		var thumb = dojo.doc.createElement('div');
		thumb.className = 'thumb';
		sizer.appendChild(thumb);

		// FIXME: are you serious? why aren't we using mover start/stop combo?
		this.connect(sizer, "onmousedown", '_onSizerMouseDown');

		dojo.setSelectable(sizer, false);
	},

	removeChild: function(widget){
		// summary:
		//		Remove sizer, but only if widget is really our child and
		// we have at least one sizer to throw away
		if(this.sizers.length){
			var i=dojo.indexOf(this.getChildren(), widget)
			if(i != -1){
				if(i == this.sizers.length){
					i--;
				}
				dojo.destroy(this.sizers[i]);
				this.sizers.splice(i,1);
			}
		}

		// Remove widget and repaint
		this.inherited(arguments);
		if(this._started){
			this.layout();
		}
	},

	addChild: function(/*dijit._Widget*/ child, /*Integer?*/ insertIndex){
		// summary:
		//		Add a child widget to the container
		// child:
		//		a widget to add
		// insertIndex:
		//		postion in the "stack" to add the child widget

		this.inherited(arguments);

		if(this._started){
			// Do the stuff that startup() does for each widget
			var children = this.getChildren();
			if(children.length > 1){
				this._addSizer(insertIndex);
			}

			// and then reposition (ie, shrink) every pane to make room for the new guy
			this.layout();
		}
	},

	layout: function(){
		// summary:
		//		Do layout of panels

		// base class defines this._contentBox on initial creation and also
		// on resize
		this.paneWidth = this._contentBox.w;
		this.paneHeight = this._contentBox.h;

		var children = this.getChildren();
		if(!children.length){ return; }

		//
		// calculate space
		//

		var space = this.isHorizontal ? this.paneWidth : this.paneHeight;
		if(children.length > 1){
			space -= this.sizerWidth * (children.length - 1);
		}

		//
		// calculate total of SizeShare values
		//
		var outOf = 0;
		dojo.forEach(children, function(child){
			outOf += child.sizeShare;
		});

		//
		// work out actual pixels per sizeshare unit
		//
		var pixPerUnit = space / outOf;

		//
		// set the SizeActual member of each pane
		//
		var totalSize = 0;
		dojo.forEach(children.slice(0, children.length - 1), function(child){
			var size = Math.round(pixPerUnit * child.sizeShare);
			child.sizeActual = size;
			totalSize += size;
		});

		children[children.length-1].sizeActual = space - totalSize;

		//
		// make sure the sizes are ok
		//
		this._checkSizes();

		//
		// now loop, positioning each pane and letting children resize themselves
		//

		var pos = 0;
		var size = children[0].sizeActual;
		this._movePanel(children[0], pos, size);
		children[0].position = pos;
		pos += size;

		// if we don't have any sizers, our layout method hasn't been called yet
		// so bail until we are called..TODO: REVISIT: need to change the startup
		// algorithm to guaranteed the ordering of calls to layout method
		if(!this.sizers){
			return;
		}

		dojo.some(children.slice(1), function(child, i){
			// error-checking
			if(!this.sizers[i]){
				return true;
			}
			// first we position the sizing handle before this pane
			this._moveSlider(this.sizers[i], pos, this.sizerWidth);
			this.sizers[i].position = pos;
			pos += this.sizerWidth;

			size = child.sizeActual;
			this._movePanel(child, pos, size);
			child.position = pos;
			pos += size;
		}, this);
	},

	_movePanel: function(panel, pos, size){
		if(this.isHorizontal){
			panel.domNode.style.left = pos + 'px';	// TODO: resize() takes l and t parameters too, don't need to set manually
			panel.domNode.style.top = 0;
			var box = {w: size, h: this.paneHeight};
			if(panel.resize){
				panel.resize(box);
			}else{
				dojo.marginBox(panel.domNode, box);
			}
		}else{
			panel.domNode.style.left = 0;	// TODO: resize() takes l and t parameters too, don't need to set manually
			panel.domNode.style.top = pos + 'px';
			var box = {w: this.paneWidth, h: size};
			if(panel.resize){
				panel.resize(box);
			}else{
				dojo.marginBox(panel.domNode, box);
			}
		}
	},

	_moveSlider: function(slider, pos, size){
		if(this.isHorizontal){
			slider.style.left = pos + 'px';
			slider.style.top = 0;
			dojo.marginBox(slider, { w: size, h: this.paneHeight });
		}else{
			slider.style.left = 0;
			slider.style.top = pos + 'px';
			dojo.marginBox(slider, { w: this.paneWidth, h: size });
		}
	},

	_growPane: function(growth, pane){
		if(growth > 0){
			if(pane.sizeActual > pane.sizeMin){
				if((pane.sizeActual - pane.sizeMin) > growth){

					// stick all the growth in this pane
					pane.sizeActual = pane.sizeActual - growth;
					growth = 0;
				}else{
					// put as much growth in here as we can
					growth -= pane.sizeActual - pane.sizeMin;
					pane.sizeActual = pane.sizeMin;
				}
			}
		}
		return growth;
	},

	_checkSizes: function(){

		var totalMinSize = 0;
		var totalSize = 0;
		var children = this.getChildren();

		dojo.forEach(children, function(child){
			totalSize += child.sizeActual;
			totalMinSize += child.sizeMin;
		});

		// only make adjustments if we have enough space for all the minimums

		if(totalMinSize <= totalSize){

			var growth = 0;

			dojo.forEach(children, function(child){
				if(child.sizeActual < child.sizeMin){
					growth += child.sizeMin - child.sizeActual;
					child.sizeActual = child.sizeMin;
				}
			});

			if(growth > 0){
				var list = this.isDraggingLeft ? children.reverse() : children;
				dojo.forEach(list, function(child){
					growth = this._growPane(growth, child);
				}, this);
			}
		}else{
			dojo.forEach(children, function(child){
				child.sizeActual = Math.round(totalSize * (child.sizeMin / totalMinSize));
			});
		}
	},

	beginSizing: function(e, i){
		var children = this.getChildren();
		this.paneBefore = children[i];
		this.paneAfter = children[i+1];

		this.isSizing = true;
		this.sizingSplitter = this.sizers[i];

		if(!this.cover){
			this.cover = dojo.create('div', {
					style: {
						position:'absolute',
						zIndex:5,
						top: 0,
						left: 0,
						width: "100%",
						height: "100%"
					}
				}, this.domNode);
		}else{
			this.cover.style.zIndex = 5;
		}
		this.sizingSplitter.style.zIndex = 6;

		// TODO: REVISIT - we want MARGIN_BOX and core hasn't exposed that yet (but can't we use it anyway if we pay attention? we do elsewhere.)
		this.originPos = dojo.position(children[0].domNode, true);
		if(this.isHorizontal){
			var client = e.layerX || e.offsetX || 0;
			var screen = e.pageX;
			this.originPos = this.originPos.x;
		}else{
			var client = e.layerY || e.offsetY || 0;
			var screen = e.pageY;
			this.originPos = this.originPos.y;
		}
		this.startPoint = this.lastPoint = screen;
		this.screenToClientOffset = screen - client;
		this.dragOffset = this.lastPoint - this.paneBefore.sizeActual - this.originPos - this.paneBefore.position;

		if(!this.activeSizing){
			this._showSizingLine();
		}

		//
		// attach mouse events
		//
		this._ownconnects = [];
		this._ownconnects.push(dojo.connect(dojo.doc.documentElement, "onmousemove", this, "changeSizing"));
		this._ownconnects.push(dojo.connect(dojo.doc.documentElement, "onmouseup", this, "endSizing"));

		dojo.stopEvent(e);
	},

	changeSizing: function(e){
		if(!this.isSizing){ return; }
		this.lastPoint = this.isHorizontal ? e.pageX : e.pageY;
		this.movePoint();
		if(this.activeSizing){
			this._updateSize();
		}else{
			this._moveSizingLine();
		}
		dojo.stopEvent(e);
	},

	endSizing: function(e){
		if(!this.isSizing){ return; }
		if(this.cover){
			this.cover.style.zIndex = -1;
		}
		if(!this.activeSizing){
			this._hideSizingLine();
		}

		this._updateSize();

		this.isSizing = false;

		if(this.persist){
			this._saveState(this);
		}

		dojo.forEach(this._ownconnects, dojo.disconnect);
	},

	movePoint: function(){

		// make sure lastPoint is a legal point to drag to
		var p = this.lastPoint - this.screenToClientOffset;

		var a = p - this.dragOffset;
		a = this.legaliseSplitPoint(a);
		p = a + this.dragOffset;

		this.lastPoint = p + this.screenToClientOffset;
	},

	legaliseSplitPoint: function(a){

		a += this.sizingSplitter.position;

		this.isDraggingLeft = !!(a > 0);

		if(!this.activeSizing){
			var min = this.paneBefore.position + this.paneBefore.sizeMin;
			if(a < min){
				a = min;
			}

			var max = this.paneAfter.position + (this.paneAfter.sizeActual - (this.sizerWidth + this.paneAfter.sizeMin));
			if(a > max){
				a = max;
			}
		}

		a -= this.sizingSplitter.position;

		this._checkSizes();

		return a;
	},

	_updateSize: function(){
	//FIXME: sometimes this.lastPoint is NaN
		var pos = this.lastPoint - this.dragOffset - this.originPos;

		var start_region = this.paneBefore.position;
		var end_region = this.paneAfter.position + this.paneAfter.sizeActual;

		this.paneBefore.sizeActual = pos - start_region;
		this.paneAfter.position	= pos + this.sizerWidth;
		this.paneAfter.sizeActual = end_region - this.paneAfter.position;

		dojo.forEach(this.getChildren(), function(child){
			child.sizeShare = child.sizeActual;
		});

		if(this._started){
			this.layout();
		}
	},

	_showSizingLine: function(){

		this._moveSizingLine();

		dojo.marginBox(this.virtualSizer,
			this.isHorizontal ? { w: this.sizerWidth, h: this.paneHeight } : { w: this.paneWidth, h: this.sizerWidth });

		this.virtualSizer.style.display = 'block';
	},

	_hideSizingLine: function(){
		this.virtualSizer.style.display = 'none';
	},

	_moveSizingLine: function(){
		var pos = (this.lastPoint - this.startPoint) + this.sizingSplitter.position;
		dojo.style(this.virtualSizer,(this.isHorizontal ? "left" : "top"),pos+"px");
		// this.virtualSizer.style[ this.isHorizontal ? "left" : "top" ] = pos + 'px'; // FIXME: remove this line if the previous is better
	},

	_getCookieName: function(i){
		return this.id + "_" + i;
	},

	_restoreState: function(){
		dojo.forEach(this.getChildren(), function(child, i){
			var cookieName = this._getCookieName(i);
			var cookieValue = dojo.cookie(cookieName);
			if(cookieValue){
				var pos = parseInt(cookieValue);
				if(typeof pos == "number"){
					child.sizeShare = pos;
				}
			}
		}, this);
	},

	_saveState: function(){
		if(!this.persist){
			return;
		}
		dojo.forEach(this.getChildren(), function(child, i){
			dojo.cookie(this._getCookieName(i), child.sizeShare, {expires:365});
		}, this);
	}
});

// These arguments can be specified for the children of a SplitContainer.
// Since any widget can be specified as a SplitContainer child, mix them
// into the base widget class.  (This is a hack, but it's effective.)
dojo.extend(dijit._Widget, {
	// sizeMin: [deprecated] Integer
	//		Deprecated.  Parameter for children of `dijit.layout.SplitContainer`.
	//		Minimum size (width or height) of a child of a SplitContainer.
	//		The value is relative to other children's sizeShare properties.
	sizeMin: 10,

	// sizeShare: [deprecated] Integer
	//		Deprecated.  Parameter for children of `dijit.layout.SplitContainer`.
	//		Size (width or height) of a child of a SplitContainer.
	//		The value is relative to other children's sizeShare properties.
	//		For example, if there are two children and each has sizeShare=10, then
	//		each takes up 50% of the available space.
	sizeShare: 10
});

}

if(!dojo._hasResource["plugins.view.jbrowse.js.Browser"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.view.jbrowse.js.Browser"] = true;
/**
 * Construct a new Browser object.
 * @class This class is the main interface between JBrowse and embedders
 * @constructor
 * @param params a dictionary with the following keys:<br>
 * <ul>
 * <li><code>containerID</code> - ID of the HTML element that contains the browser</li>
 * <li><code>refSeqs</code> - list of reference sequence information items (usually from refSeqs.js)</li>
 * <li><code>trackData</code> - list of track data items (usually from trackInfo.js)</li>
 * <li><code>dataRoot</code> - (optional) URL prefix for the data directory</li>
 * <li><code>browserRoot</code> - (optional) URL prefix for the browser code</li>
 * <li><code>tracks</code> - (optional) comma-delimited string containing initial list of tracks to view</li>
 * <li><code>location</code> - (optional) string describing the initial location</li>
 * <li><code>defaultTracks</code> - (optional) comma-delimited string containing initial list of tracks to view if there are no cookies and no "tracks" parameter</li>
 * <li><code>defaultLocation</code> - (optional) string describing the initial location if there are no cookies and no "location" parameter</li>
 * </ul>
 */

//var Browser = function(params) {

dojo.provide("plugins.view.jbrowse.js.Browser");

	
	
	
	
	
	



dojo.declare( "plugins.view.jbrowse.js.Browser",
	[ dijit._Widget, dijit._Templated, plugins.core.Common ], {

//Path to the template of this widget. 
templatePath: dojo.moduleUrl("", "../plugins/view/templates/browser.html"),

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

// CSS FILE FOR BUTTON STYLING
/* CHANGED */
cssFiles : [ "dojo-1.6.1rc2/dojox/layout/resources/ExpandoPane.css" ],

////}}}
constructor : function(args) {		
	//console.log("js.Browser.constructor	args:");
	//console.dir({args:args});
	
	// LOAD CSS
	this.loadCSS();
	
	// SET ARGS
	//this.attachWidget = Agua.tabs;
	this.viewObject = args.viewObject;
	this.parentWidget = args.parentWidget;
	this.projectName = args.projectName;
	this.viewName = args.viewName;
	this.speciesName = args.speciesName;
	this.buildName = args.buildName;

	this.location = args.location;
	this.locationObject = args.locationObject;

	this.params = args;
	this.refSeqs = args.refSeqs;
	this.trackData = args.trackData;
	this.deferredFunctions = [];

	this.tracks = args.tracks;
	this.trackList = args.trackList;
	//console.log("Browser.constructor	this.trackList: " + dojo.toJson(this.trackList));
	
	//this.baseUrl = args.baseUrl;

	this.dataRoot = args.dataRoot;
	this.dataRoot;
	if ("dataRoot" in args)
		dataRoot = args.dataRoot;
	else
		dataRoot = "";
		
	
	this.attachWidget = args.attachWidget;
	//console.log("Browser.constructor	this.attachWidget: " + this.attachWidget);
	
},

postCreate: function() {
	this.startup();
},

startup : function () {
	//console.log("Browser.startup	plugins.view.jbrowse.js.Browser.startup()");

	// SET UP THE ELEMENT OBJECTS AND THEIR VALUE FUNCTIONS
	this.inherited(arguments);

	// ADD THE PANE TO THE TAB CONTAINER
	this.attachWidget.addChild(this.mainTab);
	this.attachWidget.selectChild(this.mainTab);

	//console.log("Browser.startup	this.viewObject: " + dojo.toJson(this.viewObject));

	// SET TITLE
	this.mainTab.set('title', this.viewObject.project + "." + this.viewObject.view); 

	// SET SPECIES AND BUILD
	this.topPane.titleNode.innerHTML = this.firstLetterUpperCase(this.viewObject.species) + " (" + this.viewObject.build + ")";


// CHANGED IN THE REST OF THIS (startup) METHOD
// FROM:			TO:
// params.refSeqs	this.refSeqs
// params.trackDAta	this.trackData
// params.dataRoot	this.dataRoot

	this.deferredFunctions = [];

	var refSeqs = this.refSeqs;
	//console.log("plugins.view.js.jbrowse.Browser.startup    refSeqs: " + dojo.toJson(refSeqs));
	var trackData = this.trackData;
	var dataRoot = this.dataRoot || "";
	
//	var refSeqs = params.refSeqs;
//	var trackData = params.trackData;
//	this.deferredFunctions = [];
//	this.dataRoot = params.dataRoot;
//	var dataRoot;
//	if ("dataRoot" in params)
//		dataRoot = params.dataRoot;
//	else
//		dataRoot = "";

	//console.log("js.Browser.startup    dataRoot: " + dataRoot);

	this.names = new LazyTrie(dataRoot + "data/names/lazy-",
//	this.names = new LazyTrie(dataRoot + "/names/lazy-",
				  dataRoot + "data/names/root.json");
	////console.log("js.Browser.startup    names:");
	////console.dir({names:names});

	
	this.tracks = [];
	var brwsr = this;
	brwsr.isInitialized = false;

//	dojo.addOnLoad(
//		function() {

		//set up top nav/overview pane and main GenomeView pane
//			dojo.addClass(document.body, "tundra");
//			brwsr.container = dojo.byId(params.containerID);

	brwsr.container = this.mainTab;
	brwsr.container.genomeBrowser = brwsr;

//			var topPane = document.createElement("div");
//			brwsr.container.appendChild(topPane);

//			var overview = document.createElement("div");
//			overview.className = "overview";
//			overview.id = "overview";
//			topPane.appendChild(overview);

	//try to come up with a good estimate of how big the location box
	//actually has to be
	var maxBase = refSeqs.reduce(function(a,b) {return a.end > b.end ? a : b;}).end;
//			var navbox = brwsr.createNavBox(topPane, (2 * (String(maxBase).length + (((String(maxBase).length / 3) | 0) / 2))) + 2, params);
	var navbox = this.createNavBox(this.topPane, (2 * (String(maxBase).length + (((String(maxBase).length / 3) | 0) / 2))) + 2, this.params);



//			var viewElem = document.createElement("div");
//			brwsr.container.appendChild(viewElem);
//			viewElem.className = "dragWindow";

//			var containerWidget = new dijit.layout.BorderContainer({
//				liveSplitters: false,
//				design: "sidebar",
//				gutters: false
//			}, brwsr.container);
//			var contentWidget = new dijit.layout.ContentPane({region: "top"}, topPane);
//			var browserWidget = new dijit.layout.ContentPane({region: "center"}, viewElem);

	// GET contentWidget AND browserWidget
	var contentWidget = this.topPane;
	var browserWidget = this.centerPane;


// LATER: CONVERT THIS TO MARKUP
	//create location trapezoid
	brwsr.locationTrap = document.createElement("div");
	brwsr.locationTrap.className = "locationTrap";

	this.topPane.domNode.appendChild(brwsr.locationTrap);
	//			topPane.appendChild(brwsr.locationTrap);
	//			topPane.style.overflow="hidden";

	//set up ref seqs
	brwsr.allRefs = {};
	for (var i = 0; i < refSeqs.length; i++)
		brwsr.allRefs[refSeqs[i].name] = refSeqs[i];



//			var refCookie = dojo.cookie(params.containerID + "-refseq");
	//var refCookie = dojo.cookie(this.params.containerID + "-refseq");

	brwsr.refSeq = refSeqs[0];
	//console.log("js.Browser.startup    this.locationObject: " + dojo.toJson(this.locationObject));
	
	for (var i = 0; i < refSeqs.length; i++) {

		brwsr.chromList.options[i] = new Option(refSeqs[i].name,
												refSeqs[i].name);
		if (refSeqs[i].name.toUpperCase() == this.locationObject.name.toUpperCase() ) {
			//console.log("js.Browser.startup    MATCHED REFSEQ: " + brwsr.allRefs[refSeqs[i].name]);
			brwsr.refSeq = brwsr.allRefs[refSeqs[i].name];
			brwsr.chromList.selectedIndex = i;
		}

		//if (refSeqs[i].name.toUpperCase() == String(refCookie).toUpperCase()) {
		//	brwsr.refSeq = brwsr.allRefs[refSeqs[i].name];
		//	brwsr.chromList.selectedIndex = i;
		//}
	}

	dojo.connect(brwsr.chromList, "onchange", function(event) {

		//var oldLocMap = dojo.fromJson(dojo.cookie(brwsr.container.id + "-location")) || {};

		//console.log("js.Browser.startup    chromoList.onchange fired    dojo.cookie(brwsr.container.id + '-location'): " + dojo.cookie(brwsr.container.id + "-location"));

		var newRef = brwsr.allRefs[brwsr.chromList.options[brwsr.chromList.selectedIndex].value];

		//if (oldLocMap[newRef.name])
		//	brwsr.navigateTo(newRef.name + ":"
		//					 + oldLocMap[newRef.name]);
		//else

			brwsr.navigateTo(newRef.name + ":"
							 + (((newRef.start + newRef.end) * 0.4) | 0)
							 + " .. "
							 + (((newRef.start + newRef.end) * 0.6) | 0));
	});

	//hook up GenomeView
//			var gv = new GenomeView(viewElem, 250, brwsr.refSeq, 1/200);
	var gv = new GenomeView(this.viewElem.containerNode, 250, brwsr.refSeq, 1/200, this);
	brwsr.view = gv;
//			brwsr.viewElem = viewElem;
	brwsr.viewElem = this.viewElem;
	//gv.setY(0);
//			viewElem.view = gv;
	this.viewElem.view = gv;

	dojo.connect(browserWidget, "resize", function() {
			gv.sizeInit();

			brwsr.view.locationTrapHeight = dojo.marginBox(navbox).h;
			gv.showVisibleBlocks();
			gv.showFine();
			gv.showCoarse();
		});
	brwsr.view.locationTrapHeight = dojo.marginBox(navbox).h;

	dojo.connect(gv, "onFineMove", brwsr, "onFineMove");
	dojo.connect(gv, "onCoarseMove", brwsr, "onCoarseMove");

	//set up track list
//			var trackListDiv = brwsr.createTrackList(brwsr.container, params);
//	var trackListDiv = brwsr.createTrackList(brwsr.container, this.params);
//			containerWidget.startup();

	//console.log("js.Browser.startup    Doing trackListDiv = brwsr.createTrackList(brwsr.container, this.params)");


	//console.log("js.Browser.startup    this.params: ");
	//console.dir({params:this.params});
	var trackListDiv = brwsr.createTrackList(brwsr.container, this.params);

	brwsr.isInitialized = true;

	// set initial location
	var oldLocMap = dojo.fromJson(dojo.cookie(brwsr.container.id + "-location")) || {};
	//console.log("js.Browser.startup    BEFORE CALL TO this.navigateTo");
	//console.log("js.Browser.startup    this.params.location: " + this.params.location);
//			if (params.location) {
//				brwsr.navigateTo(params.location);
	if (this.params.location) {
		brwsr.navigateTo(this.params.location);
	} else if (oldLocMap[brwsr.refSeq.name]) {
		brwsr.navigateTo(brwsr.refSeq.name
						 + ":"
						 + oldLocMap[brwsr.refSeq.name]);
//			} else if (params.defaultLocation){
//				brwsr.navigateTo(params.defaultLocation);
	} else if (this.params.defaultLocation){
		brwsr.navigateTo(this.params.defaultLocation);
	} else {
		brwsr.navigateTo(brwsr.refSeq.name
						 + ":"
						 + ((((brwsr.refSeq.start + brwsr.refSeq.end)
							  * 0.4) | 0)
							+ " .. "
							+ (((brwsr.refSeq.start + brwsr.refSeq.end)
								* 0.6) | 0)));
	}

	//if someone calls methods on this browser object
	//before it's fully initialized, then we defer
	//those functions until now
	for (var i = 0; i < brwsr.deferredFunctions.length; i++)
	brwsr.deferredFunctions[i]();
	brwsr.deferredFunctions = [];
//		});
//};
},
/**
 * @private
 */
//onFineMove = function(startbp, endbp) {
onFineMove : function(startbp, endbp) {
	var length = this.view.ref.end - this.view.ref.start;
	var trapLeft = Math.round((((startbp - this.view.ref.start) / length)
							   * this.view.overviewBox.w) + this.view.overviewBox.l);
	var trapRight = Math.round((((endbp - this.view.ref.start) / length)
								* this.view.overviewBox.w) + this.view.overviewBox.l);
	var locationTrapStyle;
	if (dojo.isIE) {
		//IE apparently doesn't like borders thicker than 1024px
		locationTrapStyle =
			"top: " + this.view.overviewBox.t + "px;"
			+ "height: " + this.view.overviewBox.h + "px;"
			+ "left: " + trapLeft + "px;"
			+ "width: " + (trapRight - trapLeft) + "px;"
			+ "border-width: 0px";
	} else {
		locationTrapStyle =
			"top: " + this.view.overviewBox.t + "px;"
			+ "height: " + this.view.overviewBox.h + "px;"
			+ "left: " + this.view.overviewBox.l + "px;"
			+ "width: " + (trapRight - trapLeft) + "px;"
			+ "border-width: " + "0px "
			+ (this.view.overviewBox.w - trapRight) + "px "
			+ this.view.locationTrapHeight + "px " + trapLeft + "px;";
	}

	this.locationTrap.style.cssText = locationTrapStyle;
//};
},
/**
 * @private
 */
//createTrackList = function(parent, params) {
createTrackList : function(parent, params) {
	//console.log("js.Browser.createTrackList    js.Browser.createTrackList    (parent, params)");
	//console.log("js.Browser.createTrackList    params: ");
	//console.dir({params:params});

	// ADDED: HOOK TO CONTAINER NODE IN TEMPLATE
//	var leftPane = document.createElement("div");
//	leftPane.style.cssText="width: 10em";
//	parent.appendChild(leftPane);
	var leftPane = this.leftPane.containerNode;

	// ADDED: HOOK TO LEFT PANE IN TEMPLATE
//	var leftWidget = new dijit.layout.ContentPane({region: "left", splitter: true}, leftPane);
	var leftWidget = this.leftPane;
	var trackListDiv = document.createElement("div");
	//trackListDiv.id = "tracksAvail";
	trackListDiv.className = "container handles";
	trackListDiv.style.cssText =
		"width: 100%; height: 100%; overflow-x: hidden; overflow-y: auto; text-align: center";
	trackListDiv.innerHTML = ""
		//"(Drag Tracks<img src=\""
		//+ (params.browserRoot ? params.browserRoot : "")
		//+ "img/right_arrow.png\"/> To View)<br/>";	
	leftPane.appendChild(trackListDiv);

	var brwsr = this;

	var changeCallback = function() {
		brwsr.view.showVisibleBlocks(true);
	};

	var setNodeDblClick = function (node, url) {
		console.log("js.Browser.trackListCreate    setNodeDblClick     url: "  + url);

		node.ondblclick = function(event) {
			console.log("js.Browser.trackListCreate    DOING node.DOUBLECLICK url: "  + url);
			window.open(url, "_blank");
			event.stopPropagation();
		};
	};


	var trackListCreate = function(track, hint) {

//console.log("js.Browser.createTrackList    trackListCreate track:");
//console.dir({track:track});

		var node = document.createElement("div");
		node.className = "tracklist-label";
		node.innerHTML = track.key;

		// ADDED: ONCLICK IF trackInfo.infoUrl EXISTS
		for ( var i = 0; i < params.trackData.length; i++ ) {
			if ( params.trackData[i].label == track.label ) {
				if ( params.trackData[i].urlInfo ) {
					setNodeDblClick(node, params.trackData[i].urlInfo);
				}
				break;
			}		
		}
		
		// ADDED: source LABEL CLASS
		for ( var i = 0; i < params.trackData.length; i++ ) {
			
			if ( params.trackData[i].label == track.label ) {
				dojo.addClass(node, params.trackData[i].label + "-label");
				if ( params.trackData[i].sourceType != null ) {
					dojo.addClass(node, params.trackData[i].sourceType + "-label");
				}
				continue;
			}	
		}

		//in the list, wrap the list item in a container for
		//border drag-insertion-point monkeying
		if ("avatar" != hint) {
			var container = document.createElement("div");
			container.className = "tracklist-container";
			container.appendChild(node);
			node = container;
		}
//		// SET FANCY FORMAT IN NODE INNERHTML
//		else {
//			var avatarHtml = "<table><tr>"; 
//			avatarHtml += "<td class='dojoDndAvatarHeader'><strong style='color: darkred'>" + track.label + "</strong></td>";
//			//if ( track.sourceType )
//			//	avatarHtml += "<td class=\"" + track.sourceType + "-label\"></td>";
//			avatarHtml += "</tr></table>";
//			node.innerHTML = avatarHtml;
//			dojo.addClass(node, track.label + "-label");
//			if ( track.sourceType )
//				dojo.addClass(node, track.sourceType + "-label");
//			
//		}
		node.id = dojo.dnd.getUniqueId();
		return {node: node, data: track, type: ["track"]};
	};

	this.listTracks = function () {
		var allNodes = brwsr.viewDndWidget.getAllNodes();
		//console.dir({allNodes:allNodes});
		var array = [];
		for ( var i = 0; i < allNodes.length; i++ ) {
			array.push(allNodes[i].track.name);
		}
		var tracklist = array.join(',');
		return tracklist;
	};

	this.trackListWidget = new dojo.dnd.Source(trackListDiv,
		{
			creator: trackListCreate,
			accept: ["track"],
			withHandles: false
		}
	);

	var trackCreate = function(track, hint) {
		var node;
		if ("avatar" == hint) {
			return trackListCreate(track, hint);
		} else {
			var replaceData = {refseq: brwsr.refSeq.name};
			var url = track.url.replace(/\{([^}]+)\}/g, function(match, group) {return replaceData[group];});
			var klass = eval(track.type);
			
			// NB: trackBaseUrl IS BROWSER dataRoot
			var trackBaseUrl = brwsr.dataRoot;

			var newTrack = new klass(track, url, brwsr.refSeq,
			{
				changeCallback: changeCallback,
				trackPadding: brwsr.view.trackPadding,

				parentWidget: brwsr.parentWidget,

				//ADDED: CHANGED baseUrl TO trackBaseUrl
				//baseUrl: brwsr.dataRoot,
				baseUrl: trackBaseUrl,

				charWidth: brwsr.view.charWidth,
				seqHeight: brwsr.view.seqHeight
			});
			node = brwsr.view.addTrack(newTrack);


			// ADDED: ADD NEW TRACK IN CORRECT ORDER TO TRACKLIST IN View.js
			setTimeout(
				function ()
				{
					brwsr.viewObject.tracklist = brwsr.listTracks();
					brwsr.parentWidget.updateViewTracklist(brwsr.viewObject);
				},
				100
			);
		}
		return {node: node, data: track, type: ["track"]};
	};

	this.viewDndWidget = new dojo.dnd.Source(this.view.zoomContainer,
		{
			creator: trackCreate,
			accept: ["track"],
			withHandles: true
		});
	
	
	dojo.subscribe("/dnd/drop", function(source,nodes,iscopy){

//console.log("js.Browser.createTrackList    inside dojo.subscribe('/dnd/drop')    source:");
//console.dir({source:source});

		brwsr.onVisibleTracksChanged();
		//multi-select too confusing?
		//brwsr.viewDndWidget.selectNone();

		// ADDED: SIGNAL REMOVE TRACK IN View.js
		// NB: USE track.name FOR NAME OF TRACK
		if ( source === brwsr.viewDndWidget )
		{
			//console.log("js.Browser.createTrackList    /dnd/drop   nodes[0].track.name: " + nodes[0].track.name);
			//console.dir({track:nodes[0].track});
			//console.dir({trackListWidget:brwsr.trackListWidget});
			//console.dir({viewDndWidget:brwsr.viewDndWidget});

			// ADD/REMOVE UPDATE TRACKLIST IN View.js
			if ( source.anchor == null ) {
				brwsr.parentWidget.handleTrackChange(brwsr.viewObject, nodes[0].track.name, "remove");
			}
			else {
				//console.log("js.Browser.createTrackList    MOVED TRACK. UPDATE TRACK ORDERING");
				brwsr.viewObject.tracklist = brwsr.listTracks();
				brwsr.parentWidget.updateViewTracklist(brwsr.viewObject);
			}
		}
	});


	this.trackListWidget.insertNodes(false, params.trackData);

	/*CHANGED */
	var oldTrackList = this.trackList;
	// GET TRACK LIST FROM USER-INPUT ARGS OR USE
	// DEFAULT TRACK LIST FROM LAST TIME USED
//	var oldTrackList = dojo.cookie(this.container.id + "-tracks");
	//if ( oldTrackList == null || ! oldTrackList )
	//{
	//	oldTrackList = dojo.cookie(this.container.id + "-tracks");
	//}


	if (params.tracks) {
		this.showTracks(params.tracks);
	} else if (oldTrackList) {
		this.showTracks(oldTrackList);
	} else if (params.defaultTracks) {
		this.showTracks(params.defaultTracks);
	}

	return trackListDiv;
//};
},
/**
 * @private
 */
//onVisibleTracksChanged = function() {
onVisibleTracksChanged : function() {


	this.view.updateTrackList();


	var trackLabels = dojo.map(this.view.tracks,
							   function(track) { return track.name; });
	
	/*CHANGED */
	//dojo.cookie(this.container.id + "-tracks",
	//			trackLabels.join(","),
	//			{expires: 60});


	this.view.showVisibleBlocks();
//};
},
/**
 * @private
 * add new tracks to the track list
 * @param trackList list of track information items
 * @param replace true if this list of tracks should replace any existing
 * tracks, false to merge with the existing list of tracks
 */
//addTracks = function(trackList, replace) {
addTracks : function(trackList, replace) {

//console.log("Browser.addTracks(trackList, replace)");
//console.log("Browser.addTracks    trackList: " + dojo.toJson(trackList));
//console.log("Browser.addTracks    replace: " + replace);

	if (!this.isInitialized) {
		var brwsr = this;
		this.deferredFunctions.push(
			function() {brwsr.addTracks(trackList, show); }
		);
	return;
	}

	this.tracks.concat(trackList);
	if (show || (show === undefined)) {
		this.showTracks(dojo.map(trackList,
								 function(t) {return t.label;}).join(","));
	}
//};
},
/**
 * navigate to a given location
 * @example
 * gb=dojo.byId("GenomeBrowser").genomeBrowser
 * gb.navigateTo("ctgA:100..200")
 * gb.navigateTo("f14")
 * @param loc can be either:<br>
 * &lt;chromosome&gt;:&lt;start&gt; .. &lt;end&gt;<br>
 * &lt;start&gt; .. &lt;end&gt;<br>
 * &lt;center base&gt;<br>
 * &lt;feature name/ID&gt;
 */
//navigateTo = function(loc) {
navigateTo : function(loc) {
	//console.log("js.Browser.navigateTo    js.Browser.navigateTo(loc)");
	//console.log("js.Browser.navigateTo    caller: " + this.navigateTo.caller.nom);
	//console.log("js.Browser.navigateTo    this.isInitialized: " + this.isInitialized);

	if (!this.isInitialized) {
		//console.log("js.Browser.navigateTo    NOT this.isInitialized");
		var brwsr = this;
		this.deferredFunctions.push(function() { brwsr.navigateTo(loc); });
	return;
	}

	//console.log("js.Browser.navigateTo    loc: " + loc);
	loc = dojo.trim(loc);

	//								(chromosome)	(	start	  )   (  sep	 )	 (	end   )

	// MOVED TO NAVBOX 'Save Location' BUTTON
	//////// ADDED: CONNECT TO browser.navigateTo TO DO this.updateViewLocation
	//////this.parentWidget.updateViewLocation(this.viewObject, loc, this.chromList.value);

	var matches = String(loc).match(/^(((\S*)\s*:)?\s*(-?[0-9,.]*[0-9])\s*(\.\.|-|\s+))?\s*(-?[0-9,.]+)$/i);
	//matches potentially contains location components:
	//matches[3] = chromosome (optional)
	//matches[4] = start base (optional)
	//matches[6] = end base (or center base, if it's the only one)
	if (matches) {
	if (matches[3]) {
		var refName;
		for (ref in this.allRefs) {
		if ((matches[3].toUpperCase() == ref.toUpperCase())
					||
					("CHR" + matches[3].toUpperCase() == ref.toUpperCase())
					||
					(matches[3].toUpperCase() == "CHR" + ref.toUpperCase())) {

			refName = ref;
				}
			}
		if (refName) {


		//console.log("js.Browser.navigateTo    adding cookie: " + this.container.id + "-refseq"+ refName);
		//dojo.cookie(this.container.id + "-refseq", refName, {expires: 60});


		if (refName == this.refSeq.name) {
			//go to given start, end on current refSeq
			this.view.setLocation(this.refSeq,
					  parseInt(matches[4].replace(/[,.]/g, "")),
					  parseInt(matches[6].replace(/[,.]/g, "")));
		} else {
			//new refseq, record open tracks and re-open on new refseq
					var curTracks = [];
					this.viewDndWidget.forInItems(function(obj, id, map) {
							curTracks.push(obj.data);
						});

			for (var i = 0; i < this.chromList.options.length; i++)
			if (this.chromList.options[i].text == refName)
				this.chromList.selectedIndex = i;
			this.refSeq = this.allRefs[refName];
			//go to given refseq, start, end
			this.view.setLocation(this.refSeq,
					  parseInt(matches[4].replace(/[,.]/g, "")),
					  parseInt(matches[6].replace(/[,.]/g, "")));

					this.viewDndWidget.insertNodes(false, curTracks);
					this.onVisibleTracksChanged();
		}
		return;
		}
	} else if (matches[4]) {
		//go to start, end on this refseq
		this.view.setLocation(this.refSeq,
				  parseInt(matches[4].replace(/[,.]/g, "")),
				  parseInt(matches[6].replace(/[,.]/g, "")));
		return;
	} else if (matches[6]) {
		//center at given base
		this.view.centerAtBase(parseInt(matches[6].replace(/[,.]/g, "")));
		return;
	}
	}
	//if we get here, we didn't match any expected location format

	var brwsr = this;
	this.names.exactMatch(loc, function(nameMatches) {
		var goingTo;
		//first check for exact case match
		for (var i = 0; i < nameMatches.length; i++) {
		if (nameMatches[i][1] == loc)
			goingTo = nameMatches[i];
		}
		//if no exact case match, try a case-insentitive match
			if (!goingTo) {
				for (var i = 0; i < nameMatches.length; i++) {
					if (nameMatches[i][1].toLowerCase() == loc.toLowerCase())
						goingTo = nameMatches[i];
				}
			}
			//else just pick a match
		if (!goingTo) goingTo = nameMatches[0];
		var startbp = goingTo[3];
		var endbp = goingTo[4];
		var flank = Math.round((endbp - startbp) * .2);
		//go to location, with some flanking region
		brwsr.navigateTo(goingTo[2]
				 + ":" + (startbp - flank)
				 + ".." + (endbp + flank));
		brwsr.showTracks(brwsr.names.extra[nameMatches[0][0]]);
	});
//};
},
/**
 * load and display the given tracks
 * @example
 * gb=dojo.byId("GenomeBrowser").genomeBrowser
 * gb.showTracks("DNA,gene,mRNA,noncodingRNA")
 * @param trackNameList {String} comma-delimited string containing track names,
 * each of which should correspond to the "label" element of the track
 * information dictionaries
 */
//showTracks = function(trackNameList) {
showTracks : function(trackNameList) {

//console.log("js.Browser.showTracks    trackNameList: " + trackNameList);
	if (!this.isInitialized) {

//console.log("js.Browser.showTracks    PUSHING ONTO this.deferredFunctions: showTracks(trackNameList)");

		var brwsr = this;
		this.deferredFunctions.push(
			function() { brwsr.showTracks(trackNameList); }
		);
	return;
	}

	//console.log("js.Browser.showTracks    Past check for ! this.isInitialized");

	var trackNames = trackNameList.split(",");

	//console.log("js.Browser.showTracks    trackNames: " + dojo.toJson(trackNames));
	//console.log("js.Browser.showTracks    this.trackListWidget: ");
	//console.dir({trackListWidget:this.trackListWidget});

	var removeFromList = [];
	var brwsr = this;
	for (var n = 0; n < trackNames.length; n++) {
		this.trackListWidget.forInItems(function(obj, id, map) {
//console.log("js.Browser.showTracks    trackNames[n]: " + trackNames[n] );
//console.log("js.Browser.showTracks    obj.data.label: " + obj.data.label );
//
			if (trackNames[n] == obj.data.label) {
//console.log("js.Browser.showTracks    Matched. Doing brwsr.viewDndWidget.insertNodes(false, [obj.data])" );

				brwsr.viewDndWidget.insertNodes(false, [obj.data]);
				removeFromList.push(id);
			}
		});
	}

//console.log("js.Browser.showTracks    removeFromList: " + dojo.toJson(removeFromList) );

	var movedNode;
	for (var i = 0; i < removeFromList.length; i++) {
		this.trackListWidget.delItem(removeFromList[i]);

		movedNode = dojo.byId(removeFromList[i]);
		//console.log("js.Browser.showTracks    movedNode = dojo.byId(removeFromList[i]): " + movedNode);

		//// ADDED: TO AVOID ERROR IF movedNode IS NULL
		//if ( movedNode == null )
		//{
		//	setTimeout(function(){
				movedNode = dojo.byId(removeFromList[i]);
				movedNode.parentNode.removeChild(movedNode);
		//	}, 1000);
		//
		//	//this.deferredFunctions.push(
		//	//function() {
		//	//	try {
		//	//		movedNode = dojo.byId(removeFromList[i]);
		//	//		movedNode.parentNode.removeChild(movedNode);
		//	//	}
		//	//	catch(e) {
		//	//		//console.log("js.Browser.showTracks    Could not do deferredFunction movedNode.parentNode.removeChild(movedNode)");
		//	//	}
		//	//});
		//}
		//else
		//{
		//	movedNode = dojo.byId(removeFromList[i]);
		//	movedNode.parentNode.removeChild(movedNode);
		//}
	}
	this.onVisibleTracksChanged();
//};
},
/**
 * @returns {String} string representation of the current location<br>
 * (suitable for passing to navigateTo)
 */
//visibleRegion = function() {
visibleRegion : function() {
	return this.view.ref.name + ":" + Math.round(this.view.minVisible()) + ".." + Math.round(this.view.maxVisible());
//};
},
/**
 * @returns {String} containing comma-separated list of currently-viewed tracks<br>
 * (suitable for passing to showTracks)
 */
//visibleTracks = function() {
visibleTracks : function() {
	var trackLabels = dojo.map(this.view.tracks,
							   function(track) { return track.name; });
	return trackLabels.join(",");
//};
},
/**
 * @private
 */
//onCoarseMove = function(startbp, endbp) {
onCoarseMove : function(startbp, endbp) {
	//console.log("js.Browser.onCoarseMove    js.Browser.onCoarseMove(startbp, endbp)");
	//console.log("js.Browser.onCoarseMove    startbp: " + dojo.toJson(startbp));
	//console.log("js.Browser.onCoarseMove    endbp: " + dojo.toJson(endbp));

	if ( ! startbp || ! endbp ) {
		//console.log("js.Browser.onCoarseMove    ! startbp or ! endbp");
		return;
	}

	//if ( this.onCoarseMove.caller )
	//	//console.log("js.Browser.onCoarseMove    caller: " + this.onCoarseMove.caller.nom);

	//console.log("js.Browser.onCoarseMove    this.isInitialized: " + this.isInitialized);
	if (!this.isInitialized) {
		//console.log("js.Browser.onCoarseMove    NOT this.isInitialized");
		return;
	}

	var length = this.view.ref.end - this.view.ref.start;
	var trapLeft = Math.round((((startbp - this.view.ref.start) / length)
							   * this.view.overviewBox.w) + this.view.overviewBox.l);
	var trapRight = Math.round((((endbp - this.view.ref.start) / length)
								* this.view.overviewBox.w) + this.view.overviewBox.l);

	//console.log("js.Browser.onCoarseMove    here 1");

	this.view.locationThumb.style.cssText =
	"height: " + (this.view.overviewBox.h - 4) + "px; "
	+ "left: " + trapLeft + "px; "
	+ "width: " + (trapRight - trapLeft) + "px;"
	+ "z-index: 20";
	//console.log("js.Browser.onCoarseMove    here 2");

	//since this method gets triggered by the initial GenomeView.sizeInit,
	//we don't want to save whatever location we happen to start at
	if (! this.isInitialized) return;
	var locString = Util.addCommas(Math.round(startbp)) + " .. " + Util.addCommas(Math.round(endbp));
	this.locationBox.value = locString;
	this.goButton.disabled = true;
	this.locationBox.blur();

	//console.log("js.Browser.onCoarseMove    here 3");

	// MOVED: TO NAVBOX 'Save Location' BUTTON
	// ADDED: UPDATE LOCATION IN View.js AND ON SERVER
	//console.log("js.Browser.onCoarseMove    locString: " + dojo.toJson(locString));
	//this.parentWidget.updateViewLocation(this.viewObject, locString, this.chromList.value);
	//console.log("js.Browser.onCoarseMove    here 4");

	
	//var oldLocMap = dojo.fromJson(dojo.cookie(this.container.id + "-location"));

	//if ((typeof oldLocMap) != "object") oldLocMap = {};
	//oldLocMap[this.refSeq.name] = locString;
	//

	//dojo.cookie(this.container.id + "-location",
	//			dojo.toJson(oldLocMap),
	//			{expires: 60});


	document.title = this.refSeq.name + ":" + locString;
//};
},
/**
 * @private
 */
//createNavBox = function(parent, locLength, params) {
createNavBox : function(parent, locLength, params) {
	var brwsr = this;
//	var navbox = document.createElement("div");
	var browserRoot = params.browserRoot ? params.browserRoot : "";
	var navbox = this.navbox;
//	navbox.id = "navbox";
//	parent.appendChild(navbox);
//	navbox.style.cssText = "text-align: center; padding: 2px; z-index: 10;";

	if (params.bookmark) {
		this.link = document.createElement("a");
		this.link.appendChild(document.createTextNode("Link"));
		this.link.href = window.location.href;
		dojo.connect(this, "onCoarseMove", function() {
						 brwsr.link.href = params.bookmark(brwsr);
					 });
		dojo.connect(this, "onVisibleTracksChanged", function() {
						 brwsr.link.href = params.bookmark(brwsr);
					 });
		this.link.style.cssText = "float: right; clear";
		navbox.appendChild(this.link);
	}

		// ADDED: 'Save Location' BUTTON WITH CONNECT TO
	// parentWidget.updateViewLocation
	this.saveButton = document.createElement("button");
	this.saveButton.appendChild(document.createTextNode("Save Location"));
	dojo.addClass(this.saveButton, "saveButton");

	dojo.connect(this.saveButton, "click", function(event) {
		//console.log("Browser.createNavBox    Save Location Button click    brwsr.locationBox.value: " + brwsr.locationBox.value);
		brwsr.parentWidget.updateViewLocation(brwsr.viewObject, brwsr.locationBox.value, brwsr.chromList.value);
		dojo.stopEvent(event);
	});
	navbox.appendChild(this.saveButton);
	
	
	var moveLeft = document.createElement("input");
	moveLeft.type = "image";
	moveLeft.src = browserRoot + "img/slide-left.png";
	//console.log("js.Browser.createNavBox    browserRoot: "  + browserRoot);
	//console.log("js.Browser.createNavBox    moveLeft.src: "  + moveLeft.src);
	moveLeft.id = "moveLeft";
	moveLeft.className = "icon nav";
	moveLeft.style.height = "40px";
	dojo.connect(moveLeft, "click",
				 function(event) {
					 dojo.stopEvent(event);
					 brwsr.view.slide(0.9);
				 });
	navbox.appendChild(moveLeft);

	var moveRight = document.createElement("input");
	moveRight.type = "image";
	moveRight.src = browserRoot + "img/slide-right.png";
	moveRight.id="moveRight";
	moveRight.className = "icon nav";
	moveRight.style.height = "40px";
	dojo.connect(moveRight, "click",
				 function(event) {
					 dojo.stopEvent(event);
					 brwsr.view.slide(-0.9);
				 });
	navbox.appendChild(moveRight);

	navbox.appendChild(document.createTextNode("\u00a0\u00a0\u00a0\u00a0"));

	var bigZoomOut = document.createElement("input");
	bigZoomOut.type = "image";
	bigZoomOut.src = browserRoot + "img/zoom-out-2.png";
	bigZoomOut.id = "bigZoomOut";
	bigZoomOut.className = "icon nav";
	bigZoomOut.style.height = "40px";
	navbox.appendChild(bigZoomOut);
	dojo.connect(bigZoomOut, "click",
				 function(event) {
					 dojo.stopEvent(event);
					 brwsr.view.zoomOut(undefined, undefined, 2);
				 });

	var zoomOut = document.createElement("input");
	zoomOut.type = "image";
	zoomOut.src = browserRoot + "img/zoom-out-1.png";
	zoomOut.id = "zoomOut";
	zoomOut.className = "icon nav";
	zoomOut.style.height = "40px";
	dojo.connect(zoomOut, "click",
				 function(event) {
					 dojo.stopEvent(event);
					 brwsr.view.zoomOut();
				 });
	navbox.appendChild(zoomOut);

	var zoomIn = document.createElement("input");
	zoomIn.type = "image";
	zoomIn.src = browserRoot + "img/zoom-in-1.png";
	zoomIn.id = "zoomIn";
	zoomIn.className = "icon nav";
	zoomIn.style.height = "40px";
	dojo.connect(zoomIn, "click",
				 function(event) {
					 dojo.stopEvent(event);
					 brwsr.view.zoomIn();
				 });
	navbox.appendChild(zoomIn);

	var bigZoomIn = document.createElement("input");
	bigZoomIn.type = "image";
	bigZoomIn.src = browserRoot + "img/zoom-in-2.png";
	bigZoomIn.id = "bigZoomIn";
	bigZoomIn.className = "icon nav";
	bigZoomIn.style.height = "40px";
	dojo.connect(bigZoomIn, "click",
				 function(event) {
					 dojo.stopEvent(event);
					 brwsr.view.zoomIn(undefined, undefined, 2);
				 });
	navbox.appendChild(bigZoomIn);

	navbox.appendChild(document.createTextNode("\u00a0\u00a0\u00a0\u00a0"));

	this.chromList = document.createElement("select");
	this.chromList.id="chrom";
	
	// ADDED: CHROMLIST CSS CLASS
	dojo.addClass(this.chromList, "chromList");

	
	navbox.appendChild(this.chromList);
	this.locationBox = document.createElement("input");
	this.locationBox.size=locLength;
	this.locationBox.type="text";
	this.locationBox.id="location";
	dojo.connect(this.locationBox, "keydown", function(event) {
			if (event.keyCode == dojo.keys.ENTER) {
				brwsr.navigateTo(brwsr.locationBox.value);
				//brwsr.locationBox.blur();
				brwsr.goButton.disabled = true;
				dojo.stopEvent(event);
			} else {
				brwsr.goButton.disabled = false;
			}
		});
	navbox.appendChild(this.locationBox);

	this.goButton = document.createElement("button");
	this.goButton.appendChild(document.createTextNode("Go"));
	this.goButton.disabled = true;
	dojo.connect(this.goButton, "click", function(event) {
			brwsr.navigateTo(brwsr.locationBox.value);
			//brwsr.locationBox.blur();
			brwsr.goButton.disabled = true;
			dojo.stopEvent(event);
		});
	navbox.appendChild(this.goButton);

	// ADDED: 'Go' BUTTON CLASS
	dojo.addClass(this.goButton, "goButton");

	
	return navbox;
	}
});

/*

Copyright (c) 2007-2009 The Evolutionary Software Foundation

Created by Mitchell Skinner <mitch_skinner@berkeley.edu>

This package and its accompanying libraries are free software; you can
redistribute it and/or modify it under the terms of the LGPL (either
version 2.1, or at your option, any later version) or the Artistic
License 2.0.  Refer to LICENSE for the full license text.

*/

}

if(!dojo._hasResource["plugins.view.jbrowse.js.Util"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.view.jbrowse.js.Util"] = true;
dojo.provide("plugins.view.jbrowse.js.Util");

dojo.declare( "plugins.view.jbrowse.js.Util", null,
{
});
var Util = {};

Util.is_ie = navigator.appVersion.indexOf('MSIE') >= 0;
Util.is_ie6 = navigator.appVersion.indexOf('MSIE 6') >= 0;
Util.addCommas = function(nStr)
{
	nStr += '';
	x = nStr.split('.');
	x1 = x[0];
	x2 = x.length > 1 ? '.' + x[1] : '';
	var rgx = /(\d+)(\d{3})/;
	while (rgx.test(x1)) {
		x1 = x1.replace(rgx, '$1' + ',' + '$2');
	}
	return x1 + x2;
}

Util.wheel = function(event){
    var delta = 0;
    if (!event) event = window.event;
    if (event.wheelDelta) {
        delta = event.wheelDelta/120;
        if (window.opera) delta = -delta;
    } else if (event.detail) { delta = -event.detail/3;	}
    return Math.round(delta); //Safari Round
}

Util.isRightButton = function(e) {
    if (!e) var e = window.event;
    if (e.which) return e.which == 3;
    else if (e.button) return e.button == 2;
}

Util.getViewportWidth = function() {
  var width = 0;
  if( document.documentElement && document.documentElement.clientWidth ) {
    width = document.documentElement.clientWidth;
  }
  else if( document.body && document.body.clientWidth ) {
    width = document.body.clientWidth;
  }
  else if( window.innerWidth ) {
    width = window.innerWidth - 18;
  }
  return width;
};

Util.getViewportHeight = function() {
  var height = 0;
  if( document.documentElement && document.documentElement.clientHeight ) {
    height = document.documentElement.clientHeight;
  }
  else if( document.body && document.body.clientHeight ) {
    height = document.body.clientHeight;
  }
  else if( window.innerHeight ) {
    height = window.innerHeight - 18;
  }
  return height;
};

Util.findNearest = function(numArray, num) {
    var minIndex = 0;
    var min = Math.abs(num - numArray[0]);
    for (var i = 0; i < numArray.length; i++) {
        if (Math.abs(num - numArray[i]) < min) {
            minIndex = i;
            min = Math.abs(num - numArray[i]);
        }
    }
    return minIndex;
}

if (!Array.prototype.reduce)
{
  Array.prototype.reduce = function(fun /*, initial*/)
  {
    var len = this.length;
    if (typeof fun != "function")
      throw new TypeError();

    // no value to return if no initial value and an empty array
    if (len == 0 && arguments.length == 1)
      throw new TypeError();

    var i = 0;
    if (arguments.length >= 2)
    {
      var rv = arguments[1];
    }
    else
    {
      do
      {
        if (i in this)
        {
          rv = this[i++];
          break;
        }

        // if array contains no values, no initial value to return
        if (++i >= len)
          throw new TypeError();
      }
      while (true);
    }

    for (; i < len; i++)
    {
      if (i in this)
        rv = fun.call(null, rv, this[i], i, this);
    }

    return rv;
  };
}

function Finisher(fun) {
    this.fun = fun;
    this.count = 0;
}

Finisher.prototype.inc = function() {
    this.count++;
};

Finisher.prototype.dec = function() {
    this.count--;
    this.finish();
};

Finisher.prototype.finish = function() {
    if (this.count <= 0) this.fun();
};

/*

Copyright (c) 2007-2010 The Evolutionary Software Foundation

Created by Mitchell Skinner <mitch_skinner@berkeley.edu>

This package and its accompanying libraries are free software; you can
redistribute it and/or modify it under the terms of the LGPL (either
version 2.1, or at your option, any later version) or the Artistic
License 2.0.  Refer to LICENSE for the full license text.

*/

}

if(!dojo._hasResource["plugins.view.jbrowse.js.NCList"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.view.jbrowse.js.NCList"] = true;
dojo.provide("plugins.view.jbrowse.js.NCList");

dojo.declare( "plugins.view.jbrowse.js.NCList", null,
{
});


//After
//Alekseyenko, A., and Lee, C. (2007).
//Nested Containment List (NCList): A new algorithm for accelerating
//   interval query of genome alignment and interval databases.
//Bioinformatics, doi:10.1093/bioinformatics/btl647
//http://bioinformatics.oxfordjournals.org/cgi/content/abstract/btl647v1

function NCList() {
}

NCList.prototype.importExisting = function(nclist, sublistIndex,
                                           lazyIndex, baseURL,
                                           lazyUrlTemplate) {
    this.topList = nclist;
    this.sublistIndex = sublistIndex;
    this.lazyIndex = lazyIndex;
    this.baseURL = baseURL;
    this.lazyUrlTemplate = lazyUrlTemplate;
};

NCList.prototype.fill = function(intervals, sublistIndex) {
    //intervals: array of arrays of [start, end, ...]
    //sublistIndex: index into a [start, end] array for storing a sublist
    //              array. this is so you can use those arrays for something
    //              else, and keep the NCList bookkeeping from interfering.
    //              That's hacky, but keeping a separate copy of the intervals
    //              in the NCList seems like a waste (TODO: measure that waste).
    //half-open?
    this.sublistIndex = sublistIndex;
    var myIntervals = intervals;//.concat();
    //sort by OL
    myIntervals.sort(function(a, b) {
        if (a[0] != b[0])
            return a[0] - b[0];
        else
            return b[1] - a[1];
    });
    var sublistStack = new Array();
    var curList = new Array();
    this.topList = curList;
    curList.push(myIntervals[0]);
    var curInterval, topSublist;
    for (var i = 1, len = myIntervals.length; i < len; i++) {
        curInterval = myIntervals[i];
        //if this interval is contained in the previous interval,
        if (curInterval[1] < myIntervals[i - 1][1]) {
            //create a new sublist starting with this interval
            sublistStack.push(curList);
            curList = new Array(curInterval);
            myIntervals[i - 1][sublistIndex] = curList;
        } else {
            //find the right sublist for this interval
            while (true) {
                if (0 == sublistStack.length) {
                    curList.push(curInterval);
                    break;
                } else {
                    topSublist = sublistStack[sublistStack.length - 1];
                    if (topSublist[topSublist.length - 1][1] > curInterval[1]) {
                        //curList is the first (deepest) sublist that
                        //curInterval fits into
                        curList.push(curInterval);
                        break;
                    } else {
                        curList = sublistStack.pop();
                    }
                }
            }
        }
    }
};

NCList.prototype.binarySearch = function(arr, item, itemIndex) {
    var low = -1;
    var high = arr.length;
    var mid;

    while (high - low > 1) {
        mid = (low + high) >>> 1;
        if (arr[mid][itemIndex] > item)
            high = mid;
        else
            low = mid;
    }

    //if we're iterating rightward, return the high index;
    //if leftward, the low index
    if (1 == itemIndex) return high; else return low;
};

NCList.prototype.iterHelper = function(arr, from, to, fun, finish,
                                       inc, searchIndex, testIndex, path) {
    var len = arr.length;
    var i = this.binarySearch(arr, from, searchIndex);
    while ((i < len)
           && (i >= 0)
           && ((inc * arr[i][testIndex]) < (inc * to)) ) {

        if ("object" == typeof arr[i][this.lazyIndex]) {
            var ncl = this;
            // lazy node
            if (arr[i][this.lazyIndex].state) {
                if ("loading" == arr[i][this.lazyIndex].state) {
                    // node is currenly loading; finish this query once it
                    // has been loaded
                    finish.inc();
                    arr[i][this.lazyIndex].callbacks.push(
                        function(parentIndex) {
                            return function(o) {
                                ncl.iterHelper(o, from, to, fun, finish, inc,
                                               searchIndex, testIndex,
                                               path.concat(parentIndex));
                                finish.dec();
                            };
                        }(i)
                    );
                } else if ("loaded" == arr[i][this.lazyIndex].state) {
                    // just continue below
                } else {
                    //console.log("unknown lazy type: " + arr[i]);
                }
            } else {
                // no "state" property means this node hasn't been loaded,
                // start loading
                arr[i][this.lazyIndex].state = "loading";
                arr[i][this.lazyIndex].callbacks = [];
                finish.inc();
                dojo.xhrGet(
                    {
                        url: this.baseURL +
                            this.lazyUrlTemplate.replace(
                                /\{chunk\}/g,
                                arr[i][this.lazyIndex].chunk
                            ),
                        handleAs: "json",
                        load: function(lazyFeat, lazyObj,
                                       sublistIndex, parentIndex) {
                            return function(o) {
                                lazyObj.state = "loaded";
                                lazyFeat[sublistIndex] = o;
                                ncl.iterHelper(o, from, to,
                                               fun, finish, inc,
                                               searchIndex, testIndex,
                                               path.concat(parentIndex));
                                for (var c = 0;
                                     c < lazyObj.callbacks.length;
                                     c++)
                                     lazyObj.callbacks[c](o);
                                finish.dec();
                            };
                        }(arr[i], arr[i][this.lazyIndex], this.sublistIndex, i),
                        error: function() {
                            finish.dec();
                        }
                    });
            }
        } else {
            fun(arr[i], path.concat(i));
        }

        if (arr[i][this.sublistIndex])
            this.iterHelper(arr[i][this.sublistIndex], from, to,
                            fun, finish, inc, searchIndex, testIndex,
                            path.concat(i));
        i += inc;
    }
};

NCList.prototype.iterate = function(from, to, fun, postFun) {
    // calls the given function once for each of the
    // intervals that overlap the given interval
    //if from <= to, iterates left-to-right, otherwise iterates right-to-left

    //inc: iterate leftward or rightward
    var inc = (from > to) ? -1 : 1;
    //searchIndex: search on start or end
    var searchIndex = (from > to) ? 0 : 1;
    //testIndex: test on start or end
    var testIndex = (from > to) ? 1 : 0;
    var finish = new Finisher(postFun);
    this.iterHelper(this.topList, from, to, fun, finish,
                    inc, searchIndex, testIndex, []);
    finish.finish();
};

NCList.prototype.histogram = function(from, to, numBins, callback) {
    //calls callback with a histogram of the feature density
    //in the given interval

    var result = new Array(numBins);
    var binWidth = (to - from) / numBins;
    for (var i = 0; i < numBins; i++) result[i] = 0;
    //this.histHelper(this.topList, from, to, result, numBins, (to - from) / numBins);
    this.iterate(from, to,
                 function(feat) {
	             var firstBin =
                         Math.max(0, ((feat[0] - from) / binWidth) | 0);
                     var lastBin =
                         Math.min(numBins, ((feat[1] - from) / binWidth) | 0);
	             for (var bin = firstBin; bin <= lastBin; bin++)
                         result[bin]++;
                 },
                 function() {
                     callback(result);
                 }
                 );
};

/*

Copyright (c) 2007-2009 The Evolutionary Software Foundation

Created by Mitchell Skinner <mitch_skinner@berkeley.edu>

This package and its accompanying libraries are free software; you can
redistribute it and/or modify it under the terms of the LGPL (either
version 2.1, or at your option, any later version) or the Artistic
License 2.0.  Refer to LICENSE for the full license text.

*/

}

if(!dojo._hasResource["plugins.view.jbrowse.js.Layout"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.view.jbrowse.js.Layout"] = true;
dojo.provide("plugins.view.jbrowse.js.Layout");

dojo.declare( "plugins.view.jbrowse.js.Layout", null,
{
});




/*
 * Code for laying out rectangles, given that layout is also happening
 * in adjacent blocks at the same time
 *
 * This code does a lot of linear searching; n should be low enough that
 * it's not a problem but if it turns out to be, some of it can be changed to
 * binary searching without too much work.  Another possibility is to merge
 * contour spans and give up some packing closeness in exchange for speed
 * (the code already merges spans that have the same x-coord and are vertically
 * contiguous).
 */

function Contour(top) {
    /*
     * A contour is described by a set of vertical lines of varying heights,
     * like this:
     *                         |
     *                         |
     *               |
     *                   |
     *                   |
     *                   |
     *
     * The contour is the union of the rectangles ending on the right side
     * at those lines, and extending leftward toward negative infinity.
     *
     * <=======================|
     * <=======================|
     * <==========|
     * <=================|
     * <=================|
     * <=================|
     *
     * x -->
     *
     * As we add new vertical spans, the contour expands, either downward
     * or in the direction of increasing x.
     */
    // takes: top, a number indicating where the first span of the contour
    // will go
    if (top === undefined) top = 0;

    // spans is an array of {top, x, height} objects representing
    // the boundaries of the contour
    // they're always sorted by top
    this.spans = [{top: top, x: Infinity, height: 0}];
}

// finds a space in the contour into which the given span fits
// (i.e., the given span has higher x than the contour over its vertical span)
// returns an ojbect {above, count}; above is the index of the last span above
// where the given span will fit, count is the number of spans being
// replaced by the given span
Contour.prototype.getFit = function(x, height, minTop) {
    var aboveBottom, curSpan;
    var above = 0;
    if (minTop) {
        // set above = (index of the first span that starts below minTop)
        for (; this.spans[above].top < minTop; above++) {
            if (above >= (this.spans.length - 1))
                return {above: this.spans.length - 1, count: 0};
        }
    }
    // slide down the contour
    ABOVE: for (; above < this.spans.length; above++) {
        aboveBottom = this.spans[above].top + this.spans[above].height;
        for (var count = 1; above + count < this.spans.length; count++) {
            curSpan = this.spans[above + count];
            if ((aboveBottom + height) <= curSpan.top) {
                // the given span fits between span[above] and
                // curSpan, keeping curSpan
                return {above: above, count: count - 1};
            }
            if (curSpan.x > x) {
                // the span at [above + count] overlaps the given span,
                // so we continue down the contour
                continue ABOVE;
            }
            if ((curSpan.x <= x) &&
                ((aboveBottom + height) < (curSpan.top + curSpan.height))) {
                // the given span partially covers curSpan, and
                // will overlap it, so we keep curSpan
                return {above: above, count: count - 1};
            }
        }
        // the given span fits below span[above], replacing any
        // lower spans in the contour
        return {above: above, count: count - 1};
    }
    // the given span fits at the end of the contour, replacing no spans
    return {above: above, count: 0};
};

// add the given span to this contour where it fits, as given
// by getFit
Contour.prototype.insertFit = function(fit, x, top, height) {
    // if the previous span and the current span have the same x-coord,
    // and are vertically contiguous, merge them.
    var prevSpan = this.spans[fit.above];
    if ((Math.abs(prevSpan.x - x) < 1)
        && (Math.abs((prevSpan.top + prevSpan.height) - top) < 1) ) {
        prevSpan.height = (top + height) - prevSpan.top;
        // a bit of slop here is conservative if we take the max
        // (means things might get laid out slightly farther apart
        // than they would otherwise)
        prevSpan.x = Math.max(prevSpan.x, x);
        this.spans.splice(fit.above + 1, fit.count);
    } else {
        this.spans.splice(fit.above + 1, fit.count,
                          {
                              top: top,
                              x: x,
                              height: height
                          });
    }
};

// add the given span to this contour at the given location, if
// it would extend the contour
Contour.prototype.unionWith = function(x, top, height) {
    var startBottom, startIndex, endIndex, startSpan, endSpan;
    var bottom = top + height;
    START: for (startIndex = 0; startIndex < this.spans.length; startIndex++) {
        startSpan = this.spans[startIndex];
        startBottom = startSpan.top + startSpan.height;
        if (startSpan.top > top) {
            // the given span extends above an existing span
            endIndex = startIndex;
            break START;
        }
        if (startBottom > top) {
            // if startSpan covers (at least some of) the given span,
            if (startSpan.x >= x) {
                var covered = startBottom - top;
                // we don't have to worry about the covered area any more
                top += covered;
                height -= covered;
                // if we've eaten up the whole span, then it's submerged
                // and we don't have to do anything
                if (top >= bottom) return;
                continue;
            } else {
                // find the first span not covered by the given span
                for (endIndex = startIndex;
                     endIndex < this.spans.length;
                     endIndex++) {
                    endSpan = this.spans[endIndex];
                    // if endSpan extends below or to the right
                    // of the given span, then we need to keep it
                    if (((endSpan.top + endSpan.height) > bottom)
                        || endSpan.x > x) {
                        break START;
                    }
                }
                break START;
            }
        }
    }

    // if the previous span and the current span have the same x-coord,
    // and are vertically contiguous, merge them.
    var prevSpan = this.spans[startIndex - 1];
    if ((Math.abs(prevSpan.x - x) < 1)
        && (Math.abs((prevSpan.top + prevSpan.height) - top) < 1) ) {
        prevSpan.height = (top + height) - prevSpan.top;
        prevSpan.x = Math.max(prevSpan.x, x);
        this.spans.splice(startIndex, endIndex - startIndex);
    } else {
        this.spans.splice(startIndex, endIndex - startIndex,
                          {
                              top: top,
                              x: x,
                              height: height
                          });
    }
};

// returns the top of the to-be-added span that fits into "fit"
// (as returned by getFit)
Contour.prototype.getNextTop = function(fit) {
    return this.spans[fit.above].top + this.spans[fit.above].height;
};

function Layout(leftBound, rightBound) {
    this.leftBound = leftBound;
    this.rightBound = rightBound;
    // a Layout contains a left contour and a right contour;
    // the area between the contours is allocated, and the
    // area outside the contours is free.
    this.leftContour = new Contour();
    this.rightContour = new Contour();
    this.seen = {};
    this.leftOverlaps = [];
    this.rightOverlaps = [];
    this.totalHeight = 0;
}

Layout.prototype.addRect = function(id, left, right, height) {
    if (this.seen[id] !== undefined) return this.seen[id];
    // for each contour, we test the fit on the near side of the given rect,
    var leftFit = this.tryLeftFit(left, right, height, 0);
    var rightFit = this.tryRightFit(left, right, height, 0);

    var top;

    // and insert the far side from the side we tested
    // (we want to make sure the near side fits, but we want to extend
    //  the contour to cover the far side)
    if (leftFit.top < rightFit.top) {
        top = leftFit.top;
        this.leftContour.insertFit(leftFit.fit, this.rightBound - left,
                                   top, height);
        this.rightContour.unionWith(right - this.leftBound, top, height);
    } else {
        top = rightFit.top;
        this.rightContour.insertFit(rightFit.fit, right - this.leftBound,
                                    top, height);
        this.leftContour.unionWith(this.rightBound - left, top, height);
    }

    var existing = {id: id, left: left, right: right,
                    top: top, height: height};
    this.seen[id] = top;
    if (left <= this.leftBound) {
        this.leftOverlaps.push(existing);
        if (this.leftLayout) this.leftLayout.addExisting(existing);
    }
    if (right >= this.rightBound) {
        this.rightOverlaps.push(existing);
        if (this.rightLayout) this.rightLayout.addExisting(existing);
    }
    this.seen[id] = top;
    this.totalHeight = Math.max(this.totalHeight, top + height);
    return top;
};

// this method is called by the block to the left to see if a given fit works
// in this layout
// takes: proposed rectangle
// returns: {top: value that makes the rectangle fit in this layout,
//           fit: "fit" for passing to insertFit}
Layout.prototype.tryLeftFit = function(left, right, height, top) {
    var fit, nextFit;
    var curTop = top;
    while (true) {
        // check if the rectangle fits at curTop
        fit = this.leftContour.getFit(this.rightBound - right, height, curTop);
        curTop = Math.max(this.leftContour.getNextTop(fit), curTop);
        // if the rectangle extends onto the next block to the right;
        if (this.rightLayout && (right >= this.rightBound)) {
            // check if the rectangle fits into that block at this position
            nextFit = this.rightLayout.tryLeftFit(left, right, height, curTop);
            // if not, nextTop will be the next y-value where the rectangle
            // fits into that block
            if (nextFit.top > curTop) {
                // in that case, try again to see if that y-value works
                curTop = nextFit.top;
                continue;
            }
        }
        break;
    }
    return {top: curTop, fit: fit};
};

// this method is called by the block to the right to see if a given fit works
// in this layout
// takes: proposed rectangle
// returns: {top: value that makes the rectangle fit in this layout,
//           fit: "fit" for passing to insertFit}
Layout.prototype.tryRightFit = function(left, right, height, top) {
    var fit, nextFit;
    var curTop = top;
    while (true) {
        // check if the rectangle fits at curTop
        fit = this.rightContour.getFit(left - this.leftBound, height, curTop);
        curTop = Math.max(this.rightContour.getNextTop(fit), curTop);
        // if the rectangle extends onto the next block to the left;
        if (this.leftLayout && (left <= this.leftBound)) {
            // check if the rectangle fits into that block at this position
            nextFit = this.leftLayout.tryRightFit(left, right, height, curTop);
            // if not, nextTop will be the next y-value where the rectangle
            // fits into that block
            if (nextFit.top > curTop) {
                // in that case, try again to see if that y-value works
                curTop = nextFit.top;
                continue;
            }
        }
        break;
    }
    return {top: curTop, fit: fit};
};

Layout.prototype.hasSeen = function(id) {
    return (this.seen[id] !== undefined);
};

Layout.prototype.setLeftLayout = function(left) {
    for (var i = 0; i < this.leftOverlaps.length; i++) {
        left.addExisting(this.leftOverlaps[i]);
    }
    this.leftLayout = left;
};

Layout.prototype.setRightLayout = function(right) {
    for (var i = 0; i < this.rightOverlaps.length; i++) {
        right.addExisting(this.rightOverlaps[i]);
    }
    this.rightLayout = right;
};

Layout.prototype.cleanup = function() {
    this.leftLayout = undefined;
    this.rightLayout = undefined;
};

//expects an {id, left, right, height, top} object
Layout.prototype.addExisting = function(existing) {
    if (this.seen[existing.id] !== undefined) return;
    this.seen[existing.id] = existing.top;

    this.totalHeight =
        Math.max(this.totalHeight, existing.top + existing.height);

    if (existing.left <= this.leftBound) {
        this.leftOverlaps.push(existing);
        if (this.leftLayout) this.leftLayout.addExisting(existing);
    }
    if (existing.right >= this.rightBound) {
        this.rightOverlaps.push(existing);
        if (this.rightLayout) this.rightLayout.addExisting(existing);
    }

    this.leftContour.unionWith(this.rightBound - existing.left,
                               existing.top,
                               existing.height);
    this.rightContour.unionWith(existing.right - this.leftBound,
                                existing.top,
                                existing.height);
};

/*

Copyright (c) 2007-2010 The Evolutionary Software Foundation

Created by Mitchell Skinner <mitch_skinner@berkeley.edu>

This package and its accompanying libraries are free software; you can
redistribute it and/or modify it under the terms of the LGPL (either
version 2.1, or at your option, any later version) or the Artistic
License 2.0.  Refer to LICENSE for the full license text.

*/

}

if(!dojo._hasResource["plugins.view.jbrowse.js.LazyArray"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.view.jbrowse.js.LazyArray"] = true;
dojo.provide("plugins.view.jbrowse.js.LazyArray");

dojo.declare( "plugins.view.jbrowse.js.LazyArray", null,
{
});


/*
 * For a JSON array that gets too large to load in one go, this class
 * helps break it up into chunks and provides an
 * async API for using the information in the array.
 */

/**
 * Construct a new LazyArray
 * @class This class makes it easier to partially load a large JSON array
 * @constructor
 * @param lazyArrayParams object with:<br>
 * <ul>
 * <li><code>urlTemplate</code> - for each lazily-loaded array chunk, the chunk number will get substituted for {chunk} in this template, and the result will beused as the URL of the JSON for that array chunk</li>
 * <li><code>length</code> - length of the overall array</li>
 * <li><code>chunkSize</code> - the size of each array chunk</li>
 * </ul>
 */
function LazyArray(lazyArrayParams, baseUrl) {
    this.urlTemplate = lazyArrayParams.urlTemplate;
    this.chunkSize = lazyArrayParams.chunkSize;
    this.length = lazyArrayParams.length;
    this.baseUrl = (baseUrl === undefined ? "" : baseUrl);
    // Once a range gets loaded, it goes into the "chunks" array.
    // this.chunks[n] contains data for indices in the range
    // [n * chunkSize, Math.min(length - 1, (n * (chunkSize + 1)) - 1)]
    this.chunks = [];
    // If a range is currently loading, this will contain a property
    // "chunk number": [{start, end, callback, param}, ...]
    this.toProcess = {};
}

/**
 * call the callback on one element of the array
 * @param i index
 * @param callback callback, gets called with (i, value, param)
 * @param param (optional) callback will get this as its last parameter
 */
LazyArray.prototype.index = function(i, callback, param) {
    this.range(i, i, callback, undefined, param);
};

/**
 * call the callback on each element in the range [start, end]
 * @param start index of first element to call the callback on
 * @param end index of last element to call the callback on
 * @param callback callback, gets called with (i, value, param)
 * @param postFun (optional) callback that gets called when <code>callback</code> has been run on every element in the range
 * @param param (optional) callback will get this as its last parameter
 */
LazyArray.prototype.range = function(start, end, callback, postFun, param) {
    start = Math.max(0, start);
    end = Math.min(end, this.length - 1);

    var firstChunk = Math.floor(start / this.chunkSize);
    var lastChunk = Math.floor(end / this.chunkSize);

    if (postFun === undefined) postFun = function() {};
    var finish = new Finisher(postFun);

    for (var chunk = firstChunk; chunk <= lastChunk; chunk++) {
        if (this.chunks[chunk]) {
            // chunk is loaded
            this._processChunk(start, end, chunk, callback, param);
        } else {
            var toProcessInfo = {
                start: start,
                end: end,
                callback: callback,
                param: param,
                finish: finish
            };

            finish.inc();
            if (this.toProcess[chunk]) {
                // chunk is currently being loaded
                this.toProcess[chunk].push(toProcessInfo);
            } else {
                // start loading chunk
                this.toProcess[chunk] = [toProcessInfo];
                var url = this.urlTemplate.replace(/\{chunk\}/g, chunk);
                var thisObj = this;
                
                //console.log("js.LazyArray.range   loading chunk: " + this.baseUrl + url);
                
                dojo.xhrGet(
                    {
                        url: this.baseUrl + url,
                        handleAs: "json",
                        load: this._makeLoadFun(chunk),
                        error: function() { finish.dec(); }
                    });
            }
        }
    }
    finish.finish();
};

LazyArray.prototype._makeLoadFun = function(chunk) {
    var thisObj = this;
    return function(data) {
        thisObj.chunks[chunk] = data;
        var toProcess = thisObj.toProcess[chunk];
        delete thisObj.toProcess[chunk];
        for (var i = 0; i < toProcess.length; i++) {
            thisObj._processChunk(toProcess[i].start,
                                  toProcess[i].end,
                                  chunk,
                                  toProcess[i].callback,
                                  toProcess[i].param);
            toProcess[i].finish.dec();
        }
    };
};

LazyArray.prototype._processChunk = function(start, end, chunk,
                                             callback, param) {
    // index (in the overall lazy array) of the first position in this chunk
    var firstIndex = chunk * this.chunkSize;

    var chunkStart = start - firstIndex;
    var chunkEnd = end - firstIndex;
    chunkStart = Math.max(0, chunkStart);
    chunkEnd = Math.min(chunkEnd, this.chunkSize - 1);

    for (var i = chunkStart; i <= chunkEnd; i++) {
        callback(i + firstIndex, this.chunks[chunk][i], param);
    }
};

}

if(!dojo._hasResource["plugins.view.jbrowse.js.LazyPatricia"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.view.jbrowse.js.LazyPatricia"] = true;
dojo.provide("plugins.view.jbrowse.js.LazyPatricia");

dojo.declare( "plugins.view.jbrowse.js.LazyPatricia", null,
{
});


/*
  Implements a lazy PATRICIA tree.

  This class is a map where the keys are strings.  The map supports fast
  queries by key string prefix ("show me all the values for keys that
  start with "abc").  It also supports lazily loading subtrees.

  Each edge is labeled with a substring of a key string.
  Each node in the tree has one or more children, each of which represents
    a potential completion of the string formed by concatenating all of the
    edge strings from that node up to the root.
    Nodes also have zero or one data items.
  Leaves have zero or one data items.

  Each loaded node is an array.
    element 0 is the edge string;
    element 1 is the data item, or null if there is none;
    any further elements are the child nodes, sorted lexicographically
      by their edge string

  Each lazy node is an array where the first element is the number of
  data items in the subtree rooted at that node, and the second element
  is the edge string for that node.
    when the lazy node is loaded, the lazy array gets replaced with
    a loaded node array; lazy nodes and loaded nodes can be distinguished by:
    "string" == typeof loaded_node[0]
    "number" == typeof lazy_node[0]

  e.g., for the mappings:
    abc   => 0
    abcd  => 1
    abce  => "baz"
    abfoo => [3, 4]
    abbar (subtree to be loaded lazily)

  the structure is:

  [, , ["ab", ,
        [3, "bar"],
        ["c", 0, ["d", 1],
         ["e", "baz"]],
        ["foo", [3, 4]]
        ]
   ]

  The main goals for this structure were to minimize the JSON size on
  the wire (so, no type tags in the JSON to distinguish loaded nodes,
  lazy nodes, and leaves) while supporting lazy loading and reasonably
  fast lookups.
 */

function LazyTrie(baseURL, rootURL) {
    //console.log("js.LazyPatricia.LazyTrie    baseURL: " + baseURL);
    //console.log("js.LazyPatricia.LazyTrie    rootURL: " + rootURL);

    this.baseURL = baseURL;
    var trie = this;

    dojo.xhrGet({url: rootURL,
                 handleAs: "json",
                 load: function(o) {
                     if (!o) {
                         //console.log("failed to load trie");
                         return;
                     }
                     trie.root = o;
                     trie.extra = o[0];
                     if (trie.deferred) {
                         trie.deferred.callee.apply(trie, trie.deferred);
                         delete trie.deferred;
                     }
                 }
        });
}

LazyTrie.prototype.pathToPrefix = function(path) {
    var node = this.root;
    var result = "";
    loop: for (var i = 0; i < path.length; i++) {
        switch(typeof node[path[i]][0]) {
        case 'string': // regular node
            result += node[path[i]][0];
            break;
        case 'number': // lazy node
            result += node[path[i]][1];
            break loop;
        }
        node = node[path[i]];
    }
    return result;
};

LazyTrie.prototype.valuesFromPrefix = function(query, callback) {
    var trie = this;
    this.findNode(query, function(prefix, node) {
            callback(trie.valuesFromNode(node));
        });
};

LazyTrie.prototype.mappingsFromPrefix = function(query, callback) {
    var trie = this;
    this.findNode(query, function(prefix, node) {
            callback(trie.mappingsFromNode(prefix, node));
        });
};

LazyTrie.prototype.mappingsFromNode = function(prefix, node) {
    var results = [];
    if (node[1] !== null)
        results.push([prefix, node[1]]);
    for (var i = 2; i < node.length; i++) {
        if ("string" == typeof node[i][0]) {
            results = results.concat(this.mappingsFromNode(prefix + node[i][0],
                                                           node[i]));
        }
    }
    return results;
};

LazyTrie.prototype.valuesFromNode = function(node) {
    var results = [];
    if (node[1] !== null)
        results.push(node[1]);
    for (var i = 2; i < node.length; i++)
        results = results.concat(this.valuesFromNode(node[i]));
    return results;
};

LazyTrie.prototype.exactMatch = function(key, callback) {
    var trie = this;
    this.findNode(key, function(prefix, node) {
            if ((prefix.toLowerCase() == key.toLowerCase()) && node[1])
                callback(node[1]);
        });
};

LazyTrie.prototype.findNode = function(query, callback) {
    var trie = this;
    this.findPath(query, function(path) {
        var node = trie.root;
        for (i = 0; i < path.length; i++)
            node = node[path[i]];
        var foundPrefix = trie.pathToPrefix(path);
        callback(foundPrefix, node);
    });
};

LazyTrie.prototype.findPath = function(query, callback) {
    if (!this.root) {
        this.deferred = arguments;
        return;
    }
    query = query.toLowerCase();
    var node = this.root;
    var qStart = 0;
    var childIndex;

    var path = [];

    while(true) {
        childIndex = this.binarySearch(node, query.charAt(qStart));
        if (childIndex < 0) return;
        path.push(childIndex);

        if ("number" == typeof node[childIndex][0]) {
            // lazy node
            var trie = this;
            //console.log("js.LazyPatricia.LazyTrie.findPath    DOING xhrGet this.baseURL + this.pathToPrefix(path) + .json : " + this.baseURL + this.pathToPrefix(path) + ".json");
            dojo.xhrGet({url: this.baseURL + this.pathToPrefix(path) + ".json",
                         handleAs: "json",
                         load: function(o) {
                             node[childIndex] = o;
                             trie.findPath(query, callback);
                         }
                        });
            return;
        }

        node = node[childIndex];

        // if the current edge string doesn't match the
        // relevant part of the query string, then there's no
        // match
        if (query.substr(qStart, node[0].length)
            != node[0].substr(0, Math.min(node[0].length,
                                          query.length - qStart)))
            return;

        qStart += node[0].length;
        if (qStart >= query.length) {
            // we've reached the end of the query string, and we
            // have some matches
            callback(path);
            return;
        }
    }
};

LazyTrie.prototype.binarySearch = function(a, firstChar) {
    var low = 2; // skip edge string (in 0) and data item (in 1)
    var high = a.length - 1;
    var mid, midVal;
    while (low <= high) {
        mid = (low + high) >>> 1;
        switch(typeof a[mid][0]) {
        case 'string': // regular node
            midVal = a[mid][0].charAt(0);
            break;
        case 'number': // lazy node
            midVal = a[mid][1].charAt(0);
            break;
        }

        if (midVal < firstChar) {
            low = mid + 1;
        } else if (midVal > firstChar) {
            high = mid - 1;
        } else {
            return mid; // key found
        }
    }

    return -(low + 1);  // key not found.
};

/*

Copyright (c) 2007-2009 The Evolutionary Software Foundation

Created by Mitchell Skinner <mitch_skinner@berkeley.edu>

This package and its accompanying libraries are free software; you can
redistribute it and/or modify it under the terms of the LGPL (either
version 2.1, or at your option, any later version) or the Artistic
License 2.0.  Refer to LICENSE for the full license text.

*/

}

if(!dojo._hasResource["plugins.view.jbrowse.js.Track"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.view.jbrowse.js.Track"] = true;
dojo.provide("plugins.view.jbrowse.js.Track");

dojo.declare( "plugins.view.jbrowse.js.Track", null,
{
});


function Track(name, key, loaded, changeCallback) {
    this.name = name;
    this.key = key;
    this.loaded = loaded;
    this.changed = changeCallback;
    this.height = 0;
    this.shown = true;
    this.empty = false;
}

Track.prototype.load = function(url) {
	//console.log("js.Track.prototype.load    url: " + url);		

    var curTrack = this;
    dojo.xhrGet({url: url,
                 handleAs: "json",
                 load: function(o) {
			
				//console.log("js.Track.prototype.load    o: " + dojo.toJson(o));		
				curTrack.loadSuccess(o);
			},
                 error: function(o) { curTrack.loadFail(o); }
	        });
};

Track.prototype.loadFail = function(error) {
    this.empty = true;
    this.setLoaded();
};

Track.prototype.setViewInfo = function(heightUpdate, numBlocks,
                                       trackDiv, labelDiv,
                                       widthPct, widthPx, scale) {
    var track = this;
    this.heightUpdate = function(height, blockIndex) {
        if (!this.shown) {
            heightUpdate(0);
            return;
        }
        if (blockIndex !== undefined) track.blockHeights[blockIndex] = height;

        track.height = Math.max(track.height, height);
        if (!track.inShowRange) {
            heightUpdate(Math.max(track.labelHeight, track.height));
        }
    };
	
	//console.log("Track.setViewInfo    this.trackMeta: " + dojo.toJson(this.trackMeta));
	//console.dir({trackMeta:this.trackMeta});

    this.div = trackDiv;
    this.label = labelDiv;
    this.widthPct = widthPct;
    this.widthPx = widthPx;

    this.leftBlank = document.createElement("div");
    this.leftBlank.className = "blank-block";
    this.rightBlank = document.createElement("div");
    this.rightBlank.className = "blank-block";
    this.div.appendChild(this.rightBlank);
    this.div.appendChild(this.leftBlank);

    this.sizeInit(numBlocks, widthPct);
    this.labelHTML = "";
    this.labelHeight = 0;
};

Track.prototype.hide = function() {
    if (this.shown) {
        this.div.style.display = "none";
        this.shown = false;
    }
};

Track.prototype.show = function() {
    if (!this.shown) {
        this.div.style.display = "block";
        this.shown = true;
    }
};

Track.prototype.initBlocks = function() {
    this.blocks = new Array(this.numBlocks);
    this.blockHeights = new Array(this.numBlocks);
    for (var i = 0; i < this.numBlocks; i++) this.blockHeights[i] = 0;
    this.firstAttached = null;
    this.lastAttached = null;
    this._adjustBlanks();
};

Track.prototype.clear = function() {
    if (this.blocks) {
        for (var i = 0; i < this.numBlocks; i++)
            this._hideBlock(i);
    }
    this.initBlocks();
};

Track.prototype.setLabel = function(newHTML) {
    if (this.label === undefined) return;

    if (this.labelHTML == newHTML) return;
    this.labelHTML = newHTML;
    this.label.innerHTML = newHTML;
    this.labelHeight = this.label.offsetHeight;
};

Track.prototype.transfer = function() {};

Track.prototype.startZoom = function(destScale, destStart, destEnd) {};
Track.prototype.endZoom = function(destScale, destBlockBases) {};

Track.prototype.showRange = function(first, last, startBase, bpPerBlock, scale,
                                     containerStart, containerEnd) {
    if (this.blocks === undefined) return 0;

    // this might make more sense in setViewInfo, but the label element
    // isn't in the DOM tree yet at that point
    if ((this.labelHeight == 0) && this.label)
        this.labelHeight = this.label.offsetHeight;

    this.inShowRange = true;
    this.height = this.labelHeight;

    var firstAttached = (null == this.firstAttached ? last + 1 : this.firstAttached);
    var lastAttached =  (null == this.lastAttached ? first - 1 : this.lastAttached);

    var i, leftBase;
    var maxHeight = 0;
    //fill left, including existing blocks (to get their heights)
    for (i = lastAttached; i >= first; i--) {
        leftBase = startBase + (bpPerBlock * (i - first));
        this._showBlock(i, leftBase, leftBase + bpPerBlock, scale,
                        containerStart, containerEnd);
    }
    //fill right
    for (i = lastAttached + 1; i <= last; i++) {
        leftBase = startBase + (bpPerBlock * (i - first));
        this._showBlock(i, leftBase, leftBase + bpPerBlock, scale,
                        containerStart, containerEnd);
    }

    //detach left blocks
    var destBlock = this.blocks[first];
    for (i = firstAttached; i < first; i++) {
        this.transfer(this.blocks[i], destBlock, scale,
                      containerStart, containerEnd);
        this.cleanupBlock(this.blocks[i]);
        this._hideBlock(i);
    }
    //detach right blocks
    destBlock = this.blocks[last];
    for (i = lastAttached; i > last; i--) {
        this.transfer(this.blocks[i], destBlock, scale,
                      containerStart, containerEnd);
        this.cleanupBlock(this.blocks[i]);
        this._hideBlock(i);
    }

    this.firstAttached = first;
    this.lastAttached = last;
    this._adjustBlanks();
    this.inShowRange = false;
    this.heightUpdate(this.height);
};

Track.prototype.cleanupBlock = function() {};

Track.prototype._hideBlock = function(blockIndex) {
    if (this.blocks[blockIndex]) {
        this.div.removeChild(this.blocks[blockIndex]);
        this.blocks[blockIndex] = undefined;
        this.blockHeights[blockIndex] = 0;
    }
};

Track.prototype._adjustBlanks = function() {
    if ((this.firstAttached === null)
        || (this.lastAttached === null)) {
        this.leftBlank.style.left = "0px";
        this.leftBlank.style.width = "50%";
        this.rightBlank.style.left = "50%";
        this.rightBlank.style.width = "50%";
    } else {
        this.leftBlank.style.width = (this.firstAttached * this.widthPct) + "%";
        this.rightBlank.style.left = ((this.lastAttached + 1)
                                      * this.widthPct) + "%";
        this.rightBlank.style.width = ((this.numBlocks - this.lastAttached - 1)
                                       * this.widthPct) + "%";
    }
};

Track.prototype.hideAll = function() {
    if (null == this.firstAttached) return;
    for (var i = this.firstAttached; i <= this.lastAttached; i++)
        this._hideBlock(i);


    this.firstAttached = null;
    this.lastAttached = null;
    this._adjustBlanks();
    //this.div.style.backgroundColor = "#eee";
};

Track.prototype.setLoaded = function() {
    this.loaded = true;
    this.hideAll();
    this.changed();
};

Track.prototype._loadingBlock = function(blockDiv) {
    blockDiv.appendChild(document.createTextNode("Loading..."));
    blockDiv.style.backgroundColor = "#eee";
    return 50;
};

Track.prototype._showBlock = function(blockIndex, startBase, endBase, scale,
                                      containerStart, containerEnd) {
    if (this.blocks[blockIndex]) {
        this.heightUpdate(this.blockHeights[blockIndex], blockIndex);
        return;
    }
    if (this.empty) {
        this.heightUpdate(this.labelHeight, blockIndex);
        return;
    }

    var blockDiv = document.createElement("div");
    blockDiv.className = "block";
    blockDiv.style.left = (blockIndex * this.widthPct) + "%";
    blockDiv.style.width = this.widthPct + "%";
    blockDiv.startBase = startBase;
    blockDiv.endBase = endBase;
    if (this.loaded) {
        this.fillBlock(blockIndex,
                       blockDiv,
                       this.blocks[blockIndex - 1],
                       this.blocks[blockIndex + 1],
                       startBase,
                       endBase,
                       scale,
                       this.widthPx,
                       containerStart,
                       containerEnd);
    } else {
         this._loadingBlock(blockDiv);
    }

    this.blocks[blockIndex] = blockDiv;
    this.div.appendChild(blockDiv);
};

Track.prototype.moveBlocks = function(delta) {
    var newBlocks = new Array(this.numBlocks);
    var newHeights = new Array(this.numBlocks);
    var i;
    for (i = 0; i < this.numBlocks; i++)
        newHeights[i] = 0;

    var destBlock;
    if ((this.lastAttached + delta < 0)
        || (this.firstAttached + delta >= this.numBlocks)) {
        this.firstAttached = null;
        this.lastAttached = null;
    } else {
        this.firstAttached = Math.max(0, Math.min(this.numBlocks - 1,
                                                 this.firstAttached + delta));
        this.lastAttached = Math.max(0, Math.min(this.numBlocks - 1,
                                                  this.lastAttached + delta));
        if (delta < 0)
            destBlock = this.blocks[this.firstAttached - delta];
        else
            destBlock = this.blocks[this.lastAttached - delta];
    }

    for (i = 0; i < this.blocks.length; i++) {
        var newIndex = i + delta;
        if ((newIndex < 0) || (newIndex >= this.numBlocks)) {
            //We're not keeping this block around, so delete
            //the old one.
            if (destBlock && this.blocks[i])
                this.transfer(this.blocks[i], destBlock);
            this._hideBlock(i);
        } else {
            //move block
            newBlocks[newIndex] = this.blocks[i];
            if (newBlocks[newIndex])
                newBlocks[newIndex].style.left =
                    ((newIndex) * this.widthPct) + "%";

            newHeights[newIndex] = this.blockHeights[i];
        }
    }
    this.blocks = newBlocks;
    this.blockHeights = newHeights;
    this._adjustBlanks();
};

Track.prototype.sizeInit = function(numBlocks, widthPct, blockDelta) {
    var i, oldLast;
    this.numBlocks = numBlocks;
    this.widthPct = widthPct;
    if (blockDelta) this.moveBlocks(-blockDelta);
    if (this.blocks && (this.blocks.length > 0)) {
        //if we're shrinking, clear out the end blocks
        var destBlock = this.blocks[numBlocks - 1];
        for (i = numBlocks; i < this.blocks.length; i++) {
            if (destBlock && this.blocks[i])
                this.transfer(this.blocks[i], destBlock);
            this._hideBlock(i);
        }
        oldLast = this.blocks.length;
        this.blocks.length = numBlocks;
        this.blockHeights.length = numBlocks;
        //if we're expanding, set new blocks to be not there
        for (i = oldLast; i < numBlocks; i++) {
            this.blocks[i] = undefined;
            this.blockHeights[i] = 0;
        }
        this.lastAttached = Math.min(this.lastAttached, numBlocks - 1);
        if (this.firstAttached > this.lastAttached) {
            //not sure if this can happen
            this.firstAttached = null;
            this.lastAttached = null;
        }

        if (this.blocks.length != numBlocks) throw new Error("block number mismatch: should be " + numBlocks + "; blocks.length: " + this.blocks.length);
        for (i = 0; i < numBlocks; i++) {
            if (this.blocks[i]) {
                //if (!this.blocks[i].style) //console.log(this.blocks);
                this.blocks[i].style.left = (i * widthPct) + "%";
                this.blocks[i].style.width = widthPct + "%";
            }
        }
    } else {
        this.initBlocks();
    }
};

/*

Copyright (c) 2007-2009 The Evolutionary Software Foundation

Created by Mitchell Skinner <mitch_skinner@berkeley.edu>

This package and its accompanying libraries are free software; you can
redistribute it and/or modify it under the terms of the LGPL (either
version 2.1, or at your option, any later version) or the Artistic
License 2.0.  Refer to LICENSE for the full license text.

*/

}

if(!dojo._hasResource["plugins.view.jbrowse.js.SequenceTrack"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.view.jbrowse.js.SequenceTrack"] = true;
dojo.provide("plugins.view.jbrowse.js.SequenceTrack");

dojo.declare( "plugins.view.jbrowse.js.SequenceTrack", null,
{
});

function SequenceTrack(trackMeta, url, refSeq, browserParams) {
    //trackMeta: object with:
    //  key:   display text track name
    //  label: internal track name (no spaces or odd characters)
    //  className: CSS class for sequence
    //  args: object with:
    //    seqDir: directory in which to find the sequence chunks
    //    chunkSize: size of sequence chunks, in characters
    //refSeq: object with:
    //  start: refseq start
    //  end:   refseq end
    //browserParams: object with:
    //  changeCallback: function to call once JSON is loaded
    //  trackPadding: distance in px between tracks
    //  baseUrl: base URL for the URL in trackMeta
    //  charWidth: width, in pixels, of sequence base characters
    //  seqHeight: height, in pixels, of sequence elements

    Track.call(this, trackMeta.label, trackMeta.key,
               false, browserParams.changeCallback);
    this.browserParams = browserParams;
    this.trackMeta = trackMeta;
    this.setLoaded();
    this.chunks = [];
    this.chunkSize = trackMeta.args.chunkSize;
    this.baseUrl = (browserParams.baseUrl ? browserParams.baseUrl : "") + url;
}

SequenceTrack.prototype = new Track("");

SequenceTrack.prototype.startZoom = function(destScale, destStart, destEnd) {
    this.hide();
    this.heightUpdate(0);
};

SequenceTrack.prototype.endZoom = function(destScale, destBlockBases) {
    if (destScale == this.browserParams.charWidth) this.show();
    Track.prototype.clear.apply(this);
};

SequenceTrack.prototype.setViewInfo = function(genomeView, numBlocks,
                                               trackDiv, labelDiv,
                                               widthPct, widthPx, scale) {
    Track.prototype.setViewInfo.apply(this, [genomeView, numBlocks,
                                             trackDiv, labelDiv,
                                             widthPct, widthPx, scale]);
    if (scale == this.browserParams.charWidth) {
        this.show();
    } else {
        this.hide();
    }
    this.setLabel(this.key);
};

SequenceTrack.prototype.fillBlock = function(blockIndex, block,
                                             leftBlock, rightBlock,
                                             leftBase, rightBase,
                                             scale, stripeWidth,
                                             containerStart, containerEnd) {
    if (this.shown) {
        this.getRange(leftBase, rightBase,
                      function(start, end, seq) {
                          //console.log("adding seq from %d to %d: %s", start, end, seq);
                          var seqNode = document.createElement("div");
                          seqNode.className = "sequence";
                          seqNode.appendChild(document.createTextNode(seq));
	                  seqNode.style.cssText = "top: 0px;";
                          block.appendChild(seqNode);
                      });
        this.heightUpdate(this.browserParams.seqHeight, blockIndex);
    } else {
        this.heightUpdate(0, blockIndex);
    }
};

SequenceTrack.prototype.getRange = function(start, end, callback) {
    //start: start coord, in interbase
    //end: end coord, in interbase
    //callback: function that takes (start, end, seq)
    var firstChunk = Math.floor((start) / this.chunkSize);
    var lastChunk = Math.floor((end - 1) / this.chunkSize);
    var callbackInfo = {start: start, end: end, callback: callback};
    var chunkSize = this.chunkSize;
    var chunk;

    for (var i = firstChunk; i <= lastChunk; i++) {
        //console.log("working on chunk %d for %d .. %d", i, start, end);
        chunk = this.chunks[i];
        if (chunk) {
            if (chunk.loaded) {
                callback(start, end,
                         chunk.sequence.substring(start - (i * chunkSize),
                                                  end - (i * chunkSize)));
            } else {
                //console.log("added callback for %d .. %d", start, end);
                chunk.callbacks.push(callbackInfo);
            }
        } else {
            chunk = {
                loaded: false,
                num: i,
                callbacks: [callbackInfo]
            };
            this.chunks[i] = chunk;
            dojo.xhrGet({
                            url: this.baseUrl + i + ".txt",
                            load: function (response) {
                                var ci;
                                chunk.sequence = response;
                                for (var c = 0; c < chunk.callbacks.length; c++) {
                                    ci = chunk.callbacks[c];
                                    ci.callback(ci.start,
                                                ci.end,
                                                response.substring(ci.start - (chunk.num * chunkSize),
                                                                   ci.end - (chunk.num * chunkSize)));
                                }
                                chunk.callbacks = undefined;
                                chunk.loaded = true;
                            }
                        });
        }
    }
};

}

if(!dojo._hasResource["plugins.view.jbrowse.js.FeatureTrack"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.view.jbrowse.js.FeatureTrack"] = true;
dojo.provide("plugins.view.jbrowse.js.FeatureTrack");

dojo.declare( "plugins.view.jbrowse.js.FeatureTrack", null,
{
});

function FeatureTrack(trackMeta, url, refSeq, browserParams) {
    //trackMeta: object with:
    //            key:   display text track name
    //            label: internal track name (no spaces, odd characters)
    //url: URL of the track's JSON file
    //refSeq: object with:
    //         start: refseq start
    //         end:   refseq end
    //browserParams: object with:
    //                changeCallback: function to call once JSON is loaded
    //                trackPadding: distance in px between tracks
    //                baseUrl: base URL for the URL in trackMeta

    Track.call(this, trackMeta.label, trackMeta.key,
               false, browserParams.changeCallback);
    this.fields = {};
    this.features = new NCList();
    this.refSeq = refSeq;
    this.baseUrl = (browserParams.baseUrl ? browserParams.baseUrl : "");
    this.url = url;

// ADDED: TO USE IN 'clicked on feature' IN FeatureTrack.prototype.loadSuccess
	this.parentWidget = browserParams.parentWidget;
	//console.log("js.FeatureTrack    browserParams: ");
	//console.dir({browserParams:browserParams});
	//console.log("jbrowse.FeatureTrack.FeatureTrack    trackMeta: " + dojo.toJson(trackMeta));

// ADDED: TO FIX HISTOGRAM URL:
//    this.trackBaseUrl = (this.baseUrl + url).match(/^.+\//);
    this.trackBaseUrl = this.baseUrl;

//console.log("jbrowse.FeatureTrack.FeatureTrack    jbrowse.FeatureTrack.FeatureTrack(trackMeta, url, refSeq, browserParams)");
//	//console.log("jbrowse.FeatureTrack.FeatureTrack    this.trackBaseUrl: " + this.trackBaseUrl);
//	//console.log("jbrowse.FeatureTrack.FeatureTrack    this.baseUrl: " + this.baseUrl);
//	//console.log("jbrowse.FeatureTrack.FeatureTrack    url: " + url);
//	//console.log("jbrowse.FeatureTrack.FeatureTrack    this.trackBaseUrl: " + this.trackBaseUrl);

    //number of histogram bins per block
    this.numBins = 25;
    this.histLabel = false;
    this.padding = 5;
    this.trackPadding = browserParams.trackPadding;

    this.trackMeta = trackMeta;
    this.load(this.baseUrl + url);

    var thisObj = this;
}

FeatureTrack.prototype = new Track("");

FeatureTrack.prototype.loadSuccess = function(trackInfo) {
	//console.log("js.FeatureTrack.prototype.loadSuccess    caller: " + this.loadSuccess.caller.nom);
	//console.log("js.FeatureTrack.prototype.loadSuccess    trackInfo:");
	//console.dir({trackInfo:trackInfo});
	
    var startTime = new Date().getTime();
    this.count = trackInfo.featureCount;
    this.fields = {};
    for (var i = 0; i < trackInfo.headers.length; i++) {
	this.fields[trackInfo.headers[i]] = i;
    }
    this.subFields = {};
    if (trackInfo.subfeatureHeaders) {
        for (var i = 0; i < trackInfo.subfeatureHeaders.length; i++) {
            this.subFields[trackInfo.subfeatureHeaders[i]] = i;
        }
    }
    this.features.importExisting(trackInfo.featureNCList,
                                 trackInfo.sublistIndex,
                                 trackInfo.lazyIndex,
                                 this.trackBaseUrl,
                                 trackInfo.lazyfeatureUrlTemplate);
    if (trackInfo.subfeatureArray)
        this.subfeatureArray = new LazyArray(trackInfo.subfeatureArray,
                                             this.trackBaseUrl);

    this.histScale = 4 * (trackInfo.featureCount / this.refSeq.length);
    this.labelScale = 50 * (trackInfo.featureCount / this.refSeq.length);
    this.subfeatureScale = 80 * (trackInfo.featureCount / this.refSeq.length);
    this.className = trackInfo.className;
    this.subfeatureClasses = trackInfo.subfeatureClasses;
    this.arrowheadClass = trackInfo.arrowheadClass;
    this.urlTemplate = trackInfo.urlTemplate;
    this.histogramMeta = trackInfo.histogramMeta;
    for (var i = 0; i < this.histogramMeta.length; i++) {
        this.histogramMeta[i].lazyArray =
            new LazyArray(this.histogramMeta[i].arrayParams, this.trackBaseUrl);
    }
    this.histStats = trackInfo.histStats;
    this.histBinBases = trackInfo.histBinBases;

    if (trackInfo.clientConfig) {
        var cc = trackInfo.clientConfig;
        var density = trackInfo.featureCount / this.refSeq.length;
        this.histScale = (cc.histScale ? cc.histScale : 4) * density;
        this.labelScale = (cc.labelScale ? cc.labelScale : 50) * density;
        this.subfeatureScale = (cc.subfeatureScale ? cc.subfeatureScale : 80)
                                   * density;
        if (cc.featureCss) this.featureCss = cc.featureCss;
        if (cc.histCss) this.histCss = cc.histCss;
        if (cc.featureCallback) {
            try {
                this.featureCallback = eval("(" + cc.featureCallback + ")");
            } catch (e) {
                //console.log("eval failed for featureCallback on track " + this.name + ": " + cc.featureCallback);
            }
        }
    }

    //console.log((new Date().getTime() - startTime) / 1000);

	// CHANGED: ADDED thisObject
	var thisObject = this;

    var fields = this.fields;


    //if (! trackInfo.urlTemplate) {


	this.onFeatureClick = function(event) {

		//console.log("js.FeatureTrack.onFeatureClick    fired");

            event = event || window.event;
	    if (event.shiftKey) return;
	    var elem = (event.currentTarget || event.srcElement);
            //depending on bubbling, we might get the subfeature here
            //instead of the parent feature
            if (!elem.feature) elem = elem.parentElement;
            if (!elem.feature) return; //shouldn't happen; just bail if it does


// DISABLED: WORK IN PROGRESS
//		// CHANGED: ADDED CALL TO View.showUrl
//		//console.log("js.FeatureTrack.onFeatureClick   this.parentWidget: ");
//		//console.dir({parentWidget:thisObject.parentWidget});
//
//            var feat = elem.feature;
//	    alert("clicked on feature\n<br>XXXX<br>start: " + feat[fields["start"]] +
//	          ", end: " + feat[fields["end"]] +
//	          ", strand: " + feat[fields["strand"]] +
//	          ", label: " + feat[fields["name"]] +
//	          ", ID: " + feat[fields["id"]]);
        
		
		
		
		};
    //}

    this.setLoaded();
};

FeatureTrack.prototype.setViewInfo = function(genomeView, numBlocks,
                                              trackDiv, labelDiv,
                                              widthPct, widthPx, scale) {
    Track.prototype.setViewInfo.apply(this, [genomeView, numBlocks,
                                             trackDiv, labelDiv,
                                             widthPct, widthPx, scale]);
    this.setLabel(this.key);
};

FeatureTrack.prototype.fillHist = function(blockIndex, block,
                                           leftBase, rightBase,
                                           stripeWidth) {
    // bases in each histogram bin that we're currently rendering
    var bpPerBin = (rightBase - leftBase) / this.numBins;
    var pxPerCount = 2;
    var logScale = false;
    for (var i = 0; i < this.histStats.length; i++) {
        if (this.histStats[i].bases >= bpPerBin) {
            //console.log("bpPerBin: " + bpPerBin + ", histStats bases: " + this.histStats[i].bases + ", mean/max: " + (this.histStats[i].mean / this.histStats[i].max));
            logScale = ((this.histStats[i].mean / this.histStats[i].max) < .01);
            pxPerCount = 100 / (logScale
                                ? Math.log(this.histStats[i].max)
                                : this.histStats[i].max);
            break;
        }
    }
    var track = this;
    var makeHistBlock = function(hist) {
        var maxBin = 0;
        for (var bin = 0; bin < track.numBins; bin++) {
            if (typeof hist[bin] == 'number' && isFinite(hist[bin])) {
                maxBin = Math.max(maxBin, hist[bin]);
            }
        }
        var binDiv;
        for (var bin = 0; bin < track.numBins; bin++) {
            if (!(typeof hist[bin] == 'number' && isFinite(hist[bin])))
                continue;
            binDiv = document.createElement("div");
	    binDiv.className = track.className + "-hist";;
            binDiv.style.cssText =
                "left: " + ((bin / track.numBins) * 100) + "%; "
                + "height: "
                + (pxPerCount * (logScale ? Math.log(hist[bin]) : hist[bin]))
                + "px;"
                + "bottom: " + track.trackPadding + "px;"
                + "width: " + (((1 / track.numBins) * 100) - (100 / stripeWidth)) + "%;"
                + (track.histCss ? track.histCss : "");
            if (Util.is_ie6) binDiv.appendChild(document.createComment());
            block.appendChild(binDiv);
        }

        track.heightUpdate(pxPerCount * (logScale ? Math.log(maxBin) : maxBin),
                           blockIndex);
    };

    // The histogramMeta array describes multiple levels of histogram detail,
    // going from the finest (smallest number of bases per bin) to the
    // coarsest (largest number of bases per bin).
    // We want to use coarsest histogramMeta that's at least as fine as the
    // one we're currently rendering.
    // TODO: take into account that the histogramMeta chosen here might not
    // fit neatly into the current histogram (e.g., if the current histogram
    // is at 50,000 bases/bin, and we have server histograms at 20,000
    // and 2,000 bases/bin, then we should choose the 2,000 histogramMeta
    // rather than the 20,000)
    var histogramMeta = this.histogramMeta[0];
    for (var i = 0; i < this.histogramMeta.length; i++) {
        if (bpPerBin >= this.histogramMeta[i].basesPerBin)
            histogramMeta = this.histogramMeta[i];
    }

    // number of bins in the server-supplied histogram for each current bin
    var binCount = bpPerBin / histogramMeta.basesPerBin;
    // if the server-supplied histogram fits neatly into our current histogram,
    if ((binCount > .9)
        &&
        (Math.abs(binCount - Math.round(binCount)) < .0001)) {
        // we can use the server-supplied counts
        var firstServerBin = Math.floor(leftBase / histogramMeta.basesPerBin);
        binCount = Math.round(binCount);
        var histogram = [];
        for (var bin = 0; bin < this.numBins; bin++)
            histogram[bin] = 0;

        histogramMeta.lazyArray.range(
            firstServerBin,
            firstServerBin + (binCount * this.numBins),
            function(i, val) {
                // this will count features that span the boundaries of
                // the original histogram multiple times, so it's not
                // perfectly quantitative.  Hopefully it's still useful, though.
                histogram[Math.floor((i - firstServerBin) / binCount)] += val;
            },
            function() {
                makeHistBlock(histogram);
            }
        );
    } else {
        // make our own counts
        this.features.histogram(leftBase, rightBase,
                                this.numBins, makeHistBlock);
    }
};

FeatureTrack.prototype.endZoom = function(destScale, destBlockBases) {
    if (destScale < this.histScale) {
        this.setLabel(this.key + "<br>per " + Math.round(destBlockBases / this.numBins) + "bp");
    } else {
        this.setLabel(this.key);
    }
    this.clear();
};

FeatureTrack.prototype.fillBlock = function(blockIndex, block,
                                            leftBlock, rightBlock,
                                            leftBase, rightBase,
                                            scale, stripeWidth,
                                            containerStart, containerEnd) {
    //console.log("scale: %d, histScale: %d", scale, this.histScale);
    if (scale < this.histScale) {
	this.fillHist(blockIndex, block, leftBase, rightBase, stripeWidth,
                      containerStart, containerEnd);
    } else {
	this.fillFeatures(blockIndex, block, leftBlock, rightBlock,
                          leftBase, rightBase, scale,
                          containerStart, containerEnd);
    }
};

FeatureTrack.prototype.cleanupBlock = function(block) {
    if (block && block.featureLayout) block.featureLayout.cleanup();
};

FeatureTrack.prototype.transfer = function(sourceBlock, destBlock, scale,
                                           containerStart, containerEnd) {
    //transfer(sourceBlock, destBlock) is called when sourceBlock gets deleted.
    //Any child features of sourceBlock that extend onto destBlock should get
    //moved onto destBlock.

    if (!(sourceBlock && destBlock)) return;
    if (!sourceBlock.featureLayout) return;

    var destLeft = destBlock.startBase;
    var destRight = destBlock.endBase;
    var blockWidth = destRight - destLeft;
    var sourceSlot;

    var overlaps = (sourceBlock.startBase < destBlock.startBase)
                       ? sourceBlock.featureLayout.rightOverlaps
                       : sourceBlock.featureLayout.leftOverlaps;

    for (var i = 0; i < overlaps.length; i++) {
	//if the feature overlaps destBlock,
	//move to destBlock & re-position
	sourceSlot = sourceBlock.featureNodes[overlaps[i].id];
	if (sourceSlot && ("label" in sourceSlot)) {
            sourceSlot.label.parentNode.removeChild(sourceSlot.label);
	}
	if (sourceSlot && sourceSlot.feature) {
	    if ((sourceSlot.layoutEnd > destLeft)
		&& (sourceSlot.feature[this.fields["start"]] < destRight)) {

                sourceBlock.removeChild(sourceSlot);
                delete sourceBlock.featureNodes[overlaps[i].id];

                var featDiv =
                    this.renderFeature(sourceSlot.feature, overlaps[i].id,
                                   destBlock, scale,
                                   containerStart, containerEnd);
                destBlock.appendChild(featDiv);
            }
        }
    }
};

FeatureTrack.prototype.fillFeatures = function(blockIndex, block,
                                               leftBlock, rightBlock,
                                               leftBase, rightBase, scale,
                                               containerStart, containerEnd) {
    //arguments:
    //block: div to be filled with info
    //leftBlock: div to the left of the block to be filled
    //rightBlock: div to the right of the block to be filled
    //leftBase: starting base of the block
    //rightBase: ending base of the block
    //scale: pixels per base at the current zoom level
    //containerStart: don't make HTML elements extend further left than this
    //containerEnd: don't make HTML elements extend further right than this
    //0-based

    var layouter = new Layout(leftBase, rightBase);
    block.featureLayout = layouter;
    block.featureNodes = {};
    block.style.backgroundColor = "#ddd";

    //are we filling right-to-left (true) or left-to-right (false)?
    var goLeft = false;
    if (leftBlock && leftBlock.featureLayout) {
        leftBlock.featureLayout.setRightLayout(layouter);
        layouter.setLeftLayout(leftBlock.featureLayout);
    }
    if (rightBlock && rightBlock.featureLayout) {
        rightBlock.featureLayout.setLeftLayout(layouter);
        layouter.setRightLayout(rightBlock.featureLayout);
        goLeft = true;
    }

    //determine the glyph height, arrowhead width, label text dimensions, etc.
    if (!this.haveMeasurements) {
        this.measureStyles();
        this.haveMeasurements = true;
    }

    var curTrack = this;
    var featCallback = function(feature, path) {
        //uniqueId is a stringification of the path in the NCList where
        //the feature lives; it's unique across the top-level NCList
        //(the top-level NCList covers a track/chromosome combination)
        var uniqueId = path.join(",");
        //console.log("ID " + uniqueId + (layouter.hasSeen(uniqueId) ? " (seen)" : " (new)"));
        if (layouter.hasSeen(uniqueId)) {
            //console.log("this layouter has seen " + uniqueId);
            return;
        }
        var featDiv =
            curTrack.renderFeature(feature, uniqueId, block, scale,
                                   containerStart, containerEnd);
        block.appendChild(featDiv);
    };

    var startBase = goLeft ? rightBase : leftBase;
    var endBase = goLeft ? leftBase : rightBase;


    this.features.iterate(startBase, endBase, featCallback,
                          function () {
                              block.style.backgroundColor = "";
                              curTrack.heightUpdate(layouter.totalHeight,
                                                    blockIndex);
                          });
};

FeatureTrack.prototype.measureStyles = function() {
    //determine dimensions of labels (height, per-character width)
    var heightTest = document.createElement("div");
    heightTest.className = "feature-label";
    heightTest.style.height = "auto";
    heightTest.style.visibility = "hidden";
    heightTest.appendChild(document.createTextNode("1234567890"));
    document.body.appendChild(heightTest);
    this.nameHeight = heightTest.clientHeight;
    this.nameWidth = heightTest.clientWidth / 10;
    document.body.removeChild(heightTest);

    //measure the height of glyphs
    var glyphBox;
    heightTest = document.createElement("div");
    //cover all the bases: stranded or not, phase or not
    heightTest.className =
        this.className
        + " plus-" + this.className
        + " plus-" + this.className + "1";
    if (this.featureCss) heightTest.style.cssText = this.featureCss;
    heightTest.style.visibility = "hidden";
    if (Util.is_ie6) heightTest.appendChild(document.createComment("foo"));
    document.body.appendChild(heightTest);
    glyphBox = dojo.marginBox(heightTest);
    this.glyphHeight = Math.round(glyphBox.h + 2);
    this.padding += glyphBox.w;
    document.body.removeChild(heightTest);

    //determine the width of the arrowhead, if any
    if (this.arrowheadClass) {
        var ah = document.createElement("div");
        ah.className = "plus-" + this.arrowheadClass;
        if (Util.is_ie6) ah.appendChild(document.createComment("foo"));
        document.body.appendChild(ah);
        glyphBox = dojo.marginBox(ah);
        this.plusArrowWidth = glyphBox.w;
        ah.className = "minus-" + this.arrowheadClass;
        glyphBox = dojo.marginBox(ah);
        this.minusArrowWidth = glyphBox.w;
        document.body.removeChild(ah);
    }
};

FeatureTrack.prototype.renderFeature = function(feature, uniqueId, block, scale,
                                                containerStart, containerEnd) {
    var fields = this.fields;
    //featureStart and featureEnd indicate how far left or right
    //the feature extends in bp space, including labels
    //and arrowheads if applicable
    var featureEnd = feature[fields["end"]];
    var featureStart = feature[fields["start"]];
    if (this.arrowheadClass) {
        switch (feature[fields["strand"]]) {
        case 1:
            featureEnd   += (this.plusArrowWidth / scale); break;
        case -1:
            featureStart -= (this.minusArrowWidth / scale); break;
        }
    }

    // if the label extends beyond the feature, use the
    // label end position as the end position for layout
    if (scale > this.labelScale) {
	featureEnd = Math.max(featureEnd,
                              feature[fields["start"]]
                              + (((fields["name"] && feature[fields["name"]])
				  ? feature[fields["name"]].length : 0)
				 * (this.nameWidth / scale)));
    }
    featureEnd += Math.max(1, this.padding / scale);

    var levelHeight =
        this.glyphHeight + 2 +
        (
            (fields["name"] && (scale > this.labelScale)) ? this.nameHeight : 0
        );

    var top = block.featureLayout.addRect(uniqueId,
                                          featureStart,
                                          featureEnd,
                                          levelHeight);

    var featDiv;
    var featUrl = this.featureUrl(feature);
	//console.log("js.FeatureTrack.renderFeature    featUrl: " + featUrl);
    if (featUrl) {
		////console.log("js.FeatureTrack.renderFeature    featUrl: " + featUrl);
        featDiv = document.createElement("a");
        featDiv.href = featUrl;
        featDiv.target = "_new";
    } else {
        featDiv = document.createElement("div");
        featDiv.onclick = this.onFeatureClick;
    }
    featDiv.feature = feature;
    featDiv.layoutEnd = featureEnd;

    block.featureNodes[uniqueId] = featDiv;

    switch (feature[fields["strand"]]) {
    case 1:
        featDiv.className = "plus-" + this.className; break;
    case 0:
    case null:
    case undefined:
        featDiv.className = this.className; break;
    case -1:
        featDiv.className = "minus-" + this.className; break;
    }

    if ((fields["phase"] !== undefined) && (feature[fields["phase"]] !== null))
        featDiv.className = featDiv.className + feature[fields["phase"]];

    // Since some browsers don't deal well with the situation where
    // the feature goes way, way offscreen, we truncate the feature
    // to exist betwen containerStart and containerEnd.
    // To make sure the truncated end of the feature never gets shown,
    // we'll destroy and re-create the feature (with updated truncated
    // boundaries) in the transfer method.
    var displayStart = Math.max(feature[fields["start"]],
                                containerStart);
    var displayEnd = Math.min(feature[fields["end"]],
                              containerEnd);
    var blockWidth = block.endBase - block.startBase;
    featDiv.style.cssText =
        "left:" + (100 * (displayStart - block.startBase) / blockWidth) + "%;"
        + "top:" + top + "px;"
        + " width:" + (100 * ((displayEnd - displayStart) / blockWidth)) + "%;"
        + (this.featureCss ? this.featureCss : "");

    if (this.featureCallback) this.featureCallback(feature, fields, featDiv);

    if (this.arrowheadClass) {
        var ah = document.createElement("div");
        switch (feature[fields["strand"]]) {
        case 1:
            ah.className = "plus-" + this.arrowheadClass;
            ah.style.cssText = "left: 100%; top: 0px;";
            featDiv.appendChild(ah);
            break;
        case -1:
            ah.className = "minus-" + this.arrowheadClass;
            ah.style.cssText =
                "left: " + (-this.minusArrowWidth) + "px; top: 0px;";
            featDiv.appendChild(ah);
            break;
        }
    }

    if ((scale > this.labelScale)
        && fields["name"]
        && feature[fields["name"]]) {

        var labelDiv;
		//console.log("js.FeatureTrack.renderFeature    scale > this.labelScale    featUrl: " + featUrl);
        if (featUrl) {
            labelDiv = document.createElement("a");
            labelDiv.href = featUrl;
            labelDiv.target = featDiv.target;
        } else {
            labelDiv = document.createElement("div");
	    labelDiv.onclick = this.onFeatureClick;
        }

        labelDiv.className = "feature-label";
        labelDiv.appendChild(document.createTextNode(feature[fields["name"]]));
        labelDiv.style.cssText =
            "left: "
            + (100 * (feature[fields["start"]] - block.startBase) / blockWidth)
            + "%; "
            + "top: " + (top + this.glyphHeight) + "px;";
	featDiv.label = labelDiv;
        labelDiv.feature = feature;
        block.appendChild(labelDiv);
    }

    if (fields["subfeatures"]
        && (scale > this.subfeatureScale)
        && feature[fields["subfeatures"]]
        && feature[fields["subfeatures"]].length > 0) {

        for (var i = 0; i < feature[fields["subfeatures"]].length; i++) {
            this.renderSubfeature(feature, featDiv,
                                  feature[fields["subfeatures"]][i],
                                  displayStart, displayEnd);
        }
    }

    //ie6 doesn't respect the height style if the div is empty
    if (Util.is_ie6) featDiv.appendChild(document.createComment());
    //TODO: handle event-handler-related IE leaks
    return featDiv;
};

FeatureTrack.prototype.featureUrl = function(feature) {
    var urlValid = true;
    var fields = this.fields;
    if (this.urlTemplate) {
        var href = this.urlTemplate.replace(/\{([^}]+)\}/g,
        function(match, group) {
            if(feature[fields[group]] != undefined)
                return feature[fields[group]];
            else
                urlValid = false;
            return 0;
        });
		//console.log("js.FeatureTrack.featureUrl    urlValid: " + urlValid);

        if(urlValid) return href;
    }
    return undefined;
};

FeatureTrack.prototype.renderSubfeature = function(feature, featDiv, subfeature,
                                                   displayStart, displayEnd) {
    var subStart = subfeature[this.subFields["start"]];
    var subEnd = subfeature[this.subFields["end"]];
    var featLength = displayEnd - displayStart;

    var subDiv = document.createElement("div");

    if (this.subfeatureClasses) {
        var className = this.subfeatureClasses[subfeature[this.subFields["type"]]];
        switch (subfeature[this.subFields["strand"]]) {
        case 1:
            subDiv.className = "plus-" + className; break;
        case 0:
        case null:
        case undefined:
            subDiv.className = className; break;
        case -1:
            subDiv.className = "minus-" + className; break;
        }

    }

    // if the feature has been truncated to where it doesn't cover
    // this subfeature anymore, just skip this subfeature
    if ((subEnd <= displayStart) || (subStart >= displayEnd)) return;

    if (Util.is_ie6) subDiv.appendChild(document.createComment());
    subDiv.style.cssText =
        "left: " + (100 * ((subStart - displayStart) / featLength)) + "%;"
        + "top: 0px;"
        + "width: " + (100 * ((subEnd - subStart) / featLength)) + "%;";
    if (this.featureCallback)
        this.featureCallback(subfeature, this.subFields, subDiv);
    featDiv.appendChild(subDiv);
};

/*

Copyright (c) 2007-2010 The Evolutionary Software Foundation

Created by Mitchell Skinner <mitch_skinner@berkeley.edu>

This package and its accompanying libraries are free software; you can
redistribute it and/or modify it under the terms of the LGPL (either
version 2.1, or at your option, any later version) or the Artistic
License 2.0.  Refer to LICENSE for the full license text.

*/

}

if(!dojo._hasResource["plugins.view.jbrowse.js.UITracks"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.view.jbrowse.js.UITracks"] = true;
dojo.provide("plugins.view.jbrowse.js.UITracks");

dojo.declare( "plugins.view.jbrowse.js.UITracks", null,
{
});


//This track is for (e.g.) position and sequence information that should
//always stay visible at the top of the view

function StaticTrack(name, labelClass, posHeight) {
    Track.call(this, name, name, true, function() {});
    this.labelClass = labelClass;
    this.posHeight = posHeight;
    this.height = posHeight;
}

StaticTrack.prototype = new Track("");

StaticTrack.prototype.fillBlock = function(
										   blockIndex, block,
                                           leftBlock, rightBlock,
											leftBase, rightBase, scale,
											padding, stripeWidth) {
    var posLabel = document.createElement("div");
    posLabel.className = this.labelClass;
    posLabel.appendChild(document.createTextNode(Util.addCommas(leftBase)));
    posLabel.style.top = "0px";// y + "px";
    block.appendChild(posLabel);
    this.heightUpdate(this.posHeight, blockIndex);
};

//This track is for drawing the vertical gridlines

function GridTrack(name) {
    Track.call(this, name, name, true, function() {});
}

GridTrack.prototype = new Track("");

GridTrack.prototype.fillBlock = function(blockIndex, block,
                                         leftBlock, rightBlock,
                                         leftBase, rightBase, scale,
                                         padding, stripeWidth) {
    var gridline = document.createElement("div");
    gridline.className = "gridline";
    gridline.style.cssText = "left: 0%; width: 0px;";
    block.appendChild(gridline);
    this.heightUpdate(100, blockIndex);
};

/*

Copyright (c) 2007-2009 The Evolutionary Software Foundation

Created by Mitchell Skinner <mitch_skinner@berkeley.edu>

This package and its accompanying libraries are free software; you can
redistribute it and/or modify it under the terms of the LGPL (either
version 2.1, or at your option, any later version) or the Artistic
License 2.0.  Refer to LICENSE for the full license text.

*/

}

if(!dojo._hasResource["plugins.view.jbrowse.js.ImageTrack"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.view.jbrowse.js.ImageTrack"] = true;
dojo.provide("plugins.view.jbrowse.js.ImageTrack");

dojo.declare( "plugins.view.jbrowse.js.ImageTrack", null,
{
});


function ImageTrack(trackMeta, url, refSeq, browserParams) {
    Track.call(this, trackMeta.label, trackMeta.key,
               false, browserParams.changeCallback);
    this.refSeq = refSeq;
    this.tileToImage = {};
    this.zoomCache = {};
    this.baseUrl = (browserParams.baseUrl ? browserParams.baseUrl : "");
    this.load(this.baseUrl + url);

    this.imgErrorHandler = function(ev) {
        var img = ev.target || ev.srcElement;
        img.style.display = "none";
        dojo.stopEvent(ev);
    };
}

ImageTrack.prototype = new Track("");

ImageTrack.prototype.loadSuccess = function(o) {
    //tileWidth: width, in pixels, of the tiles
    this.tileWidth = o.tileWidth;
    //zoomLevels: array of {basesPerTile, scale, height, urlPrefix} hashes
    this.zoomLevels = o.zoomLevels;
    this.setLoaded();
};

ImageTrack.prototype.setViewInfo = function(heightUpdate, numBlocks,
                                            trackDiv, labelDiv,
                                            widthPct, widthPx, scale) {
    Track.prototype.setViewInfo.apply(this, [heightUpdate, numBlocks,
                                             trackDiv, labelDiv,
                                             widthPct, widthPx, scale]);
    this.setLabel(this.key);
};

ImageTrack.prototype.getZoom = function(scale) {
    var result = this.zoomCache[scale];
    if (result) return result;

    result = this.zoomLevels[0];
    var desiredBases = this.tileWidth / scale;
    for (i = 1; i < this.zoomLevels.length; i++) {
        if (Math.abs(this.zoomLevels[i].basesPerTile - desiredBases)
            < Math.abs(result.basesPerTile - desiredBases))
            result = this.zoomLevels[i];
    }

    this.zoomCache[scale] = result;
    return result;
};

ImageTrack.prototype.getImages = function(zoom, startBase, endBase) {
    //var startTile = ((startBase - this.refSeq.start) / zoom.basesPerTile) | 0;
    //var endTile = ((endBase - this.refSeq.start) / zoom.basesPerTile) | 0;
    var startTile = (startBase / zoom.basesPerTile) | 0;
    var endTile = (endBase / zoom.basesPerTile) | 0;
    startTile = Math.max(startTile, 0);
    var result = [];
    var im;
    for (var i = startTile; i <= endTile; i++) {
	im = this.tileToImage[i];
	if (!im) {
	    im = document.createElement("img");
            dojo.connect(im, "onerror", this.imgErrorHandler);
            //prepend this.baseUrl if zoom.urlPrefix is relative
            var absUrl = new RegExp("^(([^/]+:)|\/)");
            im.src = (zoom.urlPrefix.match(absUrl) ? "" : this.baseUrl)
                     + zoom.urlPrefix + i + ".png";
            //TODO: need image coord systems that don't start at 0?
	    im.startBase = (i * zoom.basesPerTile); // + this.refSeq.start;
	    im.baseWidth = zoom.basesPerTile;
	    im.tileNum = i;
	    this.tileToImage[i] = im;
	}
	result.push(im);
    }
    return result;
};

ImageTrack.prototype.fillBlock = function(blockIndex, block,
                                          leftBlock, rightBlock,
                                          leftBase, rightBase,
                                          scale, stripeWidth,
                                          containerStart, containerEnd) {
    var zoom = this.getZoom(scale);
    var blockWidth = rightBase - leftBase;
    var images = this.getImages(zoom, leftBase, rightBase);
    var im;

    for (var i = 0; i < images.length; i++) {
	im = images[i];
	if (!(im.parentNode && im.parentNode.parentNode)) {
            im.style.position = "absolute";
            im.style.left = (100 * ((im.startBase - leftBase) / blockWidth)) + "%";
            im.style.width = (100 * (im.baseWidth / blockWidth)) + "%";
            im.style.top = "0px";
            im.style.height = zoom.height + "px";
            block.appendChild(im);
	}
    }

    this.heightUpdate(zoom.height, blockIndex);
};

ImageTrack.prototype.startZoom = function(destScale, destStart, destEnd) {
    if (this.empty) return;
    this.tileToImage = {};
    this.getImages(this.getZoom(destScale), destStart, destEnd);
};

ImageTrack.prototype.endZoom = function(destScale, destBlockBases) {
    Track.prototype.clear.apply(this);
};

ImageTrack.prototype.clear = function() {
    Track.prototype.clear.apply(this);
    this.tileToImage = {};
};

ImageTrack.prototype.transfer = function(sourceBlock, destBlock, scale,
                                         containerStart, containerEnd) {
    if (!(sourceBlock && destBlock)) return;

    var children = sourceBlock.childNodes;
    var destLeft = destBlock.startBase;
    var destRight = destBlock.endBase;
    var im;
    for (var i = 0; i < children.length; i++) {
	im = children[i];
	if ("startBase" in im) {
	    //if sourceBlock contains an image that overlaps destBlock,
	    if ((im.startBase < destRight)
		&& ((im.startBase + im.baseWidth) > destLeft)) {
		//move image from sourceBlock to destBlock
		im.style.left = (100 * ((im.startBase - destLeft) / (destRight - destLeft))) + "%";
		destBlock.appendChild(im);
	    } else {
		delete this.tileToImage[im.tileNum];
	    }
	}
    }
};

/*

Copyright (c) 2007-2009 The Evolutionary Software Foundation

Created by Mitchell Skinner <mitch_skinner@berkeley.edu>

This package and its accompanying libraries are free software; you can
redistribute it and/or modify it under the terms of the LGPL (either
version 2.1, or at your option, any later version) or the Artistic
License 2.0.  Refer to LICENSE for the full license text.

*/

}

if(!dojo._hasResource["plugins.view.jbrowse.js.GenomeView"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.view.jbrowse.js.GenomeView"] = true;
dojo.provide("plugins.view.jbrowse.js.GenomeView");

dojo.declare( "plugins.view.jbrowse.js.GenomeView", null,
{
});


function Animation(subject, callback, time) {
    //subject: what's being animated
    //callback: function to call at the end of the animation
    //time: time for the animation to run
    if (subject === undefined) return;
    //don't want a zoom and a slide going on at the same time
    if ("animation" in subject) subject.animation.stop();
    this.index = 0;
    this.time = time;
    this.subject = subject;
    this.callback = callback;

    var myAnim = this;
    this.animFunction = function() { myAnim.animate(); };
    // number of milliseconds between frames (e.g., 33ms at 30fps)
    this.animID = setTimeout(this.animFunction, 33);

    this.frames = 0;

    subject.animation = this;
}

Animation.prototype.animate = function () {
    if (this.finished) {
	this.stop();
	return;
    }

    // number of milliseconds between frames (e.g., 33ms at 30fps)
    var nextTimeout = 33;
    var elapsed = 0;
    if (!("startTime" in this)) {
        this.startTime = (new Date()).getTime();
    } else {
        elapsed = (new Date()).getTime() - this.startTime;
        //set the next timeout to be the average of the
        //frame times we've achieved so far.
        //The goal is to avoid overloading the browser
        //and getting a jerky animation.
        nextTimeout = Math.max(33, elapsed / this.frames);
    }

    if (elapsed < this.time) {
        this.step(elapsed / this.time);
        this.frames++;
    } else {
	this.step(1);
        this.finished = true;
	//console.log("final timeout: " + nextTimeout);
    }
    this.animID = setTimeout(this.animFunction, nextTimeout);
};

Animation.prototype.stop = function() {
    clearTimeout(this.animID);
    delete this.subject.animation;
    this.callback(this);
};

function Slider(view, callback, time, distance) {
    Animation.call(this, view, callback, time);
    this.slideStart = view.getX();
    this.slideDistance = distance;
}

Slider.prototype = new Animation();

Slider.prototype.step = function(pos) {
    var newX = (this.slideStart -
                (this.slideDistance *
                 //cos will go from 1 to -1, we want to go from 0 to 1
                 ((-0.5 * Math.cos(pos * Math.PI)) + 0.5))) | 0;

    newX = Math.max(Math.min(this.subject.maxLeft - this.subject.offset, newX),
                         this.subject.minLeft - this.subject.offset);
    this.subject.setX(newX);
};

function Zoomer(scale, toScroll, callback, time, zoomLoc) {
    Animation.call(this, toScroll, callback, time);
    this.toZoom = toScroll.zoomContainer;
    var cWidth = this.toZoom.clientWidth;

    this.initialWidth = cWidth;

    // the container width when zoomFraction is 0
    this.width0 = cWidth * Math.min(1, scale);
    // the container width when zoomFraction is 1
    var width1 = cWidth * Math.max(1, scale);
    this.distance = width1 - this.width0;
    this.zoomingIn = scale > 1;
    //this.zoomLoc = zoomLoc;
    this.center =
        (toScroll.getX() + (toScroll.elem.clientWidth * zoomLoc))
        / toScroll.scrollContainer.clientWidth;

    // initialX and initialLeft can differ when we're scrolling
    // using scrollTop and scrollLeft
    this.initialX = this.subject.getX();
    this.initialLeft = parseInt(this.toZoom.style.left);
};

Zoomer.prototype = new Animation();

Zoomer.prototype.step = function(pos) {
    var zoomFraction = this.zoomingIn ? pos : 1 - pos;
    var newWidth =
        ((zoomFraction * zoomFraction) * this.distance) + this.width0;
    var newLeft = (this.center * this.initialWidth) - (this.center * newWidth);
    this.toZoom.style.width = newWidth + "px";
    this.toZoom.style.left = (this.initialLeft + newLeft) + "px";
    var forceRedraw = this.toZoom.offsetTop;
    this.subject.updateTrackLabels(this.initialX - newLeft);
};

function GenomeView(elem, stripeWidth, refseq, zoomLevel, browser) {
    //all coordinates are interbase

    //measure text width for the max zoom level
    var widthTest = document.createElement("div");
    widthTest.className = "sequence";
    widthTest.style.visibility = "hidden";
    var widthText = "12345678901234567890123456789012345678901234567890";
    widthTest.appendChild(document.createTextNode(widthText));
    elem.appendChild(widthTest);
    this.charWidth = widthTest.clientWidth / widthText.length;
    this.seqHeight = widthTest.clientHeight;
    elem.removeChild(widthTest);

    // measure the height of some arbitrary text in whatever font this
    // shows up in (set by an external CSS file)
    var heightTest = document.createElement("div");
    heightTest.className = "pos-label";
    heightTest.style.visibility = "hidden";
    heightTest.appendChild(document.createTextNode("42"));
    elem.appendChild(heightTest);
    this.posHeight = heightTest.clientHeight;
    // Add an arbitrary 50% padding between the position labels and the
    // topmost track
    this.topSpace = 1.5 * this.posHeight;
    elem.removeChild(heightTest);

    //the reference sequence
    this.ref = refseq;
    //current scale, in pixels per bp
    this.pxPerBp = zoomLevel;
    //width, in pixels, of the vertical stripes
    this.stripeWidth = stripeWidth;
    //the page element that the GenomeView lives in
    this.elem = elem;

    // the scrollContainer is the element that changes position
    // when the user scrolls
    this.scrollContainer = document.createElement("div");
    this.scrollContainer.id = "container";
    this.scrollContainer.style.cssText =
        "position: absolute; left: 0px; top: 0px;";
    elem.appendChild(this.scrollContainer);

    // we have a separate zoomContainer as a child of the scrollContainer.
    // they used to be the same element, but making zoomContainer separate
    // enables it to be narrower than this.elem.
    this.zoomContainer = document.createElement("div");
    this.zoomContainer.id = "zoomContainer";
    this.zoomContainer.style.cssText =
        "position: absolute; left: 0px; top: 0px; height: 100%;";
    this.scrollContainer.appendChild(this.zoomContainer);

    //width, in pixels of the "regular" (not min or max zoom) stripe
    this.regularStripe = stripeWidth;
    //width, in pixels, of stripes at full zoom (based on the sequence
    //character width)
    //The number of characters per stripe is somewhat arbitrarily set
    //at stripeWidth / 10
    this.fullZoomStripe = this.charWidth * (stripeWidth / 10);

//    this.overview = dojo.byId("overview");
    this.overview = browser.overview;	
    this.overviewBox = dojo.marginBox(this.overview);

    this.tracks = [];
    this.uiTracks = [];
    this.trackIndices = {};

    //set up size state (zoom levels, stripe percentage, etc.)
    this.sizeInit();

    //distance, in pixels, from the beginning of the reference sequence
    //to the beginning of the first active stripe
    //  should always be a multiple of stripeWidth
    this.offset = 0;
    //largest value for the sum of this.offset and this.getX()
    //this prevents us from scrolling off the right end of the ref seq
    this.maxLeft = this.bpToPx(this.ref.end) - this.dim.width;
    //smallest value for the sum of this.offset and this.getX()
    //this prevents us from scrolling off the left end of the ref seq
    this.minLeft = this.bpToPx(this.ref.start);
    //distance, in pixels, between each track
    this.trackPadding = 20;
    //extra margin to draw around the visible area, in multiples of the visible area
    //0: draw only the visible area; 0.1: draw an extra 10% around the visible area, etc.
    this.drawMargin = 0.2;
    //slide distance (pixels) * slideTimeMultiple + 200 = milliseconds for slide
    //1=1 pixel per millisecond average slide speed, larger numbers are slower
    this.slideTimeMultiple = 0.8;
    this.trackHeights = [];
    this.trackTops = [];
    this.trackLabels = [];
    this.waitElems = [dojo.byId("moveLeft"), dojo.byId("moveRight"),
                      dojo.byId("zoomIn"), dojo.byId("zoomOut"),
                      dojo.byId("bigZoomIn"), dojo.byId("bigZoomOut"),
                      document.body, elem];
    this.prevCursors = [];


	
    // SET this.locationThumb
    this.locationThumb = browser.locationThumb;
//    this.locationThumb = document.createElement("div");
    this.locationThumb.className = "locationThumb";
    this.overview.appendChild(this.locationThumb);
    this.locationThumbMover = new dojo.dnd.move.parentConstrainedMoveable(this.locationThumb, {area: "margin", within: true});
    dojo.connect(this.locationThumbMover, "onMoveStop", this, "thumbMoved");

    var view = this;

    var cssScroll = dojo.isIE;

    if (cssScroll) {
        view.x = -parseInt(view.scrollContainer.style.left);
        view.y = -parseInt(view.scrollContainer.style.top);
        view.getX = function() {
            return view.x;
        };
        view.getY = function() {
            return view.y;
        };
        view.getPosition = function() {
	    return { x: view.x, y: view.y };
        };
        view.rawSetX = function(x) {
            view.scrollContainer.style.left = -x + "px"; view.x = x;
        };
        view.setX = function(x) {
	    view.x = Math.max(Math.min(view.maxLeft - view.offset, x),
                              view.minLeft - view.offset);
            view.x = Math.round(view.x);
	    view.updateTrackLabels(view.x);
	    view.showFine();
            view.scrollContainer.style.left = -view.x + "px";
        };
        view.rawSetY = function(y) {
            view.scrollContainer.style.top = -y + "px"; view.y = y;
        };
        view.setY = function(y) {
            view.y = Math.min((y < 0 ? 0 : y),
                              view.containerHeight
                              - view.dim.height);
            view.y = Math.round(view.y);
            view.updatePosLabels(view.y);
            view.scrollContainer.style.top = -view.y + "px";
        };
        view.rawSetPosition = function(pos) {
            view.scrollContainer.style.left = -pos.x + "px";
            view.scrollContainer.style.top = -pos.y + "px";
        };
        view.setPosition = function(pos) {
            view.x = Math.max(Math.min(view.maxLeft - view.offset, pos.x),
                              view.minLeft - view.offset);
            view.y = Math.min((pos.y < 0 ? 0 : pos.y),
                              view.containerHeight - view.dim.height);
            view.x = Math.round(view.x);
            view.y = Math.round(view.y);

            view.updateTrackLabels(view.x);
            view.updatePosLabels(view.y);
	    view.showFine();

            view.scrollContainer.style.left = -view.x + "px";
            view.scrollContainer.style.top = -view.y + "px";
        };
    } else {
	view.x = view.elem.scrollLeft;
	view.y = view.elem.scrollTop;
        view.getX = function() {
	    return view.x;
	};
        view.getY = function() {
	    return view.y;
	};
        view.getPosition = function() {
	    return { x: view.x, y: view.y };
        };
        view.rawSetX = function(x) {
            view.elem.scrollLeft = x; view.x = x;
        };
        view.setX = function(x) {
	    view.x = Math.max(Math.min(view.maxLeft - view.offset, x),
			      view.minLeft - view.offset);
            view.x = Math.round(view.x);
	    view.updateTrackLabels(view.x);
	    view.showFine();

            view.elem.scrollLeft = view.x;
        };
        view.rawSetY = function(y) {
            view.elem.scrollTop = y; view.y = y;
        };
        view.rawSetPosition = function(pos) {
            view.elem.scrollLeft = pos.x; view.x = pos.x;
            view.elem.scrollTop = pos.y; view.y = pos.y;
        };

        view.setY = function(y) {
            view.y = Math.min((y < 0 ? 0 : y),
                              view.containerHeight
                              - view.dim.height);
            view.y = Math.round(view.y);
            view.updatePosLabels(view.y);
            view.elem.scrollTop = view.y;
        };
        view.setPosition = function(pos) {
            view.x = Math.max(Math.min(view.maxLeft - view.offset, pos.x),
                              view.minLeft - view.offset);
            view.y = Math.min((pos.y < 0 ? 0 : pos.y),
                              view.containerHeight - view.dim.height);
            view.x = Math.round(view.x);
            view.y = Math.round(view.y);

            view.updateTrackLabels(view.x);
            view.updatePosLabels(view.y);
	    view.showFine();

            view.elem.scrollLeft = view.x;
            view.elem.scrollTop = view.y;
	};
    }

    view.dragEnd = function(event) {
	dojo.forEach(view.dragEventHandles, dojo.disconnect);

	view.dragging = false;
        //view.elem.style.cursor = "url(\"openhand.cur\"), move";

//        view.elem.style.cursor = "url(\"openhand.cur\"), move";
        view.elem.style.cursor = "url(\"plugins/view/jbrowse/openhand.cur\"), move";

        document.body.style.cursor = "default";
        dojo.stopEvent(event);
	view.showCoarse();

        view.scrollUpdate();
	view.showVisibleBlocks(true);
    };

    var htmlNode = document.body.parentNode;
    var bodyNode = document.body;
    //stop the drag if we mouse out of the view
    view.checkDragOut = function(event) {
        if (!(event.relatedTarget || event.toElement)
            || (htmlNode === (event.relatedTarget || event.toElement))
            || (bodyNode === (event.relatedTarget || event.toElement)))
            view.dragEnd(event);
    };

    view.dragMove = function(event) {
	view.setPosition({
		x: view.winStartPos.x - (event.clientX - view.dragStartPos.x),
		y: view.winStartPos.y - (event.clientY - view.dragStartPos.y)
            });
        dojo.stopEvent(event);
    };

    view.mouseDown = function(event) {
        if ("animation" in view) {
            if (view.animation instanceof Zoomer) {
                dojo.stopEvent(event);
                return;

            } else {
                view.animation.stop();
            }
        }
	if (Util.isRightButton(event)) return;
        dojo.stopEvent(event);
	if (event.shiftKey || event.ctrlKey) return;
	view.dragEventHandles =
	    [
	     dojo.connect(document.body, "mouseup", view.dragEnd),
	     dojo.connect(document.body, "mousemove", view.dragMove),
	     dojo.connect(document.body, "mouseout", view.checkDragOut)
	     ];

	view.dragging = true;
	view.dragStartPos = {x: event.clientX,
			     y: event.clientY};
	view.winStartPos = view.getPosition();

	//document.body.style.cursor = "url(\"closedhand.cur\"), move";
	//view.elem.style.cursor = "url(\"closedhand.cur\"), move";
	document.body.style.cursor = "url(\"plugins/view/jbrowse/closedhand.cur\"), move";
	view.elem.style.cursor = "url(\"plugins/view/jbrowse/closedhand.cur\"), move";
    };

    dojo.connect(view.elem, "mousedown", view.mouseDown);

    dojo.connect(view.elem, "dblclick", function(event) {
	    if (view.dragging) return;
	    if ("animation" in view) return;
	    var zoomLoc = (event.pageX - dojo.coords(view.elem, true).x) / view.dim.width;
	    if (event.shiftKey) {
		view.zoomOut(event, zoomLoc, 2);
	    } else {
		view.zoomIn(event, zoomLoc, 2);
	    }
	    dojo.stopEvent(event);
	});

    view.afterSlide = function() {
	view.showCoarse();
        view.scrollUpdate();
	view.showVisibleBlocks(true);
    };

    view.zoomCallback = function() { view.zoomUpdate(); };

    var wheelScrollTimeout = null;
    var wheelScrollUpdate = function() {
	view.showVisibleBlocks(true);
	wheelScrollTimeout = null;
    };

    view.wheelScroll = function(e) {
	var oldY = view.getY();
        // arbitrary 60 pixel vertical movement per scroll wheel event
	var newY = Math.min(Math.max(0, oldY - 60 * Util.wheel(e)),
			    view.containerHeight - view.dim.height);
	view.setY(newY);

	//the timeout is so that we don't have to run showVisibleBlocks
	//for every scroll wheel click (we just wait until so many ms
	//after the last one).
	if (wheelScrollTimeout)
	    clearTimeout(wheelScrollTimeout);
        // 100 milliseconds since the last scroll event is an arbitrary
        // cutoff for deciding when the user is done scrolling
        // (set by a bit of experimentation)
	wheelScrollTimeout = setTimeout(wheelScrollUpdate, 100);
	dojo.stopEvent(e);
    };

    dojo.connect(view.scrollContainer, "mousewheel",
                 view.wheelScroll, false);

    dojo.connect(view.scrollContainer, "DOMMouseScroll",
                 view.wheelScroll, false);

    var trackDiv = document.createElement("div");
    trackDiv.className = "track";
    trackDiv.style.height = this.posHeight + "px";
    trackDiv.id = "static_track";
    this.staticTrack = new StaticTrack("static_track", "pos-label", this.posHeight);
    this.staticTrack.setViewInfo(function(height) {}, this.stripeCount,
                                 trackDiv, undefined, this.stripePercent,
                                 this.stripeWidth, this.pxPerBp);
    this.zoomContainer.appendChild(trackDiv);
    this.waitElems.push(trackDiv);

    var gridTrackDiv = document.createElement("div");
    gridTrackDiv.className = "track";
    gridTrackDiv.style.cssText = "top: 0px; height: 100%;";
    gridTrackDiv.id = "gridtrack";
    var gridTrack = new GridTrack("gridtrack");
    gridTrack.setViewInfo(function(height) {}, this.stripeCount,
                          gridTrackDiv, undefined, this.stripePercent,
                          this.stripeWidth, this.pxPerBp);
    this.zoomContainer.appendChild(gridTrackDiv);

    this.uiTracks = [this.staticTrack, gridTrack];

    dojo.forEach(this.uiTracks, function(track) {
        track.showRange(0, this.stripeCount - 1,
                        Math.round(this.pxToBp(this.offset)),
                        Math.round(this.stripeWidth / this.pxPerBp),
                        this.pxPerBp);
    }, this);

    this.zoomContainer.style.paddingTop = this.topSpace + "px";

    this.addOverviewTrack(new StaticTrack("overview_loc_track", "overview-pos", this.overviewPosHeight));

    //document.body.style.cursor = "url(\"closedhand.cur\")";
    document.body.style.cursor = "url(\"plugins/view/jbrowse/closedhand.cur\")";
    document.body.style.cursor = "default";

    this.showFine();
    this.showCoarse();
}

/* moves the view by (distance times the width of the view) pixels */
GenomeView.prototype.slide = function(distance) {
    if (this.animation) this.animation.stop();
    this.trimVertical();
    // slide for an amount of time that's a function of the distance being
    // traveled plus an arbitrary extra 200 milliseconds so that
    // short slides aren't too fast (200 chosen by experimentation)
    new Slider(this,
               this.afterSlide,
               Math.abs(distance) * this.dim.width * this.slideTimeMultiple + 200,
               distance * this.dim.width);
};

GenomeView.prototype.highlightRegions = function(regionList) {
};

GenomeView.prototype.setLocation = function(refseq, startbp, endbp) {
    if (startbp === undefined) startbp = this.minVisible();
    if (endbp === undefined) endbp = this.maxVisible();
    if ((startbp < refseq.start) || (startbp > refseq.end))
        startbp = refseq.start;
    if ((endbp < refseq.start) || (endbp > refseq.end))
        endbp = refseq.end;

    if (this.ref != refseq) {
	this.ref = refseq;
	var removeTrack = function(track) {
            if (track.div && track.div.parentNode)
                track.div.parentNode.removeChild(track.div);
	};
	dojo.forEach(this.tracks, removeTrack);
        dojo.forEach(this.uiTracks, function(track) { track.clear(); });
	this.overviewTrackIterate(removeTrack);

	this.addOverviewTrack(new StaticTrack("overview_loc_track", "overview-pos", this.overviewPosHeight));
        this.sizeInit();
        this.setY(0);
        this.containerHeight = this.topSpace;
    }
    this.pxPerBp = Math.min(this.dim.width / (endbp - startbp), this.charWidth);
    this.curZoom = Util.findNearest(this.zoomLevels, this.pxPerBp);
    if (Math.abs(this.pxPerBp - this.zoomLevels[this.zoomLevels.length - 1]) < 0.2) {
        //the cookie-saved location is in round bases, so if the saved
        //location was at the highest zoom level, the new zoom level probably
        //won't be exactly at the highest zoom (which is necessary to trigger
        //the sequence track), so we nudge the zoom level to be exactly at
        //the highest level if it's close.
        //Exactly how close is arbitrary; 0.2 was chosen to be close
        //enough that people wouldn't notice if we fudged that much.
        //console.log("nudging zoom level from %d to %d", this.pxPerBp, this.zoomLevels[this.zoomLevels.length - 1]);
        this.pxPerBp = this.zoomLevels[this.zoomLevels.length - 1];
    }
    this.stripeWidth = (this.stripeWidthForZoom(this.curZoom) / this.zoomLevels[this.curZoom]) * this.pxPerBp;
    this.instantZoomUpdate();

    this.centerAtBase((startbp + endbp) / 2, true);
};

GenomeView.prototype.stripeWidthForZoom = function(zoomLevel) {
    if ((this.zoomLevels.length - 1) == zoomLevel) {
        return this.fullZoomStripe;
    } else if (0 == zoomLevel) {
        return this.minZoomStripe;
    } else {
        return this.regularStripe;
    }
};

GenomeView.prototype.instantZoomUpdate = function() {
    this.scrollContainer.style.width =
        (this.stripeCount * this.stripeWidth) + "px";
    this.zoomContainer.style.width =
        (this.stripeCount * this.stripeWidth) + "px";
    this.maxOffset =
        this.bpToPx(this.ref.end) - this.stripeCount * this.stripeWidth;
    this.maxLeft = this.bpToPx(this.ref.end) - this.dim.width;
    this.minLeft = this.bpToPx(this.ref.start);
};

GenomeView.prototype.centerAtBase = function(base, instantly) {
    base = Math.min(Math.max(base, this.ref.start), this.ref.end);
    if (instantly) {
	var pxDist = this.bpToPx(base);
	var containerWidth = this.stripeCount * this.stripeWidth;
	var stripesLeft = Math.floor((pxDist - (containerWidth / 2)) / this.stripeWidth);
	this.offset = stripesLeft * this.stripeWidth;
	this.setX(pxDist - this.offset - (this.dim.width / 2));
	this.trackIterate(function(track) { track.clear(); });
	this.showVisibleBlocks(true);
        this.showCoarse();
    } else {
	var startbp = this.pxToBp(this.x + this.offset);
	var halfWidth = (this.dim.width / this.pxPerBp) / 2;
	var endbp = startbp + halfWidth + halfWidth;
	var center = startbp + halfWidth;
	if ((base >= (startbp  - halfWidth))
	    && (base <= (endbp + halfWidth))) {
	    //we're moving somewhere nearby, so move smoothly
            if (this.animation) this.animation.stop();
            var distance = (center - base) * this.pxPerBp;
	    this.trimVertical();
            // slide for an amount of time that's a function of the
            // distance being traveled plus an arbitrary extra 200
            // milliseconds so that short slides aren't too fast
            // (200 chosen by experimentation)
            new Slider(this, this.afterSlide,
                       Math.abs(distance) * this.slideTimeMultiple + 200,
		       distance);
	} else {
	    //we're moving far away, move instantly
	    this.centerAtBase(base, true);
	}
    }
};

GenomeView.prototype.minVisible = function() {
    return this.pxToBp(this.x + this.offset);
};

GenomeView.prototype.maxVisible = function() {
    return this.pxToBp(this.x + this.offset + this.dim.width);
};

GenomeView.prototype.showFine = function() {
    this.onFineMove(this.minVisible(), this.maxVisible());
};
GenomeView.prototype.showCoarse = function() {
	//console.log("js.GenomeView.showCoarse    this.minVisible(): " + dojo.toJson(this.minVisible()));
	//console.log("js.GenomeView.showCoarse    this.maxVisible(): " + dojo.toJson(this.maxVisible()));

	if ( ! this.minVisible() || ! this.maxVisible() ) {
		//console.log("js.GenomeView.showCoarse    ! this.minVisible() or ! this.maxVisible(). Returning");
		return;
	}
	
    this.onCoarseMove(this.minVisible(), this.maxVisible());
};

GenomeView.prototype.onFineMove = function() {};
GenomeView.prototype.onCoarseMove = function() {};

GenomeView.prototype.thumbMoved = function(mover) {
    var pxLeft = parseInt(this.locationThumb.style.left);
    var pxWidth = parseInt(this.locationThumb.style.width);
    var pxCenter = pxLeft + (pxWidth / 2);
    this.centerAtBase(((pxCenter / this.overviewBox.w) * (this.ref.end - this.ref.start)) + this.ref.start);
};

GenomeView.prototype.checkY = function(y) {
    return Math.min((y < 0 ? 0 : y), this.containerHeight - this.dim.height);
};

GenomeView.prototype.updatePosLabels = function(newY) {
    if (newY === undefined) newY = this.getY();
    this.staticTrack.div.style.top = newY + "px";
};

GenomeView.prototype.updateTrackLabels = function(newX) {
    if (newX === undefined) newX = this.getX();
    for (var i = 0; i < this.trackLabels.length; i++)
        this.trackLabels[i].style.left = newX + "px";
};

GenomeView.prototype.showWait = function() {
    var oldCursors = [];
    for (var i = 0; i < this.waitElems.length; i++) {
        oldCursors[i] = this.waitElems[i].style.cursor;
        this.waitElems[i].style.cursor = "wait";
    }
    this.prevCursors.push(oldCursors);
};

GenomeView.prototype.showDone = function() {
    var oldCursors = this.prevCursors.pop();
    for (var i = 0; i < this.waitElems.length; i++) {
        this.waitElems[i].style.cursor = oldCursors[i];
    }
};

GenomeView.prototype.pxToBp = function(pixels) {
    return pixels / this.pxPerBp;
};

GenomeView.prototype.bpToPx = function(bp) {
    return bp * this.pxPerBp;
};

GenomeView.prototype.sizeInit = function() {
    this.dim = {width: this.elem.clientWidth,
                height: this.elem.clientHeight};
    this.overviewBox = dojo.marginBox(this.overview);

    //scale values, in pixels per bp, for all zoom levels
    this.zoomLevels = [1/500000, 1/200000, 1/100000, 1/50000, 1/20000, 1/10000, 1/5000, 1/2000, 1/1000, 1/500, 1/200, 1/100, 1/50, 1/20, 1/10, 1/5, 1/2, 1, 2, 5, this.charWidth];
    //make sure we don't zoom out too far
    while (((this.ref.end - this.ref.start) * this.zoomLevels[0])
           < this.dim.width) {
        this.zoomLevels.shift();
    }
    this.zoomLevels.unshift(this.dim.width / (this.ref.end - this.ref.start));

    //width, in pixels, of stripes at min zoom (so the view covers
    //the whole ref seq)
    this.minZoomStripe = this.regularStripe * (this.zoomLevels[0] / this.zoomLevels[1]);

    this.curZoom = 0;
    while (this.pxPerBp > this.zoomLevels[this.curZoom])
        this.curZoom++;
    this.maxLeft = this.bpToPx(this.ref.end) - this.dim.width;

    delete this.stripePercent;
    //25, 50, 100 don't work as well due to the way scrollUpdate works
    var possiblePercents = [20, 10, 5, 4, 2, 1];
    for (var i = 0; i < possiblePercents.length; i++) {
        // we'll have (100 / possiblePercents[i]) stripes.
        // multiplying that number of stripes by the minimum stripe width
        // gives us the total width of the "container" div.
        // (or what that width would be if we used possiblePercents[i]
        // as our stripePercent)
        // That width should be wide enough to make sure that the user can
        // scroll at least one page-width in either direction without making
        // the container div bump into the edge of its parent element, taking
        // into account the fact that the container won't always be perfectly
        // centered (it may be as much as 1/2 stripe width off center)
        // So, (this.dim.width * 3) gives one screen-width on either side,
        // and we add a regularStripe width to handle the slightly off-center
        // cases.
        // The minimum stripe width is going to be halfway between
        // "canonical" zoom levels; the widest distance between those
        // zoom levels is 2.5-fold, so halfway between them is 0.7 times
        // the stripe width at the higher zoom level
        if (((100 / possiblePercents[i]) * (this.regularStripe * 0.7))
            > ((this.dim.width * 3) + this.regularStripe)) {
            this.stripePercent = possiblePercents[i];
            break;
        }
    }

    if (this.stripePercent === undefined) {
	//console.warn("stripeWidth too small: " + this.stripeWidth + ", " + this.dim.width);
	this.stripePercent = 1;
    }

    var oldX;
    var oldStripeCount = this.stripeCount;
    if (oldStripeCount) oldX = this.getX();
    this.stripeCount = Math.round(100 / this.stripePercent);

    this.scrollContainer.style.width =
        (this.stripeCount * this.stripeWidth) + "px";
    this.zoomContainer.style.width =
        (this.stripeCount * this.stripeWidth) + "px";

    var blockDelta = undefined;
    if (oldStripeCount && (oldStripeCount != this.stripeCount)) {
        blockDelta = Math.floor((oldStripeCount - this.stripeCount) / 2);
        var delta = (blockDelta * this.stripeWidth);
        var newX = this.getX() - delta;
        this.offset += delta;
        this.updateTrackLabels(newX);
        this.rawSetX(newX);
    }

    this.trackIterate(function(track, view) {
                          track.sizeInit(view.stripeCount,
                                         view.stripePercent,
                                         blockDelta);
                      });

    var newHeight = parseInt(this.scrollContainer.style.height);
    newHeight = (newHeight > this.dim.height ? newHeight : this.dim.height);

    this.scrollContainer.style.height = newHeight + "px";
    this.containerHeight = newHeight;

    var refLength = this.ref.end - this.ref.start;
    var posSize = document.createElement("div");
    posSize.className = "overview-pos";
    posSize.appendChild(document.createTextNode(Util.addCommas(this.ref.end)));
    posSize.style.visibility = "hidden";
    this.overview.appendChild(posSize);
    // we want the stripes to be at least as wide as the position labels,
    // plus an arbitrary 20% padding so it's clear which grid line
    // a position label corresponds to.
    var minStripe = posSize.clientWidth * 1.2;
    this.overviewPosHeight = posSize.clientHeight;
    this.overview.removeChild(posSize);
    for (var n = 1; n < 30; n++) {
	//http://research.att.com/~njas/sequences/A051109
        // JBrowse uses this sequence (1, 2, 5, 10, 20, 50, 100, 200, 500...)
        // as its set of zoom levels.  That gives nice round numbers for
        // bases per block, and it gives zoom transitions that feel about the
        // right size to me. -MS
	this.overviewStripeBases = (Math.pow(n % 3, 2) + 1) * Math.pow(10, Math.floor(n/3));
	this.overviewStripes = Math.ceil(refLength / this.overviewStripeBases);
	if ((this.overviewBox.w / this.overviewStripes) > minStripe) break;
	if (this.overviewStripes < 2) break;
    }

    var overviewStripePct = 100 / (refLength / this.overviewStripeBases);
    var overviewHeight = 0;
    this.overviewTrackIterate(function (track, view) {
	    track.clear();
	    track.sizeInit(view.overviewStripes,
			   overviewStripePct);
            track.showRange(0, view.overviewStripes - 1,
                            0, view.overviewStripeBases,
                            view.overviewBox.w /
                            (view.ref.end - view.ref.start));
	});
    this.updateOverviewHeight();
};

GenomeView.prototype.overviewTrackIterate = function(callback) {
    var overviewTrack = this.overview.firstChild;
    do {
        if (overviewTrack && overviewTrack.track)
	    callback(overviewTrack.track, this);
    } while (overviewTrack && (overviewTrack = overviewTrack.nextSibling));
};

GenomeView.prototype.updateOverviewHeight = function(trackName, height) {
    var overviewHeight = 0;
    this.overviewTrackIterate(function (track, view) {
	    overviewHeight += track.height;
	});
    this.overview.style.height = overviewHeight + "px";
    this.overviewBox = dojo.marginBox(this.overview);
};

GenomeView.prototype.addOverviewTrack = function(track) {
    var refLength = this.ref.end - this.ref.start;

    var overviewStripePct = 100 / (refLength / this.overviewStripeBases);
    var trackDiv = document.createElement("div");
    trackDiv.className = "track";
    trackDiv.style.height = this.overviewBox.h + "px";
    trackDiv.style.left = (((-this.ref.start) / refLength) * this.overviewBox.w) + "px";
    //trackDiv.id = "overviewtrack_" + track.name;
    trackDiv.track = track;
    var view = this;
    var heightUpdate = function(height) {
        view.updateOverviewHeight();
    };
    track.setViewInfo(heightUpdate, this.overviewStripes, trackDiv,
		      undefined,
		      overviewStripePct,
		      this.overviewStripeBases,
                      this.pxPerBp);
    this.overview.appendChild(trackDiv);
    this.updateOverviewHeight();

    return trackDiv;
};

GenomeView.prototype.trimVertical = function(y) {
    if (y === undefined) y = this.getY();
    var trackBottom;
    var trackTop = this.topSpace;
    var bottom = y + this.dim.height;
    for (var i = 0; i < this.tracks.length; i++) {
        if (this.tracks[i].shown) {
            trackBottom = trackTop + this.trackHeights[i];
            if (!((trackBottom > y) && (trackTop < bottom))) {
                this.tracks[i].hideAll();
            }
            trackTop = trackBottom + this.trackPadding;
        }
    }
};

GenomeView.prototype.zoomIn = function(e, zoomLoc, steps) {
    if (this.animation) return;
    if (zoomLoc === undefined) zoomLoc = 0.5;
    if (steps === undefined) steps = 1;
    steps = Math.min(steps, (this.zoomLevels.length - 1) - this.curZoom);
    if (0 == steps) return;

    this.showWait();
    var pos = this.getPosition();
    this.trimVertical(pos.y);

    var scale = this.zoomLevels[this.curZoom + steps] / this.pxPerBp;
    var fixedBp = this.pxToBp(pos.x + this.offset + (zoomLoc * this.dim.width));
    this.curZoom += steps;
    this.pxPerBp = this.zoomLevels[this.curZoom];
    this.maxLeft = (this.pxPerBp * this.ref.end) - this.dim.width;

    for (var track = 0; track < this.tracks.length; track++)
	this.tracks[track].startZoom(this.pxPerBp,
				     fixedBp - ((zoomLoc * this.dim.width)
                                                / this.pxPerBp),
				     fixedBp + (((1 - zoomLoc) * this.dim.width)
                                                / this.pxPerBp));
	//YAHOO.log("centerBp: " + centerBp + "; estimated post-zoom start base: " + (centerBp - ((zoomLoc * this.dim.width) / this.pxPerBp)) + ", end base: " + (centerBp + (((1 - zoomLoc) * this.dim.width) / this.pxPerBp)));

    var thisObj = this;
    // Zooms take an arbitrary 700 milliseconds, which feels about right
    // to me, although if the zooms were smoother they could probably
    // get faster without becoming off-putting. -MS
    new Zoomer(scale, this,
               function() {thisObj.zoomUpdate(zoomLoc, fixedBp);},
               700, zoomLoc);
};

GenomeView.prototype.zoomOut = function(e, zoomLoc, steps) {
    if (this.animation) return;
    if (steps === undefined) steps = 1;
    steps = Math.min(steps, this.curZoom);
    if (0 == steps) return;

    this.showWait();
    var pos = this.getPosition();
    this.trimVertical(pos.y);
    if (zoomLoc === undefined) zoomLoc = 0.5;
    var scale = this.zoomLevels[this.curZoom - steps] / this.pxPerBp;
    var edgeDist = this.bpToPx(this.ref.end) - (this.offset + pos.x + this.dim.width);
        //zoomLoc is a number on [0,1] that indicates
        //the fixed point of the zoom
    zoomLoc = Math.max(zoomLoc, 1 - (((edgeDist * scale) / (1 - scale)) / this.dim.width));
    edgeDist = pos.x + this.offset - this.bpToPx(this.ref.start);
    zoomLoc = Math.min(zoomLoc, ((edgeDist * scale) / (1 - scale)) / this.dim.width);
    var fixedBp = this.pxToBp(pos.x + this.offset + (zoomLoc * this.dim.width));
    this.curZoom -= steps;
    this.pxPerBp = this.zoomLevels[this.curZoom];

    for (var track = 0; track < this.tracks.length; track++)
	this.tracks[track].startZoom(this.pxPerBp,
				     fixedBp - ((zoomLoc * this.dim.width)
                                                / this.pxPerBp),
				     fixedBp + (((1 - zoomLoc) * this.dim.width)
                                                / this.pxPerBp));

	//YAHOO.log("centerBp: " + centerBp + "; estimated post-zoom start base: " + (centerBp - ((zoomLoc * this.dim.width) / this.pxPerBp)) + ", end base: " + (centerBp + (((1 - zoomLoc) * this.dim.width) / this.pxPerBp)));
    this.minLeft = this.pxPerBp * this.ref.start;

    var thisObj = this;
    // Zooms take an arbitrary 700 milliseconds, which feels about right
    // to me, although if the zooms were smoother they could probably
    // get faster without becoming off-putting. -MS
    new Zoomer(scale, this,
               function() {thisObj.zoomUpdate(zoomLoc, fixedBp);},
               700, zoomLoc);
};

GenomeView.prototype.zoomUpdate = function(zoomLoc, fixedBp) {
    var eWidth = this.elem.clientWidth;
    var centerPx = this.bpToPx(fixedBp) - (zoomLoc * eWidth) + (eWidth / 2);
    this.stripeWidth = this.stripeWidthForZoom(this.curZoom);
    this.scrollContainer.style.width =
        (this.stripeCount * this.stripeWidth) + "px";
    this.zoomContainer.style.width =
        (this.stripeCount * this.stripeWidth) + "px";
    var centerStripe = Math.round(centerPx / this.stripeWidth);
    var firstStripe = (centerStripe - ((this.stripeCount) / 2)) | 0;
    this.offset = firstStripe * this.stripeWidth;
    this.maxOffset = this.bpToPx(this.ref.end) - this.stripeCount * this.stripeWidth;
    this.maxLeft = this.bpToPx(this.ref.end) - this.dim.width;
    this.minLeft = this.bpToPx(this.ref.start);
    this.zoomContainer.style.left = "0px";
    this.setX((centerPx - this.offset) - (eWidth / 2));
    dojo.forEach(this.uiTracks, function(track) { track.clear(); });
    for (var track = 0; track < this.tracks.length; track++)
	this.tracks[track].endZoom(this.pxPerBp, Math.round(this.stripeWidth / this.pxPerBp));
    //YAHOO.log("post-zoom start base: " + this.pxToBp(this.offset + this.getX()) + ", end base: " + this.pxToBp(this.offset + this.getX() + this.dim.width));
    this.showVisibleBlocks(true);
    this.showDone();
    this.showCoarse();
};

GenomeView.prototype.scrollUpdate = function() {
    var x = this.getX();
    var numStripes = this.stripeCount;
    var cWidth = numStripes * this.stripeWidth;
    var eWidth = this.dim.width;
    //dx: horizontal distance between the centers of
    //this.scrollContainer and this.elem
    var dx = (cWidth / 2) - ((eWidth / 2) + x);
    //If dx is negative, we add stripes on the right, if positive,
    //add on the left.
    //We remove stripes from the other side to keep cWidth the same.
    //The end goal is to minimize dx while making sure the surviving
    //stripes end up in the same place.

    var dStripes = (dx / this.stripeWidth) | 0;
    if (0 == dStripes) return;
    var changedStripes = Math.abs(dStripes);

    var newOffset = this.offset - (dStripes * this.stripeWidth);

    if (this.offset == newOffset) return;
    this.offset = newOffset;

    this.trackIterate(function(track) { track.moveBlocks(dStripes); });

    var newX = x + (dStripes * this.stripeWidth);
    this.updateTrackLabels(newX);
    this.rawSetX(newX);
    var firstVisible = (newX / this.stripeWidth) | 0;
};

GenomeView.prototype.trackHeightUpdate = function(trackName, height) {
    var y = this.getY();
    if (! trackName in this.trackIndices) return;
    var track = this.trackIndices[trackName];
    if (Math.abs(height - this.trackHeights[track]) < 1) return;

    //console.log("trackHeightUpdate: " + trackName + " " + this.trackHeights[track] + " -> " + height);
    // if the bottom of this track is a above the halfway point,
    // and we're not all the way at the top,
    if ((((this.trackTops[track] + this.trackHeights[track]) - y)
         <  (this.dim.height / 2))
        && (y > 0) ) {
        // scroll so that lower tracks stay in place on screen
        this.setY(y + (height - this.trackHeights[track]));
        //console.log("track " + trackName + ": " + this.trackHeights[track] + " -> " + height + "; y: " + y + " -> " + this.getY());
    }
    this.trackHeights[track] = height;
    this.tracks[track].div.style.height = (height + this.trackPadding) + "px";
    var nextTop = this.trackTops[track];
    if (this.tracks[track].shown) nextTop += height + this.trackPadding;
    for (var i = track + 1; i < this.tracks.length; i++) {
        this.trackTops[i] = nextTop;
        this.tracks[i].div.style.top = nextTop + "px";
        if (this.tracks[i].shown)
            nextTop += this.trackHeights[i] + this.trackPadding;
    }
    this.containerHeight = Math.max(nextTop, this.getY() + this.dim.height);
    this.scrollContainer.style.height = this.containerHeight + "px";
};

GenomeView.prototype.showVisibleBlocks = function(updateHeight, pos, startX, endX) {
    if (pos === undefined) pos = this.getPosition();
    if (startX === undefined) startX = pos.x - (this.drawMargin * this.dim.width);
    if (endX === undefined) endX = pos.x + ((1 + this.drawMargin) * this.dim.width);
    var leftVisible = Math.max(0, (startX / this.stripeWidth) | 0);
    var rightVisible = Math.min(this.stripeCount - 1,
                               (endX / this.stripeWidth) | 0);

    var bpPerBlock = Math.round(this.stripeWidth / this.pxPerBp);

    var startBase = Math.round(this.pxToBp((leftVisible * this.stripeWidth)
                                           + this.offset));
    var containerStart = Math.round(this.pxToBp(this.offset));
    var containerEnd =
        Math.round(this.pxToBp(this.offset
                               + (this.stripeCount * this.stripeWidth)));

    this.trackIterate(function(track, view) {
                          track.showRange(leftVisible, rightVisible,
                                          startBase, bpPerBlock,
                                          view.pxPerBp,
                                          containerStart, containerEnd);
                      });
};

GenomeView.prototype.addTrack = function(track) {
	//console.log("js.GenomeView.addTrack    track:" + track);
	//console.dir({track:track});

    var trackNum = this.tracks.length;
    var labelDiv = document.createElement("div");
    labelDiv.className = "track-label dojoDndHandle";

	// ADD CLASSES	
	dojo.addClass(labelDiv, track.trackMeta.label + "-label");
	var sourceType = track.trackMeta.sourceType;
	if ( sourceType ) {
		var sourceClass = sourceType + "-label";
		//console.log("js.GenomeView.addTrack    ADDING CLASS sourceClass:" + sourceClass);
		dojo.addClass(labelDiv, sourceClass);
	}

	// ADD ONDBLCLICK
	var urlInfo = track.trackMeta.urlInfo;
	if ( urlInfo ) {
		//console.log("js.GenomeView.addTrack    ADDING ondblclick FOR label:" + track.trackMeta.label);
		labelDiv.ondblclick = function(event) {
			console.log("js.GenomeView.addTrack    FIRED ondblclick FOR urlInfo:" + urlInfo);
			window.open(urlInfo, "_blank");
			event.stopPropagation();
		}
	}
	else {
		labelDiv.ondblclick = function(event) {
			//console.log("js.GenomeView.addTrack    FIRED EMPTY ondblclick");
			event.stopPropagation();
		}
	}
	
    labelDiv.id = "label_" + track.name;
    this.trackLabels.push(labelDiv);
    var trackDiv = document.createElement("div");
    trackDiv.className = "track";
    trackDiv.id = "track_" + track.name;
    trackDiv.track = track;
    var view = this;
    var heightUpdate = function(height) {
        view.trackHeightUpdate(track.name, height);
    };
    track.setViewInfo(heightUpdate, this.stripeCount, trackDiv, labelDiv,
		      this.stripePercent, this.stripeWidth,
                      this.pxPerBp);

    labelDiv.style.position = "absolute";
    labelDiv.style.top = "0px";
    labelDiv.style.left = this.getX() + "px";
    trackDiv.appendChild(labelDiv);

    return trackDiv;
};

GenomeView.prototype.trackIterate = function(callback) {
    var i;
    for (i = 0; i < this.uiTracks.length; i++)
        callback(this.uiTracks[i], this);
    for (i = 0; i < this.tracks.length; i++)
        callback(this.tracks[i], this);
};

/* this function must be called whenever tracks in the GenomeView
 * are added, removed, or reordered
 */
GenomeView.prototype.updateTrackList = function() {
    var tracks = [];
    // after a track has been dragged, the DOM is the only place
    // that knows the new ordering
    var containerChild = this.zoomContainer.firstChild;
    do {
        // this test excludes UI tracks, whose divs don't have a track property
        if (containerChild.track) tracks.push(containerChild.track);
    } while ((containerChild = containerChild.nextSibling));
    this.tracks = tracks;

    var newIndices = {};
    var newHeights = new Array(this.tracks.length);
    for (var i = 0; i < tracks.length; i++) {
        newIndices[tracks[i].name] = i;
        if (tracks[i].name in this.trackIndices) {
            newHeights[i] = this.trackHeights[this.trackIndices[tracks[i].name]];
        } else {
            newHeights[i] = 0;
        }
        this.trackIndices[tracks[i].name] = i;
    }
    this.trackIndices = newIndices;
    this.trackHeights = newHeights;
    var nextTop = this.topSpace;
    for (var i = 0; i < this.tracks.length; i++) {
        this.trackTops[i] = nextTop;
        this.tracks[i].div.style.top = nextTop + "px";
        if (this.tracks[i].shown)
            nextTop += this.trackHeights[i] + this.trackPadding;
    }
};

/*

Copyright (c) 2007-2009 The Evolutionary Software Foundation

Created by Mitchell Skinner <mitch_skinner@berkeley.edu>

This package and its accompanying libraries are free software; you can
redistribute it and/or modify it under the terms of the LGPL (either
version 2.1, or at your option, any later version) or the Artistic
License 2.0.  Refer to LICENSE for the full license text.

*/

}

if(!dojo._hasResource["plugins.view.jbrowse.js.touchJBrowse"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.view.jbrowse.js.touchJBrowse"] = true;

dojo.provide("plugins.view.jbrowse.js.touchJBrowse");

dojo.declare( "plugins.view.jbrowse.js.touchJBrowse", null,
{
});


function CompareObjPos(nodes, touch) {
   var samePos = 0,
       j= 0,
       top = touch.pageY;
   
   for (var i=0; i < nodes.length; i++) {
      samePos = j++;
      var position = findPos(nodes[i]);
      if(position.top > top) {
         break;
      }
   }
   return samePos;
}

function checkAvatarPosition(first) {
      var leftPane = document.getElementById("tracksAvail"),
          rigthPane = document.getElementById("container");
     
       if (first.pageX < (leftPane.offsetLeft + leftPane.offsetWidth)) 
        {
         return leftPane;
         }
      else {
        return rigthPane;
        }
}  

var startX;

function removeTouchEvents() {

startX = null;

}


function touchSimulated(event)
{
    if(event.touches.length <= 1) {
   
        var touches = event.changedTouches,
            first = touches[0],
            type1 = "",
            type2 = "mouseover",
            objAvatar = document.getElementsByClassName("dojoDndAvatar"),
            obj = {},
            pane = checkAvatarPosition(first),
            nodes = pane.getElementsByClassName("dojoDndItem"),
            element = {},  
            simulatedEvent_1 = document.createEvent("MouseEvent"),
            simulatedEvent_2 = document.createEvent("MouseEvent");
            

               switch (event.type) {
            
                case "touchstart": 
                    startX = first.pageX;
                    type1 = "mousedown";
                    break;
        
                case "touchmove": 
                    event.preventDefault();
                    type1 = "mousemove";
                    break;
            
                default:
                return;
              }
            

            
            
        
    
    simulatedEvent_1.initMouseEvent(type1, true, true, window, 1, first.pageX, first.pageY, first.clientX,              first.clientY,
                                  false, false, false, false, 0, null);
                                                                            

simulatedEvent_2.initMouseEvent(type2, true, true, window, 1, first.pageX, first.pageY, first.clientX, first.clientY,
                               false, false, false, false, 0, null);
     
                        
                     
    
    switch (event.type) {
            
                case "touchstart": 
                    first.target.dispatchEvent(simulatedEvent_1);
                    first.target.dispatchEvent(simulatedEvent_2);
                    initialPane = pane;
                    break;
                case "touchmove": 
                    
                    if(objAvatar.length > 0) {
                        if (nodes.length > 0) {
                            element = CompareObjPos(nodes,first);
                            obj = nodes[element];
                        }
     
                        try {
                            
                            if (initialPane != pane) {
                                var simulatedEvent_3 = document.createEvent("MouseEvent");
                                var type3 = "mouseout";
                                simulatedEvent_3.initMouseEvent(type3, true, true, window, 1, 
                                first.pageX, first.pageY, first.clientX, first.clientY,
                                false, false, false, false, 0, null);
                                initialPane.dispatchEvent(simulatedEvent_3);
                            }
                           obj.dispatchEvent(simulatedEvent_2);
                             obj.dispatchEvent(simulatedEvent_1);
                        
                        }
                        catch(err) 
                        {
                            //No Elements in the pane
                            pane.dispatchEvent(simulatedEvent_2);
                            pane.dispatchEvent(simulatedEvent_1);
                        }
                    }
                    break;
                            
                default:
                return;
            }
       
  }
  else {
   removeTouchEvents();
   } 
}

function touchEnd(event) {
         
        
         
        var touches = event.changedTouches,
            first = touches[0],
            type1 = "mouseup",
            type2 = "mouseover",
            objAvatar = document.getElementsByClassName("dojoDndAvatar"),
            obj = {},
            pane = checkAvatarPosition(first),
            nodes = pane.getElementsByClassName("dojoDndItem"),
            element = {},  
            simulatedEvent_1 = document.createEvent("MouseEvent"),
            simulatedEvent_2 = document.createEvent("MouseEvent");
            
            
             if (startX !==  first.pageX) {
             //slide ocurrs
             event.preventDefault();
             }
            
            var test = findPos(first.target);
            
simulatedEvent_1.initMouseEvent(type1, true, true, window, 1, first.pageX, first.pageY, first.clientX,              first.clientY,
                                  false, false, false, false, 0, null);
                                                                            

simulatedEvent_2.initMouseEvent(type2, true, true, window, 1, first.pageX, first.pageY, first.clientX, first.clientY,
                               false, false, false, false, 0, null);




                    if(objAvatar.length > 0) {   
                        if (nodes.length > 0) {
                           element = CompareObjPos(nodes,first);
                            obj = nodes[element];
                         }
                                                                                   
                        try {
                            obj.dispatchEvent(simulatedEvent_2);
                            obj.dispatchEvent(simulatedEvent_1);
                            }
                        catch(error) 
                            {
                            first.target.dispatchEvent(simulatedEvent_2);
                            pane.dispatchEvent(simulatedEvent_2);
                            }    
                        }
                    else {
                            first.target.dispatchEvent(simulatedEvent_1);
                            first.target.dispatchEvent(simulatedEvent_2);
                        }



   removeTouchEvents();
}

function touchHandle(event)
{
 
    dojo.query(".dojoDndItemAnchor").connect("touchstart", touchSimulated);
    dojo.query(".dojoDndItemAnchor").connect("touchmove", touchSimulated);
    dojo.query(".dojoDndItemAnchor").connect("touchend", touchEnd); 
    dojo.query(".dojoDndItemAnchor").connect("click" , function(){void(0);});
   
     if(event.touches.length <= 1) {
   
     
		 var touches = event.changedTouches,
		 first = touches[0],
		 type = "";
		 
		 
		 
		 switch(event.type)
		 {
			 case "touchstart": 
				 startX = first.pageX;
				 type = "mousedown";
				 break;
				 
			 case "touchmove": 
				 event.preventDefault();
				 type = "mousemove";
				 break;
				 
			 case "touchend": 
				 if (startX !==  first.pageX) {
					 //slide ocurrs
					 event.preventDefault();
				 }
				 type = "mouseup";
				 break;
				 
				 
			 default:
				 return;
		 }
		 
		 
		 var simulatedEvent = document.createEvent("MouseEvent");
		 
		 simulatedEvent.initMouseEvent(type, true, true, window, 1, first.screenX, first.screenY, first.clientX, first.clientY,
									   false, false, false, false, 0/*left*/, null);
		 
		 first.target.dispatchEvent(simulatedEvent);
		 
	 }
	 else {
   removeTouchEvents();
   }
}




function touchinit() 
{
    dojo.query(".dojoDndItem").connect("touchstart", touchSimulated);
    dojo.query(".dojoDndItem").connect("touchmove", touchSimulated);
    dojo.query(".dojoDndItem").connect("touchend", touchEnd);
    
    dojo.query(".locationThumb").connect("touchstart", touchHandle);
    dojo.query(".locationThumb").connect("touchmove", touchHandle);
    dojo.query(".locationThumb").connect("touchend", touchHandle);
    
    dojo.query(".dojoDndItem").connect("click" , function(){void(0);});
    
    dojo.query(".dojoDndTarget").connect("touchstart", touchHandle);
    dojo.query(".dojoDndTarget").connect("touchmove", touchHandle);
    dojo.query(".dojoDndTarget").connect("touchend", touchHandle);
    
    dojo.query(".dijitSplitter").connect("touchstart", touchHandle);
    dojo.query(".dijitSplitter").connect("touchmove", touchHandle);
    dojo.query(".dijitSplitter").connect("touchend", touchHandle);
    
 }


function load()
{
  
    touchinit();
    document.documentElement.style.webkitTouchCallout = "none";
}

function findPos(obj) {
    var curtop = 0,
        objP = {};
	
    if (obj.offsetParent) {
	do {
			curtop += obj.offsetTop;
        } while ((obj = obj.offsetParent));
}

objP.top = curtop;

return objP;
}

}

if(!dojo._hasResource["plugins.view.View"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.view.View"] = true;
dojo.provide("plugins.view.View");

/* CLASS SUMMARY: CREATE AND MODIFY VIEWS
	
	TAB HIERARCHY IS AS FOLLOWS:
	
		tabs	

			mainTab

				leftPane (SELECT VIEW AND FEATURE TRACKS)

					comboBoxes

				rightPane (VIEW GENOMIC BROWSER)

						Browser

							Features (DRAG AND DROP FEATURE TRACKS LIST)

							GenomeView (GOOGLE MAPS-STYLE GENOME NAVIGATION)


	USE CASE SCENARIO 1: USER ADDS A FEATURE TO A VIEW

		OBJECTIVE:
		
			1. MINIMAL ACTION TO ACHIEVE THE DESIRE RESULT
			
			2. IMMEDIATE AND ANIMATED RESPONSES TO INDICATE STATUS/PROGRESS


		IMPLEMENTATION:
		
		1. USER SELECTS FEATURE IN BOTTOM OF LEFT PANE AND CLICKS 'Add'
		
		2. IF FEATURE ALREADY EXISTS IN VIEW, DO NOTHING.

		3. OTHERWISE, addViewFeature CALL TO REMOTE WILL RETURN STATUS OR AN ERROR:
		
			IF STATUS IS 'Adding feature: featureName':
				
				1. START DELAYED POLL FOR STATUS
			
				2. POLL WILL STOP WHEN STATUS IS 'ready'
				
					OR THERE IS AN ERROR RESPONSE
					
				3. IF 'ready' THEN UPDATE CLIENT AND SERVER DATABASES
				
					AND RESET THE VIEW FEATURES COMBO BOX
		
				4. USER CAN CLICK THE 'refresh' BUTTON TO REMOVE ANY ERROR OR 
				
					NON-'ready' STATUS (E.G., PROLONGED 'adding' OR 'removing'
					
					DUE TO ERROR ON REMOTE SERVER):
			
				5. THE 'refresh' BUTTON IS THE VIEW ICON ON LEFT OF VIEW COMBO BOX 
			
			IF STATUS IS DIFFERENT, DO NOTHING.
			
			E.G.: 'Feature already present in view: featureName'
		
		4. IF ERROR, DO NOTHING.
		
			E.G.: 'Undefined inputs: feature, project, view'

*/	
// EXTERNAL MODULES
if ( 1 ) {

// STORE FOR PROJECT AND WORKFLOW COMBOS


// DIALOGS
  // NOTES



// TIMER


// HAS A




// WIDGETS IN TEMPLATE











// INTERNAL MODULES

// JBROWSE
//dojo.require("plugins.view.jbrowse.jslib.dojo.jbrowse_dojo");














// STANDBY


// GENERAL




var refSeqs;
var trackInfo;


}

dojo.declare( "plugins.view.View",
	[ dijit._Widget, dijit._Templated, plugins.core.Common ], {
// PATH TO WIDGET TEMPLATE
templateString:"<div dojoAttachPoint=\"containerNode\">\n\n\t<div\n\t\tdojoAttachPoint=\"mainTab\"\n\t\tclass=\"view\"\n\t\ttitle=\"View\"\n\t\tdojoType=\"dijit.layout.BorderContainer\"\n\t\ticonClass=\"viewIcon\"\n\t\tstyle=\"width: 1100px !important; min-width: 100% !important;  height: 100% !important; min-height: 1200px !important; padding: 0px !important; bottom: 0px !important;\"\n\t\tclosable=\"true\"\n\t>\n\t\t\n\t\t<!-- LEFT PANE -->\n\t\t<div\n\t\t\tdojoAttachPoint=\"leftPane\" \n\t\t\tclass=\"leftPane\" \n\t\t\tdojoType=\"dojox.layout.ExpandoPane\" \n\t\t\tmaxWidth=\"200px\"\n\t\t\tsplitter=\"true\" \n\t\t\tduration=\"125\"\n\t\t\tregion=\"left\"\n\t\t\tstartExpanded=\"false\"\n\t\t\tstyle=\"width: 210px; min-width: 25px; background: #FFF; padding: 0; overflow: visible;\"\n\t\t\teaseIn=\"dojo.fx.easing.expoOut\" \n\t\t\teaseOut=\"dojo.fx.easing.expoInOut\"\n\t\t\tduration=\"100\"\n\t\t>\n\t\t\t\n\t\t\t<table width=\"210px\">\n\n\t\t\t\t<tr class=\"spacerTitle\">\n\n\t\t\t\t\t<td class=\"statusReady\"\n\t\t\t\t\t\tdojoAttachPoint=\"statusDisplay\"\n\t\t\t\t\t\tdojoAttachEvent=\"onclick:stopPoll\"\n\t\t\t\t\t>\n\t\t\t\t\t</td>\n\t\t\t\t\t<td colspan=\"1\" class=\"spacerTitle\">Views</td>\n\t\t\t\t\t<td class=\"spacerTitle\"> &nbsp; </td>\n\n\t\t\t\t</tr>\n\t\t\t\t<tr>\n\t\t\t\t\t<td class=\"viewTitle\" colspan=\"3\">Project</td>\n\t\t\t\t</tr>\n\n\t\t\t\t<tr>\n\t\t\t\t\t<td class=\"projectIcon\">\n\t\t\t\t\t</td>\n\t\t\t\t\t\n\t\t\t\t\t<td>\n\t\t\t\t\t\t<div dojoType=\"dijit.form.ComboBox\"\n\t\t\t\t\t\t\tclass=\"viewProjectCombo\"\n\t\t\t\t\t\t\tdojoAttachPoint=\"viewProjectCombo\"\n\t\t\t\t\t\t\tdojoAttachEvent=\"onChange:fireViewProjectCombo\"\n\t\t\t\t\t\t\tautocomplete=\"false\"\n\t\t\t\t\t\t\ttitle=\"Select a project containing your views\"\n\t\t\t\t\t\t>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</td>\n\t\t\t\t\t\n\t\t\t\t</tr>\t\t\n\n\t\t\t\t<tr>\n\t\t\t\t\t<td class=\"viewTitle\" colspan=\"4\">View</td>\n\t\t\t\t</tr>\n\t\t\t\t<tr>\n\t\t\n\t\t\t\t\t<td class=\"viewIcon\"\n\t\t\t\t\t\tdojoAttachEvent=\"onclick:refreshView\"\n\t\t\t\t\t\ttitle=\"Click to reload View\"\n\t\t\t\t\t>\n\t\t\t\t\t</td>\n\t\t\n\t\t\t\t\t<td>\n\t\t\n\t\t\t\t\t\t<div dojoType=\"dijit.form.ComboBox\"\n\t\t\t\t\t\t\tclass=\"viewCombo\"\n\t\t\t\t\t\t\tdojoAttachPoint=\"viewCombo\"\n\t\t\t\t\t\t\tdojoAttachEvent=\"onChange:fireViewCombo\"\n\t\t\t\t\t\t\tautocomplete=\"false\"'\n\t\t\t\t\t\t\ttitle=\"Select a view or type a name to create one\"\n\t\t\t\t\t\t>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</td>\n\t\t\t\t\t<td dojoAttachPoint=\"deleteViewButton\"\n\t\t\t\t\t\tclass=\"deleteViewButton\"\n\t\t\t\t\t\tdojoAttachEvent=\"onclick:confirmRemoveView\"\n\t\t\t\t\t\twidth=\"20%\"\n\t\t\t\t\t\talign=\"center\"\n\t\t\t\t\t\tclass=\"fileUpload\"\n\t\t\t\t\t\ttitle=\"Click to delete the selected View\"\n\t\t\t\t\t></td>\n\t\t\t\t</tr>\n\n\t\t\t\t<tr>\n\t\t\t\t\t<td class=\"viewTitle\" colspan=\"3\">Species</td>\n\t\t\t\t</tr>\n\n\t\t\t\t\t<td class=\"speciesIcon\">\n\t\t\t\t\t</td>\n\n\t\t\t\t\t<td>\n\t\t\t\t\t\t<table>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td\n\t\t\t\t\t\t\t\t\tclass=\"speciesLabel\"\n\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"speciesLabel\"\n\t\t\t\t\t\t\t\t>&nbsp;</td>\n\t\t\t\t\t\t\t\t<td\n\t\t\t\t\t\t\t\t\tclass=\"buildLabel\"\n\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"buildLabel\"\n\t\t\t\t\t\t\t\t>&nbsp;</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t</table>\n\t\t\t\t\t</td>\t\t\n\t\t\t\t</tr>\n\n\t\t\t\t<tr>\n\t\t\t\t\t<td class=\"viewTitle\" colspan=\"3\">Feature List</td>\n\t\t\t\t</tr>\n\n\t\t\t\t<tr>\n\t\t\t\t\t<td class=\"featureIcon\">\n\t\t\t\t\t</td>\n\n\t\t\t\t\t<td>\n\t\t\t\t\t\t<div dojoType=\"dijit.form.ComboBox\"\n\t\t\t\t\t\t\tclass=\"featureList\"\n\t\t\t\t\t\t\tdojoAttachPoint=\"featureList\"\n\t\t\t\t\t\t\tautocomplete=\"false\"\n\t\t\t\t\t\t\ttitle=\"Select a feature to add to the selected View\"\n\t\t\t\t\t\t>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</td>\n\n\t\t\t\t\t<td>\n\t\t\t\t\t\t<div dojoAttachPoint=\"deleteFeatureButton\"\n\t\t\t\t\t\tclass=\"deleteFeatureButton\"\n\t\t\t\t\t\tdojoAttachEvent=\"onclick:removeViewFeature\"\n\t\t\t\t\t\twidth=\"20%\"\n\t\t\t\t\t\talign=\"center\"\n\t\t\t\t\t\tclass=\"fileUpload\" ></div>\n\t\t\t\t\t</td>\n\t\t\t\t</tr>\n\n\n\t\t\t\t<tr>\n\t\t\t\t\t<td colspan=\"4\">\n\n\t\t\t\t\t\t<div class=\"addFeatures\">\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t<table class=\"addFeaturesTable\">\n\t\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t\t<td class=\"spacerTitle\" colspan=\"3\">Add Features</td>\n\t\t\t\t\t\t\t\t</tr>\n\t\t\t\t\n\t\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t\t<td class=\"viewTitle\" colspan=\"3\">Project</td>\n\t\t\t\t\t\t\t\t</tr>\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t\t<td class=\"projectIcon\">\n\t\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t\t\t<div dojoType=\"dijit.form.ComboBox\"\n\t\t\t\t\t\t\t\t\t\t\tclass=\"featureProjectCombo\"\n\t\t\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"featureProjectCombo\"\n\t\t\t\t\t\t\t\t\t\t\tdojoAttachEvent=\"onChange:fireFeatureProjectCombo\"\n\t\t\t\t\t\t\t\t\t\t\tautocomplete=\"false\"\n\t\t\t\t\t\t\t\t\t\t\ttitle=\"Select a project containing features\"\n\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\n\t\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t\t<td class=\"viewTitle\" colspan=\"3\">Workflow</td>\n\t\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t\t<tr>\n\t\t\t\t\n\t\t\t\t\t\t\t\t\t<td class=\"workflowIcon\">\n\t\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t\t\t<div dojoType=\"dijit.form.ComboBox\"\n\t\t\t\t\t\t\t\t\t\t\tclass=\"workflowCombo\"\n\t\t\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"workflowCombo\"\n\t\t\t\t\t\t\t\t\t\t\tdojoAttachEvent=\"onChange:fireWorkflowCombo\"\n\t\t\t\t\t\t\t\t\t\t\tautocomplete=\"false\"\n\t\t\t\t\t\t\t\t\t\t\ttitle=\"Select a workflow containing features\"\n\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t\t<td class=\"viewTitle\" colspan=\"3\">Species</td>\n\t\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t\t<tr>\n\t\t\t\t\n\t\t\t\t\t\t\t\t\t<td class=\"speciesIcon\">\n\t\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\n\t\t\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t\t\t<select dojoType=\"dijit.form.ComboBox\"\n\t\t\t\t\t\t\t\t\t\t\tclass=\"speciesCombo\"\n\t\t\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"speciesCombo\"\n\t\t\t\t\t\t\t\t\t\t\tdojoAttachEvent=\"onChange:fireSpeciesCombo\"\n\t\t\t\t\t\t\t\t\t\t\tautocomplete=\"false\"\n\t\t\t\t\t\t\t\t\t\t\ttitle=\"Select a species and build to display features below\"\n\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t</tr>\n\t\t\t\t\n\t\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t\t<td class=\"viewTitle\" colspan=\"3\">Feature Tracks</td>\n\t\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t\t<td class=\"featureIcon\">\n\t\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\n\t\t\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t\t\t<div dojoType=\"dijit.form.ComboBox\"\n\t\t\t\t\t\t\t\t\t\t\tclass=\"featureCombo\"\n\t\t\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"featureCombo\"\n\t\t\t\t\t\t\t\t\t\t\tautocomplete=\"false\"\n\t\t\t\t\t\t\t\t\t\t\ttitle=\"Select a feature to add to the selected view\"\n\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t</tr>\n\t\t\t\t\n\t\t\t\t\t\t\t\t<tr align=\"center\">\n\t\t\t\t\t\t\t\t\t<td colspan=\"3\">\n\t\t\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"addFeatureButton\"\n\t\t\t\t\t\t\t\t\t\t\tdojoAttachEvent=\"onclick:addViewFeature\"\n\t\t\t\t\t\t\t\t\t\t\tclass=\"addFeatureButton\"\n\t\t\t\t\t\t\t\t\t\t\twidth=\"20%\"\n\t\t\t\t\t\t\t\t\t\t\talign=\"center\"\n\t\t\t\t\t\t\t\t\t\t\tclass=\"fileUpload\"\n\t\t\t\t\t\t\t\t\t\t\ttitle=\"Click to add the selected Feature to the selected View\"\n\t\t\t\t\t\t\t\t\t\t\t>Add</div>\n\t\t\t\t\t\t\t\t\t</td>\t\t\t\t\t\n\t\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t</table>\n\n\t\t\t\t\t\t</div>\n\t\t\t\t\n\t\t\t\t\t</td>\n\t\t\t\t</tr>\n\t\t\t\t\n\t\t\t</table>\n\n\n\t\t</div>\n\t\t<!-- END OF LEFT PANE -->\n\n\n\t\t<!-- RIGHT PANE -->\n\t\t<div\n\t\t\tdojoType=\"dijit.layout.TabContainer\" \n\t\t\tdojoAttachPoint=\"rightPane\"\n\t\t\tclass=\"rightPane\" \n\t\t\tregion=\"center\"\n\t\t>\n\n\n\t\t</div>\n\t\t<!-- END OF RIGHT PANE -->\n\n\t</div>\n\t<!-- END OF VIEW TAB dijit.layout.BorderContainer -->\n\n</div> \n",

// PARENT NODE, I.E., TABS NODE
parentWidget : null,

// PROJECT NAME AND WORKFLOW NAME IF AVAILABLE
project : null,
workflow : null,

// onChangeListeners : Array. LIST OF COMBOBOX ONCHANGE LISTENERS
onChangeListeners : new Object,

// setListeners : Boolean. SET LISTENERS FLAG 
setListeners : false,

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

// cssFiles: Array
// CSS FILES
cssFiles : [
	dojo.moduleUrl("plugins", "view/css/view.css"),
	dojo.moduleUrl("plugins", "view/css/genome.css"),
	dojo.moduleUrl("dojox", "layout/resources/ExpandoPane.css"),
	dojo.moduleUrl("dojox", "layout/tests/_expando.css"),
	dojo.moduleUrl("plugins", "dnd/css/dnd.css")
],

// browsers: Array
// HASH ARRAY OF OPENED BROWSERS
browsers : [],

// url: String
// URL FOR REMOTE DATABASE
url: null,

// baseUrl : String
// BASE URL FOR VIEW DATA
baseUrl: "plugins/view/jbrowse/",

// browserUrl : String
// ROOT URL FOR Browser.js OBJECT
browserRoot : "plugins/view/jbrowse/",

// polling : Bool
// Polling for completion of new view
polling : false,

// delay : Int
// Delay between each poll (1000 = 1 second)
delay : 10000,

////}}}
constructor : function(args) {	
	//console.log("View.constructor    plugins.view.View.constructor(args)");

	// SET ARGS
	this.parentWidget = args.parentWidget;
	this.project = args.project;
	this.workflow = args.workflow;
	
	// SET url
	if ( Agua.cgiUrl )	this.url = Agua.cgiUrl + "/view.cgi";
	
	// LOAD CSS
	if ( args["cssFiles"] != null ) this.cssFiles = args.cssFiles;
	//console.log("View.constructor    this.cssFiles: " + dojo.toJson(this.cssFiles));
	this.loadCSS(this.cssFiles);		
},
postCreate: function() {
	this.startup();
},
// STARTUP
startup : function () {
	console.log("View.startup    plugins.view.Template.View.startup()");
	
    // ADD THIS WIDGET TO Agua.widgets[type]
    Agua.addWidget("view", this);

	// SET UP THE ELEMENT OBJECTS AND THEIR VALUE FUNCTIONS
	this.inherited(arguments);
	
	// ADD THE PANE TO THE TAB CONTAINER
	this.attachWidget.addChild(this.mainTab);
	this.attachWidget.selectChild(this.mainTab);
	
	// EXPAND LEFT PANE (WAS CLOSED SO THAT RIGHT PANE WOULD RENDER)
	this.leftPane.toggle();

	// SET URL
	this.setUrl();
	
	// SET PROGRESS POLL DELAY OBJECT
	this.setSequence();

	// SET DIALOG WIDGETS
	this.setConfirmDialog();
	this.setSelectiveDialog();

	// SET LOADING STANDBY
	this.setStandby();
	
	// LOAD COMBOS IN SUCCESSION
	this.setViewProjectCombo();
	
	// SET COMBO LISTENERS
	setTimeout(
		function (thisObj) { thisObj.setFeatureProjectCombo(); },
		10,
		this
	);

	// SET VIEW COMBO ONKEYCHANGE LISTENER
	setTimeout(
		function (thisObj) { thisObj.setOnkeyListener(); },
		1000,
		this
	);

	// LOAD BROWSER
	setTimeout(
		function (thisObj) { thisObj.loadBrowser(thisObj.getProject(), thisObj.getView()); },
		2000,
		this
	);	
},
loadEval : function (url) {
	console.log("View.loadEval    url: " + url);
	// SEND TO SERVER
	dojo.xhrGet(
		{
			url: url,
			sync: true,
			handleAs: "text",
			load: function(response) {
				//console.log("View.loadEval    response: " + dojo.toJson(response));
				eval(response);
			},
			error: function(response, ioArgs) {
				console.log("  View.loadEval    Response error. Response: " + response);
				return response;
			}
		}
	);	
},
// GETTERS
getRefseqfile : function (username, projectName, viewName) {
	return this.baseUrl + "/users"
						+ "/" + username
						+ "/" + projectName
						+ "/" + viewName
						+ "/data/refSeqs.js";
},
getTrackinfofile : function (username, projectName, viewName) {
	return this.baseUrl + "/users"
						+ "/" + username
						+ "/" + projectName
						+ "/" + viewName
						+ "/data/trackInfo.js";
},
getProject : function () {
	return this.viewProjectCombo.get('value');
},
getWorkflow : function () {
	return this.workflowCombo.get('value');
},
getView : function () {
	//console.log("view.View.getView    plugins.view.Views.getView()");	
	//console.log("view.View.getView    Returning this.viewCombo.get('value'): " + this.viewCombo.get('value'));
	return this.viewCombo.get('value');
},
getViewFeature : function () {
	return this.featureList.get('value') ?
		this.featureList.get('value') : '' ;
},
getBuild : function () {
	//console.log("View.getBuild    View.getBuild()");
	return this.buildLabel.innerHTML;
},
getSpecies : function () {
	//console.log("View.getSpecies    View.getSpecies()");
	return this.speciesLabel.innerHTML;
},
getFeatureBuild : function () {
	//console.log("View.getFeatureBuild    View.getFeatureBuild()");
	var speciesBuild = this.speciesCombo.get('value');
	//console.log("View.getFeatureBuild    speciesBuild: "+ speciesBuild);

	if ( speciesBuild.match(/^(\S+)\(([^\)]+)\)$/) )
		return  speciesBuild.match(/^(\S+)\(([^\)]+)\)$/)[2];
},
getFeatureSpecies : function () {
	//console.log("View.getFeatureSpecies    View.getFeatureSpecies()");
	//console.log("View.getFeatureSpecies    this: " + this);

	var speciesBuild = this.speciesCombo.get('value');
	//console.log("View.getFeatureSpecies    speciesBuild: "+ speciesBuild);

	if ( speciesBuild.match(/^(\S+)\(([^\)]+)\)$/) )
		return speciesBuild.match(/^(\S+)\(([^\)]+)\)$/)[1];
},
getFeature : function () {
	return this.featureCombo.get('value');
},
getFeatureProject : function () {
	return this.featureProjectCombo.get('value');
},
getFeatureWorkflow : function () {
	return this.workflowCombo.get('value');
},
setUrl : function () {
	this.url = Agua.cgiUrl + "view.cgi?";
	return this.url;
},
setSequence : function () {
	this.sequence = new plugins.dojox.timing.Sequence({});
},
setOnkeyListener : function () {
	//console.log("View.setOnkeyListener    plugins.view.View.setOnkeyListener()");

	// SET ONKEYPRESS LISTENER
	var thisObject = this;
	this.viewCombo._onKey = function(event){
		//console.log("View.setOnKeyListener._onKey	  event");
		
		// summary: handles keyboard events
		var key = event.charOrCode;			
		//console.log("View.setOnKeyListener._onKey	    key: " + key);
		if ( key == 13 )
		{
			//thisObject.workflowCombo._hideResultList();
			
			var projectName = thisObject.viewProjectCombo.get('value');
			var viewName = thisObject.viewCombo.get('value');
			//console.log("View.setOnKeyListener._onKey	   projectName: " + projectName);
			//console.log("View.setOnKeyListener._onKey	   thisObject.viewCombo: " + thisObject.viewCombo);
			//console.log("View.setOnKeyListener._onKey	   viewName: " + viewName);
			
			// STOP PROPAGATION
			//event.stopPropagation();
			
			//console.log("View.setOnKeyListener._onKey	   Checking if isView");
			var isView = Agua.isView(projectName, viewName);
			console.log("View.setOnKeyListener._onKey	   isView: " + isView);

			if ( isView == false )	thisObject.confirmAddView(projectName, viewName);
				
			if ( thisObject.viewCombo._popupWidget != null )
			{
				thisObject.viewCombo._showResultList();
			}
		}

		// STOP PROPAGATION
		//event.stopPropagation();
	};
},
setConfirmDialog : function () {
	var yesCallback = function (){};
	var noCallback = function (){};
	var title = "Dialog title";
	var message = "Dialog message";
	
	this.confirmDialog = new plugins.dijit.ConfirmDialog(
		{
			title 				:	title,
			message 			:	message,
			parentWidget 		:	this,
			yesCallback 		:	yesCallback,
			noCallback 			:	noCallback
		}			
	);
},
loadConfirmDialog : function (title, message, yesCallback, noCallback) {
	////console.log("View.loadConfirmDialog    plugins.files.View.loadConfirmDialog()");
	////console.log("View.loadConfirmDialog    yesCallback.toString(): " + yesCallback.toString());
	////console.log("View.loadConfirmDialog    title: " + title);
	////console.log("View.loadConfirmDialog    message: " + message);
	////console.log("View.loadConfirmDialog    yesCallback: " + yesCallback);
	////console.log("View.loadConfirmDialog    noCallback: " + noCallback);

	this.confirmDialog.load(
		{
			title 				:	title,
			message 			:	message,
			yesCallback 		:	yesCallback,
			noCallback 			:	noCallback
		}			
	);
},
setSelectiveDialog : function () {
	var enterCallback = function (){};
	var cancelCallback = function (){};
	var title = "";
	var message = "";
	
	console.log("Stages.setSelectiveDialog    plugins.files.Stages.setSelectiveDialog()");
	this.selectiveDialog = new plugins.dijit.SelectiveDialog(
		{
			title 				:	title,
			message 			:	message,
			parentWidget 		:	this,
			enterCallback 		:	enterCallback,
			cancelCallback 		:	cancelCallback
		}			
	);
	console.log("Stages.setSelectiveDialog    this.selectiveDialog: " + this.selectiveDialog);
},
loadSelectiveDialog : function (title, message, comboValues, inputMessage, comboMessage, checkboxMessage, enterCallback, cancelCallback) {
	console.log("Stages.loadSelectiveDialog    plugins.files.Stages.loadSelectiveDialog()");
	console.log("Stages.loadSelectiveDialog    enterCallback.toString(): " + enterCallback.toString());
	console.log("Stages.loadSelectiveDialog    title: " + title);
	console.log("Stages.loadSelectiveDialog    message: " + message);
	console.log("Stages.loadSelectiveDialog    enterCallback: " + enterCallback);
	console.log("Stages.loadSelectiveDialog    cancelCallback: " + cancelCallback);


	this.selectiveDialog.load(
		{
			title 				:	title,
			message 			:	message,
			comboValues 		:	comboValues,
			inputMessage 		:	inputMessage,
			comboMessage 		:	comboMessage,
			checkboxMessage		:	checkboxMessage,
			parentWidget 		:	this,
			enterCallback 		:	enterCallback,
			cancelCallback 		:	cancelCallback
		}			
	);
},
// COMBO METHODS
setViewProjectCombo : function (projectName, viewName) {
	console.log("View.setViewProjectCombo    projectName: " + projectName);
	console.log("View.setViewProjectCombo    viewName: " + viewName);

	var projects = Agua.getProjects();
	var projectNames = Agua.getProjectNames(projects);
	console.log("View.setViewProjectCombo    BEFORE SORT projectNames: ");
	console.dir({ projectNames: projectNames});
	
	console.log("View.setViewProjectCombo    DOING projectNames.sort(this.sortNaturally)");
	projectNames.sort(this.sortNaturally);

	console.log("View.setViewProjectCombo    AFTER SORT projectNames: ");
	console.dir({ projectName: projectName});

	if ( ! projectNames )
	{
		//console.log("  Common.setViewProjectCombo    projectNames not defined. Returning.");
		return;
	}
	////console.log("  Common.setViewProjectCombo    projects: " + dojo.toJson(projects));

	// DO DATA ARRAY
	var data = {identifier: "name", items: []};
	for ( var i in projectNames )
		data.items[i] = { name: projectNames[i]	};
	var store = new dojo.data.ItemFileReadStore( {	data: data	} );
	this.viewProjectCombo.store = store;	
	
	// SET PROJECT IF NOT DEFINED TO FIRST ENTRY IN projects
	if ( projectName == null || ! projectName)	projectName = projectNames[0];	
	this.viewProjectCombo.setValue(projectName);			
	
	if ( projectName == null )	projectName = this.viewProjectCombo.get('value');

	// RESET THE WORKFLOW COMBO
	//console.log("View.setViewProjectCombo    BEFORE this.setWorkflowCombo(" + projectName + ")");
	this.setViewCombo(projectName, viewName);
},
setViewCombo : function (projectName, viewName) {
	//console.log("View.setViewCombo    plugins.view.View.setViewCombo(projectName, viewName)");
	console.log("View.setViewCombo    projectName: " + projectName);
	console.log("View.setViewCombo    viewName: " + viewName);

	// DO COMBO WIDGET SETUP	
	this.inherited(arguments);
	
	// SET VIEW NAME IF NOT DEFINED
	if ( viewName == null )
	{
		var views = Agua.getViewsByProject(projectName);
		////console.log("View.setViewCombo    views: " + dojo.toJson(views));
		if ( views == null || views.length == 0 )	return;
		if ( views.length > 0 ) viewName = views[0].view;
	}
	//console.log("View.setViewCombo    DOING this.setSpeciesCombo(" + projectName + ", " + viewName + ")");
	
	this.setSpeciesLabel(projectName, viewName);
},
setSpeciesLabel : function (projectName, viewName) {
// SET SPECIES AND BUILD LABELS
	//console.log("View.setSpeciesLabel    plugins.view.View.setSpeciesLabel(projectName, viewName)");
	console.log("View.setSpeciesLabel    projectName: " + projectName);
	console.log("View.setSpeciesLabel    viewName: " + viewName);

	var species = Agua.getSpecies(projectName, viewName);
	this.speciesLabel.innerHTML = species || '';
	var build = Agua.getBuild(projectName, viewName);
	this.buildLabel.innerHTML = build || '';

	// SET SPECIES COMBO VALUE
	var setValue = species + "(" + build + ")";
	this.speciesCombo.set('value', setValue);

	// SET FEATURE LIST
	var viewfeatures = Agua.getViewFeatures(projectName, viewName);
	var featureNames = this.hashArrayKeyToArray(viewfeatures, "feature");
	//for ( var i = 0; i < viewfeatures.length; i++ )
	//	featureNames.push(viewfeatures[i].feature);
	//console.log("View.setSpeciesLabel    featureNames: " + dojo.toJson(featureNames));

	this.setFeatureList(featureNames);
},
setFeatureProjectCombo : function (projectName, workflowName) {
	console.log("Common.setFeatureProjectCombo    projectName: " + projectName);

	var projectNames = Agua.getFeatureProjects();
	console.log("  View.setFeatureProjectCombo    projects: ");
	console.dir({projectNames:projectNames});

	// DO DATA ARRAY
	var data = {identifier: "name", items: []};
	for ( var i in projectNames )
		data.items[i] = { name: projectNames[i]	};

	var store = new dojo.data.ItemFileReadStore( {	data: data	} );
	this.featureProjectCombo.store = store;	
	
	// SET PROJECT IF NOT DEFINED TO FIRST ENTRY IN projects
	if ( projectName == null || ! projectName)
		projectName = projectNames[0];	
	this.featureProjectCombo.setValue(projectName);			
	
	if ( projectName == null )
		projectName = this.featureProjectCombo.get('value');

	// RESET THE WORKFLOW COMBO
	////console.log("Common.setFeatureProjectCombo    BEFORE this.setWorkflowCombo(" + projectName + ")");
	this.setWorkflowCombo(projectName);
},
setWorkflowCombo : function (projectName, workflowName) {
	console.log("View.setWorkflowCombo    projectName: " + projectName);
	console.log("View.setWorkflowCombo    workflowName: " + workflowName);

	if ( projectName == null || ! projectName )	return;
	if ( this.workflowCombo == null )	return;
	
	// CREATE THE DATA FOR A STORE		
	var workflowNames = Agua.getViewProjectWorkflows(projectName);
	console.log("View.setWorkflowCombo    projectName '" + projectName + "' workflowNames: ");
	console.dir({workflowNames:workflowNames});
	
	// RETURN IF workflowNames NOT DEFINED
	if ( ! workflowNames )	return;

	// CREATE store
	var data = {identifier: "name", items: []};
	for ( var i in workflowNames )
		data.items[i] = { name: workflowNames[i]	};
	//////console.log("View.setWorkflowCombo    data: " + dojo.toJson(data));
	var store = new dojo.data.ItemFileReadStore( { data: data } );
	this.workflowCombo.store = store;

	// START UP COMBO AND SET SELECTED VALUE TO FIRST ENTRY IN workflowNames IF NOT DEFINED 
	if ( workflowName == null || ! workflowName )	workflowName = workflowNames[0];
	////console.log("View.setWorkflowCombo    workflowName: " + workflowName);

	this.workflowCombo.startup();
	this.workflowCombo.set('value', workflowName);			

	//// SET CSS
	//this.workflowCombo.popupClass = "view viewCombo dijitReset dijitMenu";
	//this.workflowCombo.wrapperClass = "view dijitPopup";
	//this.workflowCombo.itemHeight = 30;		

	if ( projectName == null ) projectName = this.viewProjectCombo.get('value');
	if ( workflowName == null ) workflowName = this.workflowCombo.get('value');

	// RESET THE VIEW COMBO
	this.setSpeciesCombo(projectName, workflowName);
},
setSpeciesCombo : function (projectName, workflowName, speciesName, buildName) {
	////console.log("View.setSpeciesCombo    plugins.view.View.setSpeciesCombo(projectName, workflowName)");
	////console.log("View.setSpeciesCombo    projectName: " + projectName);
	////console.log("View.setSpeciesCombo    workflowName: " + workflowName);

	// SET DROP TARGET (LOAD MIDDLE PANE, BOTTOM)
	if ( projectName == null ) projectName = this.featureProjectCombo.get('value');
	if ( workflowName == null ) workflowName = this.workflowCombo.get('value');

	var viewfeatures = Agua.getViewWorkflowFeatures(projectName, workflowName);
	if ( viewfeatures == null || viewfeatures.length == 0 ) {
		////console.log("View.setSpeciesCombo    viewfeatures is null or empty. Returning");
		return;
	}
	//////console.log("View.setSpeciesCombo    viewfeatures: " + dojo.toJson(viewfeatures));

	// GET SPECIES+BUILD NAMES
	var speciesBuildNames = new Array;
	for ( var i = 0; i < viewfeatures.length; i++ ) {
		speciesBuildNames.push(viewfeatures[i].species + "(" + viewfeatures[i].build + ")");
	}
	speciesBuildNames = this.uniqueValues(speciesBuildNames);
	////console.log("View.setSpeciesCombo    speciesBuildNames: " + dojo.toJson(speciesBuildNames));

	// SET SPECIES+ BUILD NAME
	var speciesBuildName;
	if ( speciesName == null || ! speciesName
		|| buildName == null || ! buildName ) {
		speciesBuildName = speciesBuildNames[0];
		speciesName = viewfeatures[0].species;
		buildName = viewfeatures[0].build;
	}
	else {
		speciesBuildName = speciesName + "(" + buildName + ")";
	}
	////console.log("View.setSpeciesCombo    speciesBuildName: " + speciesBuildName);

	// DO data FOR store
	var data = {identifier: "name", items: []};
	for ( var i in speciesBuildNames )
	{
		data.items[i] = { name: speciesBuildNames[i]	};
	}
	var store = new dojo.data.ItemFileReadStore( { data: data } );
	this.speciesCombo.store = store;

	// START UP COMBO (?? NEEDED ??)
	this.speciesCombo.startup();
	this.speciesCombo.set('value', speciesBuildName);			

	this.setFeatureCombo(projectName, workflowName, speciesName, buildName);
},
setFeatureCombo : function (projectName, workflowName, speciesName, buildName) {
	console.log("View.setFeatureCombo    plugins.view.View.setFeatureCombo(projectName, workflowName)");
	console.log("View.setFeatureCombo    projectName: " + projectName);
	console.log("View.setFeatureCombo    workflowName: " + workflowName);

	if ( projectName == null || ! projectName 
		|| workflowName == null || ! workflowName 
		|| speciesName == null || ! speciesName 
		|| buildName == null || ! buildName )
	{
		console.log("View.setFeatureCombo    Project, workflow, species or build not defined. Returning.");
		return;
	}

	// CREATE THE DATA FOR A STORE		
	var featureNames = 	Agua.getViewSpeciesFeatureNames(projectName, workflowName, speciesName, buildName);
	if ( ! featureNames )
	{
		console.log("View.setFeatureCombo    featureNames not defined. Returning.");
		return;
	}
	console.log("View.setFeatureCombo    projectName '" + projectName + "' workflowName '" + workflowName + "' speciesName '" + speciesName + "' buildName '" + buildName + "' featureNames: " + dojo.toJson(featureNames));

	// CREATE store
	var data = {identifier: "name", items: []};
	for ( var i in featureNames )
		data.items[i] = { name: featureNames[i]	};
	console.log("View.setFeatureCombo    data: " + dojo.toJson(data));
	var store = new dojo.data.ItemFileReadStore( { data: data } );
	this.featureCombo.store = store;

	// SET SELECTED VALUE TO FIRST ENTRY IN featureNames
	var featureName = featureNames[0];

	this.featureCombo.startup();
	this.featureCombo.set('value', featureName);			
},
setFeatureList : function (featureNames) {
	//console.log("View.setFeatureList    plugins.view.View.setFeatureList(featureNames)");
	console.log("View.setFeatureList    featureNames: " + dojo.toJson(featureNames));

	var data = {identifier: "name", items: []};
	for ( var i in featureNames )
		data.items[i] = { name: featureNames[i]	};

	// CREATE store
	//console.log("View.setFeatureList    data: " + dojo.toJson(data));
	var store = new dojo.data.ItemFileReadStore( { data: data } );
	this.featureList.store = store;

	// START UP COMBO AND SET SELECTED VALUE TO FIRST ENTRY 
	this.featureList.startup();
	this.featureList.set('value', featureNames[0]);			
},
// POLLING
_delayedPoll : function (viewObject, callback, message) {
	console.log("View._delayedPoll    viewObject:");
	console.dir({viewObject:viewObject});
	//console.log("View._delayedPoll    callback: " + callback);

	var putData 		= viewObject;
	putData.mode 		= "viewStatus";
	putData.username 	= Agua.cookie('username');
	putData.sessionid 	= Agua.cookie('sessionid');
	console.log("View._delayedPoll    putData:");
	console.dir({putData:putData});

	if ( ! message )	message = "";
	var delay = this.delay;
	//console.log("View._delayedPoll    delay: " + delay);
	var commands = [
		{ func: [ this.showMessage, this, message, putData ], pauseAfter: delay }
		, { func: [ this.pollStatus, this, putData, callback ] } 
	];
	
	//console.log("View._delayedPoll    sequence:");
	//console.dir({this_sequence:this.sequence});

	this.sequence.clear();
	this.sequence.go(commands, function() {});	
},
pollStatus : function(putData, callback) {
	console.log("View.pollStatus    putData:");
	console.dir({putData:putData});
	//console.log("View.pollStatus    callback: " + callback);
	console.log("View.pollStatus    this.polling: " + this.polling);

	if ( ! this.polling ) 	return;
	
	var url = this.url;
	var thisObject = this;
	this.pollStatusDeferred = dojo.xhrPut({
		url			: 	url,
		handleAs	: 	"json-comment-optional",
		sync		: 	false,
		putData		:	dojo.toJson(putData),
		handle		: 	function (response) {
			callback(response, putData);
		}
	});
},
stopPoll : function () {
	this.polling = false;
	console.log("View.stopPoll    this.polling: " + this.polling);
	if ( ! this.pollStatusDeferred )	return
	this.pollStatusDeferred.handle = function () {};
},
// VIEW METHODS
refreshView : function () {
/* RESET VIEW STATUS TO 'ready' AND RELOAD PANE */
	console.log("View.refreshView    plugins.view.View.refreshView()");
	
	// HIDE STANDBY
	this.standby.hide();
	
	// DISPLAY LOADING
	this.displayLoading();

	// RELOAD BROWSER
	this.reloadBrowser(this.getProject(), this.getView());

	// PREPARE FEATURE TRACK OBJECT
	var featureObject = new Object;
	// SOURCE FEATURE
	featureObject.feature = this.getFeature();
	featureObject.sourceproject = this.getFeatureProject();
	featureObject.sourceworkflow = this.getFeatureWorkflow();
	featureObject.species = this.getFeatureSpecies();
	featureObject.build = this.getFeatureBuild();
	// VIEW INFO
	featureObject.project = this.getProject();
	featureObject.view = this.getView();
	// USER INFO
	featureObject.username = Agua.cookie('username');
	featureObject.sessionid = Agua.cookie('sessionid');
	// MODE
	featureObject.mode = "refreshView";

	// DO REMOTE CALL
	var url = Agua.cgiUrl + "view.cgi";
	var callback = dojo.hitch(this, "_refreshView");
	this.doPut({ url: this.url, query: featureObject, callback: callback });
},
_refreshView : function (response) {
	//console.log("View._refreshView    response: " + dojo.toJson(response));
	//console.log("View._refreshView    this: ");
	;

	// DISPLAY READY
	this.displayReady();

	if ( ! response )	{
		Agua.toastError("Problem reloading 'views'/'viewfeatures'");
	}
	else {
		Agua.setData("views", response.views);
		Agua.setData("viewfeatures", response.viewfeatures);
		this.setViewCombo(this.getProject());
	}
},
updateViewLocation : function (viewObject, location, chrom) {	
	// SKIP IF STILL LOADING
	if ( this.loading == true )	return 1;

	console.log("View.updateViewLocation    location: " + location);

	//console.log("View.updateViewLocation    caller: " + this.updateViewLocation.caller.nom);
	//console.log("View.updateViewLocation    viewObject: " + dojo.toJsonviewObject));
	//console.log("View.updateViewLocation    location: " + location);
	//console.log("View.updateViewLocation    chrom: " + chrom);
	////console.log("View.updateViewLocation    this.loading: ");
	////console.dir({loading:this.loading});
	////console.log("View.updateViewLocation    VIEWS: ");
	////console.dir({views:Agua.data.views})
	
	// SKIP IF LOCATION NOT DEFINED OR NO MATCH
	if ( location == null )	return 1;
	var matches = String(location).match(/^(((\S*)\s*:)?\s*(-?[0-9,.]*[0-9])\s*(\.\.|-|\s+))?\s*(-?[0-9,.]+)$/i);
	if ( matches == null )	return 1;

	// PARSE LOCATION FOR CHROMOSOME, START AND STOP
	//matches[6] = end base (or center base, if it's the only one)
	var chromosome = matches[3];
	if ( chromosome == null)	chromosome = chrom;
	var start = parseInt(matches[4].replace(/[,.]/g, ""));
	var stop = parseInt(matches[6].replace(/[,.]/g, ""));
	//console.log("View.updateViewLocation    chromosome: " + chromosome);
	//console.log("View.updateViewLocation    start: " + start);
	//console.log("View.updateViewLocation    stop: " + stop);

	// SKIP IF BOTH START AND STOP NOT DEFINED
	if ( ! start && ! stop )	return 1;

	//console.log("View.updateViewLocation    BEFORE Agua.getViewObject");
	//console.dir({views:Agua.data.views})
	
	var object = Agua.getViewObject(viewObject.project, viewObject.view);
	//console.log("View.updateViewLocation    object: " + dojo.toJson(object));

	//console.log("View.updateViewLocation    AFTER Agua.getViewObject");
	//console.dir({views:Agua.data.views})

	if ( ! object )
	{
		console.log("View.updateViewLocation    object NOT DEFINED");
		return;
	}
	
	if ( object.chromosome == chromosome
		&& object.start == start
		&& object.stop == stop )	return;

	object.chromosome = chromosome;
	object.start = start;
	object.stop = stop;
	
	//console.log("View.updateViewLocation    BEFORE _removeView(object): " + dojo.toJson(object));
	var success = Agua._removeView(object);
	if ( success != true ) {
		console.log("View.updateViewLocation    Could not do Agua.removeView() for add track to view " + viewObject.view);
		return;
	}
	//console.log("View.updateViewLocation    BEFORE _addView(object): " + dojo.toJson(object));

	success = Agua._addView(object);
	if ( success != true ) {
		////console.log("View.updateViewLocation    Could not do Agua._addView() for update track to view " + viewObject.view);
		return;
	}	
	//////console.log("View.updateViewLocation    Agua.views: " + dojo.toJson(Agua.views, true));

	// ADD STAGE TO stage TABLE IN REMOTE DATABASE
	object.username = Agua.cookie('username');
	object.sessionid = Agua.cookie('sessionid');
	object.mode = "updateViewLocation";
	//////console.log("View.updateViewLocation    object: " + dojo.toJson(object));

	this.doPut({ url: this.url, query: object, doToast: false });	
},
handleTrackChange : function (viewObject, track, action) {	
	console.log("View.handleTrackChange    view.View.handleTrackChange(viewObject, track, action)");
	if ( this.loading == true )	return 1;

	//console.log("View.handleTrackChange    caller: " + this.handleTrackChange.caller.nom);
	//console.log("View.handleTrackChange    viewObject: " + dojo.toJson(viewObject));
	//console.log("View.handleTrackChange    track: " + track);
	//console.log("View.handleTrackChange    action: " + action);
		
	var object = Agua.getViewObject(viewObject.project, viewObject.view);
	//console.log("View.handleTrackChange    object: " + dojo.toJson(object));

	var tracks = [];
	//console.log("View.handleTrackChange    object.tracklist: " + object.tracklist);
	if ( object.tracklist ){
		tracks = object.tracklist.split(",");
	}
	//console.log("View.handleTrackChange    AFTER GENERATED, tracks: ");
	//console.dir({tracks:tracks});

	var index;
	for ( var i = 0; i < tracks.length; i++ )
	{
		if ( tracks[i] == track )
		{
			index = i;
			continue;
		}
	}
	//console.log("View.handleTrackChange    index: " + index);

	// IF DOING 'ADD', RETURN IF TRACK IS ALREADY IN TRACKLIST
	if ( action == "add" ) {
		if ( index != null )	return 0;
		else	tracks.push(track);
	}
	
	// IF DOING REMOVE, RETURN IF TRACK IS NOT IN TRACKLIST
	if ( action == "remove" ) {
		if ( index == null )	return 1;
		else	tracks.splice(index, 1);
	}
	//console.log("View.handleTrackChange    AFTER tracks: ");
	//console.dir({tracks:tracks});
	
	// REPLACE TRACKLIST IN VIEW WITH NEW VERSION
	object.tracklist = tracks.join(",");
	//console.log("View.updateViewobject.tracklist    AFTER object.tracklist: " + object.tracklist);

	this.updateViewTracklist(object);
},
updateViewTracklist : function (object) {
	console.log("View.updateViewTracklist    object: ");
	console.dir({object:object});
	
	var success = Agua._removeView(object);
	console.log("View.updateViewTracklist    success: " + success);
	console.dir({views:Agua.cloneData("views")});

	if ( ! success ) {
		console.log("View.updateViewTracklist    Could not do Agua._removeView() for view: " + object.view);
		return;
	}
	success = Agua._addView(object);
	console.log("View.updateViewTracklist    Agua._addView(object) success: " + success);
	console.dir({views:Agua.cloneData("views")});
	if ( ! success ) {
		console.log("View.updateViewTracklist    Could not do Agua._addView() for view: " + object.view);
		return;
	}
	
	// COMPLETE QUERY OBJECT
	object.username = Agua.cookie('username');
	object.sessionid = Agua.cookie('sessionid');
	object.mode = "updateViewTracklist";

	this.doPut({ url: this.url, query: object, doToast : false });	
},
confirmAddView : function (projectName, viewName) {
// DISPLAY A 'Copy Workflow' DIALOG THAT ALLOWS THE USER TO SELECT 
// THE DESTINATION PROJECT AND THE NAME OF THE NEW WORKFLOW
	console.log("View.confirmAddView    plugins.files.View.confirmAddView()");
	console.log("View.confirmAddView    this.selectiveDialog: " + this.selectiveDialog);

	// SET POLLING TO FALSE
	this.polling = false;
	
	var thisObject = this;
	var speciesBuilds = Agua.getSpeciesBuilds();
	console.log("View.confirmAddView    speciesBuilds: " + dojo.toJson(speciesBuilds));

	var cancelCallback = function () {};
	var enterCallback = dojo.hitch(this, function (input, speciesBuild, checked, dialogWidget)
		{
			console.log("View.confirmAddView    Doing enterCallback(input, speciesBuild, checked, dialogWidget)");
			console.log("View.confirmAddView    viewName: " + viewName);
			console.log("View.confirmAddView    projectName: " + projectName);
			console.log("View.confirmAddView    input: " + input);
			console.log("View.confirmAddView    speciesBuild: " + speciesBuild);
			console.log("View.confirmAddView    checked: " + checked);
			console.log("View.confirmAddView    dialogWidget: " + dialogWidget);
			
			dialogWidget.messageNode.innerHTML = "Adding view: " + viewName;
			dialogWidget.close();
			
			console.log("View.confirmAddView    Doing this.addView()");
			thisObject.addView(projectName, viewName, speciesBuild);
		}
	);		

	// SHOW THE DIALOG
	this.selectiveDialog.load(
		{
			title 				:	"Add view: " + viewName,
			message 			:	"Select species/build combination",
			comboValues 		:	speciesBuilds,
			inputMessage 		:	null,
			comboMessage 		:	null,
			checkboxMessage		:	null,
			parentWidget 		:	this,
			enterCallback 		:	enterCallback,
			cancelCallback 		:	cancelCallback,
			enterLabel			:	"Add",
			cancelLabel			:	"Cancel"
		}			
	);
},
// ADD VIEW
addView : function (projectName, viewName, speciesBuild) {
	console.log("View.addView    projectName: " + projectName);
	console.log("View.addView    viewName: " + viewName);
	console.log("View.addView    speciesBuild: " + speciesBuild);
	if ( this.polling ) {
		console.log("View.addView    this.polling is TRUE. Returning");
		return;
	}
	this.polling = true;
	
	// SHOW STANDBY
	this.standby.show();

	// GET SPECIES AND BUILD
	var species = speciesBuild.match(/^(\S+)\(([^\)]+)\)$/)[1];
	var build = speciesBuild.match(/^(\S+)\(([^\)]+)\)$/)[2];
	
	// SET SPECIES LABEL TO BLANK
	this.speciesLabel.innerHTML = '';
	this.buildLabel.innerHTML = '';

	var viewObject 		= new Object;
	viewObject.project 	= projectName;
	viewObject.view		= viewName;
	viewObject.species	= species;
	viewObject.build 	= build;
	console.log("View.addView    viewObject: " + viewObject);
	console.dir({viewObject:viewObject});
	
	if ( ! Agua._addView(dojo.clone(viewObject)) ) {
		console.log("View.addView    Could not add view to this.views[" + viewObject.view + "]");
	}

	// ADD VIEW ON REMOTE SERVER
	this._remoteAddView(dojo.clone(viewObject));

	// SET POLL
	console.log("View.addView    Doing this._delayedPoll(dojo.clone(viewObject), this._handleAddView, message)");
	var message = "View._delayedPoll    addView";
	this._delayedPoll(dojo.clone(viewObject), dojo.hitch(this,"_handleAddView"), message);
},
_remoteAddView : function (viewObject) {	
// ADD VIEW ON REMOTE
	console.log("View._remoteAddView    viewObject:");
	console.dir({viewObject:viewObject});

	var putData 		= dojo.clone(viewObject);
	putData.mode 		= "addView";
	putData.username 	= Agua.cookie('username');
	putData.sessionid 	= Agua.cookie('sessionid');

	var url 			= this.url;
	var callback 		= function (response) {
		console.log("View._remoteAddView    response: ");
		console.dir({response:response});
		if ( response.error ) {
			thisObject.standby.hide();
			console.log("View._remoteAddView    Error adding view");
			Agua.toast(response);
		}
	};
	
	// DO CALL
	this.doPut({ url: url, query: putData, callback: callback, doToast: false });
},
_handleAddView : function (response, viewObject) {
	console.log("View._handleAddView    response: ");
	console.dir({response:response});
	console.log("View._handleAddView    viewObject: ");
	console.dir({viewObject:viewObject});
	
	if ( response.status == 'ready' ) {
		this.polling = false;
		this.standby._setTextAttr("");
		this.standby.hide();
		this.displayReady();
		
		// SET VIEW COMBO
		console.log("View._handleAddView    Doing this.setViewCombo()");
		this.setViewCombo(viewObject.project, viewObject.view);

		// RELOAD BROWSER
		console.log("View._handleAddView    Doing this.reloadBrowser()");
		this.reloadBrowser(viewObject.project, viewObject.view)

		Agua.toastInfo("Added view: " + viewObject.view);
	}
	else if ( response.error ) {
		this.polling = false;
		this.standby.hide();
		this.displayReady();
		console.log("View.addView    Error on remote. Response: ");
		console.dir({response:response});
	}
	else {
		console.log("View._delayedPoll    Doing this._delayedPoll(dojo.clone(viewObject), this._handleAddView, message)");
		var message = "View._delayedPoll    addView";
		this._delayedPoll(dojo.clone(viewObject), dojo.hitch(this,"_handleAddView"), message);
	}
},
// REMOVE VIEW
confirmRemoveView : function () {
	var noCallback = function () {};
	var yesCallback = dojo.hitch(this, function () {
		this.removeView();
	});
	
	// SET TITLE AND MESSAGE
	var projectName = this.getProject();
	var viewName 	= this.getView();
	var title = "Delete view '" + projectName + "." + viewName + "' ?";
	var message = "All its data will be destroyed";

	// SHOW THE DIALOG
	this.loadConfirmDialog(title, message, yesCallback, noCallback);
},
removeView : function () {
	console.log("View.removeView    plugins.view.View.removeView()");

	var projectName = 	this.getProject();
	var viewName 	= 	this.getView();
	var species 	=	this.getSpecies();
	var build		=	this.getBuild();
	console.log("View.removeView    projectName: " + projectName);
	console.log("View.removeView    viewName: " + viewName);
	console.log("View.removeView    species: " + species);
	console.log("View.removeView    build: " + build);

	// SET SPECIES LABEL TO BLANK
	this.speciesLabel.innerHTML = '';
	this.buildLabel.innerHTML = '';

	var viewObject 		= new Object;
	viewObject.project 	= projectName;
	viewObject.view		= viewName;
	viewObject.species	= species;
	viewObject.build 	= build;
	console.log("View.removeView    viewObject: " + viewObject);
	console.dir({viewObject:viewObject});

	this._removeView(dojo.clone(viewObject));

	// REMOVE BROWSER
	console.log("View._removeView    Doing this.removeBrowser()");
	var browserObject = this.getBrowser(viewObject.project, viewObject.view);
	console.log("View._removeView    browserObject: ");
	console.dir({browserObject:browserObject});
	if ( browserObject )
		this.removeBrowser(browserObject.browser, viewObject.project, viewObject.view);
	
	// SET VIEW PROJECT COMBO
	var previousView = Agua.getPreviousView(viewObject);
	console.log("View.removeView    previousView: ");
	console.dir({previousView:previousView});
	if ( previousView ) {
		console.log("View.removeView    XXX DOING this.setViewProjectCombo(previousView.project, previousView.view)");
		this.setViewProjectCombo(previousView.project, previousView.view);
	}

	Agua.toastInfo("Removed view: " + viewObject.view);

	this._remoteRemoveView(dojo.clone(viewObject));	
},
_removeView : function (viewObject) {
// REMOVE VIEW ON CLIENT, REMOVE BROWSER TAB AND RELOAD BROWSER

	console.log("View._removeView    viewObject: " + dojo.toJson(viewObject));
	console.dir({viewObject:viewObject});

	if ( ! Agua.removeView(viewObject) ) {
		console.log("View._removeView    Could not remove view: " + viewObject.view);
		return;
	}

	//var previousView = Agua.getPreviousView(viewObject);
	//console.log("View._removeView    previousView: ");
	//console.dir({previousView:previousView});
	
},
_remoteRemoveView : function (viewObject) {	
// REMOVE VIEW ON REMOTE
	console.log("View._remoteRemoveView    viewObject:");
	console.dir({viewObject:viewObject});

	var putData 		= dojo.clone(viewObject);
	putData.mode 		= "removeView";
	putData.username 	= Agua.cookie('username');
	putData.sessionid 	= Agua.cookie('sessionid');

	var thisObject 		= this;
	var url 			= this.url;
	var callback 		= function (response) {
		console.log("View._remoteRemoveView    response: ");
		console.dir({response:response});
		if ( response.error ) {
			thisObject.standby.hide();
			console.log("View._remoteRemoveView    Error removing view");
			Agua.toast(response);
		}
	};
	
	// DO CALL
	this.doPut({ url: url, query: putData, callback: callback, doToast: false });
},
_handleRemoveView : function (response, viewObject) {
	console.log("View._handleRemoveView    response: ");
	console.dir({response:response});
	console.log("View._handleRemoveView    viewObject: ");
	console.dir({viewObject:viewObject});
	
	if ( response ) {

	console.log("View._handleRemoveView    HERE 1 XXX");
	//if ( response.status == 'none' ) {
		this.polling = false;
		if ( this.standby._textNode )
			this.standby._setTextAttr("");

	console.log("View._handleRemoveView    HERE 2");
		this.standby.hide();

	console.log("View._handleRemoveView    HERE 3");
		this.displayReady();

	console.log("View._handleRemoveView    HERE 4");
		
		var previousView = Agua.getPreviousView(viewObject);
		console.log("View._handleRemoveView    previousView: ");
		console.dir({previousView:previousView});
		
		// REMOVE BROWSER
		console.log("View._handleRemoveView    Doing this.removeBrowser()");
		var browserObject = this.getBrowser(viewObject.project, viewObject.view);
		console.log("View._handleRemoveView    browserObject: ");
		console.dir({browserObject:browserObject});
		this.removeBrowser(browserObject.browser, viewObject.project, viewObject.view);
		
		// SET VIEW PROJECT COMBO
		console.log("View._handleRemoveView    DOING this.setViewProjectCombo(previousView.project, previousView.view)");
		this.setViewProjectCombo(previousView.project, previousView.view);

		//// RELOAD BROWSER
		//console.log("View._handleRemoveView    Doing this.reloadBrowser()");
		//this.reloadBrowser(previousView.project, previousView.view);

		Agua.toastInfo("Removed view: " + viewObject.view);
	}
	else if ( response.error ) {
		this.polling = false;
		this.standby.hide();
		this.displayReady();
		console.log("View.addView    Error on remote. Response: ");
		console.dir({response:response});
	}
	else {
		console.log("View._delayedPoll    Doing this._delayedPoll(dojo.clone(viewObject), this._handleRemoveView, message)");
		var message = "View._delayedPoll    addView";
		this._delayedPoll(dojo.clone(viewObject), dojo.hitch(this,"_handleRemoveView"), message);
	}
},
// ADD VIEW FEATURE
addViewFeature : function () {
	console.log("View.addViewFeature    plugins.view.View.addViewFeature()");
	if ( ! this.getFeature()	)	return;

	// SKIP IF ALREADY BUSY
	if ( this.polling == true ) {
		console.log("View.addViewFeature    this.polling IS TRUE. Returning");
		return;
	}
	this.polling = true;

	var project		=	this.getProject();
	var view 		= 	this.getView();
	var feature 	= 	this.getFeature();

	if ( Agua.hasViewFeature(project, view, feature) ) {
		console.log("View.addViewFeature    Feature already present. Returning");
		this.polling = false;
		return;
	}

	// DISPLAY LOADING
	this.displayLoading();

	// DISPLAY STANDBY
	this.showStandby("Adding feature '" + feature + "' <br>to view '" + project + "." + view + "'");

	// PREPARE FEATURE TRACK OBJECT
	var featureObject = new Object;
	// VIEW INFO
	featureObject.project 		= project;
	featureObject.view 			= view;
	// SOURCE FEATURE INFO
	featureObject.feature 		= feature;
	featureObject.sourceproject = this.getFeatureProject();
	featureObject.sourceworkflow = this.getFeatureWorkflow();
	featureObject.species 		= this.getFeatureSpecies();
	featureObject.build 		= this.getFeatureBuild();
	
	if ( Agua.hasViewFeature == true ) {
		console.log("View.addViewFeature    hasViewFeature is TRUE");
		return;	
	}

	// ADD ON CLIENT AND REMOTE
	this._addViewFeature(dojo.clone(featureObject));
	this._remoteAddViewFeature(dojo.clone(featureObject));

	// SET POLL
	console.log("View.addViewFeature    Doing this._delayedPoll()");
	var message = "View._delayedPoll    addViewFeature";
	this._delayedPoll(dojo.clone(featureObject), dojo.hitch(this,"_handleAddViewFeature"), message);
},
_addViewFeature : function (featureObject) {
	console.log("View._addViewFeature    featureObject: ");
	console.dir({featureObject:featureObject});

	// ADD FEATURE TO VIEW
	if ( ! Agua._addViewFeature(featureObject) ) {
		console.log("View._addViewFeature    Agua._addViewFeature FAILED");
		Agua.toastError("Failed to add feature to local data: " + featureObject.feature);
	}
},
_remoteAddViewFeature : function ( featureObject) {
	console.log("View._remoteAddViewFeature    featureObject:");
	console.dir({featureObject:featureObject});

	// SET USER INFO AND MODE
	var putData 		= dojo.clone(featureObject);
	putData.username 	= Agua.cookie('username');
	putData.sessionid 	= Agua.cookie('sessionid');
	putData.mode 		= "addViewFeature";

	var url 			= this.url;
	var callback 		= function (response) {
		console.log("View._remoteAddViewFeature    response: ");
		console.dir({response:response});
		if ( response.error ) {
			thisObject.standby.hide();
			console.log("View._remoteAddViewFeature    Error adding viewFeature");
			Agua.toast(response);
		}
	};
	
	// DO CALL
	this.doPut({ url: url, query: putData, callback: callback, doToast: false });
},
_handleAddViewFeature : function (response, featureObject) {
	console.log("View._handleAddViewFeature    response: ");
	console.dir({response:response});
	console.log("View._handleAddViewFeature    featureObject: ");
	console.dir({featureObject:featureObject});
		
	if ( response.status == 'ready' ) {
		this.polling = false;
		this.standby._setTextAttr("");
		this.standby.hide();
		this.displayReady();

		// SET VIEW COMBO
		console.log("View._handleAddViewFeature    Doing this.setViewCombo(featureObject.project, featureObject.view)")
		this.setViewCombo(featureObject.project, featureObject.view);
	
		// RELOAD BROWSER
		console.log("View._handleAddViewFeature    Doing this.reloadBrowser(featureObject.project, featureObject.view)")
		this.reloadBrowser(featureObject.project, featureObject.view);
	
		Agua.toastInfo("Added feature: " + featureObject.feature);
	}
	else if ( response.error ) {
		this.polling = false;
		this.standby.hide();
		this.displayReady();
		console.log("View.handleAddViewFeature    Error on remote. Response: ");
		console.dir({response:response});
	}
	else {
		console.log("View._handleAddViewFeature    Doing this._delayedPollAddViewFeature()");
		var message = "View._delayedPoll    handleAddViewFeature";
		this._delayedPoll(dojo.clone(featureObject), dojo.hitch(this,"_handleAddViewFeature"), message);
	}
},
// REMOVE VIEW FEATURE
removeViewFeature : function () {
	console.log("View.removeViewFeature    plugins.view.View.removeViewFeature()");
	if ( ! this.getViewFeature()	)	return;

	// SKIP IF ALREADY BUSY
	if ( this.polling == true ) {
		console.log("View.addViewFeature    this.polling IS TRUE. Returning");
		return;
	}
	this.polling = true;

	var project		=	this.getProject();
	var view 		= 	this.getView();
	var feature 	= 	this.getViewFeature();

	if ( ! Agua.hasViewFeature(project, view, feature) ) {
		console.log("View.removeViewFeature    Feature NOT present. Returning");
		this.polling = false;
		return;
	}

	// DISPLAY STANDBY
	this.showStandby("Removing feature '" + feature + "' <br>from view '" + project + "." + view + "'");

	// DISPLAY LOADING
	this.displayLoading();

	// REMOVE FROM CLIENT AND REMOTE
	var featureObject = new Object;
	featureObject.project = this.getProject();
	featureObject.view = this.getView();
	featureObject.feature = this.getViewFeature();
	featureObject.species = this.getFeatureSpecies();
	featureObject.build = this.getFeatureBuild();
	featureObject.username = Agua.cookie('username');
	featureObject.sessionid = Agua.cookie('sessionid');
	featureObject.mode = "removeViewFeature";
	console.log("View.removeViewFeature    featureObject: " + dojo.toJson(featureObject, true));

	// ADD ON CLIENT AND REMOTE
	this._removeViewFeature(dojo.clone(featureObject));
	this._remoteRemoveViewFeature(dojo.clone(featureObject));

	// SET POLL
	console.log("View.addViewFeature    Doing this._delayedPoll()");
	var message = "View._delayedPoll    addViewFeature";
	this._delayedPoll(dojo.clone(featureObject), dojo.hitch(this,"_handleRemoveViewFeature"), message);	
},
_removeViewFeature : function (featureObject) {
	console.log("View._removeViewFeature    featureObject: " + dojo.toJson(featureObject));

	// REMOVE FEATURE FROM VIEW
	console.log("View._removeViewFeature    Doing Agua._removeViewFeature()");
	if ( ! Agua._removeViewFeature(featureObject) ) {
		console.log("View._removeViewFeature    Agua._removeViewFeature FAILED");
	Agua.toastError("Failed to remove feature from local data: " + featureObject.feature);
	}
},
_remoteRemoveViewFeature : function (featureObject) {
	console.log("View._remoteRemoveViewFeature    featureObject:");
	console.dir({featureObject:featureObject});

	// SET USER INFO AND MODE
	var putData 		= dojo.clone(featureObject);
	putData.username 	= Agua.cookie('username');
	putData.sessionid 	= Agua.cookie('sessionid');
	putData.mode 		= "removeViewFeature";

	var url 			= this.url;
	var callback 		= function (response) {
		console.log("View._remoteRemoveViewFeature    response: ");
		console.dir({response:response});
		if ( response.error ) {
			thisObject.standby.hide();
			console.log("View._remoteRemoveViewFeature    Error removing viewFeature");
			Agua.toast(response);
		}
	};
	
	// DO CALL
	this.doPut({ url: url, query: putData, callback: callback, doToast: false });
},
_handleRemoveViewFeature : function (response, featureObject) {
	console.log("View._handleRemoveViewFeature    response: ");
	console.dir({response:response});
	console.log("View._handleRemoveViewFeature    featureObject: ");
	console.dir({featureObject:featureObject});
		
	if ( response.status == 'ready' ) {
		this.polling = false;
		this.standby._setTextAttr("");
		this.standby.hide();
		this.displayReady();

		// SET VIEW COMBO
		console.log("View._handleRemoveViewFeature    DOING this.setViewCombo(" + featureObject.project + ", " + featureObject.view + ")");
			this.setViewCombo(featureObject.project, featureObject.view);
	
		// RELOAD BROWSER
		console.log("View._handleRemoveViewFeature    DOING this.reloadBrowser(" + featureObject.project + ", " + featureObject.view + ")");
		this.reloadBrowser(featureObject.project, featureObject.view);
	
		Agua.toastInfo("Removed feature: " + featureObject.feature);
	}
	else if ( response.error ) {
		this.polling = false;
		this.standby.hide();
		this.displayReady();
		console.log("View.handleRemoveViewFeature    Error on remote. Response: ");
		console.dir({response:response});
	}
	else {
		console.log("View._handleRemoveViewFeature    Doing this._handleRemoveViewFeature()");
		var message = "View._delayedPoll    handleRemoveViewFeature";
		this._delayedPoll(dojo.clone(featureObject), dojo.hitch(this,"_handleRemoveViewFeature"), message);
	}
},
// SET COMPONENTS
displayLoading : function () {
	dojo.removeClass(this.statusDisplay, "statusReady");
	dojo.addClass(this.statusDisplay, "statusLoading");
},
displayReady : function () {
	dojo.removeClass(this.statusDisplay, "statusLoading");
	dojo.addClass(this.statusDisplay, "statusReady");
},
onStartRemote : function () {
// 4. SHOW ANIMATED 'COPYING' DIALOGUE
	console.log("View.onStartRemote    caller: " + this.onStartRemote.caller.nom);
	console.dir({caller:this.onStartRemote.caller});
	console.log("View.onStartRemote    this.standby: " + this.standby);

	// SHOW STANDBY 
	this.standby.show();

	// DISPLAY LOADING
	this.displayLoading();
},
pollRemote: function(timer) {
// 5. POLL SERVER FOR STATUS AND WAIT UNTIL COMPLETE
	console.log("View.pollRemote    timer: " + timer);
	console.dir({timer:timer});
	if ( timer.url == null )	return;
	if ( timer.query == null ) 	return;

	var thisObject = this;
	var completed = false;
	dojo.xhrPut(
		{
			url: timer.url,
			contentType: "text",
			//preventCache : true,
			putData: dojo.toJson(timer.query),
			handleAs: "json-comment-optional",
			sync: true,
			handle : function (response) {

				console.log("View.pollRemote    response: " + dojo.toJson(response, true));
				if ( response.status == 'ready'
					|| response.status == 'error'
					|| response.error != null ) {
					console.log("View.pollRemote    setting completed to TRUE");
					completed = true;
					timer.response = response;
				}
			}
		}
	);
	
	console.log("View.pollRemote    Returning completed: " + completed);
	return completed;
},
onEndRemote : function () {
// 6. IF COPY IS COMPLETED, RELOAD THE PANE TO
// DISPLAY THE NEW FILE SYSTEM
	console.log("View.onEndRemote    plugins.view.View.onEndRemote()");

	// HIDE STANDBY
	this.standby.hide();

	// DISPLAY READY
	this.displayReady();

	console.log("View.onEndRemote    Doing this.callback()");
	console.dir({callback:this.callback});
	
	if ( this.callback )	this.callback();
},
// STANDBY
setStandby : function () {
	console.log("View.setStandby    _GroupDragPane.setStandby()");
	if ( this.standby != null )	return this.standby;
	
	var id = dijit.getUniqueId("dojox_widget_Standby");
	this.standby = new dojox.widget.Standby (
		{
			target: this.rightPane.domNode,
			//onClick: "reload",
			centerIndicator : "text",
			text: "Loading",
			id : id
			//, url: "plugins/core/images/agua-biwave-24.png"
		}
	);
	document.body.appendChild(this.standby.domNode);
	dojo.addClass(this.standby._textNode, "viewStandby");
	console.log("View.setStandby    this.standby: ");
	console.dir({this_standby:this.standby});
	
	return this.standby;
},
showStandby : function (message) {
	// SET STANDBY TEXT
	console.log("View.showStandby    message: " + message);
	this.standby._setTextAttr(message);
	this.standby.show();
},	
hideStandby : function () {
	// SET STANDBY TEXT
	this.standby._setTextAttr("");
	this.standby.hide();
},	
// BROWSER METHODS
loadBrowser : function (projectName, viewName) {
	console.log("View.loadBrowser      PASSED projectName: " + projectName);
	console.log("View.loadBrowser      PASSED viewName: " + viewName);

	if ( projectName == null )	projectName = this.getProject();
	if ( viewName == null )		viewName = this.getView();
	console.log("View.loadBrowser      projectName: " + projectName);
	console.log("View.loadBrowser      viewName: " + viewName);

	// SELECT VIEW TAB IF EXISTS
	if ( this.selectBrowser(projectName, viewName) )	return;
	
	var username = Agua.cookie('username');
	var refseqfile = this.getRefseqfile(username, projectName, viewName);
	var trackinfofile = this.getTrackinfofile(username, projectName, viewName);
	console.log("View.loadBrowser      refseqfile: " + refseqfile);
	console.log("View.loadBrowser      trackinfofile: " + trackinfofile);

	// LOAD refSeqs AND trackInfo JSON FILES
	this.loadEval(trackinfofile);
	this.loadEval(refseqfile);
	if ( refSeqs == null ) {
		console.log("View.loadBrowser      refSeqs is null. Returning");
		return;
	}
	if ( trackInfo == null ) {
		console.log("View.loadBrowser      trackInfo is null. Returning");
		return;
	}
	console.log("View.loadBrowser      refSeqs: ");
	console.dir({refSeqs:refSeqs});

	// CHECK INPUTS
	if ( projectName == null || viewName == null ) {
		console.log("View.loadBrowser    One of the required inputs (projectName, viewName) is null. Returning");
		return;
	}

	var viewObject = Agua.getViewObject(projectName, viewName);
	console.log("View.loadBrowser      viewObject: ");
	console.dir({viewObject:viewObject});
	if ( ! viewObject )	{
		console.log("View.loadBrowser      viewObject is not defined. Returning");
		return;
	}
	
	var trackList	=	viewObject.tracklist;
	var speciesName	=	viewObject.species;
	var buildName	=	viewObject.build;
	var username = Agua.cookie('username');

	// SET LOCATION OBJECT:
	// {"name":"chr1","start":"99,711,844","stop":"149,561,968"}
	// AND LOCATION STRING:
	// "chr1:99,711,844 .. 149,561,968"
	var locationObject = this.getLocationObject(viewObject);
	var startStop = locationObject.start + "..." + locationObject.stop;
	var location	=	locationObject.name + ":" + startStop;
	console.log("View.loadBrowser      location: " + location);
	
	// GET UNIQUE ID FOR THIS MENU TO BE USED IN DND SOURCE LATER
	var objectName = "plugins.view.View.jbrowse.Browser";
	var browserId = dijit.getUniqueId(objectName.replace(/\./g,"_"));
	
	// SET LOADING FLAG TO STOP PREMATURE updateViewLocation/ViewTracklist
	this.loading = true;
	
	var b = new plugins.view.jbrowse.js.Browser({
		parentWidget 	: this,
		viewObject	 	: viewObject,
		speciesName		: speciesName,
		buildName  		: buildName,
		species    		: speciesName,
		build      		: buildName,
		refSeqs			: refSeqs,
		trackData		: trackInfo,
		baseUrl 		: this.baseUrl,
		dataRoot 		: this.baseUrl + "/users/" + username + "/" + projectName + "/" + viewName+ "/",
		
		locationObject 	: locationObject,
		location 		: location,
		
		//browserRoot : this.baseUrl,
		browserRoot 	: this.browserRoot,
		//defaultLocation : "chr2:10000000..100000000",
		//defaultTracks : "vegaGene,CCDS", 
		trackList 		: trackList,
		tracks 			: trackList,
		attachWidget 	: this.rightPane
	});

	// ADD TO this.browsers ARRAY		
	this.addBrowser(b, projectName, viewName);
	console.dir({browser:b});

	//// SET NAVIGATION BOX VALUES
	//b.chromList.value = viewObject.chromosome;
	//b.locationBox.value = viewObject.start  + "..." + viewObject.stop;

	console.log("View.loadBrowser    XXXXXXX END OF LOADING XXXXXX");
	console.log("View.loadBrowser    this.loading: " + this.loading);

	// CONNECT TO browser.mainTab DESTROY TO DO this.removeBrowser
	dojo.connect(b.mainTab, "destroy", dojo.hitch(this, "removeBrowserObject", b, projectName, viewName));

	console.log("View.loadBrowser      XXXXXXX END OF NAVIGATION XXXXXX");
	this.loading = false;
	console.log("View.loadBrowser    SET this.loading TO : " + this.loading);
	
}, // 	loadBrowser 
getLocationObject : function (viewObject) {
// DEFAULT RANGE IS LEFT TENTH OF FIRST CHROMOSOME
	console.log("View.getLocationObject    viewObject:");
	console.dir({viewObject:viewObject});
	
	var locationObject = new Object;

	if ( ! viewObject.chromosome ) {
		viewObject.chromosome	= 	refSeqs[0].name;
		viewObject.start 		= 	0;
		viewObject.stop 		= 	(refSeqs[0].end / 10);
	}	
	
	locationObject.name		= 	viewObject.chromosome;
	locationObject.start	=	parseInt(viewObject.start);
	locationObject.stop		=	parseInt(viewObject.stop);

	console.log("View.getLocationObject    Returning locationObject:");
	console.dir({locationObject:locationObject});

	return locationObject;	
},
reloadBrowser : function (projectName, viewName) {
	console.log("View.reloadBrowser      projectName: " + projectName);
	console.log("View.reloadBrowser      viewName: " + viewName);

	var browser = this.getBrowser(projectName, viewName); 
	if ( browser != null )
	{
		// REMOVE EXISTING BROWSER FOR THIS VIEW
		console.log("View.reloadBrowser    BEFORE this.removeBrowser(projectName, workflow, viewName)");
		this.removeBrowser(browser.browser, projectName, viewName);
		console.log("View.reloadBrowser    AFTER this.removeBrowser(projectName, workflow, viewName)");
	}
	this.loadBrowser(projectName, viewName);

	console.log("View.reloadBrowser    AFTER loadBrowser");

}, // 	reloadBrowser 
selectBrowser : function (projectName, viewName) {
// FOR EACH NEWLY OPENED VIEW TAB, THE ASSOCIATED BROWSER 
// OBJECT IS ADDED TO this.browsers ARRAY
	//console.log("View.selectBrowser    plugins.view.View.selectBrowser(projectName, viewName)");
	//console.log("View.selectBrowser    projectName: " + projectName);
	//console.log("View.selectBrowser    viewName: " + viewName);

	var browserObject = this.getBrowser(projectName, viewName);
	//console.log("View.selectBrowser    browserObject: " + browserObject);
	if ( browserObject == null )	return;
	var browser = browserObject.browser;

	//console.log("View.selectBrowser    BEFORE selectChild(browser.mainTab)");
	this.rightPane.selectChild(browser.mainTab);
	//console.log("View.selectBrowser    AFTER selectChild(browser.mainTab)");
	return 1;
},
getBrowser : function (projectName, viewName) {
	//console.log("View.getBrowser    projectName: " + projectName);
	//console.log("View.getBrowser    viewName: " + viewName);

	var index = this.getBrowserIndex(projectName, viewName);
	console.log("View.selectBrowser    index: " + index);
	if ( index == null )	return;

	return this.browsers[index];
},
addBrowser : function(browser, projectName, viewName) {
// FOR EACH NEWLY OPENED VIEW TAB, THE ASSOCIATED BROWSER 
// OBJECT IS ADDED TO this.browsers ARRAY
	//console.log("View.addBrowser    plugins.view.View.addBrowser(browser, project, workflow, view)");
	console.log("View.addBrowser    browser: " + browser);
	console.log("View.addBrowser    projectName: " + projectName);
	console.log("View.addBrowser    viewName: " + viewName);
	
	var browserObject = {
		browser : 	browser,
		project: 	projectName,
		view:		viewName
	};

	var success = this._addObjectToArray(this.browsers, browserObject, ["browser", "project", "view"]);
	console.log("View.addBrowser    success: " + success);

	//// ADD TO TABS
	//this.rightPane.addChild(browserObject.browser.mainTab);
	//this.rightPane.selectChild(browserObject.browser.mainTab);
	
	return success;	
},
isBrowser : function (projectName, viewName) {
	console.log("View.isBrowser    projectName: " + projectName);
	console.log("View.isBrowser    viewName: " + viewName);

	if ( this.getBrowserIndex(projectName, viewName) != null )	{
		console.log("View.isBrowser    Returning 1");
		return 1;
	}
	else {
		console.log("View.isBrowser    Returning 0");
		return 0;
	}	
},
getBrowserIndex : function (projectName, viewName) {
	console.log("View.getBrowserIndex    projectName: " + projectName);
	console.log("View.getBrowserIndex    viewName: " + viewName);
	console.log("View.getBrowserIndex    this.browsers: ");
	console.dir({this_browsers:this.browsers});

	var browserObject = {
		project	: 	projectName,
		view	:	viewName
	};

	var index = this._getIndexInArray(this.browsers, { project: projectName, view: viewName }, [ "project", "view" ])
	console.log("View.getBrowserIndex    index: " + index);	
	
	return index;
},
removeBrowser : function (browser, projectName, viewName) {
// WHEN A VIEW TAB IS CLOSED, REMOVE ITS ASSOCIATED
// browser OBJECT FROM this.browsers AND DESTROY IT
	console.log("View.removeBrowser    plugins.viewName.View.removeBrowser(browser, projectName, viewName)");
	console.log("View.removeBrowser    browser: " + browser);
	console.log("View.removeBrowser    projectName: " + projectName);
	console.log("View.removeBrowser    viewName: " + viewName);
	
	this.removeBrowserTab(browser);
	var success = this.removeBrowserObject(browser, projectName, viewName);
	console.log("View.removeBrowser    success: " + success);

},
removeBrowserObject : function (browser, projectName, viewName) {
	console.log("View.removeBrowserObject    caller: " + this.removeBrowserObject.caller.nom);
	console.log("View.removeBrowserObject    browser: " + browser);
	console.dir({browser:browser});
	console.log("View.removeBrowserObject    projectName: " + projectName);
	console.log("View.removeBrowserObject    viewName: " + viewName);
	console.log("View.removeBrowserObject    BEFORE this.browsers: ");
	console.dir({this_browsers:this.browsers});

	var browserObject = {
		browser : 	browser,
		project: 	projectName,
		view:		viewName
	};
	console.log("View.removeBrowserObject    browserObject: ");
	console.dir({browserObject:browserObject});

	console.log("View.removeBrowserObject    BEFORE this.browsers.length: " + this.browsers.length);
	var success = this._removeObjectFromArray(this.browsers, browserObject, ["browser", "project", "view"]);
	console.log("View.removeBrowserObject    success: " + success);
	console.log("View.removeBrowserObject    AFTER this.browsers: ");
	console.dir({this_browsers:this.browsers});
	console.log("View.removeBrowserObject    AFTER this.browsers.length: " + this.browsers.length);

	return success;	
},
removeBrowserTab : function (browser, projectName, viewName) {
	// REMOVE BROWSER TAB FROM PANE
	console.log("View.removeBrowserTab    browser:");
	console.dir({browser:browser});
	
	this.rightPane.removeChild(browser.mainTab);
	console.log("View.removeBrowserTab    AFTER removeChild(browser.mainTab)");

	return true;
},
// FIRE COMBO HANDLERS
fireViewProjectCombo : function() {
	console.log("View.fireViewProjectCombo    viewProjectCombo._onchange");
	var projectName = this.viewProjectCombo.get('value');
	this.setViewCombo(projectName);
},
fireViewCombo : function () {
// ONCHANGE IN VIEW COMBO FIRED
	if ( ! this.viewComboFired == true )
	{
		this.viewComboFired = true;
	}
	else {
		console.log("View.fireViewCombo    plugins.view.View.fireViewCombo()");
	
		var projectName = this.getProject();
		var viewName = this.getView();
		console.log("View.fireViewCombo    projectName: " + projectName);
		console.log("View.fireViewCombo    viewName: " + viewName);
		this.setSpeciesLabel(projectName, viewName);
	
		this.loadBrowser(projectName, viewName);
	}
},
fireFeatureProjectCombo : function() {
	if ( ! this.featureProjectComboFired == true )
	{
		this.featureProjectComboFired = true;
	}
	else {
		console.log("View.fireFeatureProjectCombo    plugins.view.View.fireFeatureProjectCombo()");
		var projectName = this.featureProjectCombo.get('value');
		this.setWorkflowCombo(projectName);
	}
},
fireWorkflowCombo : function() {
	if ( ! this.workflowComboFired == true )
	{
		this.workflowComboFired = true;
	}
	else {
		console.log("View.fireWorkflowCombo    plugins.view.View.fireWorkflowCombo()");
		var projectName = this.featureProjectCombo.get('value');
		var workflowName = this.workflowCombo.get('value');
		this.setSpeciesCombo(projectName, workflowName);
	}
},
fireSpeciesCombo : function () {
	if ( ! this.speciesComboFired == true )
	{
		console.log("View.fireSpeciesCombo    FIRST FIRE");
		this.speciesComboFired = true;
	}
	else {
		console.log("View.fireSpeciesCombo    plugins.view.View.fireSpeciesCombo()");
		var projectName = this.viewProjectCombo.get('value');
		var workflowName = this.workflowCombo.get('value');
		var speciesName = this.getSpecies();
		var buildName = this.getBuild();
		console.log("View.fireSpeciesCombo    projectName: " + projectName);
		console.log("View.fireSpeciesCombo    workflowName: " + workflowName);
		console.log("View.fireSpeciesCombo    speciesName: " + speciesName);
		console.log("View.fireSpeciesCombo    buildName: " + buildName);
		console.log("View.fireSpeciesCombo    this.setFeatureCombo(" + projectName + ", " + workflowName + ", " + speciesName + ", " + buildName + ")");
		
		if ( speciesName == null || buildName == null )
		{
			console.log("View.fireSpeciesCombo    speciesName and/or buildName is null. Returning.");
			return;
		}
		
		this.setFeatureCombo(projectName, workflowName, speciesName, buildName);
	}
},
destroyRecursive : function () {
	console.log("View.destroyRecursive    this.mainTab: ");
	console.dir({this_mainTab:this.mainTab});
	if ( Agua && Agua.tabs )
		Agua.tabs.removeChild(this.mainTab);
	
	this.inherited(arguments);
}

}); // end of plugins.view.View

/*

	//// DO REMOTE CALL
	//var thisObject = this;
	//var url = Agua.cgiUrl + "view.cgi";
	//dojo.xhrPut(
	//	{
	//		url: url,
	//		contentType: "text",
	//		//preventCache : true,
	//		sync: false,
	//		handleAs: "json",
	//		putData: dojo.toJson(featureObject),
	//		load: function(response, ioArgs) {
	//			console.log("View.addViewFeature    response: " + dojo.toJson(response));
	//			if ( response.status ) {
	//				var match = response.status.match(/Adding feature:/);
	//				console.log("View.addViewFeature    match: " + match);
	//				
	//				if ( response.status.match(/Adding feature: /) ) {
	//					console.log("View.addViewFeature    STATUS: 'Adding feature...'");
	//
	//					// SET TIMER CALLBACK
	//					thisObject.timer.callback = dojo.hitch(thisObject, "_addViewFeature", featureObject);
	//					thisObject.timer.url = url;
	//					thisObject.timer.query = featureObject;
	//					thisObject.timer.query.mode = "pollStatus";
	//				
	//					// START TIMER
	//					console.log("View.addViewFeature    Doing timer.start()");
	//					thisObject.timer.start();
	//				}
	//				else {
	//					thisObject.standby._setTextAttr("");
	//					thisObject.standby.hide();
	//					thisObject.displayReady();
	//				}
	//			}
	//			else if ( response.error ) {
	//				Agua.toastError(response.error)
	//				thisObject.standby.hide();
	//				thisObject.displayReady();
	//			}
	//		},
	//		error: function(response, ioArgs) {
	//			thisObject.standby.hide();
	//			thisObject.displayReady();
	//			console.log("View.addViewFeature    Error with put. Response: " + dojo.toJson(response));
	//		}
	//	}
	//);

	
	
	
*/

}

if(!dojo._hasResource["plugins.view.Controller"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.view.Controller"] = true;
dojo.provide("plugins.view.Controller");

// OBJECT:  plugins.view.Controller
// PURPOSE: GENERATE AND MANAGE View PANES

// INHERITS


// HAS


dojo.declare( "plugins.view.Controller",
	[ dijit._Widget, dijit._Templated, plugins.core.Common ],
{
	/////}}
	
//Path to the template of this widget. 
templatePath: dojo.moduleUrl("", "../plugins/view/templates/controller.html"),

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

// CSS FILE FOR BUTTON STYLING
cssFiles : [
	dojo.moduleUrl("plugins") + "view/css/controller.css"
],

// ARRAY OF TAB PANES
tabPanes : [],

////}}}

// CONSTRUCTOR	
constructor : function(args) {
	console.log("Controller.constructor     plugins.view.Controller.constructor");
	//console.log("Controller.args: " + dojo.toJson(args));

	// LOAD CSS FOR BUTTON
	this.loadCSS();
	
},


postCreate : function() {
	console.log("Controller.postCreate    plugins.view.Controller.postCreate()");

	this.startup();
},


startup : function () {
	console.log("Controller.startup    plugins.view.Controller.startup()");

	this.inherited(arguments);

	// ADD MENU BUTTON TO TOOLBAR
	Agua.toolbar.addChild(this.menuButton);

	// SET BUTTON PARENT WIDGET
	this.menuButton.parentWidget = this;
	
	// SET BUTTON LISTENER
	var listener = dojo.connect(this.menuButton, "onClick", this, "createTab");
},


createTab : function (args) {
	console.log("Controller.createTab    args: ");
	console.dir({args:args});

	// CLEAR ANNOYING ALL-SELECTED
	window.getSelection().removeAllRanges();
	
	if ( args == null ) args = new Object;
	args.attachWidget = Agua.tabs;

	// CREATE WIDGET	
	var widget = new plugins.view.View(args);
	this.tabPanes.push(widget);

	// ADD TO _supportingWidgets FOR INCLUSION IN DESTROY	
	this._supportingWidgets.push(widget);
}




}); // end of Controller


dojo.addOnLoad(
	function()
	{
		//console.log("Controller.addOnLoad    plugins.view.Controller.addOnLoad");
		
		// DEBUG
		//Agua.controller["view"].createTab();
	}
);


}

if(!dojo._hasResource["plugins.workflow.AppRow"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.workflow.AppRow"] = true;

dojo.provide("plugins.workflow.AppRow");


dojo.declare( "plugins.workflow.AppRow",
	[ dijit._Widget, dijit._Templated ],
{
	/////}
	
//Path to the template of this widget. 
templateString:"<div dojoAttachPoint=\"containerNode\">\n    <table\n        class=\"approw\"\n        cellspacing=\"0px\"\n        height=\"16px\" width=\"100%\" style=\"padding: 0; margin: 0; height: 16px !important;\">\n        <tr width=\"100%\">\n            <td\n                colspan=\"3\"\n                dojoAttachPoint=\"name\"\n                class=\"name\"\n                >${name}</td>\n        </tr>\n        <tr width=\"100%\">\n            <td colspan=\"3\"\n                dojoAttachPoint=\"description\"\n                class='description'\n                title=\"Description\"\n                style=\"display: none;\" >${description}</td>\n        </tr>\n        <tr width=\"100%\">\n            <td colspan=\"3\"\n                dojoAttachPoint=\"location\"\n                class='location'\n                title=\"Location\"\n                style=\"display: none;\" >${location}</td>\n        </tr>\n        <tr width=\"100%\">\n            <td\n                colspan=\"1\"\n                dojoAttachPoint=\"version\"\n                class=\"version\"\n                title=\"Version\"\n                style=\"display: none;\" >${version}</td>\n\n            <td\n                colspan=\"1\"\n                dojoAttachPoint=\"executor\"\n                class=\"executor\"\n                title=\"Executor\"\n                style=\"display: none;\" >${executor}</td>\n\n            <td \n                colspan=\"1\"\n                dojoAttachPoint=\"localonly\"\n                class=\"localonly\"\n                title=\"LocalOnly\"\n                style=\"display: none;\" >${localonly}</td>\n            <td></td>\n            \n        </tr>\n        <tr width=\"100%\">\n            <td colspan=\"3\"\n                dojoAttachPoint=\"notes\"\n                class='notes'\n                title=\"Notes\"\n                style=\"display: none;\" >${notes}</td>\n        </tr>\n    </table>\n</div>\n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

// PARENT plugins.workflow.Apps WIDGET
parentWidget : null,

// CORE WORKFLOW OBJECTS
core : null,


// APPLICATION OBJECT
application : null,

constructor : function(args)
{
	//console.log("AppRow.constructor    plugins.workflow.AppRow.constructor()");
	//console.log("AppRow.constructor    args.localonly: " + args.localonly);
	
	this.core = args.core;
	this.parentWidget = args.parentWidget;

	this.application = new Object;
	for ( var key in args )
	{
		if ( key != "parentWidget" )
		{
			//console.log("AppRow.constructor    Setting this.application[" + key + "] = " + args[key]);
			this.application[key] = args[key];
		}
	}
	////console.log("AppRow.constructor    this.application: " + dojo.toJson(this.application));
	
	//this.inherited(arguments);
},

// RETURN A COPY OF this.application
getApplication : function ()
{
	return dojo.clone(this.application);
},

// SET this.application TO THE SUPPLIED APPLICATION OBJECT
setApplication : function (application)
{
	this.application = application;

	return this.application;
},



postCreate : function()
{
	//////console.log("AppRow.postCreate    plugins.workflow.AppRow.postCreate()");

	this.startup();
},

startup : function ()
{
	////console.log("AppRow.startup    plugins.workflow.AppRow.startup()");
	////console.log("AppRow.startup    this.parentWidget: " + this.parentWidget);

	this.inherited(arguments);
	
	
	// HACK:
	//
	// SET parentWidget TO this.name FOR RETRIEVAL OF this.application
	// WHEN MENU IS CLICKED
	//
	// REM: remove ONCLICK BUBBLES ON appRow.name NODE RATHER THAN ON node. 
	// I.E., CONTRARY TO DESIRED, this.name IS THE TARGET INSTEAD OF THE node.
	//
	// ALSO ADDED node.parentWidget = appRow IN Workflows.updateDropTarget()

	this.name.parentWidget = this;
	////console.log("AppRow.startup    this.name.parentWidget: " + this.name.parentWidget);
	
	// CONNECT TOGGLE EVENT
	var appRowObject = this;
	dojo.connect( this.name, "onclick", function(event) {
		event.stopPropagation();
		appRowObject.toggle();
	});

},

toggle : function ()
{
	////console.log("AppRow.toggle    plugins.workflow.AppRow.toggle()");
	////console.log("AppRow.toggle    this.description: " + this.description);

	var array = [ "description", "location", "notes", "version", "executor", "localonly" ];
	for ( var i in array )
	{
		if( this[array[i]].style )
		{
			if ( this[array[i]].style.display == 'table-cell' ) this[array[i]].style.display='none';
			else this[array[i]].style.display = 'table-cell';
		}
	}
}




});
	


}

if(!dojo._hasResource["plugins.workflow.AppSource"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.workflow.AppSource"] = true;
dojo.provide("plugins.workflow.AppSource");



dojo.declare( "plugins.workflow.AppSource",
	[ dijit._Widget, dijit._Templated, plugins.form.DndSource  ],
{

//Path to the template of this widget. 
templateString:"<div dojoAttachPoint=\"containerNode\">\n\n<div>\n    \n    <div dojoType=\"dijit.TitlePane\"\n        dojoAttachPoint=\"titlePane\"\n        title=\"${title}\"\n        style=\"width: 200px !important; min-width: 25px; background: #FFF;\"\n        >\n    \n        <div\n            dojoAttachPoint=\"dragSourceNode\"\n            class=\"dragSource\"\n            style=\"height: auto; width: 96%; margin-left: auto; margin-right: auto;\"\n        >\n    \n    </div>\n    </div>\n\n</div>\n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

// PARENT plugins.workflow.Apps WIDGET
parentWidget : null,

// CONTEXT MENU
contextMenu : null,

// ROW CLASS
rowClass : "plugins.workflow.AppRow",

// AVATAR ITEMS
avatarItems : ["name", "description"],

// FORM INPUTS (DATA ITEMS TO BE ADDED TO ROWS)
formInputs : {
	name:			1,
	owner:			1,
	type:			1,
	version:		1,
	executor:		1,
	localonly:		1,
	location:		1,
	description:	1,
	notes:			1,
	url :			1
},

/////}}}

constructor : function(args)
{
	////console.log("AppSource.constructor    plugins.workflow.AppSource.constructor()");
	this.parentWidget = args.parentWidget;
	this.itemArray = args.itemArray;
	this.contextMenu = args.contextMenu;
},

postCreate : function()
{
	////console.log("AppSource.postCreate    plugins.workflow.AppSource.postCreate()");
	this.startup();
},

startup : function ()
{
	////console.log("AppSource.startup    plugins.workflow.AppSource.startup()");
	////console.log("AppSource.startup    this.parentWidget: " + this.parentWidget);

	this.inherited(arguments);

	this.setDragSource();
},

getItemArray : function ()
{
	//console.log("AppSource.getItemArray    plugins.workflow.AppSource.getItemArray()");
	//console.log("AppSource.getItemArray.length    this.itemArray.length: " + this.itemArray.length);
	return this.itemArray;
}

	
});

}

if(!dojo._hasResource["plugins.workflow.AppType"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.workflow.AppType"] = true;
dojo.provide("plugins.workflow.AppType");


dojo.declare( "plugins.workflow.AppType",
	[ dijit._Widget, dijit._Templated ],
{
	//Path to the template of this widget. 
	templateString:"<div dojoAttachPoint=\"containerNode\">\n\n<div>\n    \n    <div dojoType=\"dijit.TitlePane\"\n        dojoAttachPoint=\"titlePane\"\n        title=\"${title}\"\n        class=\"pipelineTitlePane\"\n        style=\"width: 200px !important; min-width: 25px; background: #FFF;\"\n        >\n    \n        <div\n            dojoAttachPoint=\"dragSourceNode\"\n            class=\"dragSource\"\n            style=\"height: auto; width: 96%; margin-left: auto; margin-right: auto;\"\n        >\n    \n    </div>\n    </div>\n\n</div>\n",

	// Calls dijit._Templated.widgetsInTemplate
	widgetsInTemplate : true,
	
	// PARENT plugins.workflow.Apps WIDGET
	parentWidget : null,
	
	constructor : function(args)
	{
		////console.log("AppType.constructor    plugins.workflow.AppType.constructor()");
		this.parentWidget = args.parentWidget;
	},


	postCreate : function()
	{
		////console.log("AppType.postCreate    plugins.workflow.AppType.postCreate()");
		this.startup();
	},
	
	startup : function ()
	{
		////console.log("AppType.startup    plugins.workflow.AppType.startup()");
		////console.log("AppType.startup    this.parentWidget: " + this.parentWidget);

		this.inherited(arguments);
	}
});

}

if(!dojo._hasResource["plugins.workflow.AppsMenu"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.workflow.AppsMenu"] = true;
dojo.provide("plugins.workflow.AppsMenu");

// ALLOW THE USER TO ADD, REMOVE AND MODIFY APPS

// // optimize: load dijit layer


// HAS A


// INHERITS



dojo.declare("plugins.workflow.AppsMenu",
	[ dijit._Widget, dijit._Templated, plugins.core.Common ],
{

//Path to the template of this widget. 
templateString:"<div dojoAttachPoint=\"containerNode\">\n\n<div\n    dojoAttachPoint=\"menu\"\n    class=\"appsmenu\"\n    dojoType=\"plugins.menu.Menu\">\n\n<!--    <div dojoType=\"dijit.MenuItem\"\n        label=\"Info\"\n        dojoAttachPoint=\"title\"\n        class=\"title\"\n        disabled=\"false\">\n    </div>\n-->\n<!--    <div\n        dojoAttachPoint=\"aboutNode\"\n        dojoType=\"dijit.MenuItem\"\n        iconClass=\"dijitEditorIcon dijitEditorIconWikiword\"\n        >\n        About\n    </div>\n-->\n    <div\n        dojoAttachPoint=\"websiteNode\"\n        dojoAttachEvent=\"onClick:website\"\n        dojoType=\"dijit.MenuItem\"\n        iconClass=\"dijitEditorIcon dijitEditorIconInsertImage\"\n        >\n        Website\n    </div>\n\n</div>\n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

//addingApp STATE
addingApp : false,

// OR USE @import IN HTML TEMPLATE
cssFiles : [ dojo.moduleUrl("plugins") + "/workflow/css/appsmenu.css" ],


// PARENT WIDGET
parentWidget : null,

// CORE WORKFLOW OBJECTS
core : null,

/////}
constructor : function(args) {
	////console.log("AppsMenu.constructor     plugins.workflow.AppsMenu.constructor");			
	// GET INFO FROM ARGS
	this.parentWidget = args.parentWidget;
	////console.log("AppsMenu.constructor     this.parentWidget: " + this.parentWidget);
	////console.log("AppsMenu.constructor     this.parentWidget.parentWidget: " + this.parentWidget.parentWidget);

	// LOAD CSS
	this.loadCSS();		
},

postCreate : function() {
	////console.log("Controller.postCreate    plugins.workflow.Controller.postCreate()");

	this.startup();
},


startup : function () {
	////console.log("AppsMenu.startup    plugins.workflow.AppsMenu.startup()");

	// COMPLETE CONSTRUCTION OF OBJECT
	this.inherited(arguments);	 

	// SET DRAG APP - LIST OF APPS
	this.setMenu();
},


bind : function (node) {
// BIND THE MENU TO A NODE
	////console.log("AppsMenu.bind     plugins.workflow.AppsMenu.bind(node)");

	if ( node == null )
	{
		////console.log("AppsMenu.bind     node is null. Returning...");
		
	}
	return this.menu.bindDomNode(node);	
},

about : function (event) {
// SHOW 'ABOUT' INFORMATION
	//console.log("AppsMenu.about     plugins.workflow.Workflow.about()");
	//console.log("AppsMenu.about     this.parentWidget: " + this.parentWidget);
	//console.log("AppsMenu.about     this.parentWidget.parentWidget: " + this.parentWidget.parentWidget);

		event.stopPropagation();

},		

website : function (event) {
// OPEN WINDOW TO APPLICATION WEBSITE
	console.log("AppsMenu.website     plugins.workflow.Workflow.website(event)");
	event.stopPropagation();

	var appRow = this.menu.currentTarget.parentWidget;
	console.log("FileMenu.onUploadComplete    appRow: " + appRow);
	if ( appRow == null ) 	return;
	
	var application = appRow.application;
	console.log("FileMenu.onUploadComplete    application: " + dojo.toJson(application));
	if ( application == null )	return;
	
	var url = application.url;
	console.log("FileMenu.onUploadComplete    url: " + url);
	
	window.open(url);
	
},

setMenu : function () {
// ADD PROGRAMMATIC CONTEXT MENU
	////console.log("AppsMenu.setMenu     plugins.workflow.Workflow.setMenu()");
	////console.log("AppsMenu.setMenu     this.aboutNode: " + this.aboutNode);
	////console.log("AppsMenu.setMenu     this.websiteNode: " + this.websiteNode);

}
	
}); // plugins.workflow.AppsMenu


}

if(!dojo._hasResource["plugins.workflow.Apps"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.workflow.Apps"] = true;
dojo.provide("plugins.workflow.Apps");

// ALLOW THE USER TO SELECT FROM THEIR OWN APPLICATIONS AND DRAG THEM INTO WORKFLOWS

// NB: USERS CAN MANAGE THEIR APPS IN THE 'ADMIN' TAB

// EXTERNAL MODULES






// INTERNAL MODULES





dojo.declare("plugins.workflow.Apps",
	[ dijit._Widget, dijit._Templated, plugins.core.Common ], {

//Path to the template of this widget. 
templateString:"<div dojoAttachPoint=\"containerNode\">\n\n    <div\n        dojoAttachPoint=\"mainTab\"\n        class=\"apps\"\n        dojoType=\"dijit.layout.ContentPane\"\n        parseOnLoad=\"false\"\n        title=\"My Apps\"\n\t\tstyle=\"position: relative; height: 100%; max-height: auto !important; width: 400px !important; padding: 0 !important;\"\n    >\n\n        <table width=\"200px\">\n\t\t\t<tr valign=\"top\" width=\"100%\">\n\t\t\t\t\n\t\t\t\t<td colspan=\"3\" class=\"tabTitle\" align=\"center\">\n\t\t\t\t\t<div class=\"header\">\n\t\t\t\t\t    Applications\n\t\t\t\t\t</div>\n\t\t\t\t</td>\n\t\t\t</tr>\n            <tr>\n                <td>\n                    <div\n                        dojoAttachPoint=\"appSourcesContainer\"\n\t\t\t\t\t\tclass=\"appSource\">\n                    </div>\n                    \n                </td>\n            </tr>\n        </table>\n    \n    </div>\n</div>\n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

// OR USE @import IN HTML TEMPLATE
cssFiles : [
	dojo.moduleUrl("plugins", "workflow/css/apps.css")
],

// PARENT WIDGET
parentWidget : null,

// CORE WORKFLOW OBJECTS
core : null,

// TAB CONTAINER
tabContainer : null,

// CONTEXT MENU
contextMenu : null,

////}	

constructor : function(args) {
	////////console.log("Apps.constructor     plugins.workflow.Apps.constructor");			
	// GET INFO FROM ARGS
	this.core = args.core;
	this.parentWidget = args.parentWidget;
	this.attachNode = args.attachNode;
	this.loadCSS();		
},

postCreate : function() {
	this.startup();
},

startup : function () {
	////////console.log("Apps.startup    plugins.workflow.Apps.startup()");

	// COMPLETE CONSTRUCTION OF OBJECT
	this.inherited(arguments);	 

	// ADD TO TAB CONTAINER		
	this.attachNode.addChild(this.mainTab);
	this.attachNode.selectChild(this.mainTab);

	// CREATE SOURCE MENU
	////////console.log("Apps.startup    DOING this.setContextMenu()");
	this.setContextMenu();
	
	// SET DRAG APP - LIST OF APPS
	////////console.log("Apps.startup    DOING this.loadAppSources()");
	this.loadAppSources();
	
	// SUBSCRIBE TO UPDATES
	Agua.updater.subscribe(this, "updateApps");
},

setContextMenu : function () {
// GENERATE CONTEXT MENU
	//////console.log("Apps.setContextMenu     plugins.workflow.Apps.setContextMenu()");	
	this.contextMenu = new plugins.workflow.AppsMenu( {
			parentWidget: this
		}
	);	
},

updateApps : function (args) {
	////////console.log("Apps.refresh     plugins.workflow.Apps.refresh()");
	//console.log("Apps.updateApps    args:");
	//console.dir(args);
	this.loadAppSources();
},

closePanes : function () {
	//console.log("Apps.closePanes     plugins.workflow.Apps.closePanes()");

	if ( this.appSources == null || this.appSources.length == 0 )	return;
	for ( var i = 0; i < this.appSources.length; i++ )
	{
        var titlePane = this.appSources[i].titlePane;
        //console.log("Apps.closePanes     titlePane: " + titlePane);
        if ( titlePane.open == true )
            titlePane.toggle();
	}
},

clearAppSources : function () {
// DELETE EXISTING APP SOURCES
	//console.log("Apps.clearAppSources     plugins.workflow.Apps.clearAppSources()");
	if ( this.appSources == null || this.appSources.length == 0 )	return;
	
	for ( var i = 0; i < this.appSources.length; i++ ) {
		//console.log("Apps.clearAppSources     Destroying this.appSources[" + i + "]: " + this.appSources[i]);
		this.appSources[i].clearDragSource();
		this.appSourcesContainer.removeChild(this.appSources[i].domNode);
		this.appSources[i].destroy();
	}
},

getApps : function () {
	return Agua.getApps();
},

getAppsByType : function (type, apps) {
	//console.log("Apps.getAppsByType    plugins.workflow.Apps.getAppsByType(type)");
	//console.log("Apps.getAppsByType    type: " + type);
	var keyArray = ["type"];
	var valueArray = [type];
	var cloneapps = dojo.clone(apps);

	return this.filterByKeyValues(cloneapps, keyArray, valueArray);
},

loadAppSources : function () {
	//console.log("Apps.loadAppSources     plugins.workflow.Apps.loadAppSources()");

	// DELETE EXISTING CONTENT
	this.clearAppSources();

	var apps = this.getApps();
	//console.log("Apps.loadAppSources     apps: " + dojo.toJson(apps));
	var types = Agua.getAppTypes(apps);
	//console.log("Apps.loadAppSources     types: " + dojo.toJson(types));
	
	this.appSources = new Array;
	for ( var i = 0; i < types.length; i++ )
	{
		var type = types[i];
		//console.log("Apps.loadAppSources     Doing type: " + dojo.toJson(type));		

		// GET APPLICATIONS
		var itemArray = this.getAppsByType(type, apps);
		if ( itemArray == null || itemArray.length == 0 )	continue;
		//console.log("Apps.loadAppSources     itemArray: " + dojo.toJson(itemArray));

		// CREATE TITLE PANE
		var appSource = new plugins.workflow.AppSource(
		{
			title		: 	type,
			itemArray 	:	itemArray,
			contextMenu	:	this.contextMenu
			
		});
		this.appSources.push(appSource);
		this.appSourcesContainer.appendChild(appSource.domNode);
	}
}


}); // plugins.workflow.Apps

}

if(!dojo._hasResource["dojo.cldr.monetary"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.cldr.monetary"] = true;
dojo.provide("dojo.cldr.monetary");

dojo.getObject("cldr.monetary", true, dojo);

dojo.cldr.monetary.getData = function(/*String*/code){
// summary: A mapping of currency code to currency-specific formatting information. Returns a unique object with properties: places, round.
// code: an [ISO 4217](http://en.wikipedia.org/wiki/ISO_4217) currency code

// from http://www.unicode.org/cldr/data/common/supplemental/supplementalData.xml:supplementalData/currencyData/fractions

	var placesData = {
		ADP:0,AFN:0,ALL:0,AMD:0,BHD:3,BIF:0,BYR:0,CLF:0,CLP:0,
		COP:0,CRC:0,DJF:0,ESP:0,GNF:0,GYD:0,HUF:0,IDR:0,IQD:0,
		IRR:3,ISK:0,ITL:0,JOD:3,JPY:0,KMF:0,KPW:0,KRW:0,KWD:3,
		LAK:0,LBP:0,LUF:0,LYD:3,MGA:0,MGF:0,MMK:0,MNT:0,MRO:0,
		MUR:0,OMR:3,PKR:0,PYG:0,RSD:0,RWF:0,SLL:0,SOS:0,STD:0,
		SYP:0,TMM:0,TND:3,TRL:0,TZS:0,UGX:0,UZS:0,VND:0,VUV:0,
		XAF:0,XOF:0,XPF:0,YER:0,ZMK:0,ZWD:0
	};

	var roundingData = {CHF:5};

	var places = placesData[code], round = roundingData[code];
	if(typeof places == "undefined"){ places = 2; }
	if(typeof round == "undefined"){ round = 0; }

	return {places: places, round: round}; // Object
};

}

if(!dojo._hasResource["dojo.currency"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.currency"] = true;
dojo.provide("dojo.currency");





dojo.getObject("currency", true, dojo);

/*=====
dojo.currency = {
	// summary: localized formatting and parsing routines for currencies
	//
	// description: extends dojo.number to provide culturally-appropriate formatting of values
	//	in various world currencies, including use of a currency symbol.  The currencies are specified
	//	by a three-letter international symbol in all uppercase, and support for the currencies is
	//	provided by the data in `dojo.cldr`.  The scripts generating dojo.cldr specify which
	//	currency support is included.  A fixed number of decimal places is determined based
	//	on the currency type and is not determined by the 'pattern' argument.  The fractional
	//	portion is optional, by default, and variable length decimals are not supported.
}
=====*/

dojo.currency._mixInDefaults = function(options){
	options = options || {};
	options.type = "currency";

	// Get locale-dependent currency data, like the symbol
	var bundle = dojo.i18n.getLocalization("dojo.cldr", "currency", options.locale) || {};

	// Mixin locale-independent currency data, like # of places
	var iso = options.currency;
	var data = dojo.cldr.monetary.getData(iso);

	dojo.forEach(["displayName","symbol","group","decimal"], function(prop){
		data[prop] = bundle[iso+"_"+prop];
	});

	data.fractional = [true, false];

	// Mixin with provided options
	return dojo.mixin(data, options);
};

/*=====
dojo.declare("dojo.currency.__FormatOptions", [dojo.number.__FormatOptions], {
	//	type: String?
	//		Should not be set.  Value is assumed to be "currency".
	//	symbol: String?
	//		localized currency symbol. The default will be looked up in table of supported currencies in `dojo.cldr`
	//		A [ISO4217](http://en.wikipedia.org/wiki/ISO_4217) currency code will be used if not found.
	//	currency: String?
	//		an [ISO4217](http://en.wikipedia.org/wiki/ISO_4217) currency code, a three letter sequence like "USD".
	//		For use with dojo.currency only.
	//	places: Number?
	//		number of decimal places to show.  Default is defined based on which currency is used.
	type: "",
	symbol: "",
	currency: "",
	places: ""
});
=====*/

dojo.currency.format = function(/*Number*/value, /*dojo.currency.__FormatOptions?*/options){
// summary:
//		Format a Number as a currency, using locale-specific settings
//
// description:
//		Create a string from a Number using a known, localized pattern.
//		[Formatting patterns](http://www.unicode.org/reports/tr35/#Number_Elements)
//		appropriate to the locale are chosen from the [CLDR](http://unicode.org/cldr)
//		as well as the appropriate symbols and delimiters and number of decimal places.
//
// value:
//		the number to be formatted.

	return dojo.number.format(value, dojo.currency._mixInDefaults(options));
};

dojo.currency.regexp = function(/*dojo.number.__RegexpOptions?*/options){
//
// summary:
//		Builds the regular needed to parse a currency value
//
// description:
//		Returns regular expression with positive and negative match, group and decimal separators
//		Note: the options.places default, the number of decimal places to accept, is defined by the currency type.
	return dojo.number.regexp(dojo.currency._mixInDefaults(options)); // String
};

/*=====
dojo.declare("dojo.currency.__ParseOptions", [dojo.number.__ParseOptions], {
	//	type: String?
	//		Should not be set.  Value is assumed to be currency.
	//	currency: String?
	//		an [ISO4217](http://en.wikipedia.org/wiki/ISO_4217) currency code, a three letter sequence like "USD".
	//		For use with dojo.currency only.
	//	symbol: String?
	//		localized currency symbol. The default will be looked up in table of supported currencies in `dojo.cldr`
	//		A [ISO4217](http://en.wikipedia.org/wiki/ISO_4217) currency code will be used if not found.
	//	places: Number?
	//		fixed number of decimal places to accept.  The default is determined based on which currency is used.
	//	fractional: Boolean?|Array?
	//		Whether to include the fractional portion, where the number of decimal places are implied by the currency
	//		or explicit 'places' parameter.  The value [true,false] makes the fractional portion optional.
	//		By default for currencies, it the fractional portion is optional.
	type: "",
	currency: "",
	symbol: "",
	places: "",
	fractional: ""
});
=====*/

dojo.currency.parse = function(/*String*/expression, /*dojo.currency.__ParseOptions?*/options){
	//
	// summary:
	//		Convert a properly formatted currency string to a primitive Number,
	//		using locale-specific settings.
	//
	// description:
	//		Create a Number from a string using a known, localized pattern.
	//		[Formatting patterns](http://www.unicode.org/reports/tr35/#Number_Format_Patterns)
	//		are chosen appropriate to the locale, as well as the appropriate symbols and delimiters
	//		and number of decimal places.
	//
	// expression: A string representation of a currency value

	return dojo.number.parse(expression, dojo.currency._mixInDefaults(options));
};

}

if(!dojo._hasResource["dijit.form.CurrencyTextBox"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.CurrencyTextBox"] = true;
dojo.provide("dijit.form.CurrencyTextBox");




/*=====
dojo.declare(
	"dijit.form.CurrencyTextBox.__Constraints",
	[dijit.form.NumberTextBox.__Constraints, dojo.currency.__FormatOptions, dojo.currency.__ParseOptions], {
	// summary:
	//		Specifies both the rules on valid/invalid values (minimum, maximum,
	//		number of required decimal places), and also formatting options for
	//		displaying the value when the field is not focused (currency symbol,
	//		etc.)
	// description:
	//		Follows the pattern of `dijit.form.NumberTextBox.constraints`.
	//		In general developers won't need to set this parameter
	// example:
	//		To ensure that the user types in the cents (for example, 1.00 instead of just 1):
	//	|		{fractional:true}
});
=====*/

dojo.declare(
	"dijit.form.CurrencyTextBox",
	dijit.form.NumberTextBox,
	{
		// summary:
		//		A validating currency textbox
		// description:
		//		CurrencyTextBox is similar to `dijit.form.NumberTextBox` but has a few
		//		extra features related to currency:
		//
		//		1. After specifying the currency type (american dollars, euros, etc.) it automatically
		//			sets parse/format options such as how many decimal places to show.
		//		2. The currency mark (dollar sign, euro mark, etc.) is displayed when the field is blurred
		//			but erased during editing, so that the user can just enter a plain number.

		// currency: [const] String
		//		the [ISO4217](http://en.wikipedia.org/wiki/ISO_4217) currency code, a three letter sequence like "USD"
		currency: "",

		/*=====
		// constraints: dijit.form.CurrencyTextBox.__Constraints
		//		Despite the name, this parameter specifies both constraints on the input
		//		(including minimum/maximum allowed values) as well as
		//		formatting options.  See `dijit.form.CurrencyTextBox.__Constraints` for details.
		constraints: {},
		======*/
		
		baseClass: "dijitTextBox dijitCurrencyTextBox",

		// Override regExpGen ValidationTextBox.regExpGen().... we use a reg-ex generating function rather
		// than a straight regexp to deal with locale  (plus formatting options too?)
		regExpGen: function(constraints){
			// if focused, accept either currency data or NumberTextBox format
			return '(' + (this._focused? this.inherited(arguments, [ dojo.mixin({}, constraints, this.editOptions) ]) + '|' : '')
				+ dojo.currency.regexp(constraints) + ')';
		},

		// Override NumberTextBox._formatter to deal with currencies, ex: converts "123.45" to "$123.45"
		_formatter: dojo.currency.format,

		_parser: dojo.currency.parse,

		parse: function(/*String*/ value, /*Object*/ constraints){
			// summary:
			// 		Parses string value as a Currency, according to the constraints object
			// tags:
			// 		protected extension
			var v = this.inherited(arguments);
			if(isNaN(v) && /\d+/.test(value)){ // currency parse failed, but it could be because they are using NumberTextBox format so try its parse
				v = dojo.hitch(dojo.mixin({}, this, { _parser: dijit.form.NumberTextBox.prototype._parser }), "inherited")(arguments);
			}
			return v;
		},

		_setConstraintsAttr: function(/*Object*/ constraints){
			if(!constraints.currency && this.currency){
				constraints.currency = this.currency;
			}
			this.inherited(arguments, [ dojo.currency._mixInDefaults(dojo.mixin(constraints, { exponent: false })) ]); // get places
		}
	}
);

}

if(!dojo._hasResource["dojo.DeferredList"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.DeferredList"] = true;
dojo.provide("dojo.DeferredList");


dojo.DeferredList = function(/*Array*/ list, /*Boolean?*/ fireOnOneCallback, /*Boolean?*/ fireOnOneErrback, /*Boolean?*/ consumeErrors, /*Function?*/ canceller){
	// summary:
	//		Provides event handling for a group of Deferred objects.
	// description:
	//		DeferredList takes an array of existing deferreds and returns a new deferred of its own
	//		this new deferred will typically have its callback fired when all of the deferreds in
	//		the given list have fired their own deferreds.  The parameters `fireOnOneCallback` and
	//		fireOnOneErrback, will fire before all the deferreds as appropriate
	//
	//	list:
	//		The list of deferreds to be synchronizied with this DeferredList
	//	fireOnOneCallback:
	//		Will cause the DeferredLists callback to be fired as soon as any
	//		of the deferreds in its list have been fired instead of waiting until
	//		the entire list has finished
	//	fireonOneErrback:
	//		Will cause the errback to fire upon any of the deferreds errback
	//	canceller:
	//		A deferred canceller function, see dojo.Deferred
	var resultList = [];
	dojo.Deferred.call(this);
	var self = this;
	if(list.length === 0 && !fireOnOneCallback){
		this.resolve([0, []]);
	}
	var finished = 0;
	dojo.forEach(list, function(item, i){
		item.then(function(result){
			if(fireOnOneCallback){
				self.resolve([i, result]);
			}else{
				addResult(true, result);
			}
		},function(error){
			if(fireOnOneErrback){
				self.reject(error);
			}else{
				addResult(false, error);
			}
			if(consumeErrors){
				return null;
			}
			throw error;
		});
		function addResult(succeeded, result){
			resultList[i] = [succeeded, result];
			finished++;
			if(finished === list.length){
				self.resolve(resultList);
			}
			
		}
	});
};
dojo.DeferredList.prototype = new dojo.Deferred();

dojo.DeferredList.prototype.gatherResults= function(deferredList){
	// summary:
	//	Gathers the results of the deferreds for packaging
	//	as the parameters to the Deferred Lists' callback

	var d = new dojo.DeferredList(deferredList, false, true, false);
	d.addCallback(function(results){
		var ret = [];
		dojo.forEach(results, function(result){
			ret.push(result[1]);
		});
		return ret;
	});
	return d;
};

}

if(!dojo._hasResource["dijit.tree.TreeStoreModel"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.tree.TreeStoreModel"] = true;
dojo.provide("dijit.tree.TreeStoreModel");


dojo.declare(
		"dijit.tree.TreeStoreModel",
		null,
	{
		// summary:
		//		Implements dijit.Tree.model connecting to a store with a single
		//		root item.  Any methods passed into the constructor will override
		//		the ones defined here.

		// store: dojo.data.Store
		//		Underlying store
		store: null,

		// childrenAttrs: String[]
		//		One or more attribute names (attributes in the dojo.data item) that specify that item's children
		childrenAttrs: ["children"],

		// newItemIdAttr: String
		//		Name of attribute in the Object passed to newItem() that specifies the id.
		//
		//		If newItemIdAttr is set then it's used when newItem() is called to see if an
		//		item with the same id already exists, and if so just links to the old item
		//		(so that the old item ends up with two parents).
		//
		//		Setting this to null or "" will make every drop create a new item.
		newItemIdAttr: "id",

		// labelAttr: String
		//		If specified, get label for tree node from this attribute, rather
		//		than by calling store.getLabel()
		labelAttr: "",

	 	// root: [readonly] dojo.data.Item
		//		Pointer to the root item (read only, not a parameter)
		root: null,

		// query: anything
		//		Specifies datastore query to return the root item for the tree.
		//		Must only return a single item.   Alternately can just pass in pointer
		//		to root item.
		// example:
		//	|	{id:'ROOT'}
		query: null,

		// deferItemLoadingUntilExpand: Boolean
		//		Setting this to true will cause the TreeStoreModel to defer calling loadItem on nodes
		// 		until they are expanded. This allows for lazying loading where only one
		//		loadItem (and generally one network call, consequently) per expansion
		// 		(rather than one for each child).
		// 		This relies on partial loading of the children items; each children item of a
		// 		fully loaded item should contain the label and info about having children.
		deferItemLoadingUntilExpand: false,

		constructor: function(/* Object */ args){
			// summary:
			//		Passed the arguments listed above (store, etc)
			// tags:
			//		private

			dojo.mixin(this, args);

			this.connects = [];

			var store = this.store;
			if(!store.getFeatures()['dojo.data.api.Identity']){
				throw new Error("dijit.Tree: store must support dojo.data.Identity");
			}

			// if the store supports Notification, subscribe to the notification events
			if(store.getFeatures()['dojo.data.api.Notification']){
				this.connects = this.connects.concat([
					dojo.connect(store, "onNew", this, "onNewItem"),
					dojo.connect(store, "onDelete", this, "onDeleteItem"),
					dojo.connect(store, "onSet", this, "onSetItem")
				]);
			}
		},

		destroy: function(){
			dojo.forEach(this.connects, dojo.disconnect);
			// TODO: should cancel any in-progress processing of getRoot(), getChildren()
		},

		// =======================================================================
		// Methods for traversing hierarchy

		getRoot: function(onItem, onError){
			// summary:
			//		Calls onItem with the root item for the tree, possibly a fabricated item.
			//		Calls onError on error.
			if(this.root){
				onItem(this.root);
			}else{
				this.store.fetch({
					query: this.query,
					onComplete: dojo.hitch(this, function(items){
						if(items.length != 1){
							throw new Error(this.declaredClass + ": query " + dojo.toJson(this.query) + " returned " + items.length +
							 	" items, but must return exactly one item");
						}
						this.root = items[0];
						onItem(this.root);
					}),
					onError: onError
				});
			}
		},

		mayHaveChildren: function(/*dojo.data.Item*/ item){
			// summary:
			//		Tells if an item has or may have children.  Implementing logic here
			//		avoids showing +/- expando icon for nodes that we know don't have children.
			//		(For efficiency reasons we may not want to check if an element actually
			//		has children until user clicks the expando node)
			return dojo.some(this.childrenAttrs, function(attr){
				return this.store.hasAttribute(item, attr);
			}, this);
		},

		getChildren: function(/*dojo.data.Item*/ parentItem, /*function(items)*/ onComplete, /*function*/ onError){
			// summary:
			// 		Calls onComplete() with array of child items of given parent item, all loaded.

			var store = this.store;
			if(!store.isItemLoaded(parentItem)){
				// The parent is not loaded yet, we must be in deferItemLoadingUntilExpand
				// mode, so we will load it and just return the children (without loading each
				// child item)
				var getChildren = dojo.hitch(this, arguments.callee);
				store.loadItem({
					item: parentItem,
					onItem: function(parentItem){
						getChildren(parentItem, onComplete, onError);
					},
					onError: onError
				});
				return;
			}
			// get children of specified item
			var childItems = [];
			for(var i=0; i<this.childrenAttrs.length; i++){
				var vals = store.getValues(parentItem, this.childrenAttrs[i]);
				childItems = childItems.concat(vals);
			}

			// count how many items need to be loaded
			var _waitCount = 0;
			if(!this.deferItemLoadingUntilExpand){
				dojo.forEach(childItems, function(item){ if(!store.isItemLoaded(item)){ _waitCount++; } });
			}

			if(_waitCount == 0){
				// all items are already loaded (or we aren't loading them).  proceed...
				onComplete(childItems);
			}else{
				// still waiting for some or all of the items to load
				dojo.forEach(childItems, function(item, idx){
					if(!store.isItemLoaded(item)){
						store.loadItem({
							item: item,
							onItem: function(item){
								childItems[idx] = item;
								if(--_waitCount == 0){
									// all nodes have been loaded, send them to the tree
									onComplete(childItems);
								}
							},
							onError: onError
						});
					}
				});
			}
		},

		// =======================================================================
		// Inspecting items

		isItem: function(/* anything */ something){
			return this.store.isItem(something);	// Boolean
		},

		fetchItemByIdentity: function(/* object */ keywordArgs){
			this.store.fetchItemByIdentity(keywordArgs);
		},

		getIdentity: function(/* item */ item){
			return this.store.getIdentity(item);	// Object
		},

		getLabel: function(/*dojo.data.Item*/ item){
			// summary:
			//		Get the label for an item
			if(this.labelAttr){
				return this.store.getValue(item,this.labelAttr);	// String
			}else{
				return this.store.getLabel(item);	// String
			}
		},

		// =======================================================================
		// Write interface

		newItem: function(/* dojo.dnd.Item */ args, /*Item*/ parent, /*int?*/ insertIndex){
			// summary:
			//		Creates a new item.   See `dojo.data.api.Write` for details on args.
			//		Used in drag & drop when item from external source dropped onto tree.
			// description:
			//		Developers will need to override this method if new items get added
			//		to parents with multiple children attributes, in order to define which
			//		children attribute points to the new item.

			var pInfo = {parent: parent, attribute: this.childrenAttrs[0]}, LnewItem;

			if(this.newItemIdAttr && args[this.newItemIdAttr]){
				// Maybe there's already a corresponding item in the store; if so, reuse it.
				this.fetchItemByIdentity({identity: args[this.newItemIdAttr], scope: this, onItem: function(item){
					if(item){
						// There's already a matching item in store, use it
						this.pasteItem(item, null, parent, true, insertIndex);
					}else{
						// Create new item in the tree, based on the drag source.
						LnewItem=this.store.newItem(args, pInfo);
						if (LnewItem && (insertIndex!=undefined)){
							// Move new item to desired position
							this.pasteItem(LnewItem, parent, parent, false, insertIndex);
						}
					}
				}});
			}else{
				// [as far as we know] there is no id so we must assume this is a new item
				LnewItem=this.store.newItem(args, pInfo);
				if (LnewItem && (insertIndex!=undefined)){
					// Move new item to desired position
					this.pasteItem(LnewItem, parent, parent, false, insertIndex);
				}
			}
		},

		pasteItem: function(/*Item*/ childItem, /*Item*/ oldParentItem, /*Item*/ newParentItem, /*Boolean*/ bCopy, /*int?*/ insertIndex){
			// summary:
			//		Move or copy an item from one parent item to another.
			//		Used in drag & drop
			var store = this.store,
				parentAttr = this.childrenAttrs[0];	// name of "children" attr in parent item

			// remove child from source item, and record the attribute that child occurred in
			if(oldParentItem){
				dojo.forEach(this.childrenAttrs, function(attr){
					if(store.containsValue(oldParentItem, attr, childItem)){
						if(!bCopy){
							var values = dojo.filter(store.getValues(oldParentItem, attr), function(x){
								return x != childItem;
							});
							store.setValues(oldParentItem, attr, values);
						}
						parentAttr = attr;
					}
				});
			}

			// modify target item's children attribute to include this item
			if(newParentItem){
				if(typeof insertIndex == "number"){
					// call slice() to avoid modifying the original array, confusing the data store
					var childItems = store.getValues(newParentItem, parentAttr).slice();
					childItems.splice(insertIndex, 0, childItem);
					store.setValues(newParentItem, parentAttr, childItems);
				}else{
					store.setValues(newParentItem, parentAttr,
						store.getValues(newParentItem, parentAttr).concat(childItem));
				}
			}
		},

		// =======================================================================
		// Callbacks

		onChange: function(/*dojo.data.Item*/ item){
			// summary:
			//		Callback whenever an item has changed, so that Tree
			//		can update the label, icon, etc.   Note that changes
			//		to an item's children or parent(s) will trigger an
			//		onChildrenChange() so you can ignore those changes here.
			// tags:
			//		callback
		},

		onChildrenChange: function(/*dojo.data.Item*/ parent, /*dojo.data.Item[]*/ newChildrenList){
			// summary:
			//		Callback to do notifications about new, updated, or deleted items.
			// tags:
			//		callback
		},

		onDelete: function(/*dojo.data.Item*/ parent, /*dojo.data.Item[]*/ newChildrenList){
			// summary:
			//		Callback when an item has been deleted.
			// description:
			//		Note that there will also be an onChildrenChange() callback for the parent
			//		of this item.
			// tags:
			//		callback
		},

		// =======================================================================
		// Events from data store

		onNewItem: function(/* dojo.data.Item */ item, /* Object */ parentInfo){
			// summary:
			//		Handler for when new items appear in the store, either from a drop operation
			//		or some other way.   Updates the tree view (if necessary).
			// description:
			//		If the new item is a child of an existing item,
			//		calls onChildrenChange() with the new list of children
			//		for that existing item.
			//
			// tags:
			//		extension

			// We only care about the new item if it has a parent that corresponds to a TreeNode
			// we are currently displaying
			if(!parentInfo){
				return;
			}

			// Call onChildrenChange() on parent (ie, existing) item with new list of children
			// In the common case, the new list of children is simply parentInfo.newValue or
			// [ parentInfo.newValue ], although if items in the store has multiple
			// child attributes (see `childrenAttr`), then it's a superset of parentInfo.newValue,
			// so call getChildren() to be sure to get right answer.
			this.getChildren(parentInfo.item, dojo.hitch(this, function(children){
				this.onChildrenChange(parentInfo.item, children);
			}));
		},

		onDeleteItem: function(/*Object*/ item){
			// summary:
			//		Handler for delete notifications from underlying store
			this.onDelete(item);
		},

		onSetItem: function(/* item */ item,
						/* attribute-name-string */ attribute,
						/* object | array */ oldValue,
						/* object | array */ newValue){
			// summary:
			//		Updates the tree view according to changes in the data store.
			// description:
			//		Handles updates to an item's children by calling onChildrenChange(), and
			//		other updates to an item by calling onChange().
			//
			//		See `onNewItem` for more details on handling updates to an item's children.
			// tags:
			//		extension

			if(dojo.indexOf(this.childrenAttrs, attribute) != -1){
				// item's children list changed
				this.getChildren(item, dojo.hitch(this, function(children){
					// See comments in onNewItem() about calling getChildren()
					this.onChildrenChange(item, children);
				}));
			}else{
				// item's label/icon/etc. changed.
				this.onChange(item);
			}
		}
	});

}

if(!dojo._hasResource["dijit.tree.ForestStoreModel"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.tree.ForestStoreModel"] = true;
dojo.provide("dijit.tree.ForestStoreModel");



dojo.declare("dijit.tree.ForestStoreModel", dijit.tree.TreeStoreModel, {
	// summary:
	//		Interface between a dijit.Tree and a dojo.data store that doesn't have a root item,
	//		a.k.a. a store that has multiple "top level" items.
	//
	// description
	//		Use this class to wrap a dojo.data store, making all the items matching the specified query
	//		appear as children of a fabricated "root item".  If no query is specified then all the
	//		items returned by fetch() on the underlying store become children of the root item.
	//		This class allows dijit.Tree to assume a single root item, even if the store doesn't have one.
	//
	//		When using this class the developer must override a number of methods according to their app and
	//		data, including:
	//			- onNewRootItem
	//			- onAddToRoot
	//			- onLeaveRoot
	//			- onNewItem
	//			- onSetItem

	// Parameters to constructor

	// rootId: String
	//		ID of fabricated root item
	rootId: "$root$",

	// rootLabel: String
	//		Label of fabricated root item
	rootLabel: "ROOT",

	// query: String
	//		Specifies the set of children of the root item.
	// example:
	//	|	{type:'continent'}
	query: null,

	// End of parameters to constructor

	constructor: function(params){
		// summary:
		//		Sets up variables, etc.
		// tags:
		//		private

		// Make dummy root item
		this.root = {
			store: this,
			root: true,
			id: params.rootId,
			label: params.rootLabel,
			children: params.rootChildren	// optional param
		};
	},

	// =======================================================================
	// Methods for traversing hierarchy

	mayHaveChildren: function(/*dojo.data.Item*/ item){
		// summary:
		//		Tells if an item has or may have children.  Implementing logic here
		//		avoids showing +/- expando icon for nodes that we know don't have children.
		//		(For efficiency reasons we may not want to check if an element actually
		//		has children until user clicks the expando node)
		// tags:
		//		extension
		return item === this.root || this.inherited(arguments);
	},

	getChildren: function(/*dojo.data.Item*/ parentItem, /*function(items)*/ callback, /*function*/ onError){
		// summary:
		// 		Calls onComplete() with array of child items of given parent item, all loaded.
		if(parentItem === this.root){
			if(this.root.children){
				// already loaded, just return
				callback(this.root.children);
			}else{
				this.store.fetch({
					query: this.query,
					onComplete: dojo.hitch(this, function(items){
						this.root.children = items;
						callback(items);
					}),
					onError: onError
				});
			}
		}else{
			this.inherited(arguments);
		}
	},

	// =======================================================================
	// Inspecting items

	isItem: function(/* anything */ something){
		return (something === this.root) ? true : this.inherited(arguments);
	},

	fetchItemByIdentity: function(/* object */ keywordArgs){
		if(keywordArgs.identity == this.root.id){
			var scope = keywordArgs.scope?keywordArgs.scope:dojo.global;
			if(keywordArgs.onItem){
				keywordArgs.onItem.call(scope, this.root);
			}
		}else{
			this.inherited(arguments);
		}
	},

	getIdentity: function(/* item */ item){
		return (item === this.root) ? this.root.id : this.inherited(arguments);
	},

	getLabel: function(/* item */ item){
		return	(item === this.root) ? this.root.label : this.inherited(arguments);
	},

	// =======================================================================
	// Write interface

	newItem: function(/* dojo.dnd.Item */ args, /*Item*/ parent, /*int?*/ insertIndex){
		// summary:
		//		Creates a new item.   See dojo.data.api.Write for details on args.
		//		Used in drag & drop when item from external source dropped onto tree.
		if(parent === this.root){
			this.onNewRootItem(args);
			return this.store.newItem(args);
		}else{
			return this.inherited(arguments);
		}
	},

	onNewRootItem: function(args){
		// summary:
		//		User can override this method to modify a new element that's being
		//		added to the root of the tree, for example to add a flag like root=true
	},

	pasteItem: function(/*Item*/ childItem, /*Item*/ oldParentItem, /*Item*/ newParentItem, /*Boolean*/ bCopy, /*int?*/ insertIndex){
		// summary:
		//		Move or copy an item from one parent item to another.
		//		Used in drag & drop
		if(oldParentItem === this.root){
			if(!bCopy){
				// It's onLeaveRoot()'s responsibility to modify the item so it no longer matches
				// this.query... thus triggering an onChildrenChange() event to notify the Tree
				// that this element is no longer a child of the root node
				this.onLeaveRoot(childItem);
			}
		}
		dijit.tree.TreeStoreModel.prototype.pasteItem.call(this, childItem,
			oldParentItem === this.root ? null : oldParentItem,
			newParentItem === this.root ? null : newParentItem,
			bCopy,
			insertIndex
		);
		if(newParentItem === this.root){
			// It's onAddToRoot()'s responsibility to modify the item so it matches
			// this.query... thus triggering an onChildrenChange() event to notify the Tree
			// that this element is now a child of the root node
			this.onAddToRoot(childItem);
		}
	},

	// =======================================================================
	// Handling for top level children

	onAddToRoot: function(/* item */ item){
		// summary:
		//		Called when item added to root of tree; user must override this method
		//		to modify the item so that it matches the query for top level items
		// example:
		//	|	store.setValue(item, "root", true);
		// tags:
		//		extension
		console.log(this, ": item ", item, " added to root");
	},

	onLeaveRoot: function(/* item */ item){
		// summary:
		//		Called when item removed from root of tree; user must override this method
		//		to modify the item so it doesn't match the query for top level items
		// example:
		// 	|	store.unsetAttribute(item, "root");
		// tags:
		//		extension
		console.log(this, ": item ", item, " removed from root");
	},

	// =======================================================================
	// Events from data store

	_requeryTop: function(){
		// reruns the query for the children of the root node,
		// sending out an onSet notification if those children have changed
		var oldChildren = this.root.children || [];
		this.store.fetch({
			query: this.query,
			onComplete: dojo.hitch(this, function(newChildren){
				this.root.children = newChildren;

				// If the list of children or the order of children has changed...
				if(oldChildren.length != newChildren.length ||
					dojo.some(oldChildren, function(item, idx){ return newChildren[idx] != item;})){
					this.onChildrenChange(this.root, newChildren);
				}
			})
		});
	},

	onNewItem: function(/* dojo.data.Item */ item, /* Object */ parentInfo){
		// summary:
		//		Handler for when new items appear in the store.  Developers should override this
		//		method to be more efficient based on their app/data.
		// description:
		//		Note that the default implementation requeries the top level items every time
		//		a new item is created, since any new item could be a top level item (even in
		//		addition to being a child of another item, since items can have multiple parents).
		//
		//		If developers can detect which items are possible top level items (based on the item and the
		//		parentInfo parameters), they should override this method to only call _requeryTop() for top
		//		level items.  Often all top level items have parentInfo==null, but
		//		that will depend on which store you use and what your data is like.
		// tags:
		//		extension
		this._requeryTop();

		this.inherited(arguments);
	},

	onDeleteItem: function(/*Object*/ item){
		// summary:
		//		Handler for delete notifications from underlying store

		// check if this was a child of root, and if so send notification that root's children
		// have changed
		if(dojo.indexOf(this.root.children, item) != -1){
			this._requeryTop();
		}

		this.inherited(arguments);
	},

	onSetItem: function(/* item */ item,
					/* attribute-name-string */ attribute,
					/* object | array */ oldValue,
					/* object | array */ newValue){
		// summary:
		//		Updates the tree view according to changes to an item in the data store.
		//		Developers should override this method to be more efficient based on their app/data.
		// description:
		//		Handles updates to an item's children by calling onChildrenChange(), and
		//		other updates to an item by calling onChange().
		//
		//		Also, any change to any item re-executes the query for the tree's top-level items,
		//		since this modified item may have started/stopped matching the query for top level items.
		//
		//		If possible, developers should override this function to only call _requeryTop() when
		//		the change to the item has caused it to stop/start being a top level item in the tree.
		// tags:
		//		extension

		this._requeryTop();
		this.inherited(arguments);
	}

});

}

if(!dojo._hasResource["dijit.tree._dndContainer"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.tree._dndContainer"] = true;
dojo.provide("dijit.tree._dndContainer");




dojo.getObject("tree", true, dojo);

dijit.tree._compareNodes = function(n1, n2){
	if(n1 === n2){
		return 0;
	}
	
	if('sourceIndex' in document.documentElement){ //IE
		//TODO: does not yet work if n1 and/or n2 is a text node
		return n1.sourceIndex - n2.sourceIndex;
	}else if('compareDocumentPosition' in document.documentElement){ //FF, Opera
		return n1.compareDocumentPosition(n2) & 2 ? 1: -1;
	}else if(document.createRange){ //Webkit
		var r1 = doc.createRange();
		r1.setStartBefore(n1);

		var r2 = doc.createRange();
		r2.setStartBefore(n2);

		return r1.compareBoundaryPoints(r1.END_TO_END, r2);
	}else{
		throw Error("dijit.tree._compareNodes don't know how to compare two different nodes in this browser");
	}
};

dojo.declare("dijit.tree._dndContainer",
	null,
	{

		// summary:
		//		This is a base class for `dijit.tree._dndSelector`, and isn't meant to be used directly.
		//		It's modeled after `dojo.dnd.Container`.
		// tags:
		//		protected

		/*=====
		// current: DomNode
		//		The currently hovered TreeNode.rowNode (which is the DOM node
		//		associated w/a given node in the tree, excluding it's descendants)
		current: null,
		=====*/

		constructor: function(tree, params){
			// summary:
			//		A constructor of the Container
			// tree: Node
			//		Node or node's id to build the container on
			// params: dijit.tree.__SourceArgs
			//		A dict of parameters, which gets mixed into the object
			// tags:
			//		private
			this.tree = tree;
			this.node = tree.domNode;	// TODO: rename; it's not a TreeNode but the whole Tree
			dojo.mixin(this, params);

			// class-specific variables
			this.map = {};
			this.current = null;	// current TreeNode's DOM node

			// states
			this.containerState = "";
			dojo.addClass(this.node, "dojoDndContainer");

			// set up events
			this.events = [
				// container level events
				dojo.connect(this.node, "onmouseenter", this, "onOverEvent"),
				dojo.connect(this.node, "onmouseleave",	this, "onOutEvent"),

				// switching between TreeNodes
				dojo.connect(this.tree, "_onNodeMouseEnter", this, "onMouseOver"),
				dojo.connect(this.tree, "_onNodeMouseLeave", this, "onMouseOut"),

				// cancel text selection and text dragging
				dojo.connect(this.node, "ondragstart", dojo, "stopEvent"),
				dojo.connect(this.node, "onselectstart", dojo, "stopEvent")
			];
		},

		getItem: function(/*String*/ key){
			// summary:
			//		Returns the dojo.dnd.Item (representing a dragged node) by it's key (id).
			//		Called by dojo.dnd.Source.checkAcceptance().
			// tags:
			//		protected

			var widget = this.selection[key],
				ret = {
					data: widget,
					type: ["treeNode"]
				};

			return ret;	// dojo.dnd.Item
		},

		destroy: function(){
			// summary:
			//		Prepares this object to be garbage-collected

			dojo.forEach(this.events, dojo.disconnect);
			// this.clearItems();
			this.node = this.parent = null;
		},

		// mouse events
		onMouseOver: function(/*TreeNode*/ widget, /*Event*/ evt){
			// summary:
			//		Called when mouse is moved over a TreeNode
			// tags:
			//		protected
			this.current = widget;
		},

		onMouseOut: function(/*TreeNode*/ widget, /*Event*/ evt){
			// summary:
			//		Called when mouse is moved away from a TreeNode
			// tags:
			//		protected
			this.current = null;
		},

		_changeState: function(type, newState){
			// summary:
			//		Changes a named state to new state value
			// type: String
			//		A name of the state to change
			// newState: String
			//		new state
			var prefix = "dojoDnd" + type;
			var state = type.toLowerCase() + "State";
			//dojo.replaceClass(this.node, prefix + newState, prefix + this[state]);
			dojo.replaceClass(this.node, prefix + newState, prefix + this[state]);
			this[state] = newState;
		},

		_addItemClass: function(node, type){
			// summary:
			//		Adds a class with prefix "dojoDndItem"
			// node: Node
			//		A node
			// type: String
			//		A variable suffix for a class name
			dojo.addClass(node, "dojoDndItem" + type);
		},

		_removeItemClass: function(node, type){
			// summary:
			//		Removes a class with prefix "dojoDndItem"
			// node: Node
			//		A node
			// type: String
			//		A variable suffix for a class name
			dojo.removeClass(node, "dojoDndItem" + type);
		},

		onOverEvent: function(){
			// summary:
			//		This function is called once, when mouse is over our container
			// tags:
			//		protected
			this._changeState("Container", "Over");
		},

		onOutEvent: function(){
			// summary:
			//		This function is called once, when mouse is out of our container
			// tags:
			//		protected
			this._changeState("Container", "");
		}
});

}

if(!dojo._hasResource["dijit.tree._dndSelector"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.tree._dndSelector"] = true;
dojo.provide("dijit.tree._dndSelector");




dojo.declare("dijit.tree._dndSelector",
	dijit.tree._dndContainer,
	{
		// summary:
		//		This is a base class for `dijit.tree.dndSource` , and isn't meant to be used directly.
		//		It's based on `dojo.dnd.Selector`.
		// tags:
		//		protected

		/*=====
		// selection: Hash<String, DomNode>
		//		(id, DomNode) map for every TreeNode that's currently selected.
		//		The DOMNode is the TreeNode.rowNode.
		selection: {},
		=====*/

		constructor: function(tree, params){
			// summary:
			//		Initialization
			// tags:
			//		private

			this.selection={};
			this.anchor = null;

			dijit.setWaiState(this.tree.domNode, "multiselect", !this.singular);

			this.events.push(
				dojo.connect(this.tree.domNode, "onmousedown", this,"onMouseDown"),
				dojo.connect(this.tree.domNode, "onmouseup", this,"onMouseUp"),
				dojo.connect(this.tree.domNode, "onmousemove", this,"onMouseMove")
			);
		},

		//	singular: Boolean
		//		Allows selection of only one element, if true.
		//		Tree hasn't been tested in singular=true mode, unclear if it works.
		singular: false,

		// methods
		getSelectedTreeNodes: function(){
			// summary:
			//		Returns a list of selected node(s).
			//		Used by dndSource on the start of a drag.
			// tags:
			//		protected
			var nodes=[], sel = this.selection;
			for(var i in sel){
				nodes.push(sel[i]);
			}
			return nodes;
		},

		selectNone: function(){
			// summary:
			//		Unselects all items
			// tags:
			//		private

			this.setSelection([]);
			return this;	// self
		},

		destroy: function(){
			// summary:
			//		Prepares the object to be garbage-collected
			this.inherited(arguments);
			this.selection = this.anchor = null;
		},
		addTreeNode: function(/*dijit._TreeNode*/node, /*Boolean?*/isAnchor){
			// summary
			//		add node to current selection
			// node: Node
			//		node to add
			// isAnchor: Boolean
			//		Whether the node should become anchor.

			this.setSelection(this.getSelectedTreeNodes().concat( [node] ));
			if(isAnchor){ this.anchor = node; }
			return node;
		},
		removeTreeNode: function(/*dijit._TreeNode*/node){
			// summary
			//		remove node from current selection
			// node: Node
			//		node to remove
			this.setSelection(this._setDifference(this.getSelectedTreeNodes(), [node]))
			return node;
		},
		isTreeNodeSelected: function(/*dijit._TreeNode*/node){
			// summary
			//		return true if node is currently selected
			// node: Node
			//		the node to check whether it's in the current selection

			return node.id && !!this.selection[node.id];
		},
		setSelection: function(/*dijit._treeNode[]*/ newSelection){
			// summary
			//      set the list of selected nodes to be exactly newSelection. All changes to the
			//      selection should be passed through this function, which ensures that derived
			//      attributes are kept up to date. Anchor will be deleted if it has been removed
			//      from the selection, but no new anchor will be added by this function.
			// newSelection: Node[]
			//      list of tree nodes to make selected
			var oldSelection = this.getSelectedTreeNodes();
			dojo.forEach(this._setDifference(oldSelection, newSelection), dojo.hitch(this, function(node){
				node.setSelected(false);
				if(this.anchor == node){
					delete this.anchor;
				}
				delete this.selection[node.id];
			}));
			dojo.forEach(this._setDifference(newSelection, oldSelection), dojo.hitch(this, function(node){
				node.setSelected(true);
				this.selection[node.id] = node;
			}));
			this._updateSelectionProperties();
		},
		_setDifference: function(xs,ys){
			// summary
			//      Returns a copy of xs which lacks any objects
			//      occurring in ys. Checks for membership by
			//      modifying and then reading the object, so it will
			//      not properly handle sets of numbers or strings.
			
			dojo.forEach(ys, function(y){ y.__exclude__ = true; });
			var ret = dojo.filter(xs, function(x){ return !x.__exclude__; });

			// clean up after ourselves.
			dojo.forEach(ys, function(y){ delete y['__exclude__'] });
			return ret;
		},
		_updateSelectionProperties: function() {
			// summary
			//      Update the following tree properties from the current selection:
			//      path[s], selectedItem[s], selectedNode[s]
			
			var selected = this.getSelectedTreeNodes();
			var paths = [], nodes = [];
			dojo.forEach(selected, function(node) {
				nodes.push(node);
				paths.push(node.getTreePath());
			});
			var items = dojo.map(nodes,function(node) { return node.item; });
			this.tree._set("paths", paths);
			this.tree._set("path", paths[0] || []);
			this.tree._set("selectedNodes", nodes);
			this.tree._set("selectedNode", nodes[0] || null);
			this.tree._set("selectedItems", items);
			this.tree._set("selectedItem", items[0] || null);
		},
		// mouse events
		onMouseDown: function(e){
			// summary:
			//		Event processor for onmousedown
			// e: Event
			//		mouse event
			// tags:
			//		protected

			// ignore click on expando node
			if(!this.current || this.tree.isExpandoNode( e.target, this.current)){ return; }

			if(e.button == dojo.mouseButtons.RIGHT){ return; }	// ignore right-click

			dojo.stopEvent(e);

			var treeNode = this.current,
			  copy = dojo.isCopyKey(e), id = treeNode.id;

			// if shift key is not pressed, and the node is already in the selection,
			// delay deselection until onmouseup so in the case of DND, deselection
			// will be canceled by onmousemove.
			if(!this.singular && !e.shiftKey && this.selection[id]){
				this._doDeselect = true;
				return;
			}else{
				this._doDeselect = false;
			}
			this.userSelect(treeNode, copy, e.shiftKey);
		},

		onMouseUp: function(e){
			// summary:
			//		Event processor for onmouseup
			// e: Event
			//		mouse event
			// tags:
			//		protected

			// _doDeselect is the flag to indicate that the user wants to either ctrl+click on
			// a already selected item (to deselect the item), or click on a not-yet selected item
			// (which should remove all current selection, and add the clicked item). This can not
			// be done in onMouseDown, because the user may start a drag after mousedown. By moving
			// the deselection logic here, the user can drags an already selected item.
			if(!this._doDeselect){ return; }
			this._doDeselect = false;
			this.userSelect(this.current, dojo.isCopyKey( e ), e.shiftKey);
		},
		onMouseMove: function(e){
			// summary
			//		event processor for onmousemove
			// e: Event
			//		mouse event
			this._doDeselect = false;
		},

		userSelect: function(node, multi, range){
			// summary:
			//		Add or remove the given node from selection, responding
			//      to a user action such as a click or keypress.
			// multi: Boolean
			//		Indicates whether this is meant to be a multi-select action (e.g. ctrl-click)
			// range: Boolean
			//		Indicates whether this is meant to be a ranged action (e.g. shift-click)
			// tags:
			//		protected

			if(this.singular){
				if(this.anchor == node && multi){
					this.selectNone();
				}else{
					this.setSelection([node]);
					this.anchor = node;
				}
			}else{
				if(range && this.anchor){
					var cr = dijit.tree._compareNodes(this.anchor.rowNode, node.rowNode),
					begin, end, anchor = this.anchor;
					
					if(cr < 0){ //current is after anchor
						begin = anchor;
						end = node;
					}else{ //current is before anchor
						begin = node;
						end = anchor;
					}
					nodes = [];
					//add everything betweeen begin and end inclusively
					while(begin != end) {
						nodes.push(begin)
						begin = this.tree._getNextNode(begin);
					}
					nodes.push(end)

					this.setSelection(nodes);
				}else{
				    if( this.selection[ node.id ] && multi ) {
						this.removeTreeNode( node );
				    } else if(multi) {
						this.addTreeNode(node, true);
					} else {
						this.setSelection([node]);
						this.anchor = node;
				    }
				}
			}
		},

		forInSelectedItems: function(/*Function*/ f, /*Object?*/ o){
			// summary:
			//		Iterates over selected items;
			//		see `dojo.dnd.Container.forInItems()` for details
			o = o || dojo.global;
			for(var id in this.selection){
				// console.log("selected item id: " + id);
				f.call(o, this.getItem(id), id, this);
			}
		}
});

}

if(!dojo._hasResource["dijit.Tree"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.Tree"] = true;
dojo.provide("dijit.Tree");













dojo.declare(
	"dijit._TreeNode",
	[dijit._Widget, dijit._Templated, dijit._Container, dijit._Contained, dijit._CssStateMixin],
{
	// summary:
	//		Single node within a tree.   This class is used internally
	//		by Tree and should not be accessed directly.
	// tags:
	//		private

	// item: [const] dojo.data.Item
	//		the dojo.data entry this tree represents
	item: null,

	// isTreeNode: [protected] Boolean
	//		Indicates that this is a TreeNode.   Used by `dijit.Tree` only,
	//		should not be accessed directly.
	isTreeNode: true,

	// label: String
	//		Text of this tree node
	label: "",

	// isExpandable: [private] Boolean
	//		This node has children, so show the expando node (+ sign)
	isExpandable: null,

	// isExpanded: [readonly] Boolean
	//		This node is currently expanded (ie, opened)
	isExpanded: false,

	// state: [private] String
	//		Dynamic loading-related stuff.
	//		When an empty folder node appears, it is "UNCHECKED" first,
	//		then after dojo.data query it becomes "LOADING" and, finally "LOADED"
	state: "UNCHECKED",

	templateString: dojo.cache("dijit", "templates/TreeNode.html", "<div class=\"dijitTreeNode\" role=\"presentation\"\n\t><div dojoAttachPoint=\"rowNode\" class=\"dijitTreeRow\" role=\"presentation\" dojoAttachEvent=\"onmouseenter:_onMouseEnter, onmouseleave:_onMouseLeave, onclick:_onClick, ondblclick:_onDblClick\"\n\t\t><img src=\"${_blankGif}\" alt=\"\" dojoAttachPoint=\"expandoNode\" class=\"dijitTreeExpando\" role=\"presentation\"\n\t\t/><span dojoAttachPoint=\"expandoNodeText\" class=\"dijitExpandoText\" role=\"presentation\"\n\t\t></span\n\t\t><span dojoAttachPoint=\"contentNode\"\n\t\t\tclass=\"dijitTreeContent\" role=\"presentation\">\n\t\t\t<img src=\"${_blankGif}\" alt=\"\" dojoAttachPoint=\"iconNode\" class=\"dijitIcon dijitTreeIcon\" role=\"presentation\"\n\t\t\t/><span dojoAttachPoint=\"labelNode\" class=\"dijitTreeLabel\" role=\"treeitem\" tabindex=\"-1\" aria-selected=\"false\" dojoAttachEvent=\"onfocus:_onLabelFocus\"></span>\n\t\t</span\n\t></div>\n\t<div dojoAttachPoint=\"containerNode\" class=\"dijitTreeContainer\" role=\"presentation\" style=\"display: none;\"></div>\n</div>\n"),

	baseClass: "dijitTreeNode",

	// For hover effect for tree node, and focus effect for label
	cssStateNodes: {
		rowNode: "dijitTreeRow",
		labelNode: "dijitTreeLabel"
	},

	attributeMap: dojo.delegate(dijit._Widget.prototype.attributeMap, {
		label: {node: "labelNode", type: "innerText"},
		tooltip: {node: "rowNode", type: "attribute", attribute: "title"}
	}),

	buildRendering: function(){
		this.inherited(arguments);

		// set expand icon for leaf
		this._setExpando();

		// set icon and label class based on item
		this._updateItemClasses(this.item);

		if(this.isExpandable){
			dijit.setWaiState(this.labelNode, "expanded", this.isExpanded);
		}

		//aria-selected should be false on all selectable elements.
		this.setSelected(false);
	},

	_setIndentAttr: function(indent){
		// summary:
		//		Tell this node how many levels it should be indented
		// description:
		//		0 for top level nodes, 1 for their children, 2 for their
		//		grandchildren, etc.

		// Math.max() is to prevent negative padding on hidden root node (when indent == -1)
		var pixels = (Math.max(indent, 0) * this.tree._nodePixelIndent) + "px";

		dojo.style(this.domNode, "backgroundPosition",	pixels + " 0px");
		dojo.style(this.rowNode, this.isLeftToRight() ? "paddingLeft" : "paddingRight", pixels);

		dojo.forEach(this.getChildren(), function(child){
			child.set("indent", indent+1);
		});
		
		this._set("indent", indent);
	},

	markProcessing: function(){
		// summary:
		//		Visually denote that tree is loading data, etc.
		// tags:
		//		private
		this.state = "LOADING";
		this._setExpando(true);
	},

	unmarkProcessing: function(){
		// summary:
		//		Clear markup from markProcessing() call
		// tags:
		//		private
		this._setExpando(false);
	},

	_updateItemClasses: function(item){
		// summary:
		//		Set appropriate CSS classes for icon and label dom node
		//		(used to allow for item updates to change respective CSS)
		// tags:
		//		private
		var tree = this.tree, model = tree.model;
		if(tree._v10Compat && item === model.root){
			// For back-compat with 1.0, need to use null to specify root item (TODO: remove in 2.0)
			item = null;
		}
		this._applyClassAndStyle(item, "icon", "Icon");
		this._applyClassAndStyle(item, "label", "Label");
		this._applyClassAndStyle(item, "row", "Row");
	},

	_applyClassAndStyle: function(item, lower, upper){
		// summary:
		//		Set the appropriate CSS classes and styles for labels, icons and rows.
		//
		// item:
		//		The data item.
		//
		// lower:
		//		The lower case attribute to use, e.g. 'icon', 'label' or 'row'.
		//
		// upper:
		//		The upper case attribute to use, e.g. 'Icon', 'Label' or 'Row'.
		//
		// tags:
		//		private

		var clsName = "_" + lower + "Class";
		var nodeName = lower + "Node";
		var oldCls = this[clsName];

		this[clsName] = this.tree["get" + upper + "Class"](item, this.isExpanded);
		dojo.replaceClass(this[nodeName], this[clsName] || "", oldCls || "");
 
		dojo.style(this[nodeName], this.tree["get" + upper + "Style"](item, this.isExpanded) || {});
 	},

	_updateLayout: function(){
		// summary:
		//		Set appropriate CSS classes for this.domNode
		// tags:
		//		private
		var parent = this.getParent();
		if(!parent || parent.rowNode.style.display == "none"){
			/* if we are hiding the root node then make every first level child look like a root node */
			dojo.addClass(this.domNode, "dijitTreeIsRoot");
		}else{
			dojo.toggleClass(this.domNode, "dijitTreeIsLast", !this.getNextSibling());
		}
	},

	_setExpando: function(/*Boolean*/ processing){
		// summary:
		//		Set the right image for the expando node
		// tags:
		//		private

		var styles = ["dijitTreeExpandoLoading", "dijitTreeExpandoOpened",
						"dijitTreeExpandoClosed", "dijitTreeExpandoLeaf"],
			_a11yStates = ["*","-","+","*"],
			idx = processing ? 0 : (this.isExpandable ?	(this.isExpanded ? 1 : 2) : 3);

		// apply the appropriate class to the expando node
		dojo.replaceClass(this.expandoNode, styles[idx], styles);

		// provide a non-image based indicator for images-off mode
		this.expandoNodeText.innerHTML = _a11yStates[idx];

	},

	expand: function(){
		// summary:
		//		Show my children
		// returns:
		//		Deferred that fires when expansion is complete

		// If there's already an expand in progress or we are already expanded, just return
		if(this._expandDeferred){
			return this._expandDeferred;		// dojo.Deferred
		}

		// cancel in progress collapse operation
		this._wipeOut && this._wipeOut.stop();

		// All the state information for when a node is expanded, maybe this should be
		// set when the animation completes instead
		this.isExpanded = true;
		dijit.setWaiState(this.labelNode, "expanded", "true");
		if(this.tree.showRoot || this !== this.tree.rootNode){
			dijit.setWaiRole(this.containerNode, "group");
		}
		dojo.addClass(this.contentNode,'dijitTreeContentExpanded');
		this._setExpando();
		this._updateItemClasses(this.item);
		if(this == this.tree.rootNode){
			dijit.setWaiState(this.tree.domNode, "expanded", "true");
		}

		var def,
			wipeIn = dojo.fx.wipeIn({
				node: this.containerNode, duration: dijit.defaultDuration,
				onEnd: function(){
					def.callback(true);
				}
			});

		// Deferred that fires when expand is complete
		def = (this._expandDeferred = new dojo.Deferred(function(){
			// Canceller
			wipeIn.stop();
		}));

		wipeIn.play();

		return def;		// dojo.Deferred
	},

	collapse: function(){
		// summary:
		//		Collapse this node (if it's expanded)

		if(!this.isExpanded){ return; }

		// cancel in progress expand operation
		if(this._expandDeferred){
			this._expandDeferred.cancel();
			delete this._expandDeferred;
		}

		this.isExpanded = false;
		dijit.setWaiState(this.labelNode, "expanded", "false");
		if(this == this.tree.rootNode){
			dijit.setWaiState(this.tree.domNode, "expanded", "false");
		}
		dojo.removeClass(this.contentNode,'dijitTreeContentExpanded');
		this._setExpando();
		this._updateItemClasses(this.item);

		if(!this._wipeOut){
			this._wipeOut = dojo.fx.wipeOut({
				node: this.containerNode, duration: dijit.defaultDuration
			});
		}
		this._wipeOut.play();
	},

	// indent: Integer
	//		Levels from this node to the root node
	indent: 0,

	setChildItems: function(/* Object[] */ items){
		// summary:
		//		Sets the child items of this node, removing/adding nodes
		//		from current children to match specified items[] array.
		//		Also, if this.persist == true, expands any children that were previously
		// 		opened.
		// returns:
		//		Deferred object that fires after all previously opened children
		//		have been expanded again (or fires instantly if there are no such children).

		var tree = this.tree,
			model = tree.model,
			defs = [];	// list of deferreds that need to fire before I am complete


		// Orphan all my existing children.
		// If items contains some of the same items as before then we will reattach them.
		// Don't call this.removeChild() because that will collapse the tree etc.
		dojo.forEach(this.getChildren(), function(child){
			dijit._Container.prototype.removeChild.call(this, child);
		}, this);

		this.state = "LOADED";

		if(items && items.length > 0){
			this.isExpandable = true;

			// Create _TreeNode widget for each specified tree node, unless one already
			// exists and isn't being used (presumably it's from a DnD move and was recently
			// released
			dojo.forEach(items, function(item){
				var id = model.getIdentity(item),
					existingNodes = tree._itemNodesMap[id],
					node;
				if(existingNodes){
					for(var i=0;i<existingNodes.length;i++){
						if(existingNodes[i] && !existingNodes[i].getParent()){
							node = existingNodes[i];
							node.set('indent', this.indent+1);
							break;
						}
					}
				}
				if(!node){
					node = this.tree._createTreeNode({
							item: item,
							tree: tree,
							isExpandable: model.mayHaveChildren(item),
							label: tree.getLabel(item),
							tooltip: tree.getTooltip(item),
							dir: tree.dir,
							lang: tree.lang,
							indent: this.indent + 1
						});
					if(existingNodes){
						existingNodes.push(node);
					}else{
						tree._itemNodesMap[id] = [node];
					}
				}
				this.addChild(node);

				// If node was previously opened then open it again now (this may trigger
				// more data store accesses, recursively)
				if(this.tree.autoExpand || this.tree._state(item)){
					defs.push(tree._expandNode(node));
				}
			}, this);

			// note that updateLayout() needs to be called on each child after
			// _all_ the children exist
			dojo.forEach(this.getChildren(), function(child, idx){
				child._updateLayout();
			});
		}else{
			this.isExpandable=false;
		}

		if(this._setExpando){
			// change expando to/from dot or + icon, as appropriate
			this._setExpando(false);
		}

		// Set leaf icon or folder icon, as appropriate
		this._updateItemClasses(this.item);

		// On initial tree show, make the selected TreeNode as either the root node of the tree,
		// or the first child, if the root node is hidden
		if(this == tree.rootNode){
			var fc = this.tree.showRoot ? this : this.getChildren()[0];
			if(fc){
				fc.setFocusable(true);
				tree.lastFocused = fc;
			}else{
				// fallback: no nodes in tree so focus on Tree <div> itself
				tree.domNode.setAttribute("tabIndex", "0");
			}
		}

		return new dojo.DeferredList(defs);	// dojo.Deferred
	},

	getTreePath: function(){
		var node = this;
		var path = [];
		while(node && node !== this.tree.rootNode){
				path.unshift(node.item);
				node = node.getParent();
		}
		path.unshift(this.tree.rootNode.item);

		return path;
	},

	getIdentity: function() {
		return this.tree.model.getIdentity(this.item);
	},

	removeChild: function(/* treeNode */ node){
		this.inherited(arguments);

		var children = this.getChildren();
		if(children.length == 0){
			this.isExpandable = false;
			this.collapse();
		}

		dojo.forEach(children, function(child){
				child._updateLayout();
		});
	},

	makeExpandable: function(){
		// summary:
		//		if this node wasn't already showing the expando node,
		//		turn it into one and call _setExpando()

		// TODO: hmm this isn't called from anywhere, maybe should remove it for 2.0

		this.isExpandable = true;
		this._setExpando(false);
	},

	_onLabelFocus: function(evt){
		// summary:
		//		Called when this row is focused (possibly programatically)
		//		Note that we aren't using _onFocus() builtin to dijit
		//		because it's called when focus is moved to a descendant TreeNode.
		// tags:
		//		private
		this.tree._onNodeFocus(this);
	},

	setSelected: function(/*Boolean*/ selected){
		// summary:
		//		A Tree has a (single) currently selected node.
		//		Mark that this node is/isn't that currently selected node.
		// description:
		//		In particular, setting a node as selected involves setting tabIndex
		//		so that when user tabs to the tree, focus will go to that node (only).
		dijit.setWaiState(this.labelNode, "selected", selected);
		dojo.toggleClass(this.rowNode, "dijitTreeRowSelected", selected);
	},

	setFocusable: function(/*Boolean*/ selected){
		// summary:
		//		A Tree has a (single) node that's focusable.
		//		Mark that this node is/isn't that currently focsuable node.
		// description:
		//		In particular, setting a node as selected involves setting tabIndex
		//		so that when user tabs to the tree, focus will go to that node (only).

		this.labelNode.setAttribute("tabIndex", selected ? "0" : "-1");
	},

	_onClick: function(evt){
		// summary:
		//		Handler for onclick event on a node
		// tags:
		//		private
		this.tree._onClick(this, evt);
	},
	_onDblClick: function(evt){
		// summary:
		//		Handler for ondblclick event on a node
		// tags:
		//		private
		this.tree._onDblClick(this, evt);
	},

	_onMouseEnter: function(evt){
		// summary:
		//		Handler for onmouseenter event on a node
		// tags:
		//		private
		this.tree._onNodeMouseEnter(this, evt);
	},

	_onMouseLeave: function(evt){
		// summary:
		//		Handler for onmouseenter event on a node
		// tags:
		//		private
		this.tree._onNodeMouseLeave(this, evt);
	}
});

dojo.declare(
	"dijit.Tree",
	[dijit._Widget, dijit._Templated],
{
	// summary:
	//		This widget displays hierarchical data from a store.

	// store: [deprecated] String||dojo.data.Store
	//		Deprecated.  Use "model" parameter instead.
	//		The store to get data to display in the tree.
	store: null,

	// model: dijit.Tree.model
	//		Interface to read tree data, get notifications of changes to tree data,
	//		and for handling drop operations (i.e drag and drop onto the tree)
	model: null,

	// query: [deprecated] anything
	//		Deprecated.  User should specify query to the model directly instead.
	//		Specifies datastore query to return the root item or top items for the tree.
	query: null,

	// label: [deprecated] String
	//		Deprecated.  Use dijit.tree.ForestStoreModel directly instead.
	//		Used in conjunction with query parameter.
	//		If a query is specified (rather than a root node id), and a label is also specified,
	//		then a fake root node is created and displayed, with this label.
	label: "",

	// showRoot: [const] Boolean
	//		Should the root node be displayed, or hidden?
	showRoot: true,

	// childrenAttr: [deprecated] String[]
	//		Deprecated.   This information should be specified in the model.
	//		One ore more attributes that holds children of a tree node
	childrenAttr: ["children"],

	// paths: String[][] or Item[][]
	//		Full paths from rootNode to selected nodes expressed as array of items or array of ids.
	//		Since setting the paths may be asynchronous (because ofwaiting on dojo.data), set("paths", ...)
	//		returns a Deferred to indicate when the set is complete.
	paths: [],
	
	// path: String[] or Item[]
	//      Backward compatible singular variant of paths.
	path: [],

	// selectedItems: [readonly] Item[]
	//		The currently selected items in this tree.
	//		This property can only be set (via set('selectedItems', ...)) when that item is already
	//		visible in the tree.   (I.e. the tree has already been expanded to show that node.)
	//		Should generally use `paths` attribute to set the selected items instead.
	selectedItems: null,

	// selectedItem: [readonly] Item
	//      Backward compatible singular variant of selectedItems.
	selectedItem: null,

	// openOnClick: Boolean
	//		If true, clicking a folder node's label will open it, rather than calling onClick()
	openOnClick: false,

	// openOnDblClick: Boolean
	//		If true, double-clicking a folder node's label will open it, rather than calling onDblClick()
	openOnDblClick: false,

	templateString: dojo.cache("dijit", "templates/Tree.html", "<div class=\"dijitTree dijitTreeContainer\" role=\"tree\"\n\tdojoAttachEvent=\"onkeypress:_onKeyPress\">\n\t<div class=\"dijitInline dijitTreeIndent\" style=\"position: absolute; top: -9999px\" dojoAttachPoint=\"indentDetector\"></div>\n</div>\n"),

	// persist: Boolean
	//		Enables/disables use of cookies for state saving.
	persist: true,

	// autoExpand: Boolean
	//		Fully expand the tree on load.   Overrides `persist`.
	autoExpand: false,

	// dndController: [protected] String
	//		Class name to use as as the dnd controller.  Specifying this class enables DnD.
	//		Generally you should specify this as "dijit.tree.dndSource".
	//      Default of "dijit.tree._dndSelector" handles selection only (no actual DnD).
	dndController: "dijit.tree._dndSelector",

	// parameters to pull off of the tree and pass on to the dndController as its params
	dndParams: ["onDndDrop","itemCreator","onDndCancel","checkAcceptance", "checkItemAcceptance", "dragThreshold", "betweenThreshold"],

	//declare the above items so they can be pulled from the tree's markup

	// onDndDrop: [protected] Function
	//		Parameter to dndController, see `dijit.tree.dndSource.onDndDrop`.
	//		Generally this doesn't need to be set.
	onDndDrop: null,

	/*=====
	itemCreator: function(nodes, target, source){
		// summary:
		//		Returns objects passed to `Tree.model.newItem()` based on DnD nodes
		//		dropped onto the tree.   Developer must override this method to enable
		// 		dropping from external sources onto this Tree, unless the Tree.model's items
		//		happen to look like {id: 123, name: "Apple" } with no other attributes.
		// description:
		//		For each node in nodes[], which came from source, create a hash of name/value
		//		pairs to be passed to Tree.model.newItem().  Returns array of those hashes.
		// nodes: DomNode[]
		//		The DOMNodes dragged from the source container
		// target: DomNode
		//		The target TreeNode.rowNode
		// source: dojo.dnd.Source
		//		The source container the nodes were dragged from, perhaps another Tree or a plain dojo.dnd.Source
		// returns: Object[]
		//		Array of name/value hashes for each new item to be added to the Tree, like:
		// |	[
		// |		{ id: 123, label: "apple", foo: "bar" },
		// |		{ id: 456, label: "pear", zaz: "bam" }
		// |	]
		// tags:
		//		extension
		return [{}];
	},
	=====*/
	itemCreator: null,

	// onDndCancel: [protected] Function
	//		Parameter to dndController, see `dijit.tree.dndSource.onDndCancel`.
	//		Generally this doesn't need to be set.
	onDndCancel: null,

/*=====
	checkAcceptance: function(source, nodes){
		// summary:
		//		Checks if the Tree itself can accept nodes from this source
		// source: dijit.tree._dndSource
		//		The source which provides items
		// nodes: DOMNode[]
		//		Array of DOM nodes corresponding to nodes being dropped, dijitTreeRow nodes if
		//		source is a dijit.Tree.
		// tags:
		//		extension
		return true;	// Boolean
	},
=====*/
	checkAcceptance: null,

/*=====
	checkItemAcceptance: function(target, source, position){
		// summary:
		//		Stub function to be overridden if one wants to check for the ability to drop at the node/item level
		// description:
		//		In the base case, this is called to check if target can become a child of source.
		//		When betweenThreshold is set, position="before" or "after" means that we
		//		are asking if the source node can be dropped before/after the target node.
		// target: DOMNode
		//		The dijitTreeRoot DOM node inside of the TreeNode that we are dropping on to
		//		Use dijit.getEnclosingWidget(target) to get the TreeNode.
		// source: dijit.tree.dndSource
		//		The (set of) nodes we are dropping
		// position: String
		//		"over", "before", or "after"
		// tags:
		//		extension
		return true;	// Boolean
	},
=====*/
	checkItemAcceptance: null,

	// dragThreshold: Integer
	//		Number of pixels mouse moves before it's considered the start of a drag operation
	dragThreshold: 5,

	// betweenThreshold: Integer
	//		Set to a positive value to allow drag and drop "between" nodes.
	//
	//		If during DnD mouse is over a (target) node but less than betweenThreshold
	//		pixels from the bottom edge, dropping the the dragged node will make it
	//		the next sibling of the target node, rather than the child.
	//
	//		Similarly, if mouse is over a target node but less that betweenThreshold
	//		pixels from the top edge, dropping the dragged node will make it
	//		the target node's previous sibling rather than the target node's child.
	betweenThreshold: 0,

	// _nodePixelIndent: Integer
	//		Number of pixels to indent tree nodes (relative to parent node).
	//		Default is 19 but can be overridden by setting CSS class dijitTreeIndent
	//		and calling resize() or startup() on tree after it's in the DOM.
	_nodePixelIndent: 19,

	_publish: function(/*String*/ topicName, /*Object*/ message){
		// summary:
		//		Publish a message for this widget/topic
		dojo.publish(this.id, [dojo.mixin({tree: this, event: topicName}, message || {})]);
	},

	postMixInProperties: function(){
		this.tree = this;

		if(this.autoExpand){
			// There's little point in saving opened/closed state of nodes for a Tree
			// that initially opens all it's nodes.
			this.persist = false;
		}

		this._itemNodesMap={};

		if(!this.cookieName){
			this.cookieName = this.id + "SaveStateCookie";
		}

		this._loadDeferred = new dojo.Deferred();

		this.inherited(arguments);
	},

	postCreate: function(){
		this._initState();

		// Create glue between store and Tree, if not specified directly by user
		if(!this.model){
			this._store2model();
		}

		// monitor changes to items
		this.connect(this.model, "onChange", "_onItemChange");
		this.connect(this.model, "onChildrenChange", "_onItemChildrenChange");
		this.connect(this.model, "onDelete", "_onItemDelete");

		this._load();

		this.inherited(arguments);

		if(this.dndController){
			if(dojo.isString(this.dndController)){
				this.dndController = dojo.getObject(this.dndController);
			}
			var params={};
			for(var i=0; i<this.dndParams.length;i++){
				if(this[this.dndParams[i]]){
					params[this.dndParams[i]] = this[this.dndParams[i]];
				}
			}
			this.dndController = new this.dndController(this, params);
		}
	},

	_store2model: function(){
		// summary:
		//		User specified a store&query rather than model, so create model from store/query
		this._v10Compat = true;
		dojo.deprecated("Tree: from version 2.0, should specify a model object rather than a store/query");

		var modelParams = {
			id: this.id + "_ForestStoreModel",
			store: this.store,
			query: this.query,
			childrenAttrs: this.childrenAttr
		};

		// Only override the model's mayHaveChildren() method if the user has specified an override
		if(this.params.mayHaveChildren){
			modelParams.mayHaveChildren = dojo.hitch(this, "mayHaveChildren");
		}

		if(this.params.getItemChildren){
			modelParams.getChildren = dojo.hitch(this, function(item, onComplete, onError){
				this.getItemChildren((this._v10Compat && item === this.model.root) ? null : item, onComplete, onError);
			});
		}
		this.model = new dijit.tree.ForestStoreModel(modelParams);

		// For backwards compatibility, the visibility of the root node is controlled by
		// whether or not the user has specified a label
		this.showRoot = Boolean(this.label);
	},

	onLoad: function(){
		// summary:
		//		Called when tree finishes loading and expanding.
		// description:
		//		If persist == true the loading may encompass many levels of fetches
		//		from the data store, each asynchronous.   Waits for all to finish.
		// tags:
		//		callback
	},

	_load: function(){
		// summary:
		//		Initial load of the tree.
		//		Load root node (possibly hidden) and it's children.
		this.model.getRoot(
			dojo.hitch(this, function(item){
				var rn = (this.rootNode = this.tree._createTreeNode({
					item: item,
					tree: this,
					isExpandable: true,
					label: this.label || this.getLabel(item),
					indent: this.showRoot ? 0 : -1
				}));
				if(!this.showRoot){
					rn.rowNode.style.display="none";
					// if root is not visible, move tree role to the invisible
					// root node's containerNode, see #12135
					dijit.setWaiRole(this.domNode, 'presentation');
					
					dijit.setWaiRole(rn.labelNode, 'presentation');
					dijit.setWaiRole(rn.containerNode, 'tree');
				}
				this.domNode.appendChild(rn.domNode);
				var identity = this.model.getIdentity(item);
				if(this._itemNodesMap[identity]){
					this._itemNodesMap[identity].push(rn);
				}else{
					this._itemNodesMap[identity] = [rn];
				}

				rn._updateLayout();		// sets "dijitTreeIsRoot" CSS classname

				// load top level children and then fire onLoad() event
				this._expandNode(rn).addCallback(dojo.hitch(this, function(){
					this._loadDeferred.callback(true);
					this.onLoad();
				}));
			}),
			function(err){
				console.error(this, ": error loading root: ", err);
			}
		);
	},

	getNodesByItem: function(/*dojo.data.Item or id*/ item){
		// summary:
		//		Returns all tree nodes that refer to an item
		// returns:
		//		Array of tree nodes that refer to passed item

		if(!item){ return []; }
		var identity = dojo.isString(item) ? item : this.model.getIdentity(item);
		// return a copy so widget don't get messed up by changes to returned array
		return [].concat(this._itemNodesMap[identity]);
	},

	_setSelectedItemAttr: function(/*dojo.data.Item or id*/ item){
		this.set('selectedItems', [item]);
	},

	_setSelectedItemsAttr: function(/*dojo.data.Items or ids*/ items){
		// summary:
		//		Select tree nodes related to passed items.
		//		WARNING: if model use multi-parented items or desired tree node isn't already loaded
		//		behavior is undefined. Use set('paths', ...) instead.
		var tree = this;
		this._loadDeferred.addCallback( dojo.hitch(this, function(){
			var identities = dojo.map(items, function(item){
				return (!item || dojo.isString(item)) ? item : tree.model.getIdentity(item);
			});
			var nodes = [];
			dojo.forEach(identities, function(id){
				nodes = nodes.concat(tree._itemNodesMap[id] || []);
			});
			this.set('selectedNodes', nodes);
		}));
	},

	_setPathAttr: function(/*Item[] || String[]*/ path){
		// summary:
		//      Singular variant of _setPathsAttr
		if(path.length) {
			return this.set("paths", [path]);
		} else {
			//Empty list is interpreted as "select nothing"
			return this.set("paths", []);
		}
	},
	
	_setPathsAttr: function(/*Item[][] || String[][]*/ paths){
		// summary:
		//		Select the tree nodes identified by passed paths.
		// paths:
		//		Array of arrays of items or item id's
		// returns:
		//		Deferred to indicate when the set is complete
		var tree = this;

		// We may need to wait for some nodes to expand, so setting
		// each path will involve a Deferred. We bring those deferreds
		// together witha DeferredList.
		return new dojo.DeferredList(dojo.map(paths, function(path){
			var d = new dojo.Deferred();
			
			// normalize path to use identity
			path = dojo.map(path, function(item){
				return dojo.isString(item) ? item : tree.model.getIdentity(item);
			});

			if(path.length){
				// Wait for the tree to load, if it hasn't already.
				tree._loadDeferred.addCallback(function(){ selectPath(path, [tree.rootNode], d); });
			}else{
				d.errback("Empty path");
			}
			return d;
		})).addCallback(setNodes);

		function selectPath(path, nodes, def){
			// Traverse path; the next path component should be among "nodes".
			var nextPath = path.shift();
			var nextNode = dojo.filter(nodes, function(node){
				return node.getIdentity() == nextPath;
			})[0];
			if(!!nextNode){
				if(path.length){
					tree._expandNode(nextNode).addCallback(function(){ selectPath(path, nextNode.getChildren(), def); });
				}else{
					//Successfully reached the end of this path
					def.callback(nextNode);
				}
			} else {
				def.errback("Could not expand path at " + nextPath);
			}
		}
		
		function setNodes(newNodes){
			//After all expansion is finished, set the selection to
			//the set of nodes successfully found.
			tree.set("selectedNodes", dojo.map(
				dojo.filter(newNodes,function(x){return x[0];}),
				function(x){return x[1];}));
		}
	},

	_setSelectedNodeAttr: function(node){
		this.set('selectedNodes', [node]);
	},
	_setSelectedNodesAttr: function(nodes){
		this._loadDeferred.addCallback( dojo.hitch(this, function(){
			this.dndController.setSelection(nodes);
		}));
	},


	////////////// Data store related functions //////////////////////
	// These just get passed to the model; they are here for back-compat

	mayHaveChildren: function(/*dojo.data.Item*/ item){
		// summary:
		//		Deprecated.   This should be specified on the model itself.
		//
		//		Overridable function to tell if an item has or may have children.
		//		Controls whether or not +/- expando icon is shown.
		//		(For efficiency reasons we may not want to check if an element actually
		//		has children until user clicks the expando node)
		// tags:
		//		deprecated
	},

	getItemChildren: function(/*dojo.data.Item*/ parentItem, /*function(items)*/ onComplete){
		// summary:
		//		Deprecated.   This should be specified on the model itself.
		//
		// 		Overridable function that return array of child items of given parent item,
		//		or if parentItem==null then return top items in tree
		// tags:
		//		deprecated
	},

	///////////////////////////////////////////////////////
	// Functions for converting an item to a TreeNode
	getLabel: function(/*dojo.data.Item*/ item){
		// summary:
		//		Overridable function to get the label for a tree node (given the item)
		// tags:
		//		extension
		return this.model.getLabel(item);	// String
	},

	getIconClass: function(/*dojo.data.Item*/ item, /*Boolean*/ opened){
		// summary:
		//		Overridable function to return CSS class name to display icon
		// tags:
		//		extension
		return (!item || this.model.mayHaveChildren(item)) ? (opened ? "dijitFolderOpened" : "dijitFolderClosed") : "dijitLeaf"
	},

	getLabelClass: function(/*dojo.data.Item*/ item, /*Boolean*/ opened){
		// summary:
		//		Overridable function to return CSS class name to display label
		// tags:
		//		extension
	},

	getRowClass: function(/*dojo.data.Item*/ item, /*Boolean*/ opened){
		// summary:
		//		Overridable function to return CSS class name to display row
		// tags:
		//		extension
	},

	getIconStyle: function(/*dojo.data.Item*/ item, /*Boolean*/ opened){
		// summary:
		//		Overridable function to return CSS styles to display icon
		// returns:
		//		Object suitable for input to dojo.style() like {backgroundImage: "url(...)"}
		// tags:
		//		extension
	},

	getLabelStyle: function(/*dojo.data.Item*/ item, /*Boolean*/ opened){
		// summary:
		//		Overridable function to return CSS styles to display label
		// returns:
		//		Object suitable for input to dojo.style() like {color: "red", background: "green"}
		// tags:
		//		extension
	},

	getRowStyle: function(/*dojo.data.Item*/ item, /*Boolean*/ opened){
		// summary:
		//		Overridable function to return CSS styles to display row
		// returns:
		//		Object suitable for input to dojo.style() like {background-color: "#bbb"}
		// tags:
		//		extension
	},

	getTooltip: function(/*dojo.data.Item*/ item){
		// summary:
		//		Overridable function to get the tooltip for a tree node (given the item)
		// tags:
		//		extension
		return "";	// String
	},

	/////////// Keyboard and Mouse handlers ////////////////////

	_onKeyPress: function(/*Event*/ e){
		// summary:
		//		Translates keypress events into commands for the controller
		if(e.altKey){ return; }
		var dk = dojo.keys;
		var treeNode = dijit.getEnclosingWidget(e.target);
		if(!treeNode){ return; }

		var key = e.charOrCode;
		if(typeof key == "string" && key != " "){	// handle printables (letter navigation)
			// Check for key navigation.
			if(!e.altKey && !e.ctrlKey && !e.shiftKey && !e.metaKey){
				this._onLetterKeyNav( { node: treeNode, key: key.toLowerCase() } );
				dojo.stopEvent(e);
			}
		}else{	// handle non-printables (arrow keys)
			// clear record of recent printables (being saved for multi-char letter navigation),
			// because "a", down-arrow, "b" shouldn't search for "ab"
			if(this._curSearch){
				clearTimeout(this._curSearch.timer);
				delete this._curSearch;
			}

			var map = this._keyHandlerMap;
			if(!map){
				// setup table mapping keys to events
				map = {};
				map[dk.ENTER]="_onEnterKey";
				//On WebKit based browsers, the combination ctrl-enter
				//does not get passed through. To allow accessible
				//multi-select on those browsers, the space key is
				//also used for selection.
				map[dk.SPACE]= map[" "] = "_onEnterKey";
				map[this.isLeftToRight() ? dk.LEFT_ARROW : dk.RIGHT_ARROW]="_onLeftArrow";
				map[this.isLeftToRight() ? dk.RIGHT_ARROW : dk.LEFT_ARROW]="_onRightArrow";
				map[dk.UP_ARROW]="_onUpArrow";
				map[dk.DOWN_ARROW]="_onDownArrow";
				map[dk.HOME]="_onHomeKey";
				map[dk.END]="_onEndKey";
				this._keyHandlerMap = map;
			}
			if(this._keyHandlerMap[key]){
				this[this._keyHandlerMap[key]]( { node: treeNode, item: treeNode.item, evt: e } );
				dojo.stopEvent(e);
			}
		}
	},

	_onEnterKey: function(/*Object*/ message){
		this._publish("execute", { item: message.item, node: message.node } );
		this.dndController.userSelect(message.node, dojo.isCopyKey( message.evt ), message.evt.shiftKey);
		this.onClick(message.item, message.node, message.evt);
	},

	_onDownArrow: function(/*Object*/ message){
		// summary:
		//		down arrow pressed; get next visible node, set focus there
		var node = this._getNextNode(message.node);
		if(node && node.isTreeNode){
			this.focusNode(node);
		}
	},

	_onUpArrow: function(/*Object*/ message){
		// summary:
		//		Up arrow pressed; move to previous visible node

		var node = message.node;

		// if younger siblings
		var previousSibling = node.getPreviousSibling();
		if(previousSibling){
			node = previousSibling;
			// if the previous node is expanded, dive in deep
			while(node.isExpandable && node.isExpanded && node.hasChildren()){
				// move to the last child
				var children = node.getChildren();
				node = children[children.length-1];
			}
		}else{
			// if this is the first child, return the parent
			// unless the parent is the root of a tree with a hidden root
			var parent = node.getParent();
			if(!(!this.showRoot && parent === this.rootNode)){
				node = parent;
			}
		}

		if(node && node.isTreeNode){
			this.focusNode(node);
		}
	},

	_onRightArrow: function(/*Object*/ message){
		// summary:
		//		Right arrow pressed; go to child node
		var node = message.node;

		// if not expanded, expand, else move to 1st child
		if(node.isExpandable && !node.isExpanded){
			this._expandNode(node);
		}else if(node.hasChildren()){
			node = node.getChildren()[0];
			if(node && node.isTreeNode){
				this.focusNode(node);
			}
		}
	},

	_onLeftArrow: function(/*Object*/ message){
		// summary:
		//		Left arrow pressed.
		//		If not collapsed, collapse, else move to parent.

		var node = message.node;

		if(node.isExpandable && node.isExpanded){
			this._collapseNode(node);
		}else{
			var parent = node.getParent();
			if(parent && parent.isTreeNode && !(!this.showRoot && parent === this.rootNode)){
				this.focusNode(parent);
			}
		}
	},

	_onHomeKey: function(){
		// summary:
		//		Home key pressed; get first visible node, and set focus there
		var node = this._getRootOrFirstNode();
		if(node){
			this.focusNode(node);
		}
	},

	_onEndKey: function(/*Object*/ message){
		// summary:
		//		End key pressed; go to last visible node.

		var node = this.rootNode;
		while(node.isExpanded){
			var c = node.getChildren();
			node = c[c.length - 1];
		}

		if(node && node.isTreeNode){
			this.focusNode(node);
		}
	},

	// multiCharSearchDuration: Number
	//		If multiple characters are typed where each keystroke happens within
	//		multiCharSearchDuration of the previous keystroke,
	//		search for nodes matching all the keystrokes.
	//
	//		For example, typing "ab" will search for entries starting with
	//		"ab" unless the delay between "a" and "b" is greater than multiCharSearchDuration.
	multiCharSearchDuration: 250,

	_onLetterKeyNav: function(message){
		// summary:
		//		Called when user presses a prinatable key; search for node starting with recently typed letters.
		// message: Object
		//		Like { node: TreeNode, key: 'a' } where key is the key the user pressed.

		// Branch depending on whether this key starts a new search, or modifies an existing search
		var cs = this._curSearch;
		if(cs){
			// We are continuing a search.  Ex: user has pressed 'a', and now has pressed
			// 'b', so we want to search for nodes starting w/"ab".
			cs.pattern = cs.pattern + message.key;
			clearTimeout(cs.timer);
		}else{
			// We are starting a new search
			cs = this._curSearch = {
					pattern: message.key,
					startNode: message.node
			};
		}

		// set/reset timer to forget recent keystrokes
		var self = this;
		cs.timer = setTimeout(function(){
			delete self._curSearch;
		}, this.multiCharSearchDuration);

		// Navigate to TreeNode matching keystrokes [entered so far].
		var node = cs.startNode;
		do{
			node = this._getNextNode(node);
			//check for last node, jump to first node if necessary
			if(!node){
				node = this._getRootOrFirstNode();
			}
		}while(node !== cs.startNode && (node.label.toLowerCase().substr(0, cs.pattern.length) != cs.pattern));
		if(node && node.isTreeNode){
			// no need to set focus if back where we started
			if(node !== cs.startNode){
				this.focusNode(node);
			}
		}
	},

	isExpandoNode: function(node, widget){
		// summary:
		//		check whether a dom node is the expandoNode for a particular TreeNode widget
		return dojo.isDescendant(node, widget.expandoNode);
	},
	_onClick: function(/*TreeNode*/ nodeWidget, /*Event*/ e){
		// summary:
		//		Translates click events into commands for the controller to process

		var domElement = e.target,
			isExpandoClick = this.isExpandoNode(domElement, nodeWidget);

		if( (this.openOnClick && nodeWidget.isExpandable) || isExpandoClick ){
			// expando node was clicked, or label of a folder node was clicked; open it
			if(nodeWidget.isExpandable){
				this._onExpandoClick({node:nodeWidget});
			}
		}else{
			this._publish("execute", { item: nodeWidget.item, node: nodeWidget, evt: e } );
			this.onClick(nodeWidget.item, nodeWidget, e);
			this.focusNode(nodeWidget);
		}
		dojo.stopEvent(e);
	},
	_onDblClick: function(/*TreeNode*/ nodeWidget, /*Event*/ e){
		// summary:
		//		Translates double-click events into commands for the controller to process

		var domElement = e.target,
			isExpandoClick = (domElement == nodeWidget.expandoNode || domElement == nodeWidget.expandoNodeText);

		if( (this.openOnDblClick && nodeWidget.isExpandable) ||isExpandoClick ){
			// expando node was clicked, or label of a folder node was clicked; open it
			if(nodeWidget.isExpandable){
				this._onExpandoClick({node:nodeWidget});
			}
		}else{
			this._publish("execute", { item: nodeWidget.item, node: nodeWidget, evt: e } );
			this.onDblClick(nodeWidget.item, nodeWidget, e);
			this.focusNode(nodeWidget);
		}
		dojo.stopEvent(e);
	},

	_onExpandoClick: function(/*Object*/ message){
		// summary:
		//		User clicked the +/- icon; expand or collapse my children.
		var node = message.node;

		// If we are collapsing, we might be hiding the currently focused node.
		// Also, clicking the expando node might have erased focus from the current node.
		// For simplicity's sake just focus on the node with the expando.
		this.focusNode(node);

		if(node.isExpanded){
			this._collapseNode(node);
		}else{
			this._expandNode(node);
		}
	},

	onClick: function(/* dojo.data */ item, /*TreeNode*/ node, /*Event*/ evt){
		// summary:
		//		Callback when a tree node is clicked
		// tags:
		//		callback
	},
	onDblClick: function(/* dojo.data */ item, /*TreeNode*/ node, /*Event*/ evt){
		// summary:
		//		Callback when a tree node is double-clicked
		// tags:
		//		callback
	},
	onOpen: function(/* dojo.data */ item, /*TreeNode*/ node){
		// summary:
		//		Callback when a node is opened
		// tags:
		//		callback
	},
	onClose: function(/* dojo.data */ item, /*TreeNode*/ node){
		// summary:
		//		Callback when a node is closed
		// tags:
		//		callback
	},

	_getNextNode: function(node){
		// summary:
		//		Get next visible node

		if(node.isExpandable && node.isExpanded && node.hasChildren()){
			// if this is an expanded node, get the first child
			return node.getChildren()[0];		// _TreeNode
		}else{
			// find a parent node with a sibling
			while(node && node.isTreeNode){
				var returnNode = node.getNextSibling();
				if(returnNode){
					return returnNode;		// _TreeNode
				}
				node = node.getParent();
			}
			return null;
		}
	},

	_getRootOrFirstNode: function(){
		// summary:
		//		Get first visible node
		return this.showRoot ? this.rootNode : this.rootNode.getChildren()[0];
	},

	_collapseNode: function(/*_TreeNode*/ node){
		// summary:
		//		Called when the user has requested to collapse the node

		if(node._expandNodeDeferred){
			delete node._expandNodeDeferred;
		}

		if(node.isExpandable){
			if(node.state == "LOADING"){
				// ignore clicks while we are in the process of loading data
				return;
			}

			node.collapse();
			this.onClose(node.item, node);

			if(node.item){
				this._state(node.item,false);
				this._saveState();
			}
		}
	},

	_expandNode: function(/*_TreeNode*/ node, /*Boolean?*/ recursive){
		// summary:
		//		Called when the user has requested to expand the node
		// recursive:
		//		Internal flag used when _expandNode() calls itself, don't set.
		// returns:
		//		Deferred that fires when the node is loaded and opened and (if persist=true) all it's descendants
		//		that were previously opened too

		if(node._expandNodeDeferred && !recursive){
			// there's already an expand in progress (or completed), so just return
			return node._expandNodeDeferred;	// dojo.Deferred
		}

		var model = this.model,
			item = node.item,
			_this = this;

		switch(node.state){
			case "UNCHECKED":
				// need to load all the children, and then expand
				node.markProcessing();

				// Setup deferred to signal when the load and expand are finished.
				// Save that deferred in this._expandDeferred as a flag that operation is in progress.
				var def = (node._expandNodeDeferred = new dojo.Deferred());

				// Get the children
				model.getChildren(
					item,
					function(items){
						node.unmarkProcessing();

						// Display the children and also start expanding any children that were previously expanded
						// (if this.persist == true).   The returned Deferred will fire when those expansions finish.
						var scid = node.setChildItems(items);

						// Call _expandNode() again but this time it will just to do the animation (default branch).
						// The returned Deferred will fire when the animation completes.
						// TODO: seems like I can avoid recursion and just use a deferred to sequence the events?
						var ed = _this._expandNode(node, true);

						// After the above two tasks (setChildItems() and recursive _expandNode()) finish,
						// signal that I am done.
						scid.addCallback(function(){
							ed.addCallback(function(){
								def.callback();
							})
						});
					},
					function(err){
						console.error(_this, ": error loading root children: ", err);
					}
				);
				break;

			default:	// "LOADED"
				// data is already loaded; just expand node
				def = (node._expandNodeDeferred = node.expand());

				this.onOpen(node.item, node);

				if(item){
					this._state(item, true);
					this._saveState();
				}
		}

		return def;	// dojo.Deferred
	},

	////////////////// Miscellaneous functions ////////////////

	focusNode: function(/* _tree.Node */ node){
		// summary:
		//		Focus on the specified node (which must be visible)
		// tags:
		//		protected

		// set focus so that the label will be voiced using screen readers
		dijit.focus(node.labelNode);
	},

	_onNodeFocus: function(/*dijit._Widget*/ node){
		// summary:
		//		Called when a TreeNode gets focus, either by user clicking
		//		it, or programatically by arrow key handling code.
		// description:
		//		It marks that the current node is the selected one, and the previously
		//		selected node no longer is.

		if(node && node != this.lastFocused){
			if(this.lastFocused && !this.lastFocused._destroyed){
				// mark that the previously focsable node is no longer focusable
				this.lastFocused.setFocusable(false);
			}

			// mark that the new node is the currently selected one
			node.setFocusable(true);
			this.lastFocused = node;
		}
	},

	_onNodeMouseEnter: function(/*dijit._Widget*/ node){
		// summary:
		//		Called when mouse is over a node (onmouseenter event),
		//		this is monitored by the DND code
	},

	_onNodeMouseLeave: function(/*dijit._Widget*/ node){
		// summary:
		//		Called when mouse leaves a node (onmouseleave event),
		//		this is monitored by the DND code
	},

	//////////////// Events from the model //////////////////////////

	_onItemChange: function(/*Item*/ item){
		// summary:
		//		Processes notification of a change to an item's scalar values like label
		var model = this.model,
			identity = model.getIdentity(item),
			nodes = this._itemNodesMap[identity];

		if(nodes){
			var label = this.getLabel(item),
				tooltip = this.getTooltip(item);
			dojo.forEach(nodes, function(node){
				node.set({
					item: item,		// theoretically could be new JS Object representing same item
					label: label,
					tooltip: tooltip
				});
				node._updateItemClasses(item);
			});
		}
	},

	_onItemChildrenChange: function(/*dojo.data.Item*/ parent, /*dojo.data.Item[]*/ newChildrenList){
		// summary:
		//		Processes notification of a change to an item's children
		var model = this.model,
			identity = model.getIdentity(parent),
			parentNodes = this._itemNodesMap[identity];

		if(parentNodes){
			dojo.forEach(parentNodes,function(parentNode){
				parentNode.setChildItems(newChildrenList);
			});
		}
	},

	_onItemDelete: function(/*Item*/ item){
		// summary:
		//		Processes notification of a deletion of an item
		var model = this.model,
			identity = model.getIdentity(item),
			nodes = this._itemNodesMap[identity];

		if(nodes){
			dojo.forEach(nodes,function(node){
				// Remove node from set of selected nodes (if it's selected)
				this.dndController.removeTreeNode(node);

				var parent = node.getParent();
				if(parent){
					// if node has not already been orphaned from a _onSetItem(parent, "children", ..) call...
					parent.removeChild(node);
				}
				node.destroyRecursive();
			}, this);
			delete this._itemNodesMap[identity];
		}
	},

	/////////////// Miscellaneous funcs

	_initState: function(){
		// summary:
		//		Load in which nodes should be opened automatically
		if(this.persist){
			var cookie = dojo.cookie(this.cookieName);
			this._openedItemIds = {};
			if(cookie){
				dojo.forEach(cookie.split(','), function(item){
					this._openedItemIds[item] = true;
				}, this);
			}
		}
	},
	_state: function(item,expanded){
		// summary:
		//		Query or set expanded state for an item,
		if(!this.persist){
			return false;
		}
		var id=this.model.getIdentity(item);
		if(arguments.length === 1){
			return this._openedItemIds[id];
		}
		if(expanded){
			this._openedItemIds[id] = true;
		}else{
			delete this._openedItemIds[id];
		}
	},
	_saveState: function(){
		// summary:
		//		Create and save a cookie with the currently expanded nodes identifiers
		if(!this.persist){
			return;
		}
		var ary = [];
		for(var id in this._openedItemIds){
			ary.push(id);
		}
		dojo.cookie(this.cookieName, ary.join(","), {expires:365});
	},

	destroy: function(){
		if(this._curSearch){
			clearTimeout(this._curSearch.timer);
			delete this._curSearch;
		}
		if(this.rootNode){
			this.rootNode.destroyRecursive();
		}
		if(this.dndController && !dojo.isString(this.dndController)){
			this.dndController.destroy();
		}
		this.rootNode = null;
		this.inherited(arguments);
	},

	destroyRecursive: function(){
		// A tree is treated as a leaf, not as a node with children (like a grid),
		// but defining destroyRecursive for back-compat.
		this.destroy();
	},

	resize: function(changeSize){
		if(changeSize){
			dojo.marginBox(this.domNode, changeSize);
		}

		// The only JS sizing involved w/tree is the indentation, which is specified
		// in CSS and read in through this dummy indentDetector node (tree must be
		// visible and attached to the DOM to read this)
		this._nodePixelIndent = dojo._getMarginSize(this.tree.indentDetector).w;

		if(this.tree.rootNode){
			// If tree has already loaded, then reset indent for all the nodes
			this.tree.rootNode.set('indent', this.showRoot ? 0 : -1);
		}
	},

	_createTreeNode: function(/*Object*/ args){
		// summary:
		//		creates a TreeNode
		// description:
		//		Developers can override this method to define their own TreeNode class;
		//		However it will probably be removed in a future release in favor of a way
		//		of just specifying a widget for the label, rather than one that contains
		//		the children too.
		return new dijit._TreeNode(args);
	}
});

// For back-compat.  TODO: remove in 2.0

}

if(!dojo._hasResource["dijit.layout.AccordionPane"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.layout.AccordionPane"] = true;
dojo.provide("dijit.layout.AccordionPane");



dojo.declare("dijit.layout.AccordionPane", dijit.layout.ContentPane, {
	// summary:
	//		Deprecated widget.   Use `dijit.layout.ContentPane` instead.
	// tags:
	//		deprecated

	constructor: function(){
		dojo.deprecated("dijit.layout.AccordionPane deprecated, use ContentPane instead", "", "2.0");
	},

	onSelected: function(){
		// summary:
		//		called when this pane is selected
	}
});

}

if(!dojo._hasResource["dijit.layout.AccordionContainer"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.layout.AccordionContainer"] = true;
dojo.provide("dijit.layout.AccordionContainer");








//dojo.require("dijit.layout.AccordionPane ");	// for back compat, remove for 2.0

// Design notes:
//
// An AccordionContainer is a StackContainer, but each child (typically ContentPane)
// is wrapped in a _AccordionInnerContainer.   This is hidden from the caller.
//
// The resulting markup will look like:
//
//	<div class=dijitAccordionContainer>
//		<div class=dijitAccordionInnerContainer>	(one pane)
//				<div class=dijitAccordionTitle>		(title bar) ... </div>
//				<div class=dijtAccordionChildWrapper>   (content pane) </div>
//		</div>
//	</div>
//
// Normally the dijtAccordionChildWrapper is hidden for all but one child (the shown
// child), so the space for the content pane is all the title bars + the one dijtAccordionChildWrapper,
// which on claro has a 1px border plus a 2px bottom margin.
//
// During animation there are two dijtAccordionChildWrapper's shown, so we need
// to compensate for that.

dojo.declare(
	"dijit.layout.AccordionContainer",
	dijit.layout.StackContainer,
	{
		// summary:
		//		Holds a set of panes where every pane's title is visible, but only one pane's content is visible at a time,
		//		and switching between panes is visualized by sliding the other panes up/down.
		// example:
		//	| 	<div dojoType="dijit.layout.AccordionContainer">
		//	|		<div dojoType="dijit.layout.ContentPane" title="pane 1">
		//	|		</div>
		//	|		<div dojoType="dijit.layout.ContentPane" title="pane 2">
		//	|			<p>This is some text</p>
		//	|		</div>
		//	|	</div>

		// duration: Integer
		//		Amount of time (in ms) it takes to slide panes
		duration: dijit.defaultDuration,

		// buttonWidget: [const] String
		//		The name of the widget used to display the title of each pane
		buttonWidget: "dijit.layout._AccordionButton",

/*=====
		// _verticalSpace: Number
		//		Pixels of space available for the open pane
		//		(my content box size minus the cumulative size of all the title bars)
		_verticalSpace: 0,
=====*/
		baseClass: "dijitAccordionContainer",

		buildRendering: function(){
			this.inherited(arguments);
			this.domNode.style.overflow = "hidden";		// TODO: put this in dijit.css
			dijit.setWaiRole(this.domNode, "tablist");	// TODO: put this in template
		},

		startup: function(){
			if(this._started){ return; }
			this.inherited(arguments);
			if(this.selectedChildWidget){
				var style = this.selectedChildWidget.containerNode.style;
				style.display = "";
				style.overflow = "auto";
				this.selectedChildWidget._wrapperWidget.set("selected", true);
			}
		},

		layout: function(){
			// Implement _LayoutWidget.layout() virtual method.
			// Set the height of the open pane based on what room remains.

			var openPane = this.selectedChildWidget;
			
			if(!openPane){ return;}

			// space taken up by title, plus wrapper div (with border/margin) for open pane
			var wrapperDomNode = openPane._wrapperWidget.domNode,
				wrapperDomNodeMargin = dojo._getMarginExtents(wrapperDomNode),
				wrapperDomNodePadBorder = dojo._getPadBorderExtents(wrapperDomNode),
				wrapperContainerNode = openPane._wrapperWidget.containerNode,
				wrapperContainerNodeMargin = dojo._getMarginExtents(wrapperContainerNode),
				wrapperContainerNodePadBorder = dojo._getPadBorderExtents(wrapperContainerNode),
				mySize = this._contentBox;

			// get cumulative height of all the unselected title bars
			var totalCollapsedHeight = 0;
			dojo.forEach(this.getChildren(), function(child){
	            if(child != openPane){
					totalCollapsedHeight += dojo._getMarginSize(child._wrapperWidget.domNode).h;
				}
			});
			this._verticalSpace = mySize.h - totalCollapsedHeight - wrapperDomNodeMargin.h
			 	- wrapperDomNodePadBorder.h - wrapperContainerNodeMargin.h - wrapperContainerNodePadBorder.h
				- openPane._buttonWidget.getTitleHeight();

			// Memo size to make displayed child
			this._containerContentBox = {
				h: this._verticalSpace,
				w: this._contentBox.w - wrapperDomNodeMargin.w - wrapperDomNodePadBorder.w
					- wrapperContainerNodeMargin.w - wrapperContainerNodePadBorder.w
			};

			if(openPane){
				openPane.resize(this._containerContentBox);
			}
		},

		_setupChild: function(child){
			// Overrides _LayoutWidget._setupChild().
			// Put wrapper widget around the child widget, showing title

			child._wrapperWidget = new dijit.layout._AccordionInnerContainer({
				contentWidget: child,
				buttonWidget: this.buttonWidget,
				id: child.id + "_wrapper",
				dir: child.dir,
				lang: child.lang,
				parent: this
			});

			this.inherited(arguments);
		},

		addChild: function(/*dijit._Widget*/ child, /*Integer?*/ insertIndex){
			if(this._started){
				// Adding a child to a started Accordion is complicated because children have
				// wrapper widgets.  Default code path (calling this.inherited()) would add
				// the new child inside another child's wrapper.

				// First add in child as a direct child of this AccordionContainer
				dojo.place(child.domNode, this.containerNode, insertIndex);

				if(!child._started){
					child.startup();
				}
				
				// Then stick the wrapper widget around the child widget
				this._setupChild(child);

				// Code below copied from StackContainer
				dojo.publish(this.id+"-addChild", [child, insertIndex]);
				this.layout();
				if(!this.selectedChildWidget){
					this.selectChild(child);
				}
			}else{
				// We haven't been started yet so just add in the child widget directly,
				// and the wrapper will be created on startup()
				this.inherited(arguments);
			}
		},

		removeChild: function(child){
			// Overrides _LayoutWidget.removeChild().

			// Destroy wrapper widget first, before StackContainer.getChildren() call.
			// Replace wrapper widget with true child widget (ContentPane etc.).
			// This step only happens if the AccordionContainer has been started; otherwise there's no wrapper.
			if(child._wrapperWidget){
				dojo.place(child.domNode, child._wrapperWidget.domNode, "after");
				child._wrapperWidget.destroy();
				delete child._wrapperWidget;
			}

			dojo.removeClass(child.domNode, "dijitHidden");

			this.inherited(arguments);
		},

		getChildren: function(){
			// Overrides _Container.getChildren() to return content panes rather than internal AccordionInnerContainer panes
			return dojo.map(this.inherited(arguments), function(child){
				return child.declaredClass == "dijit.layout._AccordionInnerContainer" ? child.contentWidget : child;
			}, this);
		},

		destroy: function(){
			if(this._animation){
				this._animation.stop();
			}
			dojo.forEach(this.getChildren(), function(child){
				// If AccordionContainer has been started, then each child has a wrapper widget which
				// also needs to be destroyed.
				if(child._wrapperWidget){
					child._wrapperWidget.destroy();
				}else{
					child.destroyRecursive();
				}
			});
			this.inherited(arguments);
		},

		_showChild: function(child){
			// Override StackContainer._showChild() to set visibility of _wrapperWidget.containerNode
			child._wrapperWidget.containerNode.style.display="block";
			return this.inherited(arguments);
		},

		_hideChild: function(child){
			// Override StackContainer._showChild() to set visibility of _wrapperWidget.containerNode
			child._wrapperWidget.containerNode.style.display="none";
			this.inherited(arguments);
		},

		_transition: function(/*dijit._Widget?*/ newWidget, /*dijit._Widget?*/ oldWidget, /*Boolean*/ animate){
			// Overrides StackContainer._transition() to provide sliding of title bars etc.

			if(dojo.isIE < 8){
				// workaround animation bugs by not animating; not worth supporting animation for IE6 & 7
				animate = false;
			}

			if(this._animation){
				// there's an in-progress animation.  speedily end it so we can do the newly requested one
				this._animation.stop(true);
				delete this._animation;
			}

			var self = this;

			if(newWidget){
				newWidget._wrapperWidget.set("selected", true);

				var d = this._showChild(newWidget);	// prepare widget to be slid in

				// Size the new widget, in case this is the first time it's being shown,
				// or I have been resized since the last time it was shown.
				// Note that page must be visible for resizing to work.
				if(this.doLayout && newWidget.resize){
					newWidget.resize(this._containerContentBox);
				}
			}

			if(oldWidget){
				oldWidget._wrapperWidget.set("selected", false);
				if(!animate){
					this._hideChild(oldWidget);
				}
			}

			if(animate){
				var newContents = newWidget._wrapperWidget.containerNode,
					oldContents = oldWidget._wrapperWidget.containerNode;

				// During the animation we will be showing two dijitAccordionChildWrapper nodes at once,
				// which on claro takes up 4px extra space (compared to stable AccordionContainer).
				// Have to compensate for that by immediately shrinking the pane being closed.
				var wrapperContainerNode = newWidget._wrapperWidget.containerNode,
					wrapperContainerNodeMargin = dojo._getMarginExtents(wrapperContainerNode),
					wrapperContainerNodePadBorder = dojo._getPadBorderExtents(wrapperContainerNode),
					animationHeightOverhead = wrapperContainerNodeMargin.h + wrapperContainerNodePadBorder.h;

				oldContents.style.height = (self._verticalSpace - animationHeightOverhead) + "px";

				this._animation = new dojo.Animation({
					node: newContents,
					duration: this.duration,
					curve: [1, this._verticalSpace - animationHeightOverhead - 1],
					onAnimate: function(value){
						value = Math.floor(value);	// avoid fractional values
						newContents.style.height = value + "px";
						oldContents.style.height = (self._verticalSpace - animationHeightOverhead - value) + "px";
					},
					onEnd: function(){
						delete self._animation;
						newContents.style.height = "auto";
						oldWidget._wrapperWidget.containerNode.style.display = "none";
						oldContents.style.height = "auto";
						self._hideChild(oldWidget);
					}
				});
				this._animation.onStop = this._animation.onEnd;
				this._animation.play();
			}

			return d;	// If child has an href, promise that fires when the widget has finished loading
		},

		// note: we are treating the container as controller here
		_onKeyPress: function(/*Event*/ e, /*dijit._Widget*/ fromTitle){
			// summary:
			//		Handle keypress events
			// description:
			//		This is called from a handler on AccordionContainer.domNode
			//		(setup in StackContainer), and is also called directly from
			//		the click handler for accordion labels
			if(this.disabled || e.altKey || !(fromTitle || e.ctrlKey)){
				return;
			}
			var k = dojo.keys,
				c = e.charOrCode;
			if((fromTitle && (c == k.LEFT_ARROW || c == k.UP_ARROW)) ||
					(e.ctrlKey && c == k.PAGE_UP)){
				this._adjacent(false)._buttonWidget._onTitleClick();
				dojo.stopEvent(e);
			}else if((fromTitle && (c == k.RIGHT_ARROW || c == k.DOWN_ARROW)) ||
					(e.ctrlKey && (c == k.PAGE_DOWN || c == k.TAB))){
				this._adjacent(true)._buttonWidget._onTitleClick();
				dojo.stopEvent(e);
			}
		}
	}
);

dojo.declare("dijit.layout._AccordionInnerContainer",
	[dijit._Widget, dijit._CssStateMixin], {
		// summary:
		//		Internal widget placed as direct child of AccordionContainer.containerNode.
		//		When other widgets are added as children to an AccordionContainer they are wrapped in
		//		this widget.
		
/*=====
		// buttonWidget: String
		//		Name of class to use to instantiate title
		//		(Wish we didn't have a separate widget for just the title but maintaining it
		//		for backwards compatibility, is it worth it?)
		 buttonWidget: null,
=====*/

/*=====
		// contentWidget: dijit._Widget
		//		Pointer to the real child widget
	 	contentWidget: null,
=====*/

		baseClass: "dijitAccordionInnerContainer",

		// tell nested layout widget that we will take care of sizing
		isContainer: true,
		isLayoutContainer: true,

		buildRendering: function(){
			// Builds a template like:
			//	<div class=dijitAccordionInnerContainer>
			//		Button
			//		<div class=dijitAccordionChildWrapper>
			//			ContentPane
			//		</div>
			//	</div>

			// Create wrapper div, placed where the child is now
			this.domNode = dojo.place("<div class='" + this.baseClass + "'>", this.contentWidget.domNode, "after");
			
			// wrapper div's first child is the button widget (ie, the title bar)
			var child = this.contentWidget,
				cls = dojo.getObject(this.buttonWidget);
			this.button = child._buttonWidget = (new cls({
				contentWidget: child,
				label: child.title,
				title: child.tooltip,
				dir: child.dir,
				lang: child.lang,
				iconClass: child.iconClass,
				id: child.id + "_button",
				parent: this.parent
			})).placeAt(this.domNode);
			
			// and then the actual content widget (changing it from prior-sibling to last-child),
			// wrapped by a <div class=dijitAccordionChildWrapper>
			this.containerNode = dojo.place("<div class='dijitAccordionChildWrapper' style='display:none'>", this.domNode);
			dojo.place(this.contentWidget.domNode, this.containerNode);
		},

		postCreate: function(){
			this.inherited(arguments);

			// Map changes in content widget's title etc. to changes in the button
			var button = this.button;
			this._contentWidgetWatches = [
				this.contentWidget.watch('title', dojo.hitch(this, function(name, oldValue, newValue){
					button.set("label", newValue);
				})),
				this.contentWidget.watch('tooltip', dojo.hitch(this, function(name, oldValue, newValue){
					button.set("title", newValue);
				})),
				this.contentWidget.watch('iconClass', dojo.hitch(this, function(name, oldValue, newValue){
					button.set("iconClass", newValue);
				}))
			];
		},

		_setSelectedAttr: function(/*Boolean*/ isSelected){
			this._set("selected", isSelected);
			this.button.set("selected", isSelected);
			if(isSelected){
				var cw = this.contentWidget;
				if(cw.onSelected){ cw.onSelected(); }
			}
		},

		startup: function(){
			// Called by _Container.addChild()
			this.contentWidget.startup();
		},

		destroy: function(){
			this.button.destroyRecursive();

			dojo.forEach(this._contentWidgetWatches || [], function(w){ w.unwatch(); });

			delete this.contentWidget._buttonWidget;
			delete this.contentWidget._wrapperWidget;

			this.inherited(arguments);
		},
		
		destroyDescendants: function(){
			// since getChildren isn't working for me, have to code this manually
			this.contentWidget.destroyRecursive();
		}
});

dojo.declare("dijit.layout._AccordionButton",
	[dijit._Widget, dijit._Templated, dijit._CssStateMixin],
	{
	// summary:
	//		The title bar to click to open up an accordion pane.
	//		Internal widget used by AccordionContainer.
	// tags:
	//		private

	templateString: dojo.cache("dijit.layout", "templates/AccordionButton.html", "<div dojoAttachEvent='onclick:_onTitleClick' class='dijitAccordionTitle'>\n\t<div dojoAttachPoint='titleNode,focusNode' dojoAttachEvent='onkeypress:_onTitleKeyPress'\n\t\t\tclass='dijitAccordionTitleFocus' role=\"tab\" aria-expanded=\"false\"\n\t\t><span class='dijitInline dijitAccordionArrow' role=\"presentation\"></span\n\t\t><span class='arrowTextUp' role=\"presentation\">+</span\n\t\t><span class='arrowTextDown' role=\"presentation\">-</span\n\t\t><img src=\"${_blankGif}\" alt=\"\" class=\"dijitIcon\" dojoAttachPoint='iconNode' style=\"vertical-align: middle\" role=\"presentation\"/>\n\t\t<span role=\"presentation\" dojoAttachPoint='titleTextNode' class='dijitAccordionText'></span>\n\t</div>\n</div>\n"),
	attributeMap: dojo.mixin(dojo.clone(dijit.layout.ContentPane.prototype.attributeMap), {
		label: {node: "titleTextNode", type: "innerHTML" },
		title: {node: "titleTextNode", type: "attribute", attribute: "title"},
		iconClass: { node: "iconNode", type: "class" }
	}),

	baseClass: "dijitAccordionTitle",

	getParent: function(){
		// summary:
		//		Returns the AccordionContainer parent.
		// tags:
		//		private
		return this.parent;
	},

	buildRendering: function(){
		this.inherited(arguments);
		var titleTextNodeId = this.id.replace(' ','_');
		dojo.attr(this.titleTextNode, "id", titleTextNodeId+"_title");
		dijit.setWaiState(this.focusNode, "labelledby", dojo.attr(this.titleTextNode, "id"));
		dojo.setSelectable(this.domNode, false);
	},

	getTitleHeight: function(){
		// summary:
		//		Returns the height of the title dom node.
		return dojo._getMarginSize(this.domNode).h;	// Integer
	},

	// TODO: maybe the parent should set these methods directly rather than forcing the code
	// into the button widget?
	_onTitleClick: function(){
		// summary:
		//		Callback when someone clicks my title.
		var parent = this.getParent();
			parent.selectChild(this.contentWidget, true);
			dijit.focus(this.focusNode);
	},

	_onTitleKeyPress: function(/*Event*/ evt){
		return this.getParent()._onKeyPress(evt, this.contentWidget);
	},

	_setSelectedAttr: function(/*Boolean*/ isSelected){
		this._set("selected", isSelected);
		dijit.setWaiState(this.focusNode, "expanded", isSelected);
		dijit.setWaiState(this.focusNode, "selected", isSelected);
		this.focusNode.setAttribute("tabIndex", isSelected ? "0" : "-1");
	}
});

}

if(!dojo._hasResource["dojox.rpc.Service"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.rpc.Service"] = true;
dojo.provide("dojox.rpc.Service");



dojo.declare("dojox.rpc.Service", null, {
	constructor: function(smd, options){
		// summary:
		//		Take a string as a url to retrieve an smd or an object that is an smd or partial smd to use
		//		as a definition for the service
		//
		//	smd: object
		//		Takes a number of properties as kwArgs for defining the service.  It also
		//		accepts a string.  When passed a string, it is treated as a url from
		//		which it should synchronously retrieve an smd file.  Otherwise it is a kwArgs
		//		object.  It accepts serviceUrl, to manually define a url for the rpc service
		//		allowing the rpc system to be used without an smd definition. strictArgChecks
		//		forces the system to verify that the # of arguments provided in a call
		//		matches those defined in the smd.  smdString allows a developer to pass
		//		a jsonString directly, which will be converted into an object or alternatively
		//		smdObject is accepts an smdObject directly.
		//
		//	description:
		//		dojox.rpc.Service must be loaded prior to any plugin services like dojox.rpc.Rest
		// 		dojox.rpc.JsonRpc in order for them to register themselves, otherwise you get
		// 		a "No match found" error.
		var url;
		var self = this;
		function processSmd(smd){
			smd._baseUrl = new dojo._Url((dojo.isBrowser ? location.href : dojo.config.baseUrl) ,url || '.') + '';
			self._smd = smd;

			//generate the methods
 			for(var serviceName in self._smd.services){
				var pieces = serviceName.split("."); // handle "namespaced" services by breaking apart by .
				var current = self;
				for(var i=0; i< pieces.length-1; i++){
					// create or reuse each object as we go down the chain
					current = current[pieces[i]] || (current[pieces[i]] = {});
				}
				current[pieces[pieces.length-1]]=	self._generateService(serviceName, self._smd.services[serviceName]);
 			}
		}
		if(smd){
			//ifthe arg is a string, we assume it is a url to retrieve an smd definition from
			if( (dojo.isString(smd)) || (smd instanceof dojo._Url)){
				if(smd instanceof dojo._Url){
					url = smd + "";
				}else{
					url = smd;
				}

				var text = dojo._getText(url);
				if(!text){
					throw new Error("Unable to load SMD from " + smd);
				}else{
					processSmd(dojo.fromJson(text));
				}
			}else{
				processSmd(smd);
			}
		}

		this._options = (options ? options : {});
		this._requestId = 0;
	},

	_generateService: function(serviceName, method){
		if(this[method]){
			throw new Error("WARNING: "+ serviceName+ " already exists for service. Unable to generate function");
		}
		method.name = serviceName;
		var func = dojo.hitch(this, "_executeMethod",method);
		var transport = dojox.rpc.transportRegistry.match(method.transport || this._smd.transport);
		if(transport.getExecutor){
			func = transport.getExecutor(func,method,this);
		}
		var schema = method.returns || (method._schema = {}); // define the schema
		var servicePath = '/' + serviceName +'/';
		// schemas are minimally used to track the id prefixes for the different services
		schema._service = func;
		func.servicePath = servicePath;
		func._schema = schema;
		func.id = dojox.rpc.Service._nextId++;
		return func;
	},
	_getRequest: function(method,args){
		var smd = this._smd;
		var envDef = dojox.rpc.envelopeRegistry.match(method.envelope || smd.envelope || "NONE");
		var parameters = (method.parameters || []).concat(smd.parameters || []);
		if(envDef.namedParams){
			// the serializer is expecting named params
			if((args.length==1) && dojo.isObject(args[0])){
				// looks like we have what we want
				args = args[0];
			}else{
				// they provided ordered, must convert
				var data={};
				for(var i=0;i<method.parameters.length;i++){
					if(typeof args[i] != "undefined" || !method.parameters[i].optional){
						data[method.parameters[i].name]=args[i];
					}
				}
				args = data;
			}
			if(method.strictParameters||smd.strictParameters){
				//remove any properties that were not defined
				for(i in args){
					var found=false;
					for(var j=0; j<parameters.length;j++){
						if(parameters[i].name==i){ found=true; }
					}
					if(!found){
						delete args[i];
					}
				}
				
			}
			// setting default values
			for(i=0; i< parameters.length; i++){
				var param = parameters[i];
				if(!param.optional && param.name && !args[param.name]){
					if(param["default"]){
						args[param.name] = param["default"];
					}else if(!(param.name in args)){
						throw new Error("Required parameter " + param.name + " was omitted");
					}
				}
			}
		}else if(parameters && parameters[0] && parameters[0].name && (args.length==1) && dojo.isObject(args[0])){
			// looks like named params, we will convert
			if(envDef.namedParams === false){
				// the serializer is expecting ordered params, must be ordered
				args = dojox.rpc.toOrdered(parameters, args);
			}else{
				// named is ok
				args = args[0];
			}
		}
		
		if(dojo.isObject(this._options)){
			args = dojo.mixin(args, this._options);
		}
		
		var schema = method._schema || method.returns; // serialize with the right schema for the context;
		var request = envDef.serialize.apply(this, [smd, method, args]);
		request._envDef = envDef;// save this for executeMethod
		var contentType = (method.contentType || smd.contentType || request.contentType);

		// this allows to mandate synchronous behavior from elsewhere when necessary, this may need to be changed to be one-shot in FF3 new sync handling model
		return dojo.mixin(request, {
			sync: dojox.rpc._sync,
			contentType: contentType,
			headers: method.headers || smd.headers || request.headers || {},
			target: request.target || dojox.rpc.getTarget(smd, method),
			transport: method.transport || smd.transport || request.transport,
			envelope: method.envelope || smd.envelope || request.envelope,
			timeout: method.timeout || smd.timeout,
			callbackParamName: method.callbackParamName || smd.callbackParamName,
			rpcObjectParamName: method.rpcObjectParamName || smd.rpcObjectParamName,
			schema: schema,
			handleAs: request.handleAs || "auto",
			preventCache: method.preventCache || smd.preventCache,
			frameDoc: this._options.frameDoc || undefined
		});
	},
	_executeMethod: function(method){
		var args = [];
		var i;
		for(i=1; i< arguments.length; i++){
			args.push(arguments[i]);
		}
		var request = this._getRequest(method,args);
		var deferred = dojox.rpc.transportRegistry.match(request.transport).fire(request);
		
		deferred.addBoth(function(results){
			return request._envDef.deserialize.call(this,results);
		});
		return deferred;
	}
});

dojox.rpc.getTarget = function(smd, method){
	var dest=smd._baseUrl;
	if(smd.target){
		dest = new dojo._Url(dest,smd.target) + '';
	}
	if(method.target){
		dest = new dojo._Url(dest,method.target) + '';
	}
	return dest;
};

dojox.rpc.toOrdered=function(parameters, args){
	if(dojo.isArray(args)){ return args; }
	var data=[];
	for(var i=0;i<parameters.length;i++){
		data.push(args[parameters[i].name]);
	}
	return data;
};

dojox.rpc.transportRegistry = new dojo.AdapterRegistry(true);
dojox.rpc.envelopeRegistry = new dojo.AdapterRegistry(true);
//Built In Envelopes

dojox.rpc.envelopeRegistry.register(
	"URL",
	function(str){ return str == "URL"; },
	{
		serialize:function(smd, method, data ){
			var d = dojo.objectToQuery(data);
			return {
				data: d,
				transport:"POST"
			};
		},
		deserialize:function(results){
			return results;
		},
		namedParams: true
	}
);

dojox.rpc.envelopeRegistry.register(
	"JSON",
	function(str){ return str == "JSON"; },
	{
		serialize: function(smd, method, data){
			var d = dojo.toJson(data);

			return {
				data: d,
				handleAs: 'json',
				contentType : 'application/json'
			};
		},
		deserialize: function(results){
			return results;
		}
	}
);
dojox.rpc.envelopeRegistry.register(
	"PATH",
	function(str){ return str == "PATH"; },
	{
		serialize:function(smd, method, data){
			var i;
			var target = dojox.rpc.getTarget(smd, method);
			if(dojo.isArray(data)){
				for(i = 0; i < data.length;i++){
					target += '/' + data[i];
				}
			}else{
				for(i in data){
					target += '/' + i + '/' + data[i];
				}
			}

			return {
				data:'',
				target: target
			};
		},
		deserialize:function(results){
			return results;
		}
	}
);



//post is registered first because it is the default;
dojox.rpc.transportRegistry.register(
	"POST",
	function(str){ return str == "POST"; },
	{
		fire:function(r){
			r.url = r.target;
			r.postData = r.data;
			return dojo.rawXhrPost(r);
		}
	}
);

dojox.rpc.transportRegistry.register(
	"GET",
	function(str){ return str == "GET"; },
	{
		fire: function(r){
			r.url=  r.target + (r.data ? '?' + ((r.rpcObjectParamName) ? r.rpcObjectParamName + '=' : '') + r.data : '');
			return dojo.xhrGet(r);
		}
	}
);


//only works ifyou include dojo.io.script
dojox.rpc.transportRegistry.register(
	"JSONP",
	function(str){ return str == "JSONP"; },
	{
		fire: function(r){
			r.url = r.target + ((r.target.indexOf("?") == -1) ? '?' : '&') + ((r.rpcObjectParamName) ? r.rpcObjectParamName + '=' : '') + r.data;
			r.callbackParamName = r.callbackParamName || "callback";
			return dojo.io.script.get(r);
		}
	}
);
dojox.rpc.Service._nextId = 1;

dojo._contentHandlers.auto = function(xhr){
	// automatically choose the right handler based on the returned content type
	var handlers = dojo._contentHandlers;
	var retContentType = xhr.getResponseHeader("Content-Type");
	var results = !retContentType ? handlers.text(xhr) :
		retContentType.match(/\/.*json/) ? handlers.json(xhr) :
		retContentType.match(/\/javascript/) ? handlers.javascript(xhr) :
		retContentType.match(/\/xml/) ? handlers.xml(xhr) : handlers.text(xhr);
	return results;
};

}

if(!dojo._hasResource["dojo.io.script"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.io.script"] = true;
dojo.provide("dojo.io.script");

dojo.getObject("io", true, dojo);

/*=====
dojo.declare("dojo.io.script.__ioArgs", dojo.__IoArgs, {
	constructor: function(){
		//	summary:
		//		All the properties described in the dojo.__ioArgs type, apply to this
		//		type as well, EXCEPT "handleAs". It is not applicable to
		//		dojo.io.script.get() calls, since it is implied by the usage of
		//		"jsonp" (response will be a JSONP call returning JSON)
		//		or the response is pure JavaScript defined in
		//		the body of the script that was attached.
		//	callbackParamName: String
		//		Deprecated as of Dojo 1.4 in favor of "jsonp", but still supported for
		// 		legacy code. See notes for jsonp property.
		//	jsonp: String
		//		The URL parameter name that indicates the JSONP callback string.
		//		For instance, when using Yahoo JSONP calls it is normally,
		//		jsonp: "callback". For AOL JSONP calls it is normally
		//		jsonp: "c".
		//	checkString: String
		//		A string of JavaScript that when evaluated like so:
		//		"typeof(" + checkString + ") != 'undefined'"
		//		being true means that the script fetched has been loaded.
		//		Do not use this if doing a JSONP type of call (use callbackParamName instead).
		//	frameDoc: Document
		//		The Document object for a child iframe. If this is passed in, the script
		//		will be attached to that document. This can be helpful in some comet long-polling
		//		scenarios with Firefox and Opera.
		this.callbackParamName = callbackParamName;
		this.jsonp = jsonp;
		this.checkString = checkString;
		this.frameDoc = frameDoc;
	}
});
=====*/
(function(){
	var loadEvent = dojo.isIE ? "onreadystatechange" : "load",
		readyRegExp = /complete|loaded/;

	dojo.io.script = {
		get: function(/*dojo.io.script.__ioArgs*/args){
			//	summary:
			//		sends a get request using a dynamically created script tag.
			var dfd = this._makeScriptDeferred(args);
			var ioArgs = dfd.ioArgs;
			dojo._ioAddQueryToUrl(ioArgs);
	
			dojo._ioNotifyStart(dfd);

			if(this._canAttach(ioArgs)){
				var node = this.attach(ioArgs.id, ioArgs.url, args.frameDoc);

				//If not a jsonp callback or a polling checkString case, bind
				//to load event on the script tag.
				if(!ioArgs.jsonp && !ioArgs.args.checkString){
					var handle = dojo.connect(node, loadEvent, function(evt){
						if(evt.type == "load" || readyRegExp.test(node.readyState)){
							dojo.disconnect(handle);
							ioArgs.scriptLoaded = evt;
						}
					});
				}
			}

			dojo._ioWatch(dfd, this._validCheck, this._ioCheck, this._resHandle);
			return dfd;
		},
	
		attach: function(/*String*/id, /*String*/url, /*Document?*/frameDocument){
			//	summary:
			//		creates a new <script> tag pointing to the specified URL and
			//		adds it to the document.
			//	description:
			//		Attaches the script element to the DOM.  Use this method if you
			//		just want to attach a script to the DOM and do not care when or
			//		if it loads.
			var doc = (frameDocument || dojo.doc);
			var element = doc.createElement("script");
			element.type = "text/javascript";
			element.src = url;
			element.id = id;
			element.charset = "utf-8";
			return doc.getElementsByTagName("head")[0].appendChild(element);
		},
	
		remove: function(/*String*/id, /*Document?*/frameDocument){
			//summary: removes the script element with the given id, from the given frameDocument.
			
			console.log("dojo.io.script.remove    DESTROYING ALL");
			return;
		
			//If no frameDocument is passed, the current document is used.
			dojo.destroy(dojo.byId(id, frameDocument));
			
			//Remove the jsonp callback on dojo.io.script, if it exists.
			if(this["jsonp_" + id]){
				delete this["jsonp_" + id];
			}
		},
	
		_makeScriptDeferred: function(/*Object*/args){
			//summary:
			//		sets up a Deferred object for an IO request.
			var dfd = dojo._ioSetArgs(args, this._deferredCancel, this._deferredOk, this._deferredError);
	
			var ioArgs = dfd.ioArgs;
			ioArgs.id = dojo._scopeName + "IoScript" + (this._counter++);
			ioArgs.canDelete = false;
	
			//Special setup for jsonp case
			ioArgs.jsonp = args.callbackParamName || args.jsonp;
			if(ioArgs.jsonp){
				//Add the jsonp parameter.
				ioArgs.query = ioArgs.query || "";
				if(ioArgs.query.length > 0){
					ioArgs.query += "&";
				}
				ioArgs.query += ioArgs.jsonp
					+ "="
					+ (args.frameDoc ? "parent." : "")
					+ dojo._scopeName + ".io.script.jsonp_" + ioArgs.id + "._jsonpCallback";
	
				ioArgs.frameDoc = args.frameDoc;
	
				//Setup the Deferred to have the jsonp callback.
				ioArgs.canDelete = true;
				dfd._jsonpCallback = this._jsonpCallback;
				this["jsonp_" + ioArgs.id] = dfd;
			}
			return dfd; // dojo.Deferred
		},
		
		_deferredCancel: function(/*Deferred*/dfd){
			//summary: canceller function for dojo._ioSetArgs call.
	
			//DO NOT use "this" and expect it to be dojo.io.script.
			dfd.canceled = true;
			if(dfd.ioArgs.canDelete){
				dojo.io.script._addDeadScript(dfd.ioArgs);
			}
		},
	
		_deferredOk: function(/*Deferred*/dfd){
			//summary: okHandler function for dojo._ioSetArgs call.
	
			//DO NOT use "this" and expect it to be dojo.io.script.
			var ioArgs = dfd.ioArgs;
	
			//Add script to list of things that can be removed.
			if(ioArgs.canDelete){
				dojo.io.script._addDeadScript(ioArgs);
			}
	
			//Favor JSONP responses, script load events then lastly ioArgs.
			//The ioArgs are goofy, but cannot return the dfd since that stops
			//the callback chain in Deferred. The return value is not that important
			//in that case, probably a checkString case.
			return ioArgs.json || ioArgs.scriptLoaded || ioArgs;
		},
	
		_deferredError: function(/*Error*/error, /*Deferred*/dfd){
			//summary: errHandler function for dojo._ioSetArgs call.
	
			if(dfd.ioArgs.canDelete){
				//DO NOT use "this" and expect it to be dojo.io.script.
				if(error.dojoType == "timeout"){
					//For timeouts, remove the script element immediately to
					//avoid a response from it coming back later and causing trouble.
					dojo.io.script.remove(dfd.ioArgs.id, dfd.ioArgs.frameDoc);
				}else{
					dojo.io.script._addDeadScript(dfd.ioArgs);
				}
			}
			console.log("dojo.io.script error", error);
			return error;
		},
	
		_deadScripts: [],
		_counter: 1,
	
		_addDeadScript: function(/*Object*/ioArgs){
			//summary: sets up an entry in the deadScripts array.
			dojo.io.script._deadScripts.push({id: ioArgs.id, frameDoc: ioArgs.frameDoc});
			//Being extra paranoid about leaks:
			ioArgs.frameDoc = null;
		},
	
		_validCheck: function(/*Deferred*/dfd){
			//summary: inflight check function to see if dfd is still valid.
	
			//Do script cleanup here. We wait for one inflight pass
			//to make sure we don't get any weird things by trying to remove a script
			//tag that is part of the call chain (IE 6 has been known to
			//crash in that case).
			var _self = dojo.io.script;
			var deadScripts = _self._deadScripts;
			if(deadScripts && deadScripts.length > 0){
				for(var i = 0; i < deadScripts.length; i++){
					//Remove the script tag
					_self.remove(deadScripts[i].id, deadScripts[i].frameDoc);
					deadScripts[i].frameDoc = null;
				}
				dojo.io.script._deadScripts = [];
			}
	
			return true;
		},
	
		_ioCheck: function(/*Deferred*/dfd){
			//summary: inflight check function to see if IO finished.
			var ioArgs = dfd.ioArgs;
			//Check for finished jsonp
			if(ioArgs.json || (ioArgs.scriptLoaded && !ioArgs.args.checkString)){
				return true;
			}
	
			//Check for finished "checkString" case.
			var checkString = ioArgs.args.checkString;
			if(checkString && eval("typeof(" + checkString + ") != 'undefined'")){
				return true;
			}
	
			return false;
		},
	
		_resHandle: function(/*Deferred*/dfd){
			//summary: inflight function to handle a completed response.
			if(dojo.io.script._ioCheck(dfd)){
				dfd.callback(dfd);
			}else{
				//This path should never happen since the only way we can get
				//to _resHandle is if _ioCheck is true.
				dfd.errback(new Error("inconceivable dojo.io.script._resHandle error"));
			}
		},
	
		_canAttach: function(/*Object*/ioArgs){
			//summary: A method that can be overridden by other modules
			//to control when the script attachment occurs.
			return true;
		},
		
		_jsonpCallback: function(/*JSON Object*/json){
			//summary:
			//		generic handler for jsonp callback. A pointer to this function
			//		is used for all jsonp callbacks.  NOTE: the "this" in this
			//		function will be the Deferred object that represents the script
			//		request.
			this.ioArgs.json = json;
		}
	};
})();

}

if(!dojo._hasResource["plugins.workflow.ParameterRow"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.workflow.ParameterRow"] = true;
dojo.provide("plugins.workflow.ParameterRow");

// INTERNAL MODULES
// HAS A 



// INHERITS




dojo.declare( "plugins.workflow.ParameterRow",
	[ plugins.form.EditRow, plugins.form.Inputs, plugins.core.Common, dijit._Widget, dijit._Templated ],
{
//Path to the template of this widget. 
templateString:"<div dojoAttachPoint=\"containerNode\">\n\n<div class=\"${paramtype}\">\n    \n    <table width=\"100%\">\n        <tr>\n            <td\n                colspan=\"1\"\n                width=\"120px\"\n                dojoAttachPoint=\"nameNode\"\n                class=\"name\"\n                >${name}</td>\n            <td\n                colspan=\"1\"\n                dojoAttachPoint=\"valueNode\"\n                class=\"value\"\n                title=\"Click to edit value then press 'Return' to save (ESC to quit)\"\n                >${value}</td>\n        </tr>\n    </table>\n    <table\n        dojoAttachPoint=\"hidden\"\n        class=\"hidden\"\n        style=\"display: none;\"\n        width=\"100%\">\n        \n        <tr width=\"100%\">\n            <td colspan=\"2\">\n                <table width=\"100%\">\n                    <tr width=\"100%\">\n                        <td\n                            colspan=\"1\"\n                            width=\"60px\"\n                            dojoAttachPoint=\"typeTitle\"\n                            class=\"discretion\"\n                            style=\"display: none;\">${discretion}</td>\n                        <td \n                            colspan=\"1\"\n                            width=\"60px\"\n                            dojoAttachPoint=\"typeNode\"\n                            class=\"valuetype\"\n                            title=\"Parameter type, e.g., file, directory, integer or text string\"\n                            style=\"display: none;\">${valuetype}</td>\n                        <td \n                            colspan=\"1\"\n                            width=\"50px\"\n                            dojoAttachPoint=\"browseButton\"\n                            class=\"browseButton\"\n                            title=\"Click to browse the filesystem in your home directory on the server\"\n                            style=\"display: none;\">&nbsp;</td>\n                        <td\n                            dojoAttachPoint=\"downloadButton\"\n                            class=\"downloadButton\"\n                            title=\"Click to download this file to your computer\"\n                            style=\"display: none;\">&nbsp;</td>\n                        <td\n                            dojoAttachPoint=\"uploadButton\"\n                            dojoAttachEvent=\"onclick:upload\"\n                            class=\"uploadButton\"\n                            title=\"Click to upload a file from your computer\"\n                            style=\"display: none;\">&nbsp;</td>\n                        <td dojoAttachPoint=\"fileInputMask\"\n                            class=\"fileInputMask\"\n                            style=\"display: none;\" ></td>\n                        <td class=\"filler\">&nbsp;</td>\n                    </tr>\n                </table>\n            </td>\n        </tr>\n        <tr>\n            <td \n                colspan=\"2\"\n                dojoAttachPoint=\"descriptionNode\"\n                class=\"description\"\n                title=\"Click to edit description then press 'Return' to save (ESC to quit)\"\n                style=\"display: none;\" >${description}</td>\n        <tr>\n    </table>\n\n</div>\n\n</div>\n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

validInput : true,	// FILE PRESENT BOOLEAN

// CORE WORKFLOW OBJECTS
core : null,

formInputs : {		// FORM INPUTS AND TYPES (word|phrase)
	valueNode: "word",
	descriptionNode: "phrase"
},
defaultInputs : {	// DEFAULT INPUTS
	valueNode: "",
	descriptionNode: ["Description"]
},

requiredInputs : {	// REQUIRED INPUTS CANNOT BE ''
	valueNode : 1
},
invalidInputs : {	// THESE INPUTS ARE INVALID

	valueNode : ["essential", "required", "optional"]
	//description: "Description",
	//notes: "Notes"
},
/////}}}}
constructor : function(args) {
	////console.log("ParameterRow.constructor    plugins.workflow.ParameterRow.constructor(args)");
	this.passedArgs = args;
	this.core = args.core;
	this.uploader = args.uploader;

	// POPULATE this.parameterObject TO BE USED IN saveInputs
	this.parameterObject = new Object;
	for ( var key in args )
	{
		if ( key == "core" || key == "uploader" )	continue;
		//console.log("ParameterRow.constructor    this.parameterObject[" + key + "]: " + args[key]);
		this.parameterObject[key] = args[key];
	}

	//console.log("ParameterRow.constructor    END");	
},
postCreate : function() {
	//console.log("ParameterRow.postCreate    plugins.workflow.ParameterRow.postCreate()");
	//console.log("ParameterRow.postCreate    DOING this.inherited(arguments)");
	this.inherited(arguments);
	this.startup();
},
startup : function () {
	//console.log("ParameterRow.startup    plugins.workflow.ParameterRow.startup()");
	this.inherited(arguments);

	// SET TOGGLE VISIBILITY WITH name ELEMENT ONCLICK
	this.setToggle();

	// SET LISTENERS FOR EDIT ONCLICK
	this.setEditOnclicks();

	// SET this.nameNode.parentWidget FOR 'ONCLICK REMOVE' IN Workflow.updateDropTarget
	this.nameNode.parentWidget = this;
	
	// SET BROWSE BUTTON IF FILE OR DIRECTORY
	this.setBrowseButton();
	
	// SET UPLOAD BUTTON ONCLICK LISTENER
	if ( this.valuetype == "file" )
		this.setFileDownload();
	
	if ( this.valuetype == "flag" )
		this.setCheckbox();
		
	// CHECK CURRENT VALUE IS VALID
	//console.log("ParameterRow.startup    Doing this.checkInput(node, inputValue, force)");
	var node = this.valueNode;
	//console.log("ParameterRow.startup    node: " + node);

	//var inputValue = this.valueNode.innerHTML;	
	//var force = true;
	//this.checkInput(node, inputValue, force);	
},
getInputValue : function () {
// GET INPUTS FROM THE FORM
	console.log("ParameterRow.getInputValue    plugins.workflow.ParameterRow.getInputValue()");
	console.log("ParameterRow.getInputValue    '" + this.name + "' this.valueNode.innerHTML: " + this.valueNode.innerHTML);

	if ( inputValue && inputValue.match(/^<input type="checkbox">/) )
	{
		return this.valueNode.firstChild.checked;
	}

	var value;
	if ( this.valueNode.innerHTML )
	{
		value = this.valueNode.innerHTML;
	}
	
	var name = "valueNode";
	if ( this.formInputs[name] == "word" )
	{
		value = this.cleanWord(value);
	}
	else if ( this.formInputs[name] == "phrase" )
	{
		value = this.cleanEnds(value);
	}

	//console.log("ParameterRow.getvalue    BEFORE convertString, value: " + value);
	value = this.convertString(value, "htmlToText");
	//console.log("ParameterRow.getvalue    AFTER convertString, value: " + value);

	this.valueNode.value = value;

	return value;
},
destroy: function (preserveDom) {
// overridden destroy method. call the parent method
	//console.log("ParameterRow.destroy    plugins.report.ParameterRow.destroy()");
	this.inherited(arguments);
},
/////////	FLAG
setCheckbox : function () {
// ADD A CHECKBOX TO THE valueNode IF THE INPUT TYPE IS A FLAG
	console.log("ParameterRow.setCheckbox    plugins.workflow.ParameterRow.setCheckbox()");
	console.log("ParameterRow.setCheckbox    this.valuetype: " + this.valuetype);

	this.checkbox = document.createElement('input');
	this.checkbox.type = "checkbox";
	if ( this.parameterObject.valuetype == "flag" )
	if ( this.value == 1 )
		this.checkbox.checked = true;
	else
		this.checkbox.checked = false;
	this.valueNode.innerHTML = '';
	this.valueNode.appendChild(this.checkbox);

	dojo.connect(this.checkbox, "onchange", dojo.hitch(this, "handleCheckboxOnChange"));
},
handleCheckboxOnChange : function (event) {
	console.log("ParameterRow.handleCheckboxOnChange    plugins.workflow.ParameterRow.handleCheckboxOnChange(event)");
	console.log("ParameterRow.handleCheckboxOnChange    event: " + event);

	//Stop Event Bubbling
	event.stopPropagation(); 

	// GET INPUTS
	var inputs = this.getFormInputs(this);
	console.log("ParameterRow.handleCheckboxOnChange    inputs: " + dojo.toJson(inputs));
	if ( inputs == null ) return;

	// SAVE STAGE PARAMETER
	console.log("ParameterRow.setCheckbox    Doing thisObject.saveInputs(inputs)");
	this.saveInputs(inputs, {originator: this, reload: false});
},
/////////	FILE MANAGER
setBrowseButton : function() {
	//console.log("ParameterRow.setBrowseButton    plugins.report.ParameterRow.browseButton()");
	//console.log("ParameterRow.setBrowseButton    this.paramtype: " + this.paramtype);
	//console.log("ParameterRow.setBrowseButton    this.valuetype: " + this.valuetype);
	
	// RETURN IF THE PARAMTYPE IS NOT file* OR director*
	if (! this.valuetype.match(/^file/) && ! this.valuetype.match(/^director/))	return;

	//console.log("ParameterRow.setBrowseButton    Doing dojo.connect");
	dojo.connect(this.browseButton, "onclick", this, dojo.hitch( this, function(event)
		{
			// DO FILTER REPORT
			this.openFileManager();
		}
	));
},
openFileManager : function() {
/* OPEN FILE MANAGER TO ALLOW SELECTION OF FILE AS ARGUMENT VALUE.
	PASS THIS PARAMETER ROW OBJECT AS A PARAMETER TO BE USED IN
	THE CALLBACK TO SET THE ARGUMENT VALUE (LOCALLY AND REMOTELY).
*/

	console.log("ParameterRow.openFileManager     workflow.ParameterRow.openFileManager()");
	if ( ! Agua.fileManager ) {
		console.log("ParameterRow.openFileManager     Agua.fileManager is null. Returning");
		return;
	}
		
	if ( this.paramtype != "input" ) {
		console.log("ParameterRow.openFileManager     Doing Agua.fileManager.disableMenus()");
		Agua.fileManager.disableMenuSelect();
		Agua.fileManager.disableMenuAdd();
	}
	else {
		console.log("ParameterRow.openFileManager     Doing Agua.fileManager.enableMenus()");
		Agua.fileManager.enableMenuSelect();	
		Agua.fileManager.enableMenuAdd();	
	}

	Agua.fileManager.show(this);
},
/////////	CHECKINPUT 
saveInputs : function(inputs, updateArgs) {
	console.log("ParameterRow.saveInputs    plugins.workflow.ParameterRow.saveInputs(inputs, updateArgs)");	
	console.log("ParameterRow.saveInputs    inputs: " + inputs);
	console.dir(inputs);
	console.log("ParameterRow.saveInputs    updateArgs: ");
	console.dir(updateArgs) 

	// SET savingParameter FLAG
	console.log("ParameterRow.saveInputs    this.savingParameter: " + this.savingParameter);
	if ( this.savingParameter == true )
		return;
	this.savingParameter = true;

	// PREPARE ARGUMENTS:	node, inputValue, force
	var node = updateArgs.originator.valueNode;
	var inputValue = inputs.valueNode;	
	var force = true;
	console.log("ParameterRow.saveInputs    node: " + node);
	console.log("ParameterRow.saveInputs    inputValue: " + inputValue);
	console.log("ParameterRow.saveInputs    force: " + force);
	console.log("ParameterRow.saveInputs    this.valuetype: " + this.valuetype);

	if ( this.valuetype == "flag" )
	{
		console.log("ParameterRow.saveInputs    DOING inputValue = this.getCheckboxValue()");
		inputValue = this.getCheckboxValue();
		console.log("ParameterRow.saveInputs    inputValue: " + inputValue);
		inputs.valueNode = inputValue;
	}

	console.log("ParameterRow.saveInputs    Doing this.checkInput(node, inputValue, force)");
	this.checkInput(node, inputValue, force);

	// DOUBLE-UP BACKSLASHES
	for ( var i = 0; i < inputs.length; i++ )
	{
		inputs[i] = this.convertBackslash(inputs[i], "expand");
	}
	console.log("ParameterRow.saveInputs    AFTER this.convertBackslash() inputs: " + dojo.toJson(inputs));
	
	// POPULATE PARAMETER OBJECT
	this.parameterObject.username = Agua.cookie('username');
	this.parameterObject.sessionid = Agua.cookie('sessionid');
	for ( key in inputs )
	{
		this.parameterObject[key] = inputs[key];
	}
	delete this.parameterObject.uploader;
	this.parameterObject.value = this.parameterObject.valueNode;
	delete this.parameterObject.valueNode;
	//this.parameterObject.chained = 0;

	// UNSET savingParameter FLAG
	this.savingParameter = false;
	
	// ADD STAGE PARAMETER		
	console.log("ParameterRow.saveInputs    Doing Agua.addStageParameter(stageParameterObject)");
	Agua.addStageParameter(this.parameterObject);

	// CHAIN OUTPUTS
	console.log("ParameterRow.saveInputs    Doing this.core.io.chainOutputs()");
	var application = this.core.parameters.application;
	console.log("ParameterRow.saveInputs    application: " + dojo.toJson(application));
	var chainedOutputs = this.core.io.chainOutputs(application, true);
	console.log("ParameterRow.saveInputs    chainedOutputs: " + dojo.toJson(chainedOutputs));
	this.core.parameters.resetChainedOutputs(chainedOutputs);

	// REFRESH VALIDITY OF PARAMETERS PANE
	this.core.parameters.checkValidInputs();
	
},
getCheckboxValue : function () {
	//console.log("ParameterRow.checkCheckBoxValue    plugins.workflow.ParameterRow.checkCheckBoxValue()");	
	if ( this.valueNode.firstChild.checked == true )	return "1";
	return "0";
},
checkInput : function (node, inputValue, force) {
// CHECK IF INPUT IS VALID OR IF FILE/DIRECTORY IS PRESENT.
// SET NODE CSS ACCORDINGLY.
	console.group("ParameterRow-" + this.id + "    checkInput");
	console.log("ParameterRow.checkInput    node, inputValue, force");	
	console.log("ParameterRow.checkInput    node: " + node);
	console.log("ParameterRow.checkInput    inputValue: " + inputValue);
	console.log("ParameterRow.checkInput    force: " + force);
	
	// NO NEED TO CHECK FLAG
	if ( this.valuetype == "flag" )
	{
		//console.log("ParameterRow.checkInput    this.valuetype = flag. Setting this.validInput = true and returning");
		this.validInput == true;	
		this.setValid(node);
	}

	// IF EMPTY, CHECK IF REQUIRED OR ESSENTIAL
	else if ( inputValue == null || inputValue == '' )
		this.checkEmpty(node);

	// DO TEXT INPUT IF TYPE IS NOT file, files, directory, OR directories
	else if ( ! this.valuetype.match(/^file$/)
			&& ! this.valuetype.match(/^directory$/) )
	{
		if ( this.parameterObject.valuetype == "integer" )
		{
			//console.log("ParameterRow.checkInput    Doing this.checkIntegerInput");
			this.checkIntegerInput(node, inputValue);
		}
		else if ( this.parameterObject.valuetype == "string" )
		{
			//console.log("ParameterRow.checkInput    Doing this.checkTextInput");
			this.checkTextInput(node, inputValue);
		}
	}
	
	// OTHERWISE, DO FILE INPUT
	else
	{
		//console.log("ParameterRow.checkInput    Doing this.checkFile");
		if ( force == null )	force = false;
		this.checkFile(node, inputValue, force);
	}

	console.groupEnd("ParameterRow-" + this.id + "    checkInput");
},
checkEmpty : function (node) {
	//console.log("ParameterRow.checkEmpty    ParameterRow.checkEmpty(node)");
	
	// IF ESSENTIAL/REQUIRED, SET AS INVALID
	if ( this.discretion == "essential"
		||	this.discretion == "required" )
	{
		// SET this.validInput AS FALSE AND SET invalid CSS
		this.setInvalid(node);
		this.validInput = false;

		// SET STAGE PARAMETER'S  AS false
		//console.log("ParameterRow.checkEmpty    null/empty for essential/required input '" + this.name + "'. Setting stageParameter. to FALSE");
		Agua.setParameterValidity(this, false);
	}
	else
	{
		// SET STAGE PARAMETER  AS TRUE
		//console.log("ParameterRow.checkEmpty    null/empty for NON-essential/required input '" + this.name + "'. Setting stageParameter. to TRUE");
		Agua.setParameterValidity(this, true);
		this.setValid(node);
		this.validInput = true;
	}

	// SET PARENT INFO PANE'S validInputs FLAG AND
	// CALL stages.updateRunButton
	this.core.parameters.checkValidInputs();
},
checkIntegerInput : function (node, inputValue) {
	console.log("ParameterRow.checkIntegerInput    plugins.workflow.ParameterRow.checkIntegerInput()");	
	console.log("ParameterRow.checkIntegerInput    node: " + node);
	console.log("ParameterRow.checkIntegerInput    inputValue: " + inputValue);

	// ADD invalid CLASS IF INPUT IS NOT VALID
	if ( ! inputValue.match(/^\s*[\d\.]+\s*$/) )
	{
		console.log("ParameterRow.isValidInput    Non-integer inputValue. Returning false");
		this.validInput = false;
		this.setInvalid(node);
		Agua.setParameterValidity(this, false);
	}
	else {
		this.setValid(node);
		Agua.setParameterValidity(this, true);
	}
},
checkTextInput : function (node, inputValue) {
	console.log("ParameterRow.checkTextInput    plugins.workflow.ParameterRow.checkTextInput()");	
	console.log("ParameterRow.checkTextInput    node: " + node);
	console.log("ParameterRow.checkTextInput    inputValue: " + inputValue);

	var validInput = true;
	this.validInput = this.isValidInput(this.invalidInputs, "valueNode", inputValue);
	console.log("ParameterRow.checkIntegerInput    this.validInput: " + this.validInput);

	// IF THE INPUT IS NOT VALID, ADD THE invalid CLASS.
	if ( this.validInput == false
		&& this.paramtype == "input" )
	{
		console.log("ParameterRow.checkInput    text input not valid. Setting stageParameter. to FALSE");
		this.setInvalid(node);
		Agua.setParameterValidity(this, false);
	}
	
	// IF THE INPUT IS VALID, TOGGLE ITS 'required|satisfied'
	// ACCORDINGLY IF THE INPUT IS REQUIRED. IF NOT, DO NOTHING
	else
	{
		console.log("ParameterRow.checkInput    text input is valid. Setting stageParameter. to TRUE");
		this.setValid(node);
		Agua.setParameterValidity(this, true);
	}

	//// MAKE THE PARENT Parameters CHECK FOR VALID INPUTS
	//// AMONG ALL OF ITS ParameterRow CHILDREN AND UPDATE
	//// THE DISPLAY OF THE STAGE IN THE WORKFLOW ACCORDINGLY.
	//// ALSO SET PARENT INFO PANE'S validInputs FLAG AND
	//// CALL stages.updateRunButton
	this.core.parameters.checkValidInputs();

},	//	checkTextInput
checkFile : function (node, inputValue, force) {
/* CHECK IF FILE/DIRECTORY IS PRESENT ON SERVER.
// CALL PARENT WIDGET TO UPDATE ITS validInputs SLOT.
// NB: RETURN NULL IF inputValue IS EMPTY OR NULL */
	console.log("ParameterRow.checkFile    plugins.workflow.ParameterRow.checkFile()");	
	console.log("ParameterRow.checkFile    node: " + node);
	//console.log("ParameterRow.checkFile    '" + this.name + "' inputValue: " + inputValue);
	//console.log("ParameterRow.checkFile    force: " + force);

	if ( inputValue == null || inputValue == '' )	return null;

	// RETURN IF fileExists HAS BEEN ALREADY SET TO true
	console.log("ParameterRow.checkFile    force: " + force);
	if ( this.parameterObject.fileinfo != null )
		this.handleCheckfile(node, this.parameterObject.fileinfo);
	var fileinfo = Agua.getFileInfo(this.parameterObject);
	if ( fileinfo != null )
		this.handleCheckfile(node, fileinfo);

	// GENERATE QUERY JSON FOR THIS WORKFLOW IN THIS PROJECT
	var query = new Object;

	// SET requestor = THIS_USER IF core.parameters.shared IS TRUE
	if ( this.core.parameters.shared == true )
	{
		query.username = this.username;
		query.requestor = Agua.cookie('username');
	}
	else
	{
		query.username = Agua.cookie('username');
	}

	query.sessionid = Agua.cookie('sessionid');
	query.project = this.project;
	query.workflow = this.workflow;
	query.mode = "checkFile";
	query.filepath = inputValue;
	////console.log("ParameterRow.checkFile    checkFile query: " + dojo.toJson(query));

	var url = this.randomiseUrl(Agua.cgiUrl + "workflow.cgi");
	//////console.log("ParameterRow.checkFile    url: " + url);

	// ADD RANDOM NUMBER CONTENT TO DISAMBIGUATE xhrPut REQUESTS ON SERVER
	var content = Math.floor(Math.random()*1000000000000);
	var thisObject = this;
	dojo.xhrPut(
		{
			url: url,
			contentType: "text",
			preventCache: true,
			sync : false,
			handleAs: "json",
			content: content,
			putData: dojo.toJson(query),
			//timeout: 20000,
			handle: function(fileinfo, ioArgs) {
				console.log("ParameterRow.checkFile    JSON fileinfo for inputValue '" + inputValue + "': " + dojo.toJson(fileinfo));

				Agua.setFileInfo(thisObject.parameterObject, fileinfo);

				thisObject.handleCheckfile(node, fileinfo);

				// SET PARENT INFO PANE'S validInputs FLAG AND
				// CALL stages.updateRunButton
				thisObject.core.parameters.checkValidInputs();
			},
			error: function(response, ioArgs) {
				console.log("ParameterRow.checkFile    Error with JSON Post, response: " + response);
			}
		}
	);	
},
handleCheckfile : function (node, fileinfo) {
// HANDLE JSON RESPONSE FROM checkFile QUERY
	console.log("ParameterRow.handleCheckfile    plugins.workflow.ParameterRow.handleCheckfile(node, fileinfo)");
	console.log("ParameterRow.handleCheckfile    BEFORE node: node");
	console.log("ParameterRow.handleCheckfile    node: " + node);
	console.log("ParameterRow.handleCheckfile    fileinfo: " + dojo.toJson(fileinfo));

	// SET FILEINFO
	console.log("ParameterRow.handleCheckfile    DOING Agua.setFileInfo(this.parameterObject, fileinfo)");
	Agua.setFileInfo(this.parameterObject, fileinfo);

	if ( fileinfo == null || fileinfo.exists == null )
	{
		console.log("ParameterRow.handleCheckfile    Either fileinfo or fileinfo.exists is null. Returning");
		return;
	}


	//if ( this.discretion == "required" )
	//{
	//	this.validInput = true;
	//	this.inputSatisfied(node);
	//
	//	// SET STAGE PARAMETER'S isValid AS true
	//	//console.log("ParameterRow.Checkfile    null/empty for essential/required input. DOING Agua.setParameterValidity(this, true)");
	//	Agua.setParameterValidity(this, true);
	//	return;
	//}
	//
	
	// IF THE FILE EXISTS, SET this.validInput TO TRUE
	// AND ADD filePresent AND inputSatisfied CSS CLASSES 
	if ( fileinfo.exists == "true" )
	{
		console.log("ParameterRow.handleCheckfile    File exists. Changing CSS");
		console.log("ParameterRow.handleCheckfile    this.valuetype: " + this.valuetype);
		console.log("ParameterRow.handleCheckfile    fileinfo.type: " + fileinfo.type);
		
		// SET FILE PRESENT CSS
		this.filePresent(node);

		// IF file, files OR directory, directories SET CSS TO satisfied
		if( (this.valuetype == "directory" && fileinfo.type == "directory")
		   || (this.valuetype == "file" && fileinfo.type == "file") )
		{
			console.log("ParameterRow.handleCheckfile    The file or directory is of the correct type. Doing this.setValid(node)");
			
			// SET SATIFIED/REQUIRED CSS AND this.validInput			
			this.setValid(node);
			this.validInput = true;

			// SET STAGE PARAMETER'S isValid AS true
			console.log("ParameterRow.handleCheckfile    essential/required file/dir is  present. DOING Agua.setParameterValidity(this, true)");
			Agua.setParameterValidity(this, true);
		}
		
		// OTHERWISE, ITS A DIRECTORY WHEN A FILE IS REQUIRED, OR VICE-VERSA
		// SO SET CSS CLASS TO required
		else
		{
			console.log("ParameterRow.handleCheckfile    File found when directory required (or vice-versa). Doing this.setInvalid(node)");
			////console.log("ParameterRow.handleCheckfile    Setting CSS to required");
			this.setInvalid(node);
			this.validInput = false;
			//this.inputRequired(node);

			// SET STAGE PARAMETER'S isValid AS false
			console.log("ParameterRow.handleCheckfile    null/empty for essential/required input. DOING Agua.setParameterValidity(this, false)");
			Agua.setParameterValidity(this, false);
		}
	}	// fileinfo.exists == true
	
	// OTHERWISE, ADD fileMissing AND inputRequired CSS
	// CLASSES AND SET this.validInput TO FALSE
	else
	{
		console.log("ParameterRow.handleCheckfile    File does not exist. Changing class of node to 'fileMissing'");
		console.log("ParameterRow.handleCheckfile    node: " + node);

		// SET FILE MISSING CSS
		this.fileMissing(node);

		// IF FILE MUST BE PHYSICALLY PRESENT (I.E., IT'S essential)
		// SET required CSS AND this.validInput TO FALSE			
		if ( this.discretion == "essential" )
		{
			this.validInput = false;
			this.setInvalid(node);
			//this.inputRequired(node);
		
			// SET STAGE PARAMETER'S isValid AS false
			console.log("ParameterRow.handleCheckfile    null/empty for essential input. DOING Agua.setParameterValidity(this, false)");
			Agua.setParameterValidity(this, false);
		}

		// FILE IS NOT REQUIRED TO BE PHYSICALLY PRESENT
		// (I.E., IT'S NOT essential).
		// SET satisfied CSS AND this.validInput TO TRUE
		else
		{
			this.validInput = true;
			this.setValid(node);

			// SET STAGE PARAMETER'S isValid AS true
			console.log("ParameterRow.handleCheckfile    null/empty for required input. DOING Agua.setParameterValidity(this, true)");
			Agua.setParameterValidity(this, true);
		}
	}
	
	console.log("ParameterRow.handleCheckfile    " + this.appname + " parameter " + this.name + " FINAL this.validInput: " + this.validInput);
	
	// MAKE PARENT WIDGET CHECK ALL INPUTS ARE VALID AND SET
	// ITS OWN isValid FLAG AND CSS ACCORDINGLY
	
	console.log("ParameterRow.handleCheckfile    " + this.appname + " parameter " + this.name + " FINAL this.validInput: " + this.validInput);


	//console.log("ParameterRow.handleCheckfile    DOING this.core.parameters.checkValidInputs()");
	
},
isValidInput : function (name, value) {
// DEFER VALIDITY CHECK UNTIL saveInputs
	return true;
},
/////////	EDIT VALUE 
setEditOnclicks : function () {
// ADD 'ONCLICK' EDIT VALUE LISTENERS
	////console.log("ParameterRow.setEditOnClicks    plugins.workflow.ParameterRow.setEditOnClicks()");

	if ( this.paramtype != "input" )
	{
		//console.log("ParameterRow.setEditOnClicks    Skipping onclick listeners for paramtype: " + this.paramtype);
		return;
	}
	var thisObject = this;
	var array = ["valueNode", "descriptionNode"];
	for ( var i in array )
	{
		// IGNORE IF TYPE IS FLAG (SET FLAG ONCHANGE EARLIER IN setCheckbox)
		if ( this.valuetype != "flag" )
		{
			////console.log("ParameterRow.setEditOnClicks    [" + i + "]    Non-flag input: " + array[i]);

			dojo.connect(this[array[i]], "onclick", dojo.hitch(this, function(event)
				{
					////console.log("ParameterRow.setEditOnClicks    [" + i + "]    onclick listener fired: " + array[i]);
					var node = event.target;
					this.editRow(this, node);
					event.stopPropagation(); //Stop Event Bubbling
				}
			));
		}	
	}
},
/////////	DOWNLOAD 
setFileDownload : function(node, name) {
	//console.log("ParameterRow.setFileDownload    plugins.report.ParameterRow.setFileDownload()");
	
	dojo.connect(this.downloadButton, "onclick", this, dojo.hitch( this, function(event)
		{
			//console.log("ParameterRow.setFileDownload    download onclick fired");
			
			// DO FILTER REPORT
			this.downloadFile(this.valueNode.innerHTML);
		}
	));
},
downloadFile : function (filepath) {
	//console.log("ParameterRow.downloadFile     plugins.workflow.ParameterRow.downloadFile(filepath)");
	//console.log("ParameterRow.downloadFile     filepath: " + filepath);
	var query = "?mode=downloadFile";

	// SET requestor = THIS_USER IF core.parameters.shared IS TRUE
	if ( this.core.parameters.shared == true )
	{
		query += "&username=" + this.username;
		query += "&requestor=" + Agua.cookie('username');
	}
	else
	{
		query += "&username=" + Agua.cookie('username');
	}

	query += "&sessionid=" + Agua.cookie('sessionid');
	query += "&filepath=" + filepath;
	//console.log("ParameterRow.downloadFile     query: " + query);
	
	var url = Agua.cgiUrl + "download.cgi";
	//console.log("ParameterRow.downloadFile     url: " + url);
	
	var args = {
		method: "GET",
		url: url + query,
		handleAs: "json",
		//timeout: 10000,
		load: this.handleDownload
	};
	//console.log("ParameterRow.downloadFile     args: ", args);

	// do an IFrame request to download the csv file.
	////console.log("ParameterRow.downloadFile     Doing dojo.io.iframe.send(args))");
	var value = dojo.io.iframe.send(args);
},
handleDownload : function (response, ioArgs) {
	//console.log("ParameterRow.handleDownload     plugins.workflow.ParameterRow.handleDownload(response, ioArgs)");
	//console.log("ParameterRow.handleDownload     response: " + dojo.toJson(response));
	//console.log("ParameterRow.handleDownload     response.message: " + response.message);

	if ( response.message == "ifd.getElementsByTagName(\"textarea\")[0] is undefined" )
	{
		Agua.toastMessage({
			message: "Download failed: File is not present",
			type: "error"
		});	////console.log("ParameterRow.downloadFile     value: " + dojo.toJson(value));

	}	
},
/////////	UPLOAD 
upload : function (event) {
	//////console.log("ParameterRow.upload     plugins.files.Menu.upload(event)");
	//////console.log("ParameterRow.upload     this: " + this);
	//////console.log("ParameterRow.upload     event: " + event);

	// SET THE PATH AS THE WORKFLOW FOLDER		
	var path = this.project + "/" + this.workflow;
	//////console.log("ParameterRow.upload     path: " + path);
	if ( path == null || path == '' )	return;

	this.uploader.getSetter('path', path);
	this.uploader.show();
	dojo.stopEvent(event);
	
	var thisObject = this;
    this.uploader.onComplete = function(/* Object */customEvent){
        thisObject.onComplete(customEvent);
    }
},
onComplete : function (customEvent) {
// 		Fires when all files have uploaded
// 		Event is an array of all files

    //////console.log("ParameterRow.onComplete    form.plugins.ParameterRow.onComplete(customEvent)");
    //////console.log("ParameterRow.onComplete    customEvent: " + dojo.toJson(customEvent));	

	if ( ! customEvent.match(/\/([^\/]+)$/) ) 	return;
	var filename = customEvent.match(/\/([^\/]+)$/)[1];
	//////console.log("ParameterRow.onComplete    filename: " + dojo.toJson(filename));	
	var path = this.project + "/" + this.workflow + "/" + filename;
	//////console.log("ParameterRow.onComplete    path: " + dojo.toJson(path));	

	this.changeValue(this.valueNode, this.valueNode.value, path, "file");
},
/////////	VALUES
changeValue : function (node, oldValue, newValue, type) {
/* 1. DISPLAY THE NEW VALUE AND ADD IT TO Agua
// 2. CHECK THE FILE IS PRESENT
// 3. UPDATE THE STAGE DISPLAY IN THE WORKFLOW
//	TO REFLECT THE STATE OF COMPLETENESS AND 
// 	VALIDITY OF ITS INPUTS  */
	console.log("ParameterRow.changeValue     plugins.workflow.ParameterRow.changeValue(node, oldValue, newValue)");
	console.log("ParameterRow.changeValue     node: " + node);
	console.log("ParameterRow.changeValue     newValue: " + newValue);
	console.log("ParameterRow.changeValue     oldValue: " + oldValue);
	console.log("ParameterRow.changeValue     type: " + type);
	console.log("ParameterRow.changeValue     this.valuetype: " + this.valuetype);

	// IF SOMETHING WENT WRONG, USE THE OLD VALUE
	if ( newValue == null || newValue == '' || newValue == oldValue )
	{
		console.log("ParameterRow.changeValue    newValue is empty or newValue == oldValue. Either upload was aborted or the files have the same name. Returning.");

		// PUT THE OLD VALUE BACK IN THE TABLE
		node.innerHTML = oldValue;
		return;
	}
	
	// PUT THE VALUE IN THE TABLE
	node.innerHTML = newValue;

	// SAVE THIS OPTION VALUE FOR THE WORKFLOW TO THE SERVER
	this.parameterObject.value = newValue;
	console.log("ParameterRow.changeValue     this.parameterObject: ");
	console.dir(this.parameterObject);
	
	// SET USER NAME TO COMPLETE stageparameter UNIQUE KEY
	this.parameterObject.username = Agua.cookie('username');
	
	// ADD STAGE PARAMETER		
	console.log("ParameterRow.changeValue     Doing Agua.addStageParameter(this.parameterObject)");
	Agua.addStageParameter(this.parameterObject);

	// SET FILE PRESENT CSS
	this.filePresent(node);

	// CHECK TYPE MATCHES E.G., EXPECTED DIRECTORY AND FOUND DIRECTORY
	// IF TYPE DOES NOT MATCH, SET AS INVALID AND REQUIRED
	if ( this.valuetype.substring(0,4) != type.substring(0,4) )
	{
		console.log("ParameterRow.changeValue     type (" + type + ") does not match this.valuetype (" + this.valuetype + ") ");

		//// ALTHOUGH FILE EXISTS, IF ITS THE WRONG TYPE,
		// SET THIS INPUT AS VALID
		this.validInput = false;

		// SET VALID CSS
		this.setInvalid(node);

		// SET STAGE PARAMETER'S isValid AS TRUE
		console.log("ParameterRow.handleCheckfile    File found where directory wanted (or vice-versa). Setting stageParameter.isValid to FALSE");
		Agua.setParameterValidity(this, false);

	}
	else
	{
		console.log("ParameterRow.changeValue     type (" + type + ") matches this.valuetype (" + this.valuetype + ") ");
		// SET THIS INPUT AS VALID
		this.validInput = true;

		// REMOVE RED BORDER (.infopane .invalid OR .infopane .input .required)
		this.setValid(node);
		
		// SET STAGE PARAMETER'S isValid AS TRUE
		console.log("ParameterRow.handleCheckfile    File found where wanted. Setting stageParameter.isValid to TRUE");
		Agua.setParameterValidity(this, true);
	}
	
	// UPDATE this.validInputs IN PARENT INFOPANE WIDGET
	console.log("ParameterRow.changeValue     DOING this.core.parameters.checkValidInputs()");
	this.core.parameters.checkValidInputs();		
},
addValue : function (node, oldValue, newValue, type) {
/* 1. DISPLAY THE NEW VALUE AND ADD IT TO Agua
// 2. CHECK THE FILE IS PRESENT
// 3. UPDATE THE STAGE DISPLAY IN THE WORKFLOW
//	TO REFLECT THE STATE OF COMPLETENESS AND 
// 	VALIDITY OF ITS INPUTS  */
	console.log("ParameterRow.addValue     plugins.workflow.ParameterRow.addValue(node, oldValue, newValue)");
	console.log("ParameterRow.addValue     node: " + node);
	console.log("ParameterRow.addValue     newValue: " + newValue);
	console.log("ParameterRow.addValue     oldValue: " + oldValue);
	console.log("ParameterRow.addValue     type: " + type);
	console.log("ParameterRow.addValue     this.valuetype: " + this.valuetype);

	// IF SOMETHING WENT WRONG, USE THE OLD VALUE
	if ( newValue == null || newValue == '' || newValue == oldValue )
	{
		console.log("ParameterRow.addValue    newValue is empty or newValue == oldValue. Either upload was aborted or the files have the same name. Returning.");

		// PUT THE OLD VALUE BACK IN THE TABLE
		node.innerHTML = oldValue;
		return;
	}

	// ADD NEW VALUE TO OLD VALUE
	if ( oldValue ) newValue = oldValue + "," + newValue;
	
	// SET INPUT VALUE TO NEW VALUE
	node.innerHTML = newValue;

	// SAVE THIS OPTION VALUE FOR THE WORKFLOW TO THE SERVER
	console.log("ParameterRow.addValue     Doing Agua.addStageParameter(stageParameterObject)");
	var stageParameterObject = new Object;
	for ( var key in this.passedArgs )
	{
		if ( key != "core" )
			stageParameterObject[key] = this.passedArgs[key];
	}
	stageParameterObject.value = newValue;
	console.log("ParameterRow.addValue     stageParameterObject: ");
	console.dir({stageParameterObject:stageParameterObject});

	// REMOVE UPLOADER
	delete stageParameterObject.uploader;
	
	// SET USER NAME TO COMPLETE stageparameter UNIQUE KEY
	stageParameterObject.username = Agua.cookie('username');
	
	// ADD STAGE PARAMETER		
	Agua.addStageParameter(stageParameterObject);

	// SET FILE PRESENT CSS
	this.filePresent(node);

	// CHECK TYPE MATCHES E.G., EXPECTED DIRECTORY AND FOUND DIRECTORY
	// IF TYPE DOES NOT MATCH, SET AS INVALID AND REQUIRED
	if ( this.valuetype != type )
		//|| ( this.valuetype == "file" && oldValue != '' )
		//|| ( this.valuetype == "directory" && oldValue != '')  )
	{
		console.log("ParameterRow.addValue     Input types do not match. Doing this.setInvalid(node)");

		// SET THIS INPUT AS VALID
		this.validInput = false;

		// SET VALID CSS
		this.setInvalid(node);

		//// SET INPUT REQUIRED CSS IF essential OR required
		//if ( this.discretion == "essential" || this.discretion == "required" )
		//	this.inputRequired(node);

		// SET STAGE PARAMETER'S isValid AS TRUE
		console.log("ParameterRow.handleCheckfile    File found where directory wanted (or vice-versa). Setting stageParameter.isValid to FALSE");
		Agua.setParameterValidity(this, false);
	}
	else
	{
		console.log("ParameterRow.addValue     Input types match. Doing this.setValid(node)");

		// SET THIS INPUT AS VALID
		this.validInput = true;

		// REMOVE RED BORDER (.infopane .invalid OR .infopane .input .required)
		this.setValid(node);
		
		// SET INPUT SATISFIED CSS
		if ( this.discretion == "essential" || this.discretion == "required" )
			this.inputSatisfied(node);
		
		// SET STAGE PARAMETER'S isValid AS TRUE
		console.log("ParameterRow.handleCheckfile    File found where wanted. Setting stageParameter.isValid to TRUE");
		Agua.setParameterValidity(this, true);
	}
	
	// UPDATE this.validInput AND required|satisfied NODE CSS
	console.log("ParameterRow.handleCheckfile    File found where wanted. Setting stageParameter.isValid to TRUE");

	var thisObj = this;
	setTimeout(function(){
		console.log("ParameterRow.handleCheckfile    Doing setTimeout thisObj.checkFile(" + node + ", " + newValue + ")");
		thisObj.checkFile(node, newValue)
	}, 100, this);

	////////// UPDATE required|satisfied NODE CSS
	
	
	// UPDATE this.validInputs IN PARENT INFOPANE WIDGET
	console.log("ParameterRow.addValue     DOING this.core.parameters.checkValidInputs()");
	this.core.parameters.checkValidInputs();		
},
filePresent : function (node) {
	//console.log("ParameterRow.filePresent(node)");
	//console.log("ParameterRow.filePresent    node: " + node);
	dojo.removeClass(node, 'fileMissing');
	dojo.addClass(node, 'filePresent');
},
fileMissing : function (node) {
	//console.log("ParameterRow.fileMissing(node)");
	//console.log("ParameterRow.fileMissing    node: " + node);
	dojo.removeClass(node, 'filePresent');
	dojo.addClass(node, 'fileMissing');
},
setInvalid : function (node) {
	console.group("ParameterRow-" + this.id + "    setInvalid");
	console.dir({node:node});
	var caller = this.setInvalid.caller.nom;
	console.log("ParameterRow.setInvalid    caller: " + caller);
	console.log("ParameterRow.setInvalid    this.discretion: " + this.discretion);
	
	dojo.addClass(node, 'invalid');
	dojo.addClass(this.domNode, 'invalid');

	if ( this.discretion == "required" || this.discretion == "essential" )
	{
		console.log("ParameterRow.setValid    Setting required");
		dojo.removeClass(node, 'satisfied');
		dojo.addClass(node, 'required');
		dojo.removeClass(this.domNode, 'satisfied');
		dojo.addClass(this.domNode, 'required');
	}

	console.groupEnd("ParameterRow-" + this.id + "    setInvalid");
},
setValid : function (node) {
	console.group("ParameterRow-" + this.id + "    setValid");
	console.dir({node:node});
	var caller = this.setValid.caller.nom;
	console.log("ParameterRow.setValid    caller: " + caller);
	console.log("ParameterRow.setValid    this.discretion: " + this.discretion);
	
	dojo.removeClass(node, 'invalid');
	dojo.removeClass(this.domNode, 'invalid');

	if ( this.discretion == "essential"
		|| this.discretion == "required" )
	{
		console.log("ParameterRow.setValid    Setting satisfied");
		dojo.removeClass(node, 'required');
		dojo.addClass(node, 'satisfied');
		dojo.removeClass(this.domNode, 'required');
		dojo.addClass(this.domNode, 'satisfied');
	}

	console.groupEnd("ParameterRow-" + this.id + "    setValid");
},
/////////	TOGGLE 
setToggle : function () {
	// CONNECT TOGGLE EVENT
	var parameterRowObject = this;
	dojo.connect( this.nameNode, "onclick", function(event) {
		////console.log("ParameterRow.setToggle    fired event");
		event.stopPropagation();
		parameterRowObject.toggle();
	});
},
toggle : function () {
	////////console.log("ParameterRow.toggle    plugins.workflow.ParameterRow.toggle()");
	////console.log("ParameterRow.toggle    this.description: " + this.description);
	////console.log("ParameterRow.toggle    this.paramtype: " + this.paramtype);
	
	// TOGGLE HIDDEN TABLE
	// TO MAKE LAST ROW TAKE UP ALL OF THE REMAINING SPACE
	if ( this["hidden"].style.display == 'table' ) this["hidden"].style.display='none';
	else this["hidden"].style.display = 'table';

	// TOGGLE HIDDEN ELEMENTS
	//var array = [ "description", "notes" ];
	var array = ["descriptionNode", "typeNode", "typeTitle"];
	for ( var i in array )
	{
		if ( this[array[i]].style.display == 'table-cell' ) this[array[i]].style.display='none';
		else this[array[i]].style.display = 'table-cell';
	}
	
	// DO SPECIAL TOGGLE FOR UPLOAD AND BROWSE BUTTONS
	// DEPENDING ON PARAMETER TYPE: file OR directory
	var buttons;
	var end = 0;
	if ( this.paramtype == "input" )
	{
		buttons = ["browseButton", "downloadButton", "uploadButton", "fileInputMask"];
		if ( this.valuetype == "file" || this.valuetype == "files" )	end = 4;
		if ( this.valuetype == "directory" || this.valuetype == "directories" )	end = 1;
		//if ( this.valuetype == "integer" )	end = 0;
		//if ( this.valuetype == "string" )	end = 0;
		//if ( this.valuetype == "flag" )	end = 0;
		
		// REMOVE UPLOAD IF this.core.parameters SHARED IS TRUE
		if ( this.core.parameters.shared == true
				&& end == 4 )
		{
			end = 2;
		}		
	}
	else if ( this.paramtype == "output" )
	{
		buttons = ["browseButton", "downloadButton"];
		if ( this.valuetype == "file" ) end = 2;
	}
	
	////console.log("ParameterRow.toggle    this.paramtype: " + this.paramtype);
	////console.log("ParameterRow.toggle    buttons: " + dojo.toJson(buttons));
	////console.log("ParameterRow.toggle    this.valuetype: " + this.valuetype);

	// DO TOGGLE
	for ( var i = 0; i < end; i++ )
	{
		//////console.log("ParameterRow.toggle    DOING toggle for this.buttons[" + i + "]");
		////console.log("ParameterRow.toggle    this[" + buttons[i] + "]" + this[buttons[i]]);

		if ( this[buttons[i]].style.display == 'table-cell' ) this[buttons[i]].style.display='none';
		else this[buttons[i]].style.display = 'table-cell';
	}
}

	
});


}

if(!dojo._hasResource["plugins.workflow.Parameters"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.workflow.Parameters"] = true;
dojo.provide("plugins.workflow.Parameters");

// ALLOW THE USER TO ADD, REMOVE AND MODIFY PARAMETERS



// // optimize: load dijit layer



// HAS A


dojo.declare("plugins.workflow.Parameters",
	[ dijit._Widget, dijit._Templated, plugins.core.Common ],
{

//Path to the template of this widget. 
templateString:"<div dojoattachpoint=\"containerNode\">\n\n    <div\n        dojoAttachPoint=\"mainTab\"\n        dojoType=\"dijit.layout.ContentPane\"\n        parseOnLoad=\"false\"\n\t\ttitle=\"Inputs\"\n\t\tclass=\"parameters\"\n\t\tstyle=\"position: relative; height: 100%; max-height: auto !important; min-width: 400px !important; width: auto !important; padding: 0 !important;\"\n    >\n\n\t\t<table width=\"100%\">\n\t\t\t<tr>\n\t\t\t\t<td colspan=\"3\"class=\"tabTitle\" align=\"center\">\n                    Inputs\n\t\t\t\t</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td\n\t\t\t\t\tdojoAttachPoint=\"appNameNode\"\n\t\t\t\t\tcolspan=\"3\"\n\t\t\t\t\tclass=\"appName\"\n\t\t\t\t\talign=\"center\"\n\t\t\t\t\t>\n\t\t\t\t</td>\n\t\t\t</tr>\n\t\t\t\n\t\t\t<tr>\n\t\t\t\t<td>\n\t\t\t\t\t<div \n\t\t\t\t\t\tdojoType=\"dijit.TitlePane\"\n\t\t\t\t\t\ttitle=\"Inputs\"\n\t\t\t\t\t\tstyle=\"background: #FFF; height: auto; width: 100% !important;\"\n\t\t\t\t\t\t>\n\n\t\t\t\t\t\t<div\n\t\t\t\t\t\t\tdojoAttachPoint=\"inputRows\"\n\t\t\t\t\t\t\tclass=\"inputRows\"\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t</div>\n\n\t\t\t\t\t</div>\n\t\t\t\t</td>\n\t\t\t\t<td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td>\n\t\t\t\t\t<div\n\t\t\t\t\t\tdojoType=\"dijit.TitlePane\"\n\t\t\t\t\t\ttitle=\"Outputs\"\n\t\t\t\t\t\tclass=\"outputsTitlePane\"\n\t\t\t\t\t\tstyle=\"background: #FFF; height: auto; width: 100% !important;\"\n\t\t\t\t\t\t>\n\t\t\t\t\t\t<div\n\t\t\t\t\t\t\tdojoAttachPoint=\"outputRows\"\n\t\t\t\t\t\t\tclass=\"outputRows\"\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</td>\n\t\t\t</tr>\n\t\t</table>\n\t\t\t\t\n\t</div>\n\n\t\n</div> \n\n\n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

// OR USE @import IN HTML TEMPLATE
cssFiles : [ dojo.moduleUrl("plugins", "workflow/css/parameters.css") ],

// PARENT WIDGET
parentWidget : null,

// ARRAY OF CHILD WIDGETS
childWidgets : null,

// isVALID BOOLEAN: ALL PARAMETERS ARE VALID
isValid : null,
// CORE WORKFLOW OBJECTS
core : null,

/////}
constructor : function(args) {
	////////console.log("Parameters.constructor     plugins.workflow.Parameters.constructor");			
	this.core = args.core;

	// LOAD CSS
	this.loadCSS();		
},
postCreate : function() {
	////////console.log("Controller.postCreate    plugins.workflow.Controller.postCreate()");

	this.startup();
},
startup : function () {
// DO inherited, LOAD ARGUMENTS AND ATTACH THE MAIN TAB TO THE ATTACH NODE
	////////console.log("Parameters.startup    plugins.workflow.Parameters.startup()");

	// COMPLETE CONSTRUCTION OF OBJECT
	this.inherited(arguments);	 

	////////console.log("Parameters.startup    this.application: " + this.application);
	////////console.log("Parameters.startup    this.attachNode: " + this.attachNode);

	this.setUploader();

	// ADD TO TAB CONTAINER		
	this.attachNode.addChild(this.mainTab);
	this.attachNode.selectChild(this.mainTab);
},
setUploader : function () {

	var uploaderId = dijit.getUniqueId("plugins_form_Uploader");
	//////console.log("Parameter.setUploader     uploaderId: " + uploaderId);
	var username = Agua.cookie('username');
	var sessionid = Agua.cookie('sessionid');
	this.uploader = new plugins.form.Uploader(
	{
		uploaderId: uploaderId,
		username: 	username,
		sessionid: 	sessionid
	});
},
clear : function () {
// CLEAR THE INPUT AND OUTPUT PANES
	////////console.log("Parameters.hide    plugins.workflow.Parameters.hide()");
	this.mainTab.style.visibility = "hidden";	

	this.appNameNode.innerHTML = '';

	while ( this["inputRows"].firstChild )
	{
		this["inputRows"].removeChild(this["inputRows"].firstChild);
	}
	while ( this["outputRows"].firstChild )
	{
		this["outputRows"].removeChild(this["outputRows"].firstChild);
	}
},
resetChainedOutputs : function (chainedOutputs) {
	////console.log("XXXX Parameters.resetChainedOutputs    Parameters.resetChainedOutputs(chainedOutputs");	
	////console.log("xxx Parameters.resetChainedOutputs    chainedOutputs.length: " + chainedOutputs.length);
	////console.log("Parameters.resetChainedOutputs    this.childWidgets.length: " + this.childWidgets.length);
	var thisObject = this;
	dojo.forEach(chainedOutputs, function(chainedOutput, i) {
		////console.log("Parameters.resetChainedOutputs    chainedOutput " + i + ": " + chainedOutputs[i]);
		if ( chainedOutput == null )
		{
			////console.log("Parameters.resetChainedOutputs    chainedOutput is null. NEXT");
			return;
		}
        var chainedValue = chainedOutput.value;
	////console.log("Parameters.resetChainedOutputs    chainedValue " + i + ": " + chainedValue);
		thisObject.setOutputValue(chainedValue)
	});
},
setOutputValue : function (chainedValue) {
	////console.log("Parameters.setOutputValue    Parameters.setOutputValue(chainedValue)");
	////console.log("Parameters.setOutputValue    chainedValue: " + chainedValue);
	////console.log("Parameters.setOutputValue    this.childWidgets.length: " + this.childWidgets.length);
	////console.log("Parameters.setOutputValue    ////console.dir(this): " + this.childWidgets.length);
	var thisObject = this;
	dojo.forEach(thisObject.childWidgets, function(parameterRow, j) { 
		////console.log("Parameters.setOutputValue    parameterRow" + j + " '" + parameterRow.name + "'" + "[" + parameterRow.paramtype + "]: " + parameterRow.value);
		if ( parameterRow.paramtype == "input" )    return;
////console.log("HERE");
		if ( chainedValue == null || chainedValue == '')   return;
		if ( chainedValue != parameterRow.value )
		{
			////console.log("Parameters.setOutputValue    Setting parameterRow.value: " + chainedValue);
			parameterRow.value = chainedValue;
			parameterRow.valueNode.innerHTML = chainedValue;
			return;
		}
    });
},
load : function (node, shared, force) {
// LOAD APPLICATION DATA INTO INPUT AND OUTPUT TITLE PANES
	//////console.log("Parameters.load    plugins.workflow.Parameters.load(node, shared, force)");
	//////console.log("Parameters.load    node: " + node);
	//////console.log("Parameters.load    shared: " + shared);
	//////console.log("Parameters.load    force: " + force);
	////////console.log("Parameters.load    node.parentWidget: " + node.parentWidget);
	//console.log("Parameters.load    node.stageRow: " + node.stageRow);

	console.log("Parameters.load    PASSED node.application:");
	console.dir({node_application:node.application});	

	// SET DEFAULT force = FALSE
	if ( force == null)	force = false;

	// SET this.shared
	this.shared = shared;

	// SET this.parentNode
	this.parentNode = node;
	this.parentWidget = node.parentWidget;
	//////console.log("Parameters.load    this.parentWidget: " + this.parentWidget);

	// SET this.stageRow
	if ( node.stageRow ) this.stageRow = node.stageRow;
	else this.stageRow = node.parentWidget;
	if ( this.stageRow == null && node.childNodes )
	{
		this.stageRow = dijit.byNode(node.childNodes[0]);
	}
	////////console.log("Parameters.load    node.stageRow: " + node.stageRow);
	////////console.log("Parameters.load    node.parentWidget: " + node.parentWidget);
	////////console.log("Parameters.load    node.childNodes[0]: " + node.childNodes[0]);
	////////console.log("Parameters.load    this.stageRow: " + this.stageRow);
	////////console.log("Parameters.load    dijit.getEnclosingWidget(node.childNodes[0]: " + dijit.getEnclosingWidget(node.childNodes[0]));

	// SET this.application
	this.application = node.application;
	if ( node.application == null )
	{
		console.log("Parameters.load     node.application is null. Using node.parentWidget.application");
		//this.application = this.parentWidget.getApplication();
		this.application = node.parentWidget.application;
	}

	console.log("Parameters.load    AFTER node.application:");
	console.dir({node_application:node.application});

	////////console.log("Parameters.load     this.application: " + dojo.toJson(this.application, true));
	////////console.log("Parameters.load     ////////console.dir(this):");
	////////console.dir(this);
	////////console.log("Parameters.load     this.childWidgets: " + this.childWidgets);
//
	// INITIALISE this.childWidgets
	if ( this.childWidgets == null ) this.childWidgets = new Array;

	// DESTROY ANY EXISTING ParameterRow CHILD WIDGETS
	while ( this.childWidgets.length > 0 )
	{
		var widget = this.childWidgets.splice(0,1)[0];
		if ( widget.destroy )	widget.destroy();
	}
	////////console.log("Parameters.load     AFTER widget.destroy(), this.childWidgets.length: " + this.childWidgets.length);
	
	// SET PANE TITLE
	this.appNameNode.innerHTML = this.application.number + ". " + this.application.name;

	// LOAD INPUT TITLE PANE
	////////console.log("Parameters.load     BEFORE this.loadTitlePane(****************** input ******************, shared)");
	this.loadTitlePane("input", shared);

	// LOAD OUTPUT TITLE PANE
	////////console.log("Parameters.load     BEFORE this.loadTitlePane(****************** output ******************, shared)");
	this.loadTitlePane("output", shared);

	// SELECT THIS TAB PANE
	this.attachNode.selectChild(this.mainTab);

	// CALL StageRow.checkValidParameters TO CHECK THAT ALL
	// REQUIRED PARAMETER INPUTS ARE SATISFIED
	var stageRow = node.parentWidget;
	////console.log("Parameters.load     stageRow: " + stageRow);
	////////console.log("Parameters.load     node: " + node);
	////////console.dir(node);
	
	// DON'T IGNORE STORED Agua.getParameterValidity DATA
	// USE THE UPDATED Agua.getParameterValidity DATA TO SET CSS 
	// CLASSES OF PARAMETER ROWS
	console.log("Parameters.load     BEFORE stageRow.checkValidParameters()");
	if ( ! shared )
		stageRow.checkValidParameters(force);
	console.log("Parameters.load     AFTER stageRow.checkValidParameters()");

	//////// USE THE UPDATED Agua.getParameterValidity DATA TO SET CSS 
	//////// CLASSES OF PARAMETER ROWS
	////////this.setParameterRowStyles();

	console.log("Parameters.load     END");
},
setParameterRowStyles : function () {
	console.group("Parameters-" + this.id + "    setParameterRowStyles");
	console.log("Parameters.setParameterRowStyles    caller: " + this.setParameterRowStyles.caller.nom);
	
	var parameterRows = this.childWidgets;
	var parameterHash = new Object;
	for ( var i = 0; i < parameterRows.length; i++ )
	{
		////console.log("Parameters.setParameterRowStyles     parameterRows[" + i + "]: "+ parameterRows[i]);
		//////console.log("Parameters.setParameterRowStyles     " + parameterRows[i].name + ", parameterRows[" + i + "].paramtype: " + parameterRows[i].paramtype);
		if ( parameterRows[i].paramtype == "input" ) 
			parameterHash[parameterRows[i].name] = parameterRows[i];
	}
	console.log("Parameters.setParameterRowStyles     parameterRows:");
	console.dir({parameterRows:parameterRows});

	////////console.log("Parameters.setParameterRowStyles     this.application: " + dojo.toJson(this.application, true));
	var stageParameters = Agua.getStageParameters(this.application);
	////////console.log("Parameters.setParameterRowStyles     stageParameters: " + dojo.toJson(stageParameters, true));
	//////console.log("Parameters.setParameterRowStyles     stageParameters.length: " + stageParameters.length);
	for ( var i = 0; i < stageParameters.length; i++ )
	{
		if ( stageParameters[i].paramtype != "input" ) continue;

		var parameterRow = parameterHash[stageParameters[i].name];
		////console.log("Parameters.setParameterRowStyles    stageParameters[i] " + stageParameters[i].name + " (paramtype: " + stageParameters[i].paramtype + ") parameterRow: " + parameterRow);

		var isValid = Agua.getParameterValidity(stageParameters[i]);
		//////console.log("Parameters.setParameterRowStyles     stageParameters[" + i + "] '" + stageParameters[i].name + "' isValid: " + isValid);
		if ( isValid == true || isValid == null )
		{
			//////console.log("Parameters.setParameterRowStyles     Doing parameterRows[" + i +  "].setValid()");
			parameterRow.setValid(parameterRow.domNode);
		}
		else
		{
			parameterRow.setInvalid(parameterRow.domNode);
		}
	}	

	console.groupEnd("Parameters-" + this.id + "    setParameterRowStyles");
},
loadTitlePane : function (paneType) {
	//console.log("Parameters.loadTitlePane    plugins.workflow.Parameters.loadTitlePane(paneType)");
	//console.log("Parameters.loadTitlePane    paneType: " + paneType);

	var paneRows = paneType + "Rows";

	// DEBUG
	//var stageParameters = Agua._getStageParameters();
	////////console.log("Parameters.loadTitlePane    START stageParameters.length:" + stageParameters.length);

	// CLEAR PANE
	while ( this[paneRows].firstChild )
		this[paneRows].removeChild(this[paneRows].firstChild);

	////////console.log("Parameters.loadTitlePane    this.application:" + dojo.toJson(this.application));
	var stageObject = {
		username: this.application.username,
		project: this.application.project,
		workflow: this.application.workflow,
		workflownumber: this.application.workflownumber,
		submit: this.application.submit,
		name: this.application.name,
		number: this.application.number   // NB: SWITCH FROM number TO appnumber
	};
	//////console.log("Parameters.loadTitlePane    stageObject:" + dojo.toJson(stageObject, true));

	if ( paneType == "input" )
		this.addSubmit(dojo.clone(stageObject), paneRows);
		
	// GET OUTPUTS FROM Agua.stageparameters	
	var parameters;
	if ( this.shared == true )
	{
		////////console.log("Parameters.loadTitlePane     DOING parameters = Agua.getSharedStageParameters(stageObject)");
		parameters = Agua.getSharedStageParameters(stageObject);
	}
	else
	{
		////////console.log("Parameters.loadTitlePane     DOING parameters = Agua.getStageParameters(stageObject)");
		parameters = Agua.getStageParameters(stageObject);
	}

	// DEBUG
	//stageParameters = Agua._getStageParameters();
	//////console.log("Parameters.loadTitlePane    MIDDLE stageParameters.length:" + stageParameters.length);


	//////console.log("Parameters.loadTitlePane    BEFORE filter parameters:" + dojo.toJson(parameters));
	//////console.log("Parameters.loadTitlePane    BEFORE filter, parameters.length:" + parameters.length);
	//////////console.log("Parameters.loadTitlePane    filter by paramtype:" + paneType);
	parameters = this.filterByKeyValues(parameters, ["paramtype"], [paneType]);
	parameters = this.sortHasharrayByKeys(parameters, ["ordinal","name"]);
	//////console.log("Parameters.loadTitlePane    AFTER filter, parameters.length:" + parameters.length);
	//console.log("Parameters.loadTitlePane     AFTER parameters:" + dojo.toJson(parameters, true));

	// DEBUG
	//stageParameters = Agua._getStageParameters();
	////////console.log("Parameters.loadTitlePane    END stageParameters.length:" + stageParameters.length);


	if ( parameters == null )
	{
		////////////////console.log("Parameters.loadTitlePane     parameters == null. Returning.");
		return;
	}
	
	for ( var i = 0; i < parameters.length; i++ )
	{
		//console.log("Parameters.loadTitlePane    loading parameter " + i + ": " + dojo.toJson(parameters[i]));

		// SET parameter KEY:VALUE PAIRS
		var parameter = new Object;
		for ( var key in parameters[i] )
		{
			// CONVERT '\\\\' INTO '\\'
			if ( parameters[i][key].replace )
				parameter[key] = parameters[i][key].replace(/\\\\/g, '\\');
			else
				parameter[key] = parameters[i][key];
		}
		
		// CONVERT PROJECT AND WORKFLOW VALUES
		var username = Agua.cookie('username');
		if ( parameter.value == null )	parameter.value = '';
		else {
			parameter.value = String(parameter.value);
			parameter.value = parameter.value.replace(/%username%/, username);
			parameter.value = parameter.value.replace(/%project%/, parameter.project);
			parameter.value = parameter.value.replace(/%workflow%/, parameter.workflow);
			parameter.value = parameter.value.replace(/%username%/, Agua.cookie('username'));
		}

		// ADD CORE LIST
		parameter.core = this.core;
		parameter.uploader = this.uploader;
		
		// INSTANTIATE plugins.workflow.ParameterRow
		////////////console.log("Parameters.loadTitlePane    Doing new plugins.workflow.ParameterRow(parameter)");
		var ParameterRow = new plugins.workflow.ParameterRow(parameter);
		this[paneRows].appendChild(ParameterRow.domNode);
		////////////console.log("Parameters.loadTitlePane    AFTER new plugins.workflow.ParameterRow(parameter)");
		// PUSH ONTO ARRAY OF CHILD WIDGETS
		this.childWidgets.push(ParameterRow);
	}	
	////console.log("Parameters.loadTitlePane    END");
},
addSubmit : function (stageObject, paneRows) {
	//console.group("Parameters-" + this.id + "    addSubmit")
	//console.log("Parameters.addSubmit    workflow.Parameters.addSubmit(stageObject, paneRows)");
	//console.dir({stageObject:stageObject});
	var stageRow = this.stageRow;
	//console.log("Parameters.addSubmit    stageRow: " + stageRow);
	//console.dir({stageRow:stageRow});
	//console.dir({thisApplication:this.application});
	//console.log("Parameters.addSubmit    paneRows.length: " + paneRows.length);
	
	var submitParameter = stageObject;
	submitParameter.description = "Submit this stage to the cluster (if cluster is defined)"
	submitParameter.discretion = "optional";
	submitParameter.name = "SUBMIT"
	submitParameter.value = this.application.submit;
	submitParameter.paramtype = "input";
	submitParameter.valuetype = "flag";
	if ( ! submitParameter.value )	submitParameter.value = '';
	//console.dir({submitParameter:submitParameter});

	var ParameterRow = new plugins.workflow.ParameterRow(submitParameter);

	var thisObject = this;
	ParameterRow.handleCheckboxOnChange = dojo.hitch(thisObject, function (event) {
		//console.log("Parameters.addSubmit    ParameterRow.handleCheckboxOnChange    event.target: " + event.target);
		//console.log("Parameters.addSubmit    ParameterRow.handleCheckboxOnChange    event.target.checked: " + dojo.toJson(event.target.checked));
		event.stopPropagation(); 
		//console.log("Parameters.addSubmit    ParameterRow.handleCheckboxOnChange    Doing thisObject.updateSubmit()");
		stageObject.submit = 0;
		if ( event.target.checked == true )
			stageObject.submit = 1;
		//console.log("Parameters.addSubmit    ParameterRow.handleCheckboxOnChange    stageObject.submit: " + stageObject.submit);

		this.application.submit = stageObject.submit;
		//console.log("Parameters.addSubmit    this:");

		//console.log("Parameters.addSubmit    DOING Agua.updateStageSubmit(stageObject)");
 
		this.setStageSubmitStyle(stageRow, stageObject.submit);

		Agua.updateStageSubmit(stageObject)
	
	});

	this[paneRows].appendChild(ParameterRow.domNode);

	//console.groupEnd("Parameters-" + this.id + "    addSubmit")
},
setStageSubmitStyle : function (stageRow, submit) {
	console.group("Parameters-" + this.id + "    setStageSubmitStyle")
	console.group("Parameters.setStageSubmitStyle     stageRow: " + stageRow)
	console.dir({stageRow:stageRow});
	console.group("Parameters.setStageSubmitStyle     submit: " + submit)

	stageRow.setSubmitStyle(submit);

	console.groupEnd("Parameters-" + this.id + "    setStageSubmitStyle")
},
checkValidInputs : function () {
// 1. CHECK VALIDITY OF ALL PARAMETERS, STORE AS this.isValid
// 2. CHANGE StageRow Style ACCORDINGLY	SET stageRow.isValid
// 3. stageRow CALLS Stages.updateRunButton AND TOGGLES 
// 		runWorkflow BUTTON
	////////console.log("Parameters.checkValidInputs     plugins.workflow.Parameters.checkValidInputs()");
	////////console.log("Parameters.checkValidInputs     this: " + this);
	////////console.log("Parameters.checkValidInputs     this.childWidgets.length: " + this.childWidgets.length);

	this.isValid = true;
	for ( var i = 0; i < this.childWidgets.length; i++ )
	{
		if ( this.childWidgets[i].paramtype != "input" )	continue;
		////////console.log("Parameters.checkValidInputs     this.childWidgets[" + i + "] '" + this.childWidgets[i].name + "' * " + this.childWidgets[i].value + " * validInput: " + this.childWidgets[i].validInput);

		if ( this.childWidgets[i].validInput == false )
		{
			////////console.log("Parameters.checkValidInputs     Setting this.isValid to false");
			this.isValid = false;
		
			break;
		}
	}	
	////////console.log("Parameters.checkValidInputs     this.isValid: " + this.isValid);

	// CALL StageRow.checkValidParameters TO CHECK THAT ALL
	// REQUIRED PARAMETER INPUTS ARE SATISFIED
	var stageRow = this.stageRow;
	////////console.log("Parameters.load     stageRow: " + stageRow);
	////////console.log("Parameters.load     Calling stageRow.checkValidParameters()");
	if ( this.stageRow == null )	return;
	
	////////console.log("Parameters.checkValidInputs     FINAL this.isValid: " + this.isValid);
	if ( this.isValid == true ) this.stageRow.setValid();
	else this.stageRow.setInvalid();
},
isCurrentApplication : function (application) {
// RETURN true IF THE application IS IDENTICAL TO THE CURRENT APPLICATION
	var keys = ["project", "workflow", "workflownumber", "name", "number"];
	return ( this._objectsMatchByKey(application,
		this.core.parameters.application, keys) );
}

}); // plugins.workflow.Parameters


}

if(!dojo._hasResource["plugins.workflow.Workflow"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.workflow.Workflow"] = true;
dojo.provide("plugins.workflow.Workflow");

/*	CLASS SUMMARY
 	
	THIS IS THE MAIN CLASS IN THE WORKFLOW PLUGIN WHICH INSTANTIATES ALL THE OTHERS
 
	1. SET LEFT PANE
		Apps.js
		SharedApps.js
	
	2. MIDDLE PANE
		Stages.js --> Target.js/StageRow.js
		
	
	3. RIGHT PANE
		SET STAGES, HISTORY AND SHARED IN 
	


	WIDGET HIERARCHY
		
				1_to_1	   1_to_1	 
		Workflow --> Stages --> Target 
		 |              |
		 |              |1_to_many
		 |              |   
		 | 1_to_1       --> StageRow
		 |                     |
		 |                     | 1_to_1
		 |                     |
		 -----------------> Parameters --> ParameterRow
                                    1_to_many

    CORE MODULES LIST

    core.workflow       =   plugins.workflow.Workflow
    core.parameters  	=   plugins.workflow.Parameters
    core.stages         =   plugins.workflow.Stages
    core.target         =   plugins.workflow.Target
    core.fileManager    =   plugins.workflow.FileManager
    core.apps           =   plugins.workflow.Apps
    core.sharedApps     =   plugins.workflow.SharedApps
    core.sharedWorkflows =   plugins.workflow.SharedWorkflows


-	USAGE SCENARIO 1: CREATION AND LOADING OF A NEW WORKFLOW PANE
	
		--> CREATE RIGHT PANE Parameters.js AS this.Parameters

		--> CREATE MIDDLE PANE Workflows.js VIA ITS METHOD updateDropTarget
	
			--> CREATE DROP TARGET Target.js
		
				--> OVERRIDE onDndDrop TO CONVERT DROPPED NODE
				
					INTO StageRow.js WITH ONCLICK loadParametersPane
		
					(CALLS loadParametersPane METHOD IN Workflow.js
					
					WHICH IN TURN CALLS load METHOD OF Parameters.js
					
			--> CALL loadParametersPane METHOD IN Workflow.js
					
				--> CALLS load METHOD OF Parameters.js

					--> CALLS checkValidParameters IN StageRow

			--> CHECK VALIDITY OF OTHER StageRows (2, 3, 4, ...)

				--> CALL checkValidParameters IN StageRow
			
			--> UPDATE VALIDITY OF Stage.js (RunWorkflow BUTTON)
			

	USAGE SCENARIO 2: USER DROPS APPLICATION INTO TARGET
	
		1. onDndDrop METHOD IN Target.js
		
			--> CONVERTS App.js INTO StageRow.js
		
			--> CALLS loadParametersPane IN Workflow.js 
		
				--> CALLS load IN Parameters.js
				
					--> CALLS checkValidParameters IN StageRow


	USAGE SCENARIO 3: USER UPDATES PARAMETER IN DATA PANE
	
		1. ParameterRow.js CHECKS VALIDITY AND PRESENCE OF FILES
	
			--> CALLS checkValidInputs METHOD OF Parameters.js
			
				GETS this.isValid FROM VALIDITY OF ALL PARAMETERS 
			
				--> CALLS setValid/setInvalid OF StageRow.js 
		
					--> CALLS updateRunButton OF Stages.js
					
						POLL VALIDITY OF ALL StageRows
						
						SET RunWorkflow BUTTON IF ALL STAGES VALID

*/


if ( 1 ) {
// EXTERNAL MODULES

// EXPANDOPANE


// STORE FOR COMBO BOXES


// FILE UPLOAD


// NOTES EDITOR









// WIDGETS AND TOOLS FOR EXPANDO PANE













// DnD
 // Source & Target




// Menu


// TIMER


// TOOLTIP


// TOOLTIP DIALOGUE





// INHERITED


// LAYOUT WIDGETS



// INTERNAL MODULES

}

dojo.declare( "plugins.workflow.Workflow",
	[ dijit._Widget, dijit._Templated, plugins.core.Common ], {
//Path to the template of this widget. 
templateString:"<div dojoAttachPoint=\"containerNode\">\n\n\t<!-- WORKFLOW TAB -->\n\t<div\n\t\tdojoAttachPoint=\"mainTab\"\n\t\tclass=\"workflow\"\n\t\ticonClass=\"workflowIcon\"\n\t\tminWidth=\"833\"\n\t\tstyle=\"min-width: 965px !important; width: 100% !important; padding: 0px; background: #FFF; min-height: inherit !important;\"\n\t\tclosable=\"true\"\n\t\tdojoType=\"dijit.layout.BorderContainer\"\n\t\ttitle=\"Workflow\"\n\t\tparentWidget=this>\n\n\t\t<div\n\t\t\tdojoAttachPoint=\"leftPaneExpando\"\n\t\t\tdojoType=\"dojox.layout.ExpandoPane\"\n\t\t\tclass=\"leftExpando\"\n\t\t\tstartExpanded=\"true\"\n\t\t\ttitle=\"Tools\"\n\t\t\tregion=\"left\"\n\t\t\tmaxWidth=\"200\"\n\t\t\tstyle=\"width: 200px;\">\n\t\t\t\n\t\t\t<div\n\t\t\t\tdojoAttachPoint=\"leftPane\"\n\t\t\t\tdojoType=\"dijit.layout.TabContainer\"\n\t\t\t\tregion=\"center\"\n\t\t\t\ttabStrip=\"true\">\n\t\t\t</div>\n\t\t\t\n\t\t</div>\n\t\t<div region=\"center\" startExpanded=\"false\" dojoType=\"dijit.layout.ContentPane\">\n\t\t\t\n\t\t\t<div dojoType=\"dijit.layout.BorderContainer\" style=\"height:275px; border: solid #ccc 1px;\">\n\t\t\t\t<div dojoType=\"dojox.layout.ExpandoPane\"\n\t\t\t\t\tdojoAttachPoint=\"middlePaneExpando\"\n\t\t\t\t\t title=\"Controls\"\n\t\t\t\t\t region=\"left\"\n\t\t\t\t\t class=\"middleExpando\"\n\t\t\t\t\t maxWidth=\"265\"\n\t\t\t\t\t style=\"width: 320px;\">\n\t\t\t\t\t<div\n\t\t\t\t\t\tdojoAttachPoint=\"middlePane\"\n\t\t\t\t\t\tdojoType=\"dijit.layout.TabContainer\" region=\"center\" tabStrip=\"true\">\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t\t<div\n\t\t\t\t\tdojoAttachPoint=\"rightPane\"\n\t\t\t\t\tclass=\"rightExpando\"\n\t\t\t\t\t dojoType=\"dijit.layout.TabContainer\" region=\"center\" tabStrip=\"true\">\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t\n\t\t\t\n\t\t</div>\n\n\t</div>\n\t<!-- END OF WORKFLOW TAB -->\n\n\n</div>\n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

// CSS FILE FOR BUTTON STYLING
cssFiles : [
    dojo.moduleUrl("plugins") + "workflow/css/workflow.css",
    dojo.moduleUrl("plugins") + "workflow/css/history.css",
    dojo.moduleUrl("plugins") + "workflow/css/shared.css",
    dojo.moduleUrl("dojox") + "layout/resources/ExpandoPane.css",
    dojo.moduleUrl("dijit") + "themes/tundra/tundra.css"
	
    //dojo.moduleUrl("plugins", "workflow/css/workflow.css"),
],

// PARENT NODE, I.E., TABS NODE
attachWidget : null,

// PROJECT NAME AND WORKFLOW NAME IF AVAILABLE
project : null,
workflow : null,

// POLL SERVER FOR WORKFLOW STATUS
polling : false,

// INSERT TEXT BREAKS WIDTH, CORRESPONDS TO CSS WIDTH OF INPUT 'value' TABLE ELEMENT
textBreakWidth : 22,

// plugins.workflow.FileManager
fileManager : null,

// CORE WORKFLOW OBJECTS
core : new Object,

// LOAD PANELS
// loadPanels: array of names of panels to be loaded
loadPanels : null,

////}}}
constructor : function(args) {
// LOAD CSS
	this.loadCSS();
	
	// SET ARGS
	this.attachWidget = Agua.tabs;

	if ( args != null )
	{
		this.
		project = args.project;
		this.workflow = args.workflow;
	}
	
	// SET CORE CLASSES
	this.core.workflow = this;

	// SET LOAD PANELS
	this.setLoadPanels(args);
},
postCreate: function() {
	this.startup();
},
startup : function () {
// SET UP THE ELEMENT OBJECTS AND THEIR VALUE FUNCTIONS
	this.inherited(arguments);

    // ADD THIS WIDGET TO Agua
    Agua.addWidget("workflow", this);

	// ADD THE PANE TO THE TAB CONTAINER
	this.attachWidget.addChild(this.mainTab);
	this.attachWidget.selectChild(this.mainTab);

	// INSTANTIATE MODULES	
	var modules = [
		[ "plugins.workflow.Apps", "apps", this.leftPane ]
		, [ "plugins.workflow.SharedApps", "sharedApps", this.leftPane ]
		, [ "plugins.workflow.Parameters", "parameters", this.rightPane ]
		, [ "plugins.workflow.Grid", "grid", this.middlePane ]
		, [ "plugins.workflow.UserWorkflows", "userWorkflows", this.middlePane ]
		, [ "plugins.workflow.SharedWorkflows", "sharedWorkflows", this.middlePane ]
		, [ "plugins.workflow.History", "historyPane", this.middlePane ]
		, ["plugins.workflow.RunStatus.Status", "runStatus", this.rightPane ]
	];
	
	for ( var i = 0; i < modules.length; i++ )
	{
		var module = modules[i];

		if ( this.loadPanels && ! this.loadPanels[module[1].toLowerCase()] ) {
			console.log("Workflow.startup    Skipping panel: " + module[1]);
			continue;
		}

		this.setCoreWidget(module[0], module[1], module[2]);
	}

	// CLOSE LEFT PANE / MIDDLE PANE
	//this.leftPaneExpando.toggle();
	//this.middlePaneExpando.toggle();

	// SET PROJECT COMBO IF this.project IS DEFINED
	console.log("Workflow.startup    BEFORE this.core.userWorkflows.setProjectCombo()");
	console.log("Workflow.startup    this.project: " + this.project);
	console.log("Workflow.startup    this.workflow: " + this.workflow);
	
	if ( this.project != null && this.core.userWorkflows != null )
		this.core.userWorkflows.setProjectCombo(this.project, this.workflow);
},
setCoreWidget : function (moduleName, name, pane) {
// INSTANTIATE A moduleName WIDGET AND SET IT AS this.core.name
	console.log("Workflow.setCoreWidget    moduleName: " + moduleName);
	//console.log("Workflow.setCoreWidget    name: " + name);
	//console.log("Workflow.setCoreWidget    pane: " + pane);

	console.log("Workflow.setCoreWidget    BEFORE dojo.require moduleName: " + moduleName);
	dojo["require"](moduleName);
	console.log("Workflow.setCoreWidget    AFTER dojo.require moduleName: " + moduleName);
	
	if ( this[name] != null ) return;

	var module = dojo.getObject(moduleName);
	this[name] = new module(
	{
		attachNode : pane,
		parentWidget: this,
		core: this.core
	});
	console.log("Workflow.setCoreWidget    this[" + name + "]: " + this[name]);

	this.core[name] = this[name];
},
setParameters : function () {
// SET DATA TAB IN INFO PANE BY INSTANTIATING Parameters OBJECT
	////console.log("Workflow.setParameters    plugins.workflow.Stages.setParameters()");
	this.core.parameters = new plugins.workflow.Parameters({
		attachNode : this.rightPane,
		parentWidget: this,
		core: this.core
	});
	////console.log("Workflow.setParameters    this.core.parameters: ");
	////console.dir({this_core_parameters:this.core.parameters});
},
destroyRecursive : function () {
	console.log("Workflow.destroyRecursive    this.mainTab: ");
	console.dir({this_mainTab:this.mainTab});

	if ( Agua && Agua.tabs )
		Agua.tabs.removeChild(this.mainTab);
	
	this.inherited(arguments);
}


}); // end of plugins.workflow.Workflow


}

if(!dojo._hasResource["plugins.workflow.Controller"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.workflow.Controller"] = true;
dojo.provide("plugins.workflow.Controller");

// OBJECT:  plugins.workflow.Controller
// PURPOSE: GENERATE AND MANAGE Workflow PANES

// INHERITS


// HAS


dojo.declare( "plugins.workflow.Controller",
	[ dijit._Widget, dijit._Templated, plugins.core.Common ], {

name: "plugins.workflow.Controller",
version : "0.01",
url : '',
description : "",
dependencies : [
	{	name: "plugins.core.Agua", version: 0.01	}
],


//Path to the template of this widget. 
templateString:"<div dojoAttachPoint=\"containerNode\" class=\"workflow\">\n    <button\n        dojoType=\"dijit.form.Button\"\n        dojoAttachPoint=\"menuButton\"\n        class=\"menuButton\"\n        iconClass=\"workflowIcon\"\n        type=\"button\"\n        label=\"Workflow\"\n        ></button>\n</div>\n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

// CSS FILE FOR BUTTON STYLING
cssFiles : [
	dojo.moduleUrl("plugins") + "workflow/css/controller.css",
	dojo.moduleUrl("plugins") + "workflow/css/workflow.css"
],

// ARRAY OF TAB PANES
tabPanes : [],

////}}}
constructor : function(args) {
	console.log("workflow.Controller.constructor    args:");
	console.dir({args:args});

	// SET INPUTS IF PRESENT
	if ( args.inputs )
		this.inputs = args.inputs;
	
	// LOAD CSS FOR BUTTON
	this.loadCSS();
},
postCreate : function() {
	this.startup();
},
startup : function () {
	//console.log("Controller.startup    plugins.workflow.Controller.startup()");
	//console.log("Controller.startup    Agua: " + Agua);

	this.inherited(arguments);

	// ADD MENU BUTTON TO TOOLBAR
	Agua.toolbar.addChild(this.menuButton);
	
	// SET BUTTON PARENT WIDGET
	this.menuButton.parentWidget = this;
	
	// SET ADMIN BUTTON LISTENER
	var listener = dojo.connect(this.menuButton, "onClick", this, "createTab");
},
createTab : function (args) {
	//console.log("Controller.createTab    plugins.workflow.Controller.createTab");
	console.log("Controller.createTab    args: ");
	console.dir({args:args});

	// CLEAR ANNOYING ALL-SELECTED
	window.getSelection().removeAllRanges();

	if ( args == null ) args = new Object;
	args.attachWidget = Agua.tabs;

	// GET INPUTS
	var inputs = this.inputs;
	args.inputs=	inputs;
	
	// CREATE WIDGET	
	var widget = new plugins.workflow.Workflow(args);
	//var widget;
	//if ( ! inputs )
	//	widget = new plugins.workflow.Workflow(args);
	//else
	//	widget = new plugins.workflow.Workflow({inputs:inputs});


	this.tabPanes.push(widget);

	// ADD TO _supportingWidgets FOR INCLUSION IN DESTROY	
	this._supportingWidgets.push(widget);
},
refreshTabs : function () {
    console.log("workflow.Controller.refreshTabs    Populating this.tabPanes");
    console.log("workflow.Controller.refreshTabs    BEFORE this.tabPanes: ");
    console.dir({this_tabPanes:this.tabPanes});

	var thisObject = this;
	dijit.registry.byClass("plugins.workflow.Workflow").forEach(function(workflow) {
		console.log("workflow: " + workflow);
		console.dir({workflow:workflow});
		thisObject.tabPanes.push(workflow);    
	});
    
    console.log("workflow.Controller.refreshTabs    AFTER this.tabPanes: ");
    console.dir({this_tabPanes:this.tabPanes});
}

}); // end of Controller

//dojo.addOnLoad( function() {
//		// CREATE TAB
//		Agua.controllers["workflow"].createTab();		
//	}
//);

}

if(!dojo._hasResource["dojox.mdnd.Moveable"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.mdnd.Moveable"] = true;
dojo.provide("dojox.mdnd.Moveable");

dojo.declare(
	"dojox.mdnd.Moveable",
	null,
{
	// summary:
	//		Allow end-users to track a DOM node into the web page

	// handle: DOMNode
	//		The node on which the user clicks to drag the main node.
	handle: null,
	
	// skip: Boolean
	// 		A flag to control a drag action if a form element has been focused.
	//		If true, the drag action is not executed.
	skip: true,

	// dragDistance: Integer
	//		The user clicks on the handle, but the drag action will really begin
	//		if he tracks the main node to more than 3 pixels.
	dragDistance: 3,
	
	constructor: function(/*Object*/params, /*DOMNode*/node){
		// summary:
		// 		Configure parameters and listen to mousedown events from handle
		//		node.
		// params:
		//		Hash of parameters
		// node:
		//		The draggable node

		//////console.log("dojox.mdnd.Moveable ::: constructor");
		this.node = dojo.byId(node);
		
		this.d = this.node.ownerDocument;
		
		if(!params){ params = {}; }
		this.handle = params.handle ? dojo.byId(params.handle) : null;
		if(!this.handle){ this.handle = this.node; }
		this.skip = params.skip;
		this.events = [
			dojo.connect(this.handle, "onmousedown", this, "onMouseDown")
		];
		if(dojox.mdnd.autoScroll){
			this.autoScroll = dojox.mdnd.autoScroll;
		}
		
	},
	
	isFormElement: function(/*DOMEvent*/ e){
		// summary:
		//		identify the type of target node associated with a DOM event.
		// e:
		//		a DOM event
		// returns:
		//		if true, the target is one of those specific nodes.

		//////console.log("dojox.mdnd.Moveable ::: isFormElement");
		var t = e.target;
		if(t.nodeType == 3 /*TEXT_NODE*/){
			t = t.parentNode;
		}
		return " a button textarea input select option ".indexOf(" " + t.tagName.toLowerCase() + " ") >= 0;	// Boolean
	},
	
	onMouseDown: function(/*DOMEvent*/e){
		// summary:
		//		Occurs when the user clicks on the handle node.
		//		Skip the drag action if a specific node is targeted.
		//		Listens to mouseup and mousemove events on to the HTML document.
		// e:
		//		a DOM event
		// tags:
		//		callback

		//////console.log("dojox.mdnd.Moveable ::: onMouseDown");
		if(this._isDragging){ return;}
		var isLeftButton = dojo.isIE ? (e.button == 1) : (e.which == 1);
		if(!isLeftButton){
			return;
		}
		if(this.skip && this.isFormElement(e)){ return; }
		if(this.autoScroll){
			this.autoScroll.setAutoScrollNode(this.node);
			this.autoScroll.setAutoScrollMaxPage();
		}
		this.events.push(dojo.connect(this.d, "onmouseup", this, "onMouseUp"));
		this.events.push(dojo.connect(this.d, "onmousemove", this, "onFirstMove"));
		this._selectStart = dojo.connect(dojo.body(), "onselectstart", dojo.stopEvent);
		this._firstX = e.clientX;
		this._firstY = e.clientY;
		dojo.stopEvent(e);
	},
	
	onFirstMove: function(/*DOMEvent*/e){
		// summary:
		//		Occurs when the user moves the mouse after clicking on the
		//		handle.
		//		Determinate when the drag action will have to begin (see
		//		dragDistance).
		// e:
		//		A DOM event
		// tags:
		//		callback

		//////console.log("dojox.mdnd.Moveable ::: onFirstMove");
		dojo.stopEvent(e);
		var d = (this._firstX - e.clientX) * (this._firstX - e.clientX)
				+ (this._firstY - e.clientY) * (this._firstY - e.clientY);
		if(d > this.dragDistance * this.dragDistance){
			this._isDragging = true;
			dojo.disconnect(this.events.pop());
			dojo.style(this.node, "width", dojo.contentBox(this.node).w + "px");
			this.initOffsetDrag(e);
			this.events.push(dojo.connect(this.d, "onmousemove", this, "onMove"));
		}
	},
	
	initOffsetDrag: function(/*DOMEvent*/e){
		// summary:
		//		Initialize the gap between main node coordinates and the clicked point.
		//		Call the onDragStart method.
		// e:
		//		A DOM event

		//////console.log("dojox.mdnd.Moveable ::: initOffsetDrag");
		this.offsetDrag = { 'l': e.pageX, 't': e.pageY };
		var s = this.node.style;
		var position = dojo.position(this.node, true);
		/*if(s.position == "relative" || s.position == ""){
			s.position = "absolute"; // enforcing the absolute mode
		}*/
		this.offsetDrag.l = position.x - this.offsetDrag.l;
		this.offsetDrag.t = position.y - this.offsetDrag.t;
		var coords = {
			'x': position.x,
			'y': position.y
		};
		this.size = {
			'w': position.w,
			'h': position.h
		};
		// method to catch
		this.onDragStart(this.node, coords, this.size);
	},
	
	onMove: function(/*DOMEvent*/e){
		// summary:
		//		Occurs when the user moves the mouse.
		//		Calls the onDrag method.
		// e:
		//		a DOM event
		// tags:
		//		callback

		//////console.log("dojox.mdnd.Moveable ::: onMove");
		dojo.stopEvent(e);
		// hack to avoid too many calls to onMove in IE8 causing sometimes slowness
		if(dojo.isIE == 8 && new Date() - this.date < 20){
			return;
		}
		if(this.autoScroll){
			this.autoScroll.checkAutoScroll(e);
		}
		var coords = {
			'x': this.offsetDrag.l + e.pageX,
			'y': this.offsetDrag.t + e.pageY
		};
		var s = this.node.style;
		s.left = coords.x + "px";
		s.top = coords.y + "px";
		
		// method to catch
		this.onDrag(this.node, coords, this.size, {'x':e.pageX, 'y':e.pageY});
		if(dojo.isIE == 8){
			this.date = new Date();
		}
	},
	
	onMouseUp: function(/*DOMEvent*/e){
		// summary:
		//		Occurs when the user releases the mouse
		//		Calls the onDragEnd method.
		// e:
		//		a DOM event

		if (this._isDragging){
			dojo.stopEvent(e);
			this._isDragging = false;
			if(this.autoScroll){
				this.autoScroll.stopAutoScroll();
			}
			delete this.onMove;
			this.onDragEnd(this.node);
			this.node.focus();
 		}
		dojo.disconnect(this.events.pop());
		dojo.disconnect(this.events.pop());
	},
	
	onDragStart: function(/*DOMNode*/node, /*Object*/coords, /*Object*/size){
		// summary:
		//		Stub function.
		//		Notes : border box model
		// node:
		//		a DOM node
		//	coords:
		//		absolute position of the main node
		// size:
		//		an object encapsulating width an height values
		// tags:
		//		callback

	},
	
	onDragEnd: function(/*DOMNode*/node){
		// summary:
		//		Stub function
		//		Notes : Coordinates don't contain margins
		// node:
		//		a DOM node
		// tags:
		//		callback

	},
	
	onDrag: function(/*DOMNode*/node, /*Object*/coords, /*Object*/size, /*Object*/mousePosition){
		// summary:
		//		Stub function.
		//		Notes : border box model for size value, margin box model for coordinates
		// node:
		//		a DOM node
		// coords:
		//		position of the main node (equals to css left/top properties)
		// size:
		//		an object encapsulating width and height values
		// mousePosition:
		//		coordiantes of mouse
		// tags:
		//		callback

	},

	destroy: function(){
		// summary:
		//		Delecte associated events

		// ////console.log("dojox.mdnd.Moveable ::: destroy");
		dojo.forEach(this.events, dojo.disconnect);
		this.events = this.node = null;
	}
});

}

if(!dojo._hasResource["dojox.mdnd.AreaManager"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.mdnd.AreaManager"] = true;
dojo.provide("dojox.mdnd.AreaManager");


dojo.declare(
	"dojox.mdnd.AreaManager",
	null,
{
	// summary:
	//		Drag And Drop manager

	// autoRefresh: Boolean
	//		Enable the refresh of registered areas on drag start.
	autoRefresh: true,


	// areaClass: String
	//		CSS class enabled an area if areaClass is defined
	areaClass: "dojoxDndArea",

	// dragHandleClass: String
	//		CSS class enabled a drag handle.
	dragHandleClass: "dojoxDragHandle",

	constructor: function(){
		// summary:
		//		Constructor of AreaManager class.
		//		Initialize arrays, connects and subscribes.

		//////console.log("dojox.mdnd.AreaManager ::: constructor");
		this._areaList = [];
		this.resizeHandler = dojo.connect(dojo.global,"onresize", this, function(){
			this._dropMode.updateAreas(this._areaList);
		});

		this._oldIndexArea = this._currentIndexArea = this._oldDropIndex = this._currentDropIndex = this._sourceIndexArea = this._sourceDropIndex = -1;
	},

	init: function(){
		// summary:
		//		Initialize the manager by calling the registerByClass method

		//////console.log("dojox.mdnd.AreaManager ::: init");
		this.registerByClass();
	},

	registerByNode: function(/*DOMNode*/area, /*Boolean*/notInitAreas){
		// summary:
		//		To register Dnd Area : insert the DndArea using the specific sort of dropMode.
		// area:
		//		a DOM node corresponding to the Dnd Area
		// notInitAreas:
		//		if false or undefined, init the areas.

		//////console.log("dojox.mdnd.AreaManager ::: registerByNode", area);
		var index = this._getIndexArea(area);
		if(area && index == -1){
			var acceptType = area.getAttribute("accept");
			var accept = (acceptType) ? acceptType.split(/\s*,\s*/) : ["text"];
			var obj = {
				'node': area,
				'items': [],
				'coords': {},
				'margin': null,
				'accept': accept,
				'initItems': false
			};
			dojo.forEach(this._getChildren(area), function(item){
				this._setMarginArea(obj, item);
				obj.items.push(this._addMoveableItem(item));
			}, this);
			this._areaList = this._dropMode.addArea(this._areaList, obj);
			if(!notInitAreas){
				this._dropMode.updateAreas(this._areaList);
			}
			dojo.publish("/dojox/mdnd/manager/register",[area]);
		}
	},

	registerByClass: function(){
		// summary:
		//		Register all Dnd Areas identified by the attribute areaClass :
		//		insert Dnd Areas using the specific sort of dropMode.

		//////console.log("dojox.mdnd.AreaManager ::: registerByClass");
		dojo.query('.'+this.areaClass).forEach(function(area){
			this.registerByNode(area, true);
		}, this);
		this._dropMode.updateAreas(this._areaList);
	},

	unregister: function(/*DOMNode*/area){
		// summary:
		//		Unregister a D&D Area and its children into the AreaManager.
		// area:
		//		A node corresponding to the D&D Area.
		// returns:
		//		True if the area is found and unregistered.

		//////console.log("dojox.mdnd.AreaManager ::: unregister");
		var index = this._getIndexArea(area);
		if(index != -1){
			dojo.forEach(this._areaList[index].items, function(item){
				this._deleteMoveableItem(item);
			}, this);
			this._areaList.splice(index,1);
			// refresh target area
			this._dropMode.updateAreas(this._areaList);
			return true; // Boolean
		}
		return false; // Boolean
	},

	_addMoveableItem: function(/*DOMNode*/node){
		// summary:
		//		Create a draggable item with a DOM node.
		// node:
		//		A child of the D&D Area.
		// returns:
		//		The draggable item.
		// tags:
		//		protected

		//////console.log("dojox.mdnd.AreaManager ::: _addMoveableItem");
		node.setAttribute("tabIndex", "0");
		var handle = this._searchDragHandle(node);
		var moveable = new dojox.mdnd.Moveable({ 'handle': handle, 'skip': true }, node);
		// add a css style :
		dojo.addClass(handle || node, "dragHandle");
		var type = node.getAttribute("dndType");
		var item = {
			'item': moveable,
			'type': type ? type.split(/\s*,\s*/) : ["text"],
			'handlers': [dojo.connect(moveable, "onDragStart", this, "onDragStart")]
		}
		// connect to the uninitialize method of dijit._Widget to delete a moveable before a destruct
		if(dijit && dijit.byNode){
			var widget = dijit.byNode(node);
			if(widget){
				item.type = widget.dndType ? widget.dndType.split(/\s*,\s*/) : ["text"];
				item.handlers.push(
					dojo.connect(widget, "uninitialize", this, function(){
						this.removeDragItem(node.parentNode, moveable.node);
					})
				);
			}
		}
		return item; // Object
	},

	_deleteMoveableItem: function(/*Object*/ objItem){
		// summary:
		//		Delete the Moveable object associated with a node.
		// item:
		//		A moveable Object.
		// tags:
		//		protected

		//////console.log("dojox.mdnd.AreaManager ::: _deleteMoveableItem", objItem);
		// disconnect the handle
		dojo.forEach(objItem.handlers, function(handler){
			dojo.disconnect(handler);
		});
		// delete css style :
		var node = objItem.item.node,
			handle = this._searchDragHandle(node);
		dojo.removeClass(handle || node, "dragHandle");
		// call destroy of Moveable class
		objItem.item.destroy();
	},

	_getIndexArea: function(/*DOMNode*/area){
		// summary:
		//		Get the index of an area.
	 	// area:
	 	//		A moveable Object.
	 	// returns:
	 	//		area index or -1
	 	// tags:
	 	//		protected

		//////console.log("dojox.mdnd.AreaManager ::: _getIndexArea");
		if(area){
			for(var i = 0; i < this._areaList.length; i++){
				if(this._areaList[i].node === area){
					return i;	// Integer
				}
			}
		}
		return -1;	// Integer
	},

	_searchDragHandle: function(/*DOMNode*/node){
		// summary:
		//		Return the node which contains the first specific CSS class handle.
		// node:
		//		A child of the D&D Area.
		// returns:
		//		The drag handle node.
		// tags:
		//		protected

		//////console.log("dojox.mdnd.AreaManager ::: _searchDragHandle");
		if(node){
			var cssArray = this.dragHandleClass.split(' '),
				length = cssArray.length,
				queryCss = "";
			dojo.forEach(cssArray, function(css, i){
				queryCss += "." + css;
				if(i != length - 1){
					queryCss += ", ";
				}
			});
			return dojo.query(queryCss, node)[0]; // DomNode
		}
	},

	addDragItem: function(/*DOMNode*/area, /*DOMNode*/node, /*Integer*/index, /*Boolean*/notCheckParent){
		// summary:
		//		To add an item programmatically.
		// area:
		//		a node corresponding to the D&D Area
		// node:
		//		the node which has to be treated.
		// index:
		//		the place in the area
		// noCheckParent:
		//		if true, doesn't check if node has a parent.
		// returns:
		//		True if the node has been inserted else false.

		//////console.log("dojox.mdnd.AreaManager ::: addDragItem");
		var add = true;
		if(!notCheckParent){
			add = area && node && (node.parentNode === null || (node.parentNode && node.parentNode.nodeType !== 1));
		}
		if(add){
			var indexArea = this._getIndexArea(area);
			if(indexArea !== -1){
				var item = this._addMoveableItem(node),
					items = this._areaList[indexArea].items;
				if(0 <= index && index < items.length){
					var firstListChild = items.slice(0, index),
						lastListChild = items.slice(index, items.length);
					firstListChild[firstListChild.length] = item;
					this._areaList[indexArea].items = firstListChild.concat(lastListChild);
					area.insertBefore(node, items[index].item.node);
				}
				else{
					this._areaList[indexArea].items.push(item);
					area.appendChild(node);
				}
				this._setMarginArea(this._areaList[indexArea], node);
				this._areaList[indexArea].initItems = false;
				return true;	// Boolean
			}
		}
		return false;	// Boolean
	},

	removeDragItem: function(/*DOMNode*/area, /*DOMNode*/node){
		// summary:
		//		Delete a moveable item programmatically. The node is removed from the area.
		// area:
		//		A node corresponding to the DndArea.
		// node:
		//		The node which has to be treated.
		// returns:
		//		the removed node

		//////console.log("dojox.mdnd.AreaManager ::: removeDragItem");
		var index = this._getIndexArea(area);
		if(area && index !== -1){
			var items = this._areaList[index].items;
			for(var j = 0; j < items.length; j++){
				if(items[j].item.node === node){
					this._deleteMoveableItem(items[j]);
					// delete item of the array
					items.splice(j, 1);
					return area.removeChild(node); // Object
				}
			}
		}
		return null;
	},

	_getChildren: function(/*DOMNode*/area){
		// summary:
		//		Get the children of a D&D area.
		// area:
		//		A DnD area.
		// returns:
		//		The children of a DnD area
		// tags:
		//		protected

		//////console.log("dojox.mdnd.AreaManager ::: _getChildren");
		var children = [];
		dojo.forEach(area.childNodes, function(child){
			// delete \n
			if(child.nodeType == 1){
				if(dijit && dijit.byNode){
					var widget = dijit.byNode(child);
					if(widget){
						if(!widget.dragRestriction){
							children.push(child);
						}
					}
					else{
						children.push(child);
					}
				}
				else{
					children.push(child);
				}
			}
		});
		return children;	//Array
	},

	_setMarginArea: function(/*Object*/area,/*DOMNode*/node){
		// summary:
		//		Set the value of margin in the data type of areaManager
		//		only when the margin has never been computed.
		// area:
		//		The object of a D&D Area.
		// node:
		//		The node which contains margins
		// tags:
		//		protected

		//////console.log("dojox.mdnd.AreaManager ::: _setMarginArea");
		if(area && area.margin === null && node){
			area.margin = dojo._getMarginExtents(node);
		}
	},

	findCurrentIndexArea: function(/*Object*/coords, /*Object*/size){
		// summary:
		//		find the nearest target area according to coordinates.
		//		Coordinates are representing by an object : for example, {'x':10,'y':10}
		// coords:
		//		an object encapsulating X and Y position
		// size:
		//		an object encapsulating the area size
		// returns:
		//		an index of area

		//////console.log("dojox.mdnd.AreaManager ::: findCurrentIndexArea");
		this._oldIndexArea = this._currentIndexArea;
		this._currentIndexArea = this._dropMode.getTargetArea(this._areaList, coords, this._currentIndexArea);
		if(this._currentIndexArea != this._oldIndexArea){
			if(this._oldIndexArea != -1){
				this.onDragExit(coords, size);
			}
			if(this._currentIndexArea != -1){
				this.onDragEnter(coords, size);
			}
		}
		return this._currentIndexArea;	//Integer
	},

	_isAccepted: function(/*Array*/ type, /*Array*/ accept){
		// summary:
		//		True if user can drop widget on this node.
		// type:
		//		Array containing item type
		// accept:
		//		Array containing types
		this._accept = false;
		for(var i = 0; i < accept.length; ++i){
			for(var j = 0; j < type.length;++j){
				if(type[j] == accept[i]){
					this._accept = true;
					break;
				}
			}
		}
	},

	onDragStart: function(/*DOMNode*/node, /*Object*/coords, /*Object*/size){
		// summary:
		//		Initialize the drag (see dojox.mdnd.Moveable.initOffsetDrag())
		// node:
		//		The node which is about to be dragged
		// coords:
		//		an object encapsulating X and Y position
		// size:
		//		an object encapsulating width and height values
		// tags:
		//		callback

		//////console.log("dojox.mdnd.AreaManager ::: onDragStart");
		if(this.autoRefresh){
			this._dropMode.updateAreas(this._areaList);
		}

		// Create the cover :
		var _html = (dojo.isWebKit) ? dojo.body() : dojo.body().parentNode;
		if(!this._cover){
			this._cover = dojo.create('div', {
				'class': "dndCover"
			});
			this._cover2 = dojo.clone(this._cover);
			dojo.addClass(this._cover2, "dndCover2");
		}
		var h = _html.scrollHeight+"px";
		this._cover.style.height = this._cover2.style.height = h;
		dojo.body().appendChild(this._cover);
		dojo.body().appendChild(this._cover2);

		this._dragStartHandler = dojo.connect(node.ownerDocument, "ondragstart", dojo, "stopEvent");
		// to know the source
		this._sourceIndexArea = this._lastValidIndexArea = this._currentIndexArea = this._getIndexArea(node.parentNode);
		// delete the dragItem into the source area
		var sourceArea = this._areaList[this._sourceIndexArea];
		var children = sourceArea.items;
		for(var i = 0; i < children.length; i++){
			if(children[i].item.node == node){
				this._dragItem = children[i];
				this._dragItem.handlers.push(dojo.connect(this._dragItem.item, "onDrag", this, "onDrag"));
				this._dragItem.handlers.push(dojo.connect(this._dragItem.item, "onDragEnd", this, "onDrop"));
				children.splice(i,1);
				this._currentDropIndex = this._sourceDropIndex = i;
				break;
			}
		}
		var nodeRef = null;
		if(this._sourceDropIndex !== sourceArea.items.length){
			nodeRef = sourceArea.items[this._sourceDropIndex].item.node;
		}
		// IE7 OPTIMIZATION
		if(dojo.isIE > 7){
			// connect these events on the cover
			this._eventsIE7 = [
				dojo.connect(this._cover, "onmouseover", dojo, "stopEvent"),
				dojo.connect(this._cover, "onmouseout", dojo, "stopEvent"),
				dojo.connect(this._cover, "onmouseenter", dojo, "stopEvent"),
				dojo.connect(this._cover, "onmouseleave", dojo, "stopEvent")
			];
		}

		var s = node.style;
		s.left = coords.x+"px";
		s.top = coords.y+"px";
		// attach the node to the cover
		if(s.position == "relative" || s.position == ""){
			s.position = "absolute"; // enforcing the absolute mode
		}
		this._cover.appendChild(node);

		this._dropIndicator.place(sourceArea.node, nodeRef, size);
		// add a style to place the _dragNode in foreground
		dojo.addClass(node, "dragNode");
		// A dragged node is always draggable in this source area.
		this._accept = true;
		dojo.publish("/dojox/mdnd/drag/start",[node, sourceArea, this._sourceDropIndex]);
	},

	onDragEnter: function(/*Object*/coords, /*Object*/size){
		// summary:
		//		Optionally called by the getTargetArea method of TargetFinder class.
		// coords:
		//		coordinates of the dragged Node.
		// size:
		//		size of the dragged Node.
		// tags:
		//		callback

		//////console.log("dojox.mdnd.AreaManager ::: onDragEnter", coords, size);
		if(this._currentIndexArea === this._sourceIndexArea){
			this._accept = true;
		}
		else{
			this._isAccepted(this._dragItem.type, this._areaList[this._currentIndexArea].accept);
		}
	},

	onDragExit: function(/*Object*/coords, /*Object*/size){
		// summary:
		//		Optionally called by the getTargetArea method of TargetFinder class.
		// coords:
		//		coordinates of the dragged Node.
		// size:
		//		size of the dragged Node.
		// tags:
		//		callback

		//////console.log("dojox.mdnd.AreaManager ::: onDragExit");
		this._accept = false;
	},

	onDrag: function(/*DOMNode*/node, /*Object*/coords, /*Object*/size, /*Object*/mousePosition){
		// summary:
		//		Occurs when the dojo.dnd.Moveable.onDrag is fired.
		//		Search the nearest target area and called the placeDropIndicator
		// node:
		//		The node which is dragged
		// coords:
		//		an object encapsulating X and Y position
		// size:
		//		an object encapsulating width and height values
		// mousePosition:
		//		coordinates of mouse
		// tags:
		//		callback

		////console.log("dojox.mdnd.AreaManager ::: onDrag", node, ",", coords,size);
		var coordinates = this._dropMode.getDragPoint(coords, size, mousePosition);
		this.findCurrentIndexArea(coordinates, size);
		if(this._currentIndexArea !== -1 && this._accept){
			this.placeDropIndicator(coordinates, size);
		}
	},

	placeDropIndicator: function(/*Object*/coords, /*Object*/size){
		// summary:
		//		Search the right place to insert the dropIndicator and display the dropIndicator.
		// coords:
		//		an object encapsulating X and Y position
		// size:
		//		an object encapsulating width and height values
		// returns:
		//		the current drop index

		//////console.log("dojox.mdnd.AreaManager ::: placeDropIndicator");
		//keep old drop Index
		this._oldDropIndex = this._currentDropIndex;
		// calculate all children marker (see VerticalDropMode.initItems())
		var area = this._areaList[this._currentIndexArea];
		if(!area.initItems){
			this._dropMode.initItems(area);
		}
		//get the index where the drop has to be placed.
		this._currentDropIndex = this._dropMode.getDropIndex(area, coords);
		if(!(this._currentIndexArea === this._oldIndexArea && this._oldDropIndex === this._currentDropIndex)){
			this._placeDropIndicator(size);
		}
		return this._currentDropIndex;	//Integer
	},

	_placeDropIndicator: function(/*Object*/size){
		// summary:
		//		place the dropIndicator
		// size:
		//		an object encapsulating width and height values
		// tags:
		//		protected

		var oldArea = this._areaList[this._lastValidIndexArea];
		var currentArea = this._areaList[this._currentIndexArea];
		//refresh the previous area after moving out the drop indicator
		this._dropMode.refreshItems(oldArea, this._oldDropIndex, size, false);
		// place dropIndicator
		var node = null;
		if(this._currentDropIndex != -1){
			node = currentArea.items[this._currentDropIndex].item.node;
		}
		this._dropIndicator.place(currentArea.node, node);
		this._lastValidIndexArea = this._currentIndexArea;
		//refresh the current area after placing the drop indicator
		this._dropMode.refreshItems(currentArea, this._currentDropIndex, size, true);
	},

	onDropCancel: function(){
		// summary:
		//		Cancel the drop.
		//		The dragNode returns into the source.
		// tags:
		//		callback

		//////console.log("dojox.mdnd.AreaManager ::: onDropCancel");
		if(!this._accept){
			var index = this._getIndexArea(this._dropIndicator.node.parentNode);
			if(index != -1){
				this._currentIndexArea = index;
			}
			else{
				// case if the dropIndicator is in the area which has been unregistered during the drag.
				// chose by default the first area.
				this._currentIndexArea = 0;
			}
		}
	},

	onDrop: function(/*DOMNode*/node){
		// summary:
		//		Drop the dragged item where the dropIndicator is displayed.
		// node:
		//		The node which is about to be dropped
		// tags:
		//		callback

		//////console.log("dojox.mdnd.AreaManager ::: onDrop");
		//dropCancel
		this.onDropCancel();
		var targetArea = this._areaList[this._currentIndexArea];
		dojo.removeClass(node, "dragNode");
		var style = node.style;
		style.position = "relative";
		style.left = "0";
		style.top = "0";
		style.width = "auto";
		if(targetArea.node == this._dropIndicator.node.parentNode){
			targetArea.node.insertBefore(node, this._dropIndicator.node);
		}
		else{
			// case if the dropIndicator is in the area which has been unregistered during the drag.
			targetArea.node.appendChild(node);
			this._currentDropIndex = targetArea.items.length;
		}
		// add child into the new target area.
		var indexChild = this._currentDropIndex;
		if(indexChild == -1){
			indexChild = targetArea.items.length;
		}
		var children = targetArea.items;
		var firstListArea = children.slice(0, indexChild);
		var lastListArea = children.slice(indexChild, children.length);
		firstListArea[firstListArea.length] = this._dragItem;
		targetArea.items = firstListArea.concat(lastListArea);

		this._setMarginArea(targetArea, node);
		dojo.forEach(this._areaList, function(obj){
			obj.initItems = false;
		});
		// disconnect onDrop handler
		dojo.disconnect(this._dragItem.handlers.pop());
		dojo.disconnect(this._dragItem.handlers.pop());
		this._resetAfterDrop();
		// remove the cover
		if(this._cover){
			dojo.body().removeChild(this._cover);
			dojo.body().removeChild(this._cover2);
		}
		dojo.publish("/dojox/mdnd/drop",[node, targetArea, indexChild]);
	},

	_resetAfterDrop: function(){
		// summary:
		//		reset manager properties after dropping an item
		// tags:
		//		protected

		this._accept = false;
		this._dragItem = null;
		this._currentDropIndex = -1;
		this._currentIndexArea = -1;
		this._oldDropIndex = -1;
		this._sourceIndexArea = -1;
		this._sourceDropIndex = -1;
		this._dropIndicator.remove();
		if(this._dragStartHandler){
			dojo.disconnect(this._dragStartHandler);
		}
		if(dojo.isIE > 7){
			dojo.forEach(this._eventsIE7, dojo.disconnect);
		}
	},

	destroy: function(){
		// summary:
		//		Destroy the component.

		//////console.log("dojox.mdnd.AreaManager ::: destroy");
		//see implementation of unregister()
		while(this._areaList.length > 0){
			if(!this.unregister(this._areaList[0].node)){
				throw new Error("Error while destroying AreaManager");
			}
		}
		dojo.disconnect(this.resizeHandler);
		this._dropIndicator.destroy();
		this._dropMode.destroy();
		if(dojox.mdnd.autoScroll){
			dojox.mdnd.autoScroll.destroy();
		}
		if(this.refreshListener){
			dojo.unsubscribe(this.refreshListener);
		}
		// destroy the cover
		if(this._cover){
			dojo._destroyElement(this._cover);
			dojo._destroyElement(this._cover2);
			delete this._cover;
			delete this._cover2;
		}
	}
});

if(dijit && dijit._Widget){
	//	Add a new property to widget
	dojo.extend(dijit._Widget, {
		// dndType: String
		//		Defines a type of widget.
		dndType : "text"
	});
}

dojox.mdnd._areaManager = null;
dojox.mdnd.areaManager = function(){
	// summary:
	//		Returns the current areaManager, creates one if it is not created yet.
	if(!dojox.mdnd._areaManager){
		dojox.mdnd._areaManager = new dojox.mdnd.AreaManager();
	}
	return dojox.mdnd._areaManager;	// Object
};

}

if(!dojo._hasResource["dojox.mdnd.DropIndicator"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.mdnd.DropIndicator"] = true;
dojo.provide("dojox.mdnd.DropIndicator");



dojo.declare(
	"dojox.mdnd.DropIndicator",
	null,
{
	// summary:
	//		DropIndicator managment for DnD.

	// node: DOMNode
	//		the drop indicator node
	node : null,
		
	constructor: function(){
		//////console.log("dojox.mdnd.DropIndicator ::: constructor");
		var dropIndicator = document.createElement("div");
		var subDropIndicator = document.createElement("div");
		dropIndicator.appendChild(subDropIndicator);
		dojo.addClass(dropIndicator, "dropIndicator");
		this.node = dropIndicator;
	},
	
	place: function(/*Node*/area, /*Node*/nodeRef, /*Object*/size){
		// summary:
		//		Place the DropIndicator in the right place
		// area:
		//		the dnd targer area node
		// nodeRef:
		//		node where the dropIndicator have to be placed into the area
		// dragNode:
		//		the node which is dragged
		// returns:
		//		the node inserted or null if it crashes

		//////console.log("dojox.mdnd.DropIndicator ::: place");
		if(size){
			this.node.style.height = size.h + "px";
		}
		try{
			if(nodeRef){
				area.insertBefore(this.node, nodeRef);
			}
			else{
				// empty target area or last node => appendChild
				area.appendChild(this.node);
			}
			return this.node;	// DOMNode
		}catch(e){
			return null;
		}
	},
	
	remove: function(){
		// summary:
		//		remove the DropIndicator (not destroy)

		//////console.log("dojox.mdnd.DropIndicator ::: remove");
		if(this.node){
			//FIX : IE6 problem
			this.node.style.height = "";
			if(this.node.parentNode){
				this.node.parentNode.removeChild(this.node);
			}
		}
	},
	 
	destroy: function(){
		// summary:
		//		destroy the dropIndicator

		//////console.log("dojox.mdnd.DropIndicator ::: destroy");
		if(this.node){
			if(this.node.parentNode){
				this.node.parentNode.removeChild(this.node);
			}
			dojo._destroyElement(this.node);
			delete this.node;
		}
	}
});

(function(){
	dojox.mdnd.areaManager()._dropIndicator = new dojox.mdnd.DropIndicator();
}());

}

if(!dojo._hasResource["dojox.mdnd.dropMode.OverDropMode"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.mdnd.dropMode.OverDropMode"] = true;
dojo.provide("dojox.mdnd.dropMode.OverDropMode");



dojo.declare(
	"dojox.mdnd.dropMode.OverDropMode",
	null,
{
	// summary:
	//		Default class to find the nearest target only if the mouse is over an area.

	// _oldXPoint: Integer
	//		used to save a X position
	_oldXPoint: null,

	// _oldYPoint: Integer
	//		used to save a Y position
	_oldYPoint: null,

	// _oldBehaviour: Integer
	//		see getDragpoint()
	_oldBehaviour: "up",

	constructor: function(){
		//console.log("dojox.mdnd.dropMode.OverDropMode ::: constructor");
		this._dragHandler = [
			dojo.connect(dojox.mdnd.areaManager(), "onDragEnter", function(coords, size){
				var m = dojox.mdnd.areaManager();
				if(m._oldIndexArea == -1){
					m._oldIndexArea = m._lastValidIndexArea;
				}
			})
		];

	},

	addArea: function(/*Array*/areas, /*Object*/object){
		// summary:
		//		Add a D&D Area into an array sorting by the x position.
		// areas:
		//		array of areas
		// object:
		//		data type of a DndArea
		// returns:
		//		a sorted area

		//console.log("dojox.mdnd.dropMode.OverDropMode ::: addArea");
		var length = areas.length,
			position = dojo.position(object.node, true);
		object.coords = {'x':position.x, 'y':position.y};
		if(length == 0){
			areas.push(object);
		}
		else{
			var x = object.coords.x;
			for(var i = 0; i < length; i++){
				if(x < areas[i].coords.x){
					for(var j = length-1; j >= i; j--)
						areas[j + 1] = areas[j];
					areas[i] = object;
					break;
				}
			}
			if(i == length){
				areas.push(object);
			}
		}
		return areas;	// Array
	},

	updateAreas: function(/*Array*/areaList){
		// summary:
		//		refresh areas position and size to determinate the nearest area to drop an item
		// description:
		//		the area position (and size) is equal to the postion of the domNode associated.
		// areaList:
		//		array of areas

		//console.log("dojox.mdnd.dropMode.OverDropMode ::: updateAreas");
		var length = areaList.length;
		for(var i = 0; i < length; i++){
			this._updateArea(areaList[i]);
		}
	},

	_updateArea : function(/*Object*/area){
		// summary:
		//		update the D&D area object (i.e. update coordinates of its DOM node)
		// area:
		// 		the D&D area.
		// tags:
		//		protected

		//console.log("dojox.mdnd.dropMode.OverDropMode ::: addArea");
		var position = dojo.position(area.node, true);
		area.coords.x = position.x;
		area.coords.x2 = position.x + position.w;
		area.coords.y = position.y;
	},

	initItems: function(/*Object*/area){
		// summary:
		//		initialize the horizontal line in order to determinate the drop zone.
		// area:
		//		the D&D area.

		//console.log("dojox.mdnd.dropMode.OverDropMode ::: initItems");
		dojo.forEach(area.items, function(obj){
			//get the vertical middle of the item
			var node = obj.item.node;
			var position = dojo.position(node, true);
			var y = position.y + position.h/2;
			obj.y = y;
		});
		area.initItems = true;
	},

	refreshItems: function(/*Object*/area, /*Integer*/indexItem, /*Object*/size, /*Boolean*/added){
		// summary:
		//		take into account the drop indicator DOM element in order to compute horizontal lines
		// area:
		//		a D&D area object
		// indexItem:
		//		index of a draggable item
		// size:
		//		dropIndicator size
		// added:
		//		boolean to know if a dropIndicator has been added or deleted

		//console.log("dojox.mdnd.dropMode.OverDropMode ::: refreshItems", area, indexItem, size, added);
		if(indexItem == -1){
			return;
		}
		else if(area && size && size.h){
			var height = size.h;
			if(area.margin){
				height += area.margin.t;
			}
			var length = area.items.length;
			for(var i = indexItem; i < length; i++){
				var item = area.items[i];
				if(added){
					item.y += height;
				}
				else{
					item.y -= height;
				}
			}
		}
	},

	getDragPoint: function(/*Object*/coords, /*Object*/size, /*Object*/mousePosition){
		// summary:
		//		return coordinates of the draggable item.
		//		- For X point : the x position of mouse
		//		- For Y point : the y position of mouse
		// returns:
		//		an object of coordinates
		// 		examples:{'x':10,'y':10}
		// coords:
		//		an object encapsulating X and Y position
		// size:
		// 		an object encapsulating width and height values
		// mousePosition:
		// 		coordinates of mouse

		////console.log("dojox.mdnd.dropMode.OverDropMode ::: getDragPoint");
		return {			// Object
			'x': mousePosition.x,
			'y': mousePosition.y
			}
	},


	getTargetArea: function(/*Array*/areaList, /*Object*/ coords, /*integer*/currentIndexArea ){
		// summary:
		//		get the nearest D&D area.
		// areaList:
		// 		a list of D&D areas objects
		// coords:
		//		coordinates [x,y] of the dragItem (see getDragPoint())
		// currentIndexArea:
		//		an index representing the active D&D area
		//returns:
		//		the index of the D&D area

		//console.log("dojox.mdnd.dropMode.OverDropMode ::: getTargetArea");
		var index = 0;
		var x = coords.x;
		var y = coords.y;
		var end = areaList.length;
		var start = 0, direction = "right", compute = false;
		if(currentIndexArea == -1 || arguments.length < 3){
			// first time : Need to search the nearest area in all areas.
			compute = true;
		}
		else{
			// check if it's always the same area
			if(this._checkInterval(areaList, currentIndexArea, x, y)){
				index = currentIndexArea;
			}
			else{
				if(this._oldXPoint < x){
					start = currentIndexArea + 1;
				}
				else{
					start = currentIndexArea - 1;
					end = 0;
					direction = "left";
				}
				compute = true;
			}
		}
		if(compute){
			if(direction === "right"){
				for(var i = start; i < end; i++){
					if(this._checkInterval(areaList, i, x, y)){
						index = i;
						break;
					}
				}
				if(i == end){
					index = -1;
				}
			}
			else{
				for(var i = start; i >= end; i--){
					if(this._checkInterval(areaList, i, x, y)){
						index = i;
						break;
					}
				}
				if(i == end-1){
					index = -1;
				}
			}
		}
		this._oldXPoint = x;
		return index; // Integer
	},

	_checkInterval: function(/*Array*/areaList, /*Integer*/index, /*Coord*/x, /*Coord*/y){
		// summary:
		//		check if the dragNode is in the interval.
		// returns:
		//		true if the dragNode is in intervall
		// areaList:
		//		a list of D&D areas objects
		// index:
		//		index of a D&D area (to get the interval)
		// x:
		//		coordinate x, of the dragNode (see getDragPoint())
		// tags:
		//		protected

		//console.log("dojox.mdnd.dropMode.OverDropMode ::: _checkInterval");
		var area = areaList[index];
		var node = area.node;
		var coords = area.coords;
		var startX = coords.x;
		var endX = coords.x2;
		var startY = coords.y;
		var endY = startY + node.offsetHeight;
		if(startX <= x && x <= endX && startY <= y && y <= endY){
			return true;
		}
		return false; // Boolean
	},

	getDropIndex: function(/*Object*/ targetArea, /*Object*/ coords){
		// summary:
		//		Return the index where the drop has to be placed.
		// targetArea:
		//		a D&D area object.
		// coords:
		//		coordinates [x,y] of the draggable item.
		// returns:
		//		a number or -1 if the area has no children or the drop index represents the last position in to the area

		//console.log("dojox.mdnd.dropMode.OverDropMode ::: getDropIndex");
		var length = targetArea.items.length;
		var coordinates = targetArea.coords;
		var y = coords.y;
		if(length > 0){
			// course all children in the target area.
			for(var i = 0; i < length; i++){
				// compare y value with y value of children
				if(y < targetArea.items[i].y){
					return i;	// integer
				}
				else{
					if(i == length-1){
						return -1; // integer
					}
				}
			}
		}
		return -1;	//integer
	},

	destroy: function(){
		dojo.forEach(this._dragHandler, dojo.disconnect);
	}
});

(function(){
	dojox.mdnd.areaManager()._dropMode = new dojox.mdnd.dropMode.OverDropMode();
}());

}

if(!dojo._hasResource["dojox.mdnd.AutoScroll"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.mdnd.AutoScroll"] = true;
dojo.provide("dojox.mdnd.AutoScroll");

dojo.declare(
	"dojox.mdnd.AutoScroll",
	null,
{
	// summary:
	//		Activate scrolling while dragging a widget.

	// interval: Integer
	//		default mouse move offset
	interval: 3,

	// recursiveTimer: Integer
	recursiveTimer: 10,

	// marginMouse: Integer
	//		Default mouse margin
	marginMouse: 50,

	constructor: function(){
		//////console.log("dojox.mdnd.AutoScroll ::: constructor ");
		this.resizeHandler = dojo.connect(dojo.global,"onresize", this, function(){
			this.getViewport();
		});
		dojo.ready(dojo.hitch(this, "init"));
	},

	init: function(){
		//////console.log("dojox.mdnd.AutoScroll ::: init ");
		this._html = (dojo.isWebKit) ? dojo.body() : dojo.body().parentNode;
		this.getViewport();
	},

	getViewport:function(){
		// summary:
		//		Set the visible part of the window. Varies accordion to Navigator.

		//////console.log("dojox.mdnd.AutoScroll ::: getViewport ");
		var d = dojo.doc, dd = d.documentElement, w = window, b = dojo.body();
		if(dojo.isMozilla){
			this._v = { 'w': dd.clientWidth, 'h': w.innerHeight };	// Object
		}
		else if(!dojo.isOpera && w.innerWidth){
			this._v = { 'w': w.innerWidth, 'h': w.innerHeight };		// Object
		}
		else if(!dojo.isOpera && dd && dd.clientWidth){
			this._v = { 'w': dd.clientWidth, 'h': dd.clientHeight };	// Object
		}
		else if(b.clientWidth){
			this._v = { 'w': b.clientWidth, 'h': b.clientHeight };	// Object
		}
	},

	setAutoScrollNode: function(/*Node*/node){
		// summary:
		//		set the node which is dragged
		// node:
		//		node to scroll

		//////console.log("dojox.mdnd.AutoScroll ::: setAutoScrollNode ");
		this._node = node;
	},

	setAutoScrollMaxPage: function(){
		// summary:
		//		Set the hightest heigh and width authorized scroll.

		//////console.log("dojox.mdnd.AutoScroll ::: setAutoScrollMaxPage ");
		this._yMax = this._html.scrollHeight;
		this._xMax = this._html.scrollWidth;
	},

	checkAutoScroll: function(/*Event*/e){
		// summary:
		//		Check if an autoScroll have to be launched.

		//////console.log("dojox.mdnd.AutoScroll ::: checkAutoScroll");
		if(this._autoScrollActive){
			this.stopAutoScroll();
		}
		this._y = e.pageY;
		this._x = e.pageX;
		if(e.clientX < this.marginMouse){
			this._autoScrollActive = true;
			this._autoScrollLeft(e);
		}
		else if(e.clientX > this._v.w - this.marginMouse){
			this._autoScrollActive = true;
			this._autoScrollRight(e);
		}
		if(e.clientY < this.marginMouse){
			this._autoScrollActive = true;
			this._autoScrollUp(e);
			
		}
		else if(e.clientY > this._v.h - this.marginMouse){
			this._autoScrollActive = true;
			this._autoScrollDown();
		}
	},

	_autoScrollDown: function(){
		// summary:
		//		Manage the down autoscroll.
		// tags:
		//		protected

		//////console.log("dojox.mdnd.AutoScroll ::: _autoScrollDown ");
		if(this._timer){
			clearTimeout(this._timer);
		}
		if(this._autoScrollActive && this._y + this.marginMouse < this._yMax){
			this._html.scrollTop += this.interval;
			this._node.style.top = (parseInt(this._node.style.top) + this.interval) + "px";
			this._y += this.interval;
			this._timer = setTimeout(dojo.hitch(this, "_autoScrollDown"), this.recursiveTimer);
		}
	},

	_autoScrollUp: function(){
		// summary:
		//		Manage the up autoscroll.
		// tags:
		//		protected

		//////console.log("dojox.mdnd.AutoScroll ::: _autoScrollUp ");
		if(this._timer){
			clearTimeout(this._timer);
		}
		if(this._autoScrollActive && this._y - this.marginMouse > 0){
			this._html.scrollTop -= this.interval;
			this._node.style.top = (parseInt(this._node.style.top) - this.interval) + "px";
			this._y -= this.interval;
			this._timer = setTimeout(dojo.hitch(this, "_autoScrollUp"),this.recursiveTimer);
		}
	},

	_autoScrollRight: function(){
		// summary:
		//		Manage the right autoscroll.
		// tags:
		//		protected

		//////console.log("dojox.mdnd.AutoScroll ::: _autoScrollRight ");
		if(this._timer){
			clearTimeout(this._timer);
		}
		if(this._autoScrollActive && this._x + this.marginMouse < this._xMax){
			this._html.scrollLeft += this.interval;
			this._node.style.left = (parseInt(this._node.style.left) + this.interval) + "px";
			this._x += this.interval;
			this._timer = setTimeout(dojo.hitch(this, "_autoScrollRight"), this.recursiveTimer);
		}
	},

	_autoScrollLeft: function(/*Event*/e){
		// summary:
		//		Manage the left autoscroll.
		// tags:
		//		protected

		//////console.log("dojox.mdnd.AutoScroll ::: _autoScrollLeft ");
		if(this._timer){
			clearTimeout(this._timer);
		}
		if(this._autoScrollActive && this._x - this.marginMouse > 0){
			this._html.scrollLeft -= this.interval;
			this._node.style.left = (parseInt(this._node.style.left) - this.interval) + "px";
			this._x -= this.interval;
			this._timer = setTimeout(dojo.hitch(this, "_autoScrollLeft"),this.recursiveTimer);
		}
	},

	stopAutoScroll: function(){
		// summary:
		//		Stop the autoscroll.
		
		//////console.log("dojox.mdnd.AutoScroll ::: stopAutoScroll ");
		if(this._timer){
			clearTimeout(this._timer);
		}
		this._autoScrollActive = false;
	},

	destroy: function(){
		//////console.log("dojox.mdnd.AutoScroll ::: destroy ");
		dojo.disconnect(this.resizeHandler);
	}
});

dojox.mdnd.autoScroll = null;
(function(){
	dojox.mdnd.autoScroll = new dojox.mdnd.AutoScroll();
}());

}

if(!dojo._hasResource["dojox.layout.GridContainerLite"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.layout.GridContainerLite"] = true;
dojo.provide("dojox.layout.GridContainerLite");









dojo.declare(
	"dojox.layout.GridContainerLite",
	[dijit.layout._LayoutWidget, dijit._Templated],
{
	// summary:
	// 		The GridContainerLite is a container of child elements that are placed in a kind of grid.
	//
	// description:
	//		GridContainerLite displays the child elements by column
	//		(ie: the children widths are fixed by the column width of the grid but
	//              the children heights are free).
	//		Each child is movable by drag and drop inside the GridContainer.
	//		The position of other children is automatically calculated when a child is moved.
	//
	// example:
	// 	|	<div dojoType="dojox.layout.GridContainerLite" nbZones="3" isAutoOrganized="true">
	// 	|		<div dojoType="dijit.layout.ContentPane">Content Pane 1 : Drag Me !</div>
	// 	|		<div dojoType="dijit.layout.ContentPane">Content Pane 2 : Drag Me !</div>
	// 	|		<div dojoType="dijit.layout.ContentPane">Content Pane 3 : Drag Me !</div>
	// 	|	</div>
	//
	// example:
	// 	|	dojo.ready(function(){
	// 	|		var cpane1 = new dijit.layout.ContentPane({
	//	|			title:"cpane1", content: "Content Pane 1 : Drag Me !"
	//	|		}),
	// 	|		cpane2 = new dijit.layout.ContentPane({
	//	|			title:"cpane2",
	//	|			content: "Content Pane 2 : Drag Me !"
	//	|		}),
	// 	|		cpane3 = new dijit.layout.ContentPane({
	//	|			title:"cpane3",
	//	|			content: "Content Pane 3 : Drag Me !"
	//	|		});
	// 	|
	// 	|		var widget = new dojox.layout.GridContainerLite({
	// 	|			nbZones: 3,
	// 	|			isAutoOrganized: true
	// 	|		}, dojo.byId("idNode"));
	// 	|		widget.addChild(cpane1, 0, 0);
	// 	|		widget.addChild(cpane2, 1, 0);
	// 	|		widget.addChild(cpane3, 2, 1);
	// 	|		widget.startup();
	// 	|	});
	
	//	autoRefresh: Boolean
	//		Enable the refresh of registered areas on drag start.
	autoRefresh: true,


	// templateString: String
	//		template of gridContainer.
	templateString: dojo.cache("dojox.layout", "resources/GridContainer.html", "<div id=\"${id}\" class=\"gridContainer\" dojoAttachPoint=\"containerNode\" tabIndex=\"0\" dojoAttachEvent=\"onkeypress:_selectFocus\">\n\t<div dojoAttachPoint=\"gridContainerDiv\">\n\t\t<table class=\"gridContainerTable\" dojoAttachPoint=\"gridContainerTable\" cellspacing=\"0\" cellpadding=\"0\">\n\t\t\t<tbody>\n\t\t\t\t<tr dojoAttachPoint=\"gridNode\" >\n\t\t\t\t\t\n\t\t\t\t</tr>\n\t\t\t</tbody>\n\t\t</table>\n\t</div>\n</div>\n"),

	// dragHandleClass: Array :
	//		CSS class enabling a drag handle on a child.
	dragHandleClass: "dojoxDragHandle",

	// nbZones: Integer
	//		The number of dropped zones, by default 1.
	nbZones: 1,

	// doLayout: Boolean
	//		If true, change the size of my currently displayed child to match my size.
	doLayout: true,

	// isAutoOrganized: Boolean
	//		If true, widgets are organized automatically,
	//		else the attribute colum of child will define the right column.
	isAutoOrganized: true,

	// acceptTypes: Array
	//		The GridContainer will only accept the children that fit to the types.
	acceptTypes: [],
	
	// colWidths: String
	//		A comma separated list of column widths. If the column widths do not add up
	//		to 100, the remaining columns split the rest of the width evenly
	//		between them.
	colWidths: "",

	constructor: function(/*Object*/props, /*DOMNode*/node){
		this.acceptTypes = (props || {}).acceptTypes || ["text"];
		this._disabled = true;
	},

	postCreate: function(){
		//console.log("dojox.layout.GridContainerLite ::: postCreate");
		this.inherited(arguments);
		this._grid = [];

		this._createCells();

		// need to resize dragged child when it's dropped.
		this.subscribe("/dojox/mdnd/drop", "resizeChildAfterDrop");
		this.subscribe("/dojox/mdnd/drag/start", "resizeChildAfterDragStart");

		this._dragManager = dojox.mdnd.areaManager();
		// console.info("autorefresh ::: ", this.autoRefresh);
		this._dragManager.autoRefresh = this.autoRefresh;

		//	Add specific dragHandleClass to the manager.
		this._dragManager.dragHandleClass = this.dragHandleClass;

		if(this.doLayout){
			this._border = {
				'h':(dojo.isIE) ? dojo._getBorderExtents(this.gridContainerTable).h : 0,
				'w': (dojo.isIE == 6) ? 1 : 0
			}
		}
		else{
			dojo.style(this.domNode, "overflowY", "hidden");
			dojo.style(this.gridContainerTable, "height", "auto");
		}
		// Call postCreate of dijit.layout._LayoutWidget.
		this.inherited(arguments);

	},

	startup: function(){
		//console.log("dojox.layout.GridContainerLite ::: startup");
		if(this._started){ return; }

		if(this.isAutoOrganized){
			this._organizeChildren();
		}
		else{
			this._organizeChildrenManually();
		}

		// Need to call getChildren because getChildren return null
		// The children are not direct children because of _organizeChildren method
		dojo.forEach(this.getChildren(), function(child){ child.startup(); });

		// Need to enable the Drag And Drop only if the GridContainer is visible.
		if(this._isShown()){
			this.enableDnd();
		}
		this.inherited(arguments);
	},

	resizeChildAfterDrop: function(/*Node*/node, /*Object*/targetArea, /*Integer*/indexChild){
		// summary:
		//		Resize the GridContainerLite inner table and the dropped widget.
		// description:
		//		These components are resized only if the targetArea.node is a
		//		child of this instance of gridContainerLite.
		//		To be resized, the dropped node must have also a method resize.
		// node:
		//		domNode of dropped widget.
		// targetArea:
		//		AreaManager Object containing information of targetArea
		// indexChild:
		// 		Index where the dropped widget has been placed
		// returns:
		//		True if resized.

		//console.log("dojox.layout.GridContainerLite ::: resizeChildAfterDrop");
		if(this._disabled){
			return false;
		}
		if(dijit.getEnclosingWidget(targetArea.node) == this){
			var widget = dijit.byNode(node);
			if(widget.resize && dojo.isFunction(widget.resize)){
				widget.resize();
			}

			// Update the column of the widget
			widget.set("column", node.parentNode.cellIndex);
			if(this.doLayout){
				var domNodeHeight = this._contentBox.h,
					divHeight = dojo.contentBox(this.gridContainerDiv).h;
				if(divHeight >= domNodeHeight){
					dojo.style(this.gridContainerTable, "height",
							(domNodeHeight - this._border.h) + "px");
				}
			}

			return true;
		}
		return false;
	},

	resizeChildAfterDragStart: function(/*Node*/node, /*Object*/sourceArea, /*Integer*/indexChild){
		// summary:
		//		Resize the GridContainerLite inner table only if the drag source
		//		is a child of this gridContainer.
		// node:
		//		domNode of dragged widget.
		// sourceArea:
		//		AreaManager Object containing information of sourceArea
		// indexChild:
		// 		Index where the dragged widget has been placed

		//console.log("dojox.layout.GridContainerLite ::: resizeChildAfterDragStart");
		if(this._disabled){
			return false;
		}
		if(dijit.getEnclosingWidget(sourceArea.node) == this){
			this._draggedNode = node;
			if(this.doLayout){
				dojo.marginBox(this.gridContainerTable, {
					'h': dojo.contentBox(this.gridContainerDiv).h - this._border.h
				});
			}
			return true;
		}
		return false;
	},

	getChildren: function(){
		// summary:
		//		A specific method which returns children after they were placed in zones.
		// returns:
		//		An array containing all children (widgets).
		// tags:
		//		protected

		//console.log("dojox.layout.GridContainerLite ::: _getChildren");
		var children = [];
		dojo.forEach(this._grid, function(dropZone){
			children = children.concat(dojo.query("> [widgetId]", dropZone.node).map(dijit.byNode));
		});
		return children;	// Array
	},

	_isShown: function(){
		// summary:
		//		Check if the domNode is visible or not.
		// returns:
		//		true if the content is currently shown
		// tags:
		//		protected

		//console.log("dojox.layout.GridContainerLite ::: _isShown");
		if("open" in this){		// for TitlePane, etc.
			return this.open;		// Boolean
		}
		else{
			var node = this.domNode;
			return (node.style.display != 'none') && (node.style.visibility != 'hidden') && !dojo.hasClass(node, "dijitHidden"); // Boolean
		}
	},

	layout: function(){
		// summary:
		//		Resize of each child

		//console.log("dojox.layout.GridContainerLite ::: layout    BEFORE");
		if(this.doLayout){
			var contentBox = this._contentBox;
			dojo.marginBox(this.gridContainerTable, {
				'h': contentBox.h - this._border.h
			});
			dojo.contentBox(this.domNode, {
				'w': contentBox.w - this._border.w
			});
		}
		//console.log("dojox.layout.GridContainerLite ::: layout    AFTER");

		dojo.forEach(this.getChildren(), function(widget){
			if(widget.resize && dojo.isFunction(widget.resize)){
				widget.resize();
			}
		});
	},

	onShow: function(){
		// summary:
		//		Enabled the Drag And Drop if it's necessary.

		//console.log("dojox.layout.GridContainerLite ::: onShow");
		if(this._disabled){
			this.enableDnd();
		}
	},

	onHide: function(){
		// summary:
		//		Disabled the Drag And Drop if it's necessary.

		//console.log("dojox.layout.GridContainerLite ::: onHide");
		if(!this._disabled){
			this.disableDnd();
		}
	},

	_createCells: function(){
		// summary:
		//		Create the columns of the GridContainer.
		// tags:
		//		protected

		//console.log("dojox.layout.GridContainerLite ::: _createCells");
		if(this.nbZones === 0){ this.nbZones = 1; }
		var accept = this.acceptTypes.join(","),
			i = 0;
			
		var origWidths = this.colWidths || [];
		var widths = [];
		var colWidth;
		var widthSum = 0;
		
		// Calculate the widths of each column.
		for(i = 0; i < this.nbZones; i++){
			if(widths.length < origWidths.length){
				widthSum += origWidths[i];
				widths.push(origWidths[i]);
			}else{
				if(!colWidth){
					colWidth = (100 - widthSum)/(this.nbZones - i);
				}
				widths.push(colWidth);
			}
		}

		i = 0;
		while(i < this.nbZones){
			// Add the parameter accept in each zone used by AreaManager
			// (see method dojox.mdnd.AreaManager:registerByNode)
			this._grid.push({
				'node': dojo.create("td", {
					'class': "gridContainerZone",
					'accept': accept,
					'id': this.id + "_dz" + i,
					'style': {
						'width': widths[i] + "%"
					}
				}, this.gridNode)
			});
			i++;
		}
	},
	
	_getZonesAttr: function(){
		// summary:
		//   return array of zone (domNode)
		return dojo.query(".gridContainerZone",  this.containerNode);
	},

	enableDnd: function(){
		// summary:
		//		Enable the Drag And Drop for children of GridContainer.

		//console.log("dojox.layout.GridContainerLite ::: enableDnd");
		var m = this._dragManager;
		dojo.forEach(this._grid, function(dropZone){
			m.registerByNode(dropZone.node);
		});
		m._dropMode.updateAreas(m._areaList);
		this._disabled = false;
	},

	disableDnd: function(){
		// summary:
		//		Disable the Drag And Drop for children of GridContainer.

		//console.log("dojox.layout.GridContainerLite ::: disableDnd");
		var m = this._dragManager;
		dojo.forEach(this._grid, function(dropZone){
			m.unregister(dropZone.node);
		});
		m._dropMode.updateAreas(m._areaList);
		this._disabled = true;
	},

	_organizeChildren: function(){
		// summary:
		//		List all zones and insert child into columns.

		//console.log("dojox.layout.GridContainerLite ::: _organizeChildren");
		var children = dojox.layout.GridContainerLite.superclass.getChildren.call(this);
		var numZones = this.nbZones,
			numPerZone = Math.floor(children.length / numZones),
			mod = children.length % numZones,
			i = 0;
//		console.log('numPerZone', numPerZone, ':: mod', mod);
		for(var z = 0; z < numZones; z++){
			for(var r = 0; r < numPerZone; r++){
				this._insertChild(children[i], z);
				i++;
			}
			if(mod > 0){
				try{
					this._insertChild(children[i], z);
					i++;
				}
				catch(e){
					console.error("Unable to insert child in GridContainer", e);
				}
				mod--;
			}
			else if(numPerZone === 0){
				break;	// Optimization
			}
		}
	},

	_organizeChildrenManually: function (){
		// summary:
		//		Organize children by column property of widget.

		//console.log("dojox.layout.GridContainerLite ::: _organizeChildrenManually");
		var children = dojox.layout.GridContainerLite.superclass.getChildren.call(this),
			length = children.length,
			child;
		for(var i = 0; i < length; i++){
			child = children[i];
			try{
				this._insertChild(child, child.column - 1);
			}
			catch(e){
				console.error("Unable to insert child in GridContainer", e);
			}
		}
	},

	_insertChild: function(/*Widget*/child, /*Integer*/column, /*Integer?*/p){
		// summary:
		//		Insert a child in a specific column of the GridContainer widget.
		// column:
		//		Column number
		// p:
		//		Place in the zone (0 - first)
		// returns:
		//		The widget inserted

		//console.log("dojox.layout.GridContainerLite ::: _insertChild", child, column, p);
		var zone = this._grid[column].node,
			length = zone.childNodes.length;
		if(typeof(p) == undefined || p > length){
			p = length;
		}
		if(this._disabled){
			dojo.place(child.domNode, zone, p);
			dojo.attr(child.domNode, "tabIndex", "0");
		}
		else{
			if(!child.dragRestriction){
				this._dragManager.addDragItem(zone, child.domNode, p, true);
			}
			else{
				dojo.place(child.domNode, zone, p);
				dojo.attr(child.domNode, "tabIndex", "0");
			}
		}
		child.set("column", column);
		return child; // Widget
	},

	removeChild: function(/*Widget*/ widget){
		//console.log("dojox.layout.GridContainerLite ::: removeChild");
		if(this._disabled){
			this.inherited(arguments);
		}
		else{
			this._dragManager.removeDragItem(widget.domNode.parentNode, widget.domNode);
		}
	},

	addService: function(/*Object*/child, /*Integer?*/column, /*Integer?*/p){
		//console.log("dojox.layout.GridContainerLite ::: addService");
		dojo.deprecated("addService is deprecated.", "Please use  instead.", "Future");
		this.addChild(child, column, p);
	},

	addChild: function(/*Object*/child, /*Integer?*/column, /*Integer?*/p){
		// summary:
		//		Add a child in a specific column of the GridContainer widget.
		// child:
		//		widget to insert
		// column:
		//		column number
		// p:
		//		place in the zone (first = 0)
		// returns:
		//		The widget inserted

		//console.log("dojox.layout.GridContainerLite ::: addChild");
		child.domNode.id = child.id;
		dojox.layout.GridContainerLite.superclass.addChild.call(this, child, 0);
		if(column < 0 || column == undefined){ column = 0; }
		if(p <= 0){ p = 0; }
		try{
			return this._insertChild(child, column, p);
		}
		catch(e){
			console.error("Unable to insert child in GridContainer", e);
		}
		return null; 	// Widget
	},
	
	_setColWidthsAttr: function(value){
		this.colWidths = dojo.isString(value) ? value.split(",") : (dojo.isArray(value) ? value : [value]);
		
		if(this._started){
			this._updateColumnsWidth();
		}
	},
	
	_updateColumnsWidth: function(/*Object*/ manager){
		// summary:
		//		Update the columns width.
		// manager:
		//		dojox.mdnd.AreaManager singleton
		// tags:
		//		private

		//console.log("dojox.layout.GridContainer ::: _updateColumnsWidth");
		var length = this._grid.length;

		var origWidths = this.colWidths || [];
		var widths = [];
		var colWidth;
		var widthSum = 0;
		var i;

		// Calculate the widths of each column.
		for(i = 0; i < length; i++){
			if(widths.length < origWidths.length){
				widthSum += origWidths[i] * 1;
				widths.push(origWidths[i]);
			}else{
				if(!colWidth){
					colWidth = (100 - widthSum)/(this.nbZones - i);
					
					// If the numbers don't work out, make the remaining columns
					// an even width and let the code below average
					// out the differences.
					if(colWidth < 0){
						colWidth = 100 / this.nbZones;
					}
				}
				widths.push(colWidth);
				widthSum += colWidth * 1;
			}
		}

		// If the numbers are wrong, divide them all so they add up to 100
		if(widthSum > 100){
			var divisor = 100 / widthSum;
			for(i = 0; i < widths.length; i++){
				widths[i] *= divisor;
			}
		}

		// Set the widths of each node
		for(i = 0; i < length; i++){
			this._grid[i].node.style.width = widths[i] + "%";
		}
	},

	_selectFocus: function(/*Event*/event){
		// summary:
		//		Enable keyboard accessibility into the GridContainer.
		// description:
		//		Possibility to move focus into the GridContainer (TAB, LEFT ARROW, RIGHT ARROW, UP ARROW, DOWN ARROW).
		//		Possibility to move GridContainer's children (Drag and Drop) with keyboard. (SHIFT +  ARROW).
		//		If the type of widget is not draggable, a popup is displayed.

		//console.log("dojox.layout.GridContainerLite ::: _selectFocus");
		if(this._disabled){ return; }
		var key = event.keyCode,
			k = dojo.keys,
			zone = null,
			focus = dijit.getFocus(),
			focusNode = focus.node,
			m = this._dragManager,
			found,
			i,
			j,
			r,
			children,
			area,
			widget;
		if(focusNode == this.containerNode){
			area = this.gridNode.childNodes;
			switch(key){
				case k.DOWN_ARROW:
				case k.RIGHT_ARROW:
					found = false;
					for(i = 0; i < area.length; i++){
						children = area[i].childNodes;
						for(j = 0; j < children.length; j++){
							zone = children[j];
							if(zone != null && zone.style.display != "none"){
								dijit.focus(zone);
								dojo.stopEvent(event);
								found = true;
								break;
							}
						}
						if(found){ break };
					}
				break;
				case k.UP_ARROW:
				case k.LEFT_ARROW:
					area = this.gridNode.childNodes;
					found = false;
					for(i = area.length-1; i >= 0 ; i--){
						children = area[i].childNodes;
						for(j = children.length; j >= 0; j--){
							zone = children[j];
							if(zone != null && zone.style.display != "none"){
								dijit.focus(zone);
								dojo.stopEvent(event);
								found = true;
								break;
							}
						}
						if(found){ break };
					}
				break;
			}
		}
		else{
			if(focusNode.parentNode.parentNode == this.gridNode){
				var child = (key == k.UP_ARROW || key == k.LEFT_ARROW) ? "lastChild" : "firstChild";
				var pos = (key == k.UP_ARROW || key == k.LEFT_ARROW) ? "previousSibling" : "nextSibling";
				switch(key){
					case k.UP_ARROW:
					case k.DOWN_ARROW:
						dojo.stopEvent(event);
						found = false;
						var focusTemp = focusNode;
						while(!found){
							children = focusTemp.parentNode.childNodes;
							var num = 0;
							for(i = 0; i < children.length; i++){
								if(children[i].style.display != "none"){ num++ };
								if(num > 1){ break; }
							}
							if(num == 1){ return; }
							if(focusTemp[pos] == null){
								zone = focusTemp.parentNode[child];
							}
							else{
								zone = focusTemp[pos];
							}
							if(zone.style.display === "none"){
								focusTemp = zone;
							}
							else{
								found = true;
							}
						}
						if(event.shiftKey){
							var parent = focusNode.parentNode;
							for(i = 0; i < this.gridNode.childNodes.length; i++){
								if(parent == this.gridNode.childNodes[i]){
									break;
								}
							}
							children = this.gridNode.childNodes[i].childNodes;
							for(j = 0; j < children.length; j++){
								if(zone == children[j]){
									break;
								}
							}
							if(dojo.isMoz || dojo.isWebKit){ i-- };

							widget = dijit.byNode(focusNode);
							if(!widget.dragRestriction){
								r = m.removeDragItem(parent, focusNode);
								this.addChild(widget, i, j);
								dojo.attr(focusNode, "tabIndex", "0");
								dijit.focus(focusNode);
							}
							else{
								dojo.publish("/dojox/layout/gridContainer/moveRestriction", [this]);
							}
						}
						else{
							dijit.focus(zone);
						}
					break;
					case k.RIGHT_ARROW:
					case k.LEFT_ARROW:
						dojo.stopEvent(event);
						if(event.shiftKey){
							var z = 0;
							if(focusNode.parentNode[pos] == null){
								if(dojo.isIE && key == k.LEFT_ARROW){
									z = this.gridNode.childNodes.length-1;
								}
							}
							else if(focusNode.parentNode[pos].nodeType == 3){
								z = this.gridNode.childNodes.length - 2;
							}
							else{
								for(i = 0; i < this.gridNode.childNodes.length; i++){
									if(focusNode.parentNode[pos] == this.gridNode.childNodes[i]){
										break;
									}
									z++;
								}
								if(dojo.isMoz || dojo.isWebKit){ z-- };
							}
							widget = dijit.byNode(focusNode);
							var _dndType = focusNode.getAttribute("dndtype");
							if(_dndType == null){
								//check if it's a dijit object
								if(widget && widget.dndType){
									_dndType = widget.dndType.split(/\s*,\s*/);
								}
								else{
									_dndType = ["text"];
								}
							}
							else{
								_dndType = _dndType.split(/\s*,\s*/);
							}
							var accept = false;
							for(i = 0; i < this.acceptTypes.length; i++){
								for(j = 0; j < _dndType.length; j++){
									if(_dndType[j] == this.acceptTypes[i]){
										accept = true;
										break;
									}
								}
							}
							if(accept && !widget.dragRestriction){
								var parentSource = focusNode.parentNode,
									place = 0;
								if(k.LEFT_ARROW == key){
									var t = z;
									if(dojo.isMoz || dojo.isWebKit){ t = z + 1 };
									place = this.gridNode.childNodes[t].childNodes.length;
								}
								// delete of manager :
								r = m.removeDragItem(parentSource, focusNode);
								this.addChild(widget, z, place);
								dojo.attr(r, "tabIndex", "0");
								dijit.focus(r);
							}
							else{
								dojo.publish("/dojox/layout/gridContainer/moveRestriction", [this]);
							}
						}
						else{
							var node = focusNode.parentNode;
							while(zone === null){
								if(node[pos] !== null && node[pos].nodeType !== 3){
									node = node[pos];
								}
								else{
									if(pos === "previousSibling"){
										node = node.parentNode.childNodes[node.parentNode.childNodes.length-1];
									}
									else{
										node = (dojo.isIE)? node.parentNode.childNodes[0]: node.parentNode.childNodes[1];
									}
								}
								zone = node[child];
								if(zone && zone.style.display == "none"){
									// check that all elements are not hidden
									children = zone.parentNode.childNodes;
									var childToSelect = null;
									if(pos == "previousSibling"){
										for(i = children.length-1; i >= 0; i--){
											if(children[i].style.display != "none"){
												childToSelect = children[i];
												break;
											}
										}
									}
									else{
										for(i = 0; i < children.length; i++){
											if(children[i].style.display != "none"){
												childToSelect = children[i];
												break;
											}
										}
									}
									if(!childToSelect){
										focusNode = zone;
										node = focusNode.parentNode;
										zone = null;
									}
									else{
										zone = childToSelect;
									}
								}
							}
							dijit.focus(zone);
						}
					break;
				}
			}
		}
	},

	destroy: function(){
		//console.log("dojox.layout.GridContainerLite ::: destroy");
		var m = this._dragManager;
		dojo.forEach(this._grid, function(dropZone){
			m.unregister(dropZone.node);
		});
		this.inherited(arguments);
	}
});

dojo.extend(dijit._Widget, {

	// column: String
	//		Column of the grid to place the widget.
	//		Defined only if  is done.
	column : "1",

	// dragRestriction: Boolean
	//		If true, the widget can not be draggable.
	//		Defined only if  is done.
	dragRestriction : false
});

}

if(!dojo._hasResource["dojox.layout.GridContainer"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.layout.GridContainer"] = true;
dojo.provide("dojox.layout.GridContainer");



dojo.declare(
	"dojox.layout.GridContainer",
	dojox.layout.GridContainerLite,
{
	// summary:
	//		A grid containing any kind of objects and acting like web portals.
	//
	// description:
	//		This component inherits of all features of gridContainerLite plus :
	//			- Resize colums
	//			- Add / remove columns
	//			- Fix columns at left or at right.
	// example:
	// 	|	<div dojoType="dojox.layout.GridContainer" nbZones="3" isAutoOrganized="true">
	// 	|		<div dojoType="dijit.layout.ContentPane">Content Pane 1 : Drag Me !</div>
	// 	|		<div dojoType="dijit.layout.ContentPane">Content Pane 2 : Drag Me !</div>
	// 	|		<div dojoType="dijit.layout.ContentPane">Content Pane 3 : Drag Me !</div>
	// 	|	</div>
	//
	// example:
	// 	|	dojo.ready(function(){
	// 	|		var cpane1 = new dijit.layout.ContentPane({ title:"cpane1", content: "Content Pane 1 : Drag Me !" }),
	// 	|			cpane2 = new dijit.layout.ContentPane({ title:"cpane2", content: "Content Pane 2 : Drag Me !" }),
	// 	|			cpane3 = new dijit.layout.ContentPane({ title:"cpane3", content: "Content Pane 3 : Drag Me !" });
	// 	|
	// 	|		var widget = new dojox.layout.GridContainer({
	// 	|			nbZones: 3,
	// 	|			isAutoOrganized: true
	// 	|		}, dojo.byId("idNode"));
	// 	|		widget.addChild(cpane1, 0, 0);
	// 	|		widget.addChild(cpane2, 1, 0);
	// 	|		widget.addChild(cpane3, 2, 1);
	// 	|		widget.startup();
	// 	|	});

	// hasResizableColumns: Boolean
	//		Allow or not resizing of columns by a grip handle.
	hasResizableColumns: true,

	// liveResizeColumns: Boolean
	//		Specifies whether columns resize as you drag (true) or only upon mouseup (false)
	liveResizeColumns : false,

	// minColWidth: Integer
	//		Minimum column width in percentage.
	minColWidth: 20,

	// minChildWidth: Integer
	// 		Minimum children width in pixel (only used for IE6 which doesn't handle min-width css property)
	minChildWidth: 150,

	// mode: String
	//		Location to add/remove columns, must be set to 'left' or 'right' (default).
	mode: "right",

	// isRightFixed: Boolean
	//		Define if the last right column is fixed.
	//		Used when you add or remove columns by calling setColumns method.
	isRightFixed: false,

	// isLeftFixed: Boolean
	//		Define if the last left column is fixed.
	//		Used when you add or remove columns by calling setColumns method.
	isLeftFixed: false,

	startup: function(){
		// summary:
		//		Call the startup of GridContainerLite and place grips
		//		if user has chosen the hasResizableColumns attribute to true.

		//console.log("dojox.layout.GridContainer ::: startup");
		this.inherited(arguments);
		if(this.hasResizableColumns){
			for(var i = 0; i < this._grid.length - 1; i++){
				this._createGrip(i);
			}
			// If widget has a container parent, grips will be placed
			// by method onShow.
			if(!this.getParent()){
				// Fix IE7 :
				//		The CSS property height:100% for the grip
				//		doesn't work anytime. It's necessary to wait
				//		the end of loading before to place grips.
				dojo.ready(dojo.hitch(this, "_placeGrips"));
			}
		}
	},

	resizeChildAfterDrop : function(/*Node*/node, /*Object*/targetArea, /*Integer*/indexChild){
		// summary:
		//		Call when a child is dropped.
		// description:
		//		Allow to resize and put grips
		// node:
		//		domNode of dropped widget.
		// targetArea:
		//		AreaManager Object containing information of targetArea
		// indexChild:
		// 		Index where the dropped widget has been placed

		if(this.inherited(arguments)){
			this._placeGrips();
		}
	},

	onShow: function(){
		// summary:
		//		Place grips in the right place when the GridContainer becomes visible.

		//console.log("dojox.layout.GridContainer ::: onShow");
		this.inherited(arguments);
		this._placeGrips();
	},

	resize: function(){
		// summary:
		//		Resize the GridContainer widget and columns.
		//		Replace grips if it's necessary.
		// tags:
		//		callback

		//console.log("dojox.layout.GridContainer ::: resize");
		this.inherited(arguments);
		// Fix IE6 :
		//		IE6 calls method resize itself.
		//		If the GridContainer is not visible at this time,
		//		the method _placeGrips can return a negative value with
		// 		contentBox method. (see method _placeGrip() with Fix Ie6 for the height)
		if(this._isShown() && this.hasResizableColumns){
			this._placeGrips();
		}
	},

	_createGrip: function(/*Integer*/ index){
		// summary:
		//		Create a grip for a specific zone.
		// index:
		//		index where the grip has to be created.
		// tags:
		//		protected

		//console.log("dojox.layout.GridContainer ::: _createGrip");
		var dropZone = this._grid[index],
			grip = dojo.create("div", { 'class': "gridContainerGrip" }, this.domNode);
		dropZone.grip = grip;
		dropZone.gripHandler = [
			this.connect(grip, "onmouseover", function(e){
				var gridContainerGripShow = false;
				for(var i = 0; i < this._grid.length - 1; i++){
					if(dojo.hasClass(this._grid[i].grip, "gridContainerGripShow")){
						gridContainerGripShow = true;
						break;
					}
				}
				if(!gridContainerGripShow){
					dojo.removeClass(e.target, "gridContainerGrip");
					dojo.addClass(e.target, "gridContainerGripShow");
				}
			})[0],
			this.connect(grip, "onmouseout", function(e){
				if(!this._isResized){
					dojo.removeClass(e.target, "gridContainerGripShow");
					dojo.addClass(e.target, "gridContainerGrip");
				}
			})[0],
			this.connect(grip, "onmousedown", "_resizeColumnOn")[0],
			this.connect(grip, "ondblclick", "_onGripDbClick")[0]
		];
	},

	_placeGrips: function(){
		// summary:
		//		Define the position of a grip and place it on page.
		// tags:
		//		protected

		//console.log("dojox.layout.GridContainer ::: _placeGrips");
		var gripWidth, height, left = 0, grip;
		var scroll = this.domNode.style.overflowY;

		dojo.forEach(this._grid, function(dropZone){
			if(dropZone.grip){
				grip = dropZone.grip;
				if(!gripWidth){
					gripWidth = grip.offsetWidth / 2;
				}

				left += dojo.marginBox(dropZone.node).w;

				dojo.style(grip, "left", (left - gripWidth) + "px");
				//if(dojo.isIE == 6){ do it fot all navigators
				if(!height){
					height = dojo.contentBox(this.gridNode).h;
				}
				if(height > 0){
					dojo.style(grip, "height", height + "px");
				}
				//}
			}
		}, this);
	},

	_onGripDbClick: function(){
		// summary:
		//		Called when a double click is catch. Resize all columns with the same width.
		//		The method resize of children have to be called.
		// tags:
		//		callback protected

		//console.log("dojox.layout.GridContainer ::: _onGripDbClick");
		this._updateColumnsWidth(this._dragManager);
		this.resize();
	},

	_resizeColumnOn: function(/*Event*/e){
		// summary:
		//		Connect events to listen the resize action.
		//		Change the type of width columns (% to px).
		//		Calculate the minwidth according to the children.
		// tags:
		//		callback

		//console.log("dojox.layout.GridContainer ::: _resizeColumnOn", e);
		this._activeGrip = e.target;
		this._initX = e.pageX;
		e.preventDefault();

		dojo.body().style.cursor = "ew-resize";

		this._isResized = true;

		var tabSize = [];
		var grid;
		var i;

		for(i = 0; i < this._grid.length; i++){
			tabSize[i] = dojo.contentBox(this._grid[i].node).w;
		}

		this._oldTabSize = tabSize;

		for(i = 0; i < this._grid.length; i++){
			grid = this._grid[i];
			if(this._activeGrip == grid.grip){
				this._currentColumn = grid.node;
				this._currentColumnWidth = tabSize[i];
				this._nextColumn = this._grid[i + 1].node;
				this._nextColumnWidth = tabSize[i + 1];
			}
			grid.node.style.width = tabSize[i] + "px";
		}

		// calculate the minWidh of all children for current and next column
		var calculateChildMinWidth = function(childNodes, minChild){
			var width = 0;
			var childMinWidth = 0;

			dojo.forEach(childNodes, function(child){
				if(child.nodeType == 1){
					var objectStyle = dojo.getComputedStyle(child);
					var minWidth = (dojo.isIE) ? minChild : parseInt(objectStyle.minWidth);

					childMinWidth = minWidth +
								parseInt(objectStyle.marginLeft) +
								parseInt(objectStyle.marginRight);

					if(width < childMinWidth){
						width = childMinWidth;
					}
				}
			});
			return width;
		}
		var currentColumnMinWidth = calculateChildMinWidth(this._currentColumn.childNodes, this.minChildWidth);

		var nextColumnMinWidth = calculateChildMinWidth(this._nextColumn.childNodes, this.minChildWidth);

		var minPix = Math.round((dojo.marginBox(this.gridContainerTable).w * this.minColWidth) / 100);

		this._currentMinCol = currentColumnMinWidth;
		this._nextMinCol = nextColumnMinWidth;

		if(minPix > this._currentMinCol){
			this._currentMinCol = minPix;
		}
		if(minPix > this._nextMinCol){
			this._nextMinCol = minPix;
		}
		this._connectResizeColumnMove = dojo.connect(dojo.doc, "onmousemove", this, "_resizeColumnMove");
		this._connectOnGripMouseUp = dojo.connect(dojo.doc, "onmouseup", this, "_onGripMouseUp");
	},

	_onGripMouseUp: function(){
		// summary:
		//		Call on the onMouseUp only if the reiszeColumnMove was not called.
		// tags:
		//		callback

		//console.log(dojox.layout.GridContainer ::: _onGripMouseUp");
		dojo.body().style.cursor = "default";

		dojo.disconnect(this._connectResizeColumnMove);
		dojo.disconnect(this._connectOnGripMouseUp);

		this._connectOnGripMouseUp = this._connectResizeColumnMove = null;

		if(this._activeGrip){
			dojo.removeClass(this._activeGrip, "gridContainerGripShow");
			dojo.addClass(this._activeGrip, "gridContainerGrip");
		}

		this._isResized = false;
	},

	_resizeColumnMove: function(/*Event*/e){
		// summary:
		//		Change columns size.
		// tags:
		//		callback

		//console.log("dojox.layout.GridContainer ::: _resizeColumnMove");
		e.preventDefault();
		if(!this._connectResizeColumnOff){
			dojo.disconnect(this._connectOnGripMouseUp);
			this._connectOnGripMouseUp = null;
			this._connectResizeColumnOff = dojo.connect(dojo.doc, "onmouseup", this, "_resizeColumnOff");
		}

		var d = e.pageX - this._initX;
		if(d == 0){ return; }

		if(!(this._currentColumnWidth + d < this._currentMinCol ||
				this._nextColumnWidth - d < this._nextMinCol)){

			this._currentColumnWidth += d;
			this._nextColumnWidth -= d;
			this._initX = e.pageX;
			this._activeGrip.style.left = parseInt(this._activeGrip.style.left) + d + "px";

			if(this.liveResizeColumns){
				this._currentColumn.style["width"] = this._currentColumnWidth + "px";
				this._nextColumn.style["width"] = this._nextColumnWidth + "px";
				this.resize();
			}
		}
	},

	_resizeColumnOff: function(/*Event*/e){
		// summary:
		//		Disconnect resize events.
		//		Change the type of width columns (px to %).
		// tags:
		//		callback

		//console.log("dojox.layout.GridContainer ::: _resizeColumnOff");
		dojo.body().style.cursor = "default";

		dojo.disconnect(this._connectResizeColumnMove);
		dojo.disconnect(this._connectResizeColumnOff);

		this._connectResizeColumnOff = this._connectResizeColumnMove = null;

		if(!this.liveResizeColumns){
			this._currentColumn.style["width"] = this._currentColumnWidth + "px";
			this._nextColumn.style["width"] = this._nextColumnWidth + "px";
			//this.resize();
		}

		var tabSize = [],
			testSize = [],
			tabWidth = this.gridContainerTable.clientWidth,
			node,
			update = false,
			i;

		for(i = 0; i < this._grid.length; i++){
			node = this._grid[i].node;
			if(dojo.isIE){
				tabSize[i] = dojo.marginBox(node).w;
				testSize[i] = dojo.contentBox(node).w;
			}
			else{
				tabSize[i] = dojo.contentBox(node).w;
				testSize = tabSize;
			}
		}

		for(i = 0; i < testSize.length; i++){
			if(testSize[i] != this._oldTabSize[i]){
				update = true;
				break;
			}
		}

		if(update){
			var mul = dojo.isIE ? 100 : 10000;
			for(i = 0; i < this._grid.length; i++){
				this._grid[i].node.style.width = Math.round((100 * mul * tabSize[i]) / tabWidth) / mul + "%";
			}
			this.resize();
		}

		if(this._activeGrip){
			dojo.removeClass(this._activeGrip, "gridContainerGripShow");
			dojo.addClass(this._activeGrip, "gridContainerGrip");
		}

		this._isResized = false;
	},

	setColumns: function(/*Integer*/nbColumns){
		// summary:
		//		Set the number of columns.
		// nbColumns:
		//		Number of columns

		//console.log("dojox.layout.GridContainer ::: setColumns");
		var z, j;
		if(nbColumns > 0){
			var length = this._grid.length,
				delta = length - nbColumns;
			if(delta > 0){
				var count = [], zone, start, end, nbChildren;
				// Check if right or left columns are fixed
				// Columns are not taken in account and can't be deleted
				if(this.mode == "right"){
					end = (this.isLeftFixed && length > 0) ? 1 : 0;
					start = (this.isRightFixed) ? length - 2 : length - 1
					for(z = start; z >= end; z--){
						nbChildren = 0;
						zone = this._grid[z].node;
						for(j = 0; j < zone.childNodes.length; j++){
							if(zone.childNodes[j].nodeType == 1 && !(zone.childNodes[j].id == "")){
								nbChildren++;
								break;
							}
						}
						if(nbChildren == 0){ count[count.length] = z; }
						if(count.length >= delta){
							this._deleteColumn(count);
							break;
						}
					}
					if(count.length < delta){
						dojo.publish("/dojox/layout/gridContainer/noEmptyColumn", [this]);
					}
				}
				else{ // mode = "left"
					start = (this.isLeftFixed && length > 0) ? 1 : 0;
					end = (this.isRightFixed) ? length - 1 : length;
					for(z = start; z < end; z++){
						nbChildren = 0;
						zone = this._grid[z].node;
						for(j = 0; j < zone.childNodes.length; j++){
							if(zone.childNodes[j].nodeType == 1 && !(zone.childNodes[j].id == "")){
								nbChildren++;
								break;
							}
						}
						if(nbChildren == 0){ count[count.length] = z; }
						if(count.length >= delta){
							this._deleteColumn(count);
							break;
						}
					}
					if(count.length < delta){
						//Not enough empty columns
						dojo.publish("/dojox/layout/gridContainer/noEmptyColumn", [this]);
					}
				}
			}
			else{
				if(delta < 0){ this._addColumn(Math.abs(delta)); }
			}
			if(this.hasResizableColumns){ this._placeGrips(); }
		}
	},

	_addColumn: function(/*Integer*/nbColumns){
		// summary:
		//		Add some columns.
		// nbColumns:
		//		Number of column to added
		// tags:
		//		private

		//console.log("dojox.layout.GridContainer ::: _addColumn");
		var grid = this._grid,
			dropZone,
			node,
			index,
			length,
			isRightMode = (this.mode == "right"),
			accept = this.acceptTypes.join(","),
			m = this._dragManager;

		//Add a grip to the last column
		if(this.hasResizableColumns && ((!this.isRightFixed && isRightMode)
			|| (this.isLeftFixed && !isRightMode && this.nbZones == 1) )){
			this._createGrip(grid.length - 1);
		}

		for(var i = 0; i < nbColumns; i++){
			// Fix CODEX defect #53025 :
			//		Apply acceptType attribute on each new column.
			node = dojo.create("td", {
				'class': "gridContainerZone dojoxDndArea" ,
				'accept': accept,
				'id': this.id + "_dz" + this.nbZones
			});

			length = grid.length;

			if(isRightMode){
				if(this.isRightFixed){
					index = length - 1;
					grid.splice(index, 0, {
						'node': grid[index].node.parentNode.insertBefore(node, grid[index].node)
					});
				}
				else{
					index = length;
					grid.push({ 'node': this.gridNode.appendChild(node) });
				}
			}
			else{
				if(this.isLeftFixed){
					index = (length == 1) ? 0 : 1;
					this._grid.splice(1, 0, {
						'node': this._grid[index].node.parentNode.appendChild(node, this._grid[index].node)
					});
					index = 1;
				}
				else{
					index = length - this.nbZones;
					this._grid.splice(index, 0, {
						'node': grid[index].node.parentNode.insertBefore(node, grid[index].node)
					});
				}
			}
			if(this.hasResizableColumns){
				//Add a grip to resize columns
				if((!isRightMode && this.nbZones != 1) ||
						(!isRightMode && this.nbZones == 1 && !this.isLeftFixed) ||
							(isRightMode && i < nbColumns-1) ||
								(isRightMode && i == nbColumns-1 && this.isRightFixed)){
					this._createGrip(index);
				}
			}
			// register tnbZoneshe new area into the areaManager
			m.registerByNode(grid[index].node);
			this.nbZones++;
		}
		this._updateColumnsWidth(m);
	},

	_deleteColumn: function(/*Array*/indices){
		// summary:
		//		Remove some columns with indices passed as an array.
		// indices:
		//		Column index array
		// tags:
		//		private

		//console.log("dojox.layout.GridContainer ::: _deleteColumn");
		var child, grid, index,
			nbDelZones = 0,
			length = indices.length,
			m = this._dragManager;
		for(var i = 0; i < length; i++){
			index = (this.mode == "right") ? indices[i] : indices[i] - nbDelZones;
			grid = this._grid[index];

			if(this.hasResizableColumns && grid.grip){
				dojo.forEach(grid.gripHandler, function(handler){
					dojo.disconnect(handler);
				});
				dojo.destroy(this.domNode.removeChild(grid.grip));
				grid.grip = null;
			}

			m.unregister(grid.node);
			dojo.destroy(this.gridNode.removeChild(grid.node));
			this._grid.splice(index, 1);
			this.nbZones--;
			nbDelZones++;
		}

		// last grip
		var lastGrid = this._grid[this.nbZones-1];
		if(lastGrid.grip){
			dojo.forEach(lastGrid.gripHandler, dojo.disconnect);
			dojo.destroy(this.domNode.removeChild(lastGrid.grip));
			lastGrid.grip = null;
		}

		this._updateColumnsWidth(m);
	},

	_updateColumnsWidth: function(/*Object*/ manager){
		// summary:
		//		Update the columns width.
		// manager:
		//		dojox.mdnd.AreaManager singleton
		// tags:
		//		private

		//console.log("dojox.layout.GridContainer ::: _updateColumnsWidth");
	 	this.inherited(arguments);
		manager._dropMode.updateAreas(manager._areaList);
	},

	destroy: function(){
		dojo.unsubscribe(this._dropHandler);
		this.inherited(arguments);
	}
});

}

if(!dojo._hasResource["plugins.dijit.TitlePane"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.dijit.TitlePane"] = true;
dojo.provide("plugins.dijit.TitlePane");



dojo.declare("plugins.dijit.TitlePane",
	[dijit.TitlePane],
{
	// summary:
	//		ADAPTED dijit.TitlePane TO ADD EXTRA ELEMENTS TO TEMPLATE
	
	templateString: dojo.cache("plugins", "dijit/templates/TitlePane.html", "<div>\n\t<div dojoAttachEvent=\"onclick:_onTitleClick, onkeypress:_onTitleKey\"\n\t\t\tclass=\"dijitTitlePaneTitle\" dojoAttachPoint=\"titleBarNode\">\n\t\t<div class=\"dijitTitlePaneTitleFocus\" dojoAttachPoint=\"focusNode\">\n\t\t\t<img src=\"${_blankGif}\" alt=\"\" dojoAttachPoint=\"arrowNode\" class=\"dijitArrowNode\" role=\"presentation\"\n\t\t\t/><span dojoAttachPoint=\"arrowNodeInner\" class=\"dijitArrowNodeInner\"></span\n\t\t\t><span dojoAttachPoint=\"titleNode\" class=\"dijitTitlePaneTextNode\"></span\n\t\t\t><span dojoAttachPoint=\"numberNode\" class=\"dijitTitlePaneNumberNode\"></span>\n\t\t</div>\n\t</div>\n\t<div class=\"dijitTitlePaneContentOuter\" dojoAttachPoint=\"hideNode\" role=\"presentation\">\n\t\t<div class=\"dijitReset\" dojoAttachPoint=\"wipeNode\" role=\"presentation\">\n\t\t\t<div class=\"dijitTitlePaneContentInner\" dojoAttachPoint=\"containerNode\" role=\"region\" id=\"${id}_pane\">\n\t\t\t\t<!-- nested divs because wipeIn()/wipeOut() doesn't work right on node w/padding etc.  Put padding on inner div. -->\n\t\t\t</div>\n\t\t</div>\n\t</div>\n</div>\n"),

	// NUMBER APPEARS AT FAR RIGHT OF TITLE
	number: null,

	attributeMap: dojo.delegate(dijit.layout.ContentPane.prototype.attributeMap, {
		title: { node: "titleNode", type: "innerHTML" },
		number: { node: "numberNode", type: "innerHTML" },
		tooltip: {node: "focusNode", type: "attribute", attribute: "title"},	// focusNode spans the entire width, titleNode doesn't
		id:""
	}),
	
	setNumber: function(/*String*/ number){
		// summary:
		//		Deprecated.  Use set('number', ...) instead.
		// tags:
		//		deprecated
		dojo.deprecated("dijit.TitlePane.setNumber() is deprecated.  Use set('number', ...) instead.", "", "2.0");

		this.set("number", number);
	}
	

});

}

if(!dojo._hasResource["plugins.workflow.GridStage"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.workflow.GridStage"] = true;
dojo.provide("plugins.workflow.GridStage");



dojo.declare( "plugins.workflow.GridStage",
	[ dijit._Widget, dijit._Templated, plugins.core.Common ], {
	/////}

//Path to the template of this widget. 
templateString:"<div dojoAttachPoint=\"containerNode\">\n    <table\n        class=\"stagerow\"\n        cellspacing=\"0px\"\n        height=\"16px\" width=\"100%\" style=\"padding: 0; margin: 0; height: 16px !important;\">\n        <tr>\n            <td\n                colspan=\"2\"\n                dojoAttachPoint=\"nameNode\"\n                class=\"name\"\n                >${name}</td>\n            <td\n                colspan=\"1\"\n                dojoAttachPoint=\"numberNode\"\n                class=\"number\">\n            </td>\n        </tr>\n        <tr>\n            <td\n                colspan=\"1\"\n                dojoAttachPoint=\"executorNode\"\n                class=\"executor\"\n                style=\"display: none;\" >${executor}\n            </td>\n\n            <td \n                colspan=\"2\"\n                dojoAttachPoint=\"submitNode\"\n                class=\"\"\n                style=\"display: none;\" >\n            </td>\n            \n        </tr>\n        <tr>\n            <td colspan=\"3\"\n                dojoAttachPoint=\"locationNode\"\n                class='location'\n                style=\"display: none;\" >${location}\n            </td>\n        </tr>\n        <tr>\n            <td colspan=\"3\"\n                dojoAttachPoint=\"descriptionNode\"\n                class='description'\n                style=\"display: none;\" >${description}\n            </td>\n        </tr>\n    </table>\n</div>\n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

// OR USE @import IN HTML TEMPLATE
cssFiles : [ dojo.moduleUrl("plugins") + "/workflow/css/stagerow.css" ],

// PARENT plugins.workflow.Apps WIDGET
parentWidget : null,

// APPLICATION OBJECT
application : null,

// CORE WORKFLOW OBJECTS
core : null,

postCreate : function() {
	this.startup();
},

constructor : function(args) {
	//console.log("GridStage.constructor    plugins.workflow.GridStage.constructor()");

	this.loadCSS();

	this.core = args.core;
	//console.log("GridStage.constructor    this.core: " + this.core);

	this.parentWidget = args.parentWidget;

	this.application = new Object;
	for ( var key in args )
	{
		if ( key != "parentWidget" )
		{
			this.application[key] = args[key];
		}
	}
	////console.log("GridStage.constructor    this.application: " + dojo.toJson(this.application));
	
	//this.inherited(arguments);
},

startup : function () {
	//console.log("GridStage.startup    plugins.workflow.GridStage.startup()");
	////console.log("GridStage.startup    this.parentWidget: " + this.parentWidget);

	this.inherited(arguments);
	
	this.name.parentWidget = this;
	
	// CONNECT TOGGLE EVENT
	var thisObject = this;
	dojo.connect( this.nameNode, "onclick", function(event) {
		event.stopPropagation();
		thisObject.toggle();
	});
},

toggle : function () {
	//console.log("GridStage.toggle    plugins.workflow.GridStage.toggle()");
	var array = [ "executor", "submit", "location", "description" ];
	for ( var i in array )
	{
		var nodeName = array[i] + "Node";
		//console.log("GridStage.toggle    nodeName: " + nodeName);
		if ( this[nodeName].style.display == 'table-cell' )
			this[nodeName].style.display='none';
		else this[nodeName].style.display = 'table-cell';
	}
},


/*	CHECK ALL THE PARAMETERS HAVE VALID INPUTS AND CHANGE CSS ACCORDINGLY.
 	
 	RETURN VALUE OF validInputs AS true IF ALL PARAMETERS ARE SATISFIED.
 	
 	OTHERWISE, RETURN false.
 	
	PROCESS FOR CHECKING VALIDITY FOR EACH PARAMETER

		1. SET this.validInputs TO TRUE, UPDATE ALONG THE WAY

		2. CHECK ONLY inputs (IGNORE outputs AND resources).
		
		3. FOR EACH INPUT:
	
			3.1 CHECK IF VALIDITY HAS ALREADY BEEN COMPUTED AND STORED
			
				IN Agua.getParameterValidity BOOLEAN. USE IF AVAILABLE AND NEXT 
		
			3.2 OTHERWISE, SET Agua.setParameterValidity FOR EACH
			
				PARAMETER AS FOLLOWS:
				
				a. IF FILE/DIR, IGNORE IF OPTIONAL UNLESS FILEPATH SPECIFIED
			
				b. IF NON-OPTIONAL FILE/DIR, ADD TO ARRAY OF files FOR checkFiles
			
				c. IGNORE FLAGS, CHECK INTS AND NON-OPTIONAL TEXT
				
			3.3 RUN checkFiles FOR UNKNOWN FILES/DIRS:
			
				a. DO A BATCH FILE CHECK ON THE REMOTE SERVER. 
			
				b. SET validInputs TO FALSE IF ANY FILES/DIRS ARE MISSING
				
		4. ADJUST CSS CLASS OF GridStage ACCORDING TO VALUE OF validInputs
		
		5. RETURN BOOLEAN VALUE OF validInputs
		
*/

checkAllParameters : function (force) {
	//console.log("GridStage.checkAllParameters     plugins.workflow.GridStage.checkAllParameters(force)");
	//console.log("GridStage.checkAllParameters    this.force: " + this.force);
	//console.log("GridStage.checkAllParameters    this.application.name: ****** " + this.application.name + " ******");

	// SET this.isValid TO DEFAULT true
	this.isValid = true;

	// GET STAGE PARAMETERS
	var parameterRows = new Array;
	var stageParameters = new Array;
	//console.log("GridStage.checkAllParameters    this.application: " + dojo.toJson(this.application));
	//console.log("GridStage.checkAllParameters    this.core.parameters.application: " + dojo.toJson(this.core.parameters.application));

	if ( this.core.parameters != null 
		&& this.core.parameters.isCurrentApplication(this.application) ) {
		parameterRows = this.core.parameters.childWidgets;
		//console.log("GridStage.checkAllParameters    APPLICATIONS IS CURRENT APPLICATION [" + this.application.name + "]. parameterRows.length: " + parameterRows.length);
		for ( var i = 0; i < this.core.parameters.childWidgets.length; i++ )
		{
			stageParameters.push(this.core.parameters.childWidgets[i].parameterObject);
		}
	}
	else {
		stageParameters = Agua.getStageParameters(this.application);
	}
	//console.log("GridStage.checkAllParameters    stageParameters.length: " + stageParameters.length);
	if ( stageParameters == null )	return false;

	// GET ALL REQUIRED/ESSENTIAL INPUT FILE/DIRECTORY PARAMETERS
	this.fileStageParameters = new Array;
	this.fileParameterRows = new Array;
	for ( var i = 0; i < stageParameters.length; i++ )
	{
		//if ( stageParameters[i].paramtype != "input" )	continue;

		// ADD SYSTEM VARIABLES		
		stageParameters[i].value = this.systemVariables(stageParameters[i].value, stageParameters[i]);
		////////////console.log("GridStage.checkAllParameters     [" + i + "] '"
		//////////////////	+ stageParameters[i].name + "'  ("
		//////////////////	+ stageParameters[i].valuetype + ", "
		//////////////////	+ stageParameters[i].discretion + ") value '"
		//////////////////	+ stageParameters[i].value + "', chained: "
		//////////////////	+ stageParameters[i].chained + " [fileinfo: "
		//////////////////	+ dojo.toJson(stageParameters[i].fileinfo) + "]");

		// UNLESS force SPECIFIED, GET VALIDITY IF EXISTS
		// AND MOVE ON TO NEXT STAGE PARAMETER
		var isValid = Agua.getParameterValidity(stageParameters[i]);
		if ( force != true && isValid != null )
		{
			//console.log("GridStage.checkAllParameters    isValid IS DEFINED and force != true");
			if ( parameterRows[i] != null )
			{
				//console.log("GridStage.checkValidFile    DOING parameterRow.setValid(node)");
				if ( isValid == true )
					parameterRows[i].setValid(parameterRows[i].containerNode);
				else {
					parameterRows[i].setInvalid(parameterRows[i].containerNode);
					this.isValid = false;
				}
			}
			//console.log("GridStage.checkAllParameters    End of processing parameter: " + stageParameters[i].name);

			continue;
		}

		// FLAGS ARE AUTOMATICALLY VALID
		else if ( stageParameters[i].valuetype == "flag" )
			continue;
		
		// SAVE UNKNOWN FILE/DIRECTORY FOR checkFiles LATER ON
		if ( stageParameters[i].valuetype == "file"
			||  stageParameters[i].valuetype == "directory" )
			this.checkValidFile(stageParameters[i], parameterRows[i]);

		// CHECK INTEGERS
		else if ( stageParameters[i].valuetype == "integer" )
			this.checkValidInteger(stageParameters[i], parameterRows[i]);

		// CHECK TEXT INPUTS
		else
			this.checkValidText(stageParameters[i], parameterRows[i]);
	}

	//console.log("GridStage.checkAllParameters    this.fileStageParameters.length: " + this.fileStageParameters.length);	
	if ( this.fileStageParameters.length == 0 )
	{
		//console.log("GridStage.checkAllParameters    'this.fileStageParameters' is empty. Returning");	
		//console.log("GridStage.checkAllParameters    No filecheck required. FINAL this.isValid: " + this.isValid);
		
		if ( this.isValid == false || this.isValid == null )
			this.setInvalid();
		else this.setValid();

		return this.isValid;
	}

	//console.log("GridStage.checkAllParameters    this.fileStageParameters.length: " + this.fileStageParameters.length);
	//console.log("GridStage.checkAllParameters    this.fileParameterRows.length: " + this.fileParameterRows.length);

},

checkValidParameters : function (force) {
	this.checkAllParameters(force);
	if ( this.fileStageParameters.length != 0 )
		this.checkFiles();
},

currentParametersApplication : function (application) {
	//console.log("GridStage.currentParametersApplication    GridStage.currentParametersApplication(application)");

	var keys = ["project", "workflow", "workflownumber", "name", "number"];
	return this._objectsMatchByKey(application, this.core.parameters.application, keys);	
},

checkFiles : function (files) {
	//console.log("GridStage.checkFiles    GridStage.checkFiles(files)");
	//console.log("GridStage.checkFiles    this.checkFiles.caller.nom: " + this.checkFiles.caller.nom);
	//console.dir({caller: this.checkFiles.caller});

	//console.log("GridStage.checkFiles    this.fileStageParameters.length: " + this.fileStageParameters.length);
	//console.log("GridStage.checkFiles    this.fileParameterRows.length: " + this.fileParameterRows.length);

	if ( files == null )	files = this.fileStageParameters;
	//console.log("GridStage.checkFiles    this.fileStageParameters: " + this.fileStageParameters.length);
	//console.log("GridStage.checkFiles    'this.fileStageParameters': " + dojo.toJson(this.fileStageParameters, true));
	//console.log("GridStage.checkFiles    BEFORE xhrPut this.isValid: " + this.isValid);
	
	// GET FILEINFO FROM REMOTE FILE SYSTEM
	var url = Agua.cgiUrl + "workflow.cgi";
	var query = new Object;
	query.username = Agua.cookie('username');
	query.sessionid = Agua.cookie('sessionid');
	query.project = this.application.project;
	query.workflow = this.application.workflow;
	query.mode = "checkFiles";
	query.files = files;

	// SEND TO SERVER
	var thisObject = this;
	var xhrputReturn = dojo.xhrPut({
		url: url,
		contentType: "text",
		sync : false,
		handleAs: "json",
		putData: dojo.toJson(query),
		handle: function(fileinfos, ioArgs) {
			thisObject.validateFiles(files, fileinfos);
		}
	});	

	//console.log("GridStage.checkFiles    BEFORE setting stageRow CSS, FINAL this.isValid: " + this.isValid);	
	if ( this.isValid == false || this.isValid == null ) this.setInvalid();
	else this.setValid();
	
	return this.isValid;
},


validateFiles : function (fileinfos) {
	//console.log("GridStage.validateFiles    GridStage.validateFiles(fileinfos)");
	//console.log("GridStage.validateFiles    JSON fileinfos: " + dojo.toJson(fileinfos));
	if ( fileinfos == null
		|| fileinfos.length == null
		|| ! fileinfos.length )
		return;
		
	for ( var i = 0; i < fileinfos.length; i++ )
	{
		//console.log("GridStage.validateFiles    fileinfos[" + i + "]: " + dojo.toJson(fileinfos[i]));
		var parameterRow = this.fileParameterRows[i];
		//console.log("GridStage.validateFiles    parameterRow: " + parameterRow);

		// SET FILE INFO
		Agua.setFileInfo(this.fileStageParameters[i], fileinfos[i]);
		
		if ( fileinfos[i].exists == "true" )
		{
			if ( fileinfos[i].type != this.fileStageParameters[i].valuetype )
			{
				// SET PARAMETER VALIDITY AS FALSE
				//console.log("GridStage.validateFiles    File/dir mismatch. Setting parameter validity as FALSE");
				Agua.setParameterValidity(this.fileStageParameters[i], false);
				this.isValid = false;
				if ( parameterRow != null )
				{
					//console.log("GridStage.validateFiles    DOING parameterRow.setInvalid(node)");
					parameterRow.setInvalid(parameterRow.containerNode);
				}
			}
			else {
				// SET PARAMETER VALIDITY AS TRUE
				//console.log("GridStage.validateFiles    paramtype matches. Setting parameter validity as TRUE");
				Agua.setParameterValidity(this.fileStageParameters[i], true);
				if ( parameterRow != null )
				{
					//console.log("GridStage.validateFiles    DOING parameterRow.setValid(node)");
					//console.dir(parameterRow.containerNode);
					parameterRow.setValid(parameterRow.containerNode);
				}
			}
		}
		else
		{
			if ( this.fileStageParameters[i].discretion == "essential" )
			{
				//console.log("GridStage.validateFiles    file '" + this.fileStageParameters[i].name + "' (discretion: " + this.fileStageParameters[i].discretion + ") does not exist. Setting stageParameter.isValid to FALSE");
				
				this.isValid = false;

				// DO Agua.setParameterValidity
				Agua.setParameterValidity(this.fileStageParameters[i], false);
				if ( parameterRow != null )
				{
					//console.log("GridStage.validateFiles    DOING parameterRow.setInvalid(node)");
					//console.dir(parameterRow.containerNode);
					parameterRow.setInvalid(parameterRow.containerNode);
				}
			}
			else
			{
				// DO Agua.setParameterValidity
				Agua.setParameterValidity(this.fileStageParameters[i], true);
				if ( parameterRow != null )
				{
					//console.log("GridStage.validateFiles    DOING parameterRow.setValid(node)");
					//console.dir(parameterRow.containerNode);
					parameterRow.setValid(parameterRow.containerNode);
				}
			}
		}
	}
	//console.log("GridStage.validateFiles    FINAL (w/o fileCheck) this.isValid: " + this.isValid);

	if ( this.isValid == false )
		this.setInvalid();
	else
		this.setValid();
},

checkValidFile : function (stageParameter, parameterRow) {
	//console.log("GridStage.checkValidFile     GridStage.checkValidFile(stageParameter)");
	//console.log("GridStage.checkValidFile     stageParameter: " + dojo.toJson(stageParameter));
	//console.log("GridStage.checkValidFile    stageParameter.name: " + stageParameter.name);
	
	var filepath = stageParameter.value;
	//console.log("GridStage.checkValidFile     Checking files/dirs");

	// CHECK NON-OPTIONAL FILEPATHS
	// required: FILE PATH MUST BE NON-EMPTY
	// essential: FILE/DIRECTORY MUST BE PHYSICALLY PRESENT
	if ( stageParameter.discretion == "required"
		|| stageParameter.discretion == "essential" )
	{
		//console.log("GridStage.checkValidFile     Parameter is required/essential");

		// SET this.isValid = false IF FILE/DIR IS NULL OR EMPTY
		if ( filepath == null || filepath == '' )
		{
			//console.log("GridStage.checkValidFile    Non-optional file/dir is null or empty.");
			//console.log("GridStage.checkValidFile    Setting stageParameter.parameterIsValid to FALSE.");
			this.setInvalidParameter(stageParameter, parameterRow);
		}

		// ADD TO this.fileStageParameters ARRAY IF NO fileinfo
		else if ( stageParameter.fileinfo == null )
		{
			//console.log("GridStage.checkValidFile    stageParameter.fileinfo is null. Pushing to fileStageParameters");
			this.fileStageParameters.push(stageParameter);
			this.fileParameterRows.push(parameterRow);
		}

		// FILE/DIR IS SPECIFIED BUT KNOWN TO NOT EXIST
		else if ( (stageParameter.fileinfo.exists == false) )
		{
			//console.log("GridStage.checkValidFile    Non-optional file/dir stageParameter.exists is null or false.");

			// PUSH ONTO this.fileStageParameters IF CHAINED = 0
			if ( stageParameter.chained == null
				|| stageParameter.chained == 0 )
			{
				//console.log("GridStage.checkValidFile    stageParameter.chained is 0 or null");
	 			//console.log("GridStage.checkValidFile    Pushing onto this.fileStageParameters");
				this.fileStageParameters.push(stageParameter);
				this.fileParameterRows.push(parameterRow);
			}
			
			// OTHERWISE, USE EXISTING PARAMETER VALIDITY INFO
			// TO SET THE VALIDITY OF THE PARAMETER ROW AND IGNORE
			// WHETHER OR NOT IT EXISTS (CHAINING IS THE PROMISE
			// THAT IT WILL EXIST ONCE THE PREVIOUS STAGE IS DONE.)
			else {
				this.setValidParameter(stageParameter, parameterRow);
			}
		}
		
		// FILE/DIR IS SPECIFIED AND KNOWN TO EXIST
		else {
			//console.log("GridStage.checkValidFile    File/dir exists.");
			if ( stageParameter.fileinfo.type != stageParameter.valuetype )
			{
				// SET PARAMETER VALIDITY AS FALSE
				//console.log("GridStage.checkValidFile    File/dir mismatch. Setting parameter validity as FALSE");
				this.setInvalidParameter(stageParameter, parameterRow);
			}
			else {
				// SET PARAMETER VALIDITY AS TRUE
				//console.log("GridStage.checkValidFile    Paramtype matches. Setting parameter validity as TRUE");
				this.setValidParameter(stageParameter, parameterRow);
			}
		}
	}
	
	// THIS IS AN OPTIONAL PARAMETER SO ITS VALID IF EMPTY.
	// BUT IF ITS NOT EMPTY, CHECK IT EXISTS.
	else 
	{
		// IF EMPTY 
		if ( stageParameter.value == null
			|| stageParameter.value == '' )
		{
			//console.log("GridStage.checkValidFile    Ignoring empty optional file/dir parameter");
			this.setValidParameter(stageParameter, parameterRow);
		}
		else
		{
			//console.log("GridStage.checkValidFile    Optional file/dir parameter is specified. Pushing onto this.fileStageParameters array");
			this.fileStageParameters.push(stageParameter);
			this.fileParameterRows.push(parameterRow);
		}
	}
},

checkValidInteger : function (stageParameter, parameterRow) {
	//console.log("GridStage.checkValidInteger     GridStage.checkValidInteger(stageParameter)");
	//console.log("GridStage.checkValidInteger     stageParameter: " + dojo.toJson(stageParameter));
	if ( stageParameter.discretion != "optional" )
	{
		// SET EMPTY NON-OPTIONAL INTEGER AS FALSE
		if ( stageParameter.value == null
				|| stageParameter.value == '' )
		{
			//console.log("GridStage.checkValidParameters      '" + stageParameter.name + "' Non-optional INTEGER input is empty. Setting this.isValid to FALSE");
			this.setInvalidParameter(stageParameter, parameterRow);
		}
		// NON-OPTIONAL INTEGER BUT IS NOT A PROPER NUMBER
		// ////SO SET TO false
		else if (! stageParameter.value.match(/^\s*[\d\.]+\s*$/) )
		{
			//console.log("GridStage.checkValidParameters      '" + stageParameter.name + "' Non-optional INTEGER input not valid. Setting this.isValid to FALSE");
			this.isValid = false;
			Agua.setParameterValidity(stageParameter, false);
		}
		// OTHERWISE, ITS A CORRECT OPTIONAL INTEGER SO SET TO true
		else
		{
			this.setValidParameter(stageParameter, parameterRow);
		}
	}
	else
	{
		// SET OPTIONAL INTEGER TO false IF ITS NON-EMPTY BUT NOT
		// AN INTEGER
		if ( stageParameter.value != null
				&& stageParameter.value != ''
				&& ! stageParameter.value.match(/^\s*[\d\.]+\s*$/) )
		{
			//console.log("GridStage.checkValidParameters      '" + stageParameter.name + "' Optional INTEGER input not valid. Setting this.isValid to FALSE");
			this.setInvalidParameter(stageParameter, parameterRow);
		}
		
		// OTHERWISE, ITS EITHER EMPTY OR AN INTEGER SO SET TO true
		else
		{
			//console.log("GridStage.checkValidParameters      '" + stageParameter.name + "' Optional INTEGER input is empty. Setting this.isValid to TRUE");
			this.setValidParameter(stageParameter, parameterRow);
		}
	}
},

checkValidText : function (stageParameter, parameterRow) {
	//console.log("GridStage.checkValidText     GridStage.checkValidText(stageParameter)");
	//console.log("GridStage.checkValidText     stageParameter: " + dojo.toJson(stageParameter));
	if ( stageParameter.discretion != "optional" )
	{
		if ( stageParameter.value == null
			|| stageParameter.value == '' )
		{
			//console.log("GridStage.checkValidText      '" + stageParameter.name + "' Required text input is null or empty. Setting this.isValid to FALSE");
			this.setInvalidParameter(stageParameter, parameterRow);
		}
		else
		{
			//console.log("GridStage.checkValidText      '" + stageParameter.name + "' Required text input is satisfied. Setting this.isValid to TRUE");
			this.setValidParameter(stageParameter, parameterRow);
		}
	}
	else
	{
		// THIS IS AN OPTIONAL PARAMETER SO, EMPTY OR NOT, ITS VALID
		//console.log("GridStage.checkValidText      '" + stageParameter.name + "' Optional text parameter. Setting stageParameter.isValid to TRUE");
		this.setValidParameter(stageParameter, parameterRow);
	}
},
setInvalidParameter : function (stageParameter, parameterRow) {
	//console.log("GridStage.setInvalidParameter    stageParameter.name: " + stageParameter.name);
	this.isValid = false;
	Agua.setParameterValidity(stageParameter, false);
	if ( parameterRow != null)
		parameterRow.setInvalid(parameterRow.containerNode);
},

setValidParameter : function (stageParameter, parameterRow) {
	//console.log("GridStage.setValidParameter    stageParameter.name: " + stageParameter.name);
	Agua.setParameterValidity(stageParameter, true);
	if ( parameterRow != null)
		parameterRow.setValid(parameterRow.containerNode);
},

setValid : function () {
	//console.log("GridStage.setValid    SETTING node to SATISFIED");
	//console.log("GridStage.setValid    this.core: ");
	//for ( var key in this.core )
	//{
	//	//console.log(key + ": " + this.core[key]);		
	//}
	
	dojo.removeClass(this.domNode, 'unsatisfied');
	dojo.addClass(this.domNode, 'satisfied');
	
	this.isValid = true;
	var stagesWidget = this.core.userWorkflows;
	//console.log("GridStage.setValid    this.stagesWidget: " + this.stagesWidget);
	stagesWidget.updateRunButton();	
},

setInvalid : function () {
	//console.log("GridStage.setInvalid    SETTING node to UNSATISFIED");
	//console.log("GridStage.setInvalid    this.core: ");
	for ( var key in this.core )
	{
		//console.log(key + ": " + this.core[key]);		
	}

	dojo.removeClass(this.domNode, 'satisfied');
	dojo.addClass(this.domNode, 'unsatisfied');
	
	this.isValid = false;
	var stagesWidget = this.core.userWorkflows;
	//console.log("GridStage.setInvalid    this.stagesWidget: " + this.stagesWidget);
	stagesWidget.updateRunButton();	
}


});

}

if(!dojo._hasResource["plugins.workflow.GridWorkflow"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.workflow.GridWorkflow"] = true;
dojo.provide("plugins.workflow.GridWorkflow");

/* 
	USE CASE SCENARIO 1: USER REORDERS WORKFLOWS IN PROJECT
	

*/

// REQUIRE MODULES
if ( 1 ) {



// WIDGETS AND TOOLS FOR EXPANDO PANE


	
// DnD
// // Source & Target
//
//
//

// INHERITS


// HAS A


}

dojo.declare("plugins.workflow.GridWorkflow",
	[ dijit._Widget, dijit._Templated, plugins.core.Common ],
{
//Path to the template of this widget. 
templateString:"<div dojoattachpoint=\"containerNode\">\n\n    <div\n        dojoAttachPoint=\"titlePane\"\n        dojoType=\"plugins.dijit.TitlePane\"\n        class=\"stageContainer\"\n        title=\"${title}\"\n        number=\"${number}\"\n        style=\"background: #FFF; height: auto; width: 100% !important; min-width: 306px\"\n    >\n        <div\n            dojoAttachPoint=\"dropTargetContainer\"\n        >\n        </div>\n    </div>\n\n</div>\n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

// OR USE @import IN HTML TEMPLATE
cssFiles : [
],

// PARENT WIDGET
parentWidget : null,

// ARRAY OF CHILD WIDGETS
childWidgets : null,

// TAB CONTAINER
attachNode : null,

// CONTEXT MENU
contextMenu : null,

// CORE WORKFLOW OBJECTS
core : null,

// PREVENT DOUBLE CALL ON LOAD
workflowLoaded : null,
dropTargetLoaded : null,

// WORKFLOW-RELATED VARIABLES
project : null,
workflow: null,
number : null,

/////}

constructor : function(args) {
	//console.log("GridWorkflow.constructor     plugins.workflow.GridWorkflow.constructor");			
	// GET ARGS
	this.stages 	= 	args.stages;
	this.core 		= 	args.core;
	this.project 	= 	args.project;
	this.workflow 	= 	args.workflow;
	this.number 	= 	args.number;

	// LOAD CSS
	this.loadCSS();		
},

postCreate : function() {
	this.startup();
},

startup : function () {
	//console.log("GridWorkflow.startup    plugins.workflow.GridWorkflow.startup()");

	//console.log("GridWorkflow.startup    this.titlePane: " + this.titlePane);
	//console.dir({titlepane: this.titlePane});
	
	// COMPLETE CONSTRUCTION OF OBJECT
	this.inherited(arguments);	 

	// POPULATE WITH STAGES
	this.setStages(this.stages);
},

setStages : function (stages) {
	//console.log("GridWorkflow.setStages     plugins.workflow.GridWorkflow.setStages(stages)");
	//console.log("GridWorkflow.setStages    stages: " + dojo.toJson(stages));
	//console.log("GridWorkflow.setStages    stages.length: " + stages.length);	

	// CLEAR STAGES
	this.clearStages();
	
	// SET CHILD WIDGETS
	this.childWidgets = new Array;

	// SORT STAGES
	stages = this.sortNumericHasharray(stages, "number");

	// GENERATE APPLICATIONS ARRAY FOR DRAG AND DROP
	// FROM WORKFLOW APPLICATIONS LIST
	var dataArray = new Array;
	for ( var i = 0; i < stages.length; i++ )
	{
		var hash = new Object;
		hash.data = stages[i].name;
		hash.type = [ "draggableItem" ];
		dataArray.push(hash);
	}
	console.log("GridWorkflow.setStages     dataArray: ");
	console.dir({dataArray:dataArray});

	// CREATE DROP TARGET
	if ( this.dropTarget == null )
	{
		this.dropTarget = new plugins.dnd.Target( this.dropTargetContainer,
			{
				accept: [],
				parentWidget : this
			}
		);
	}

	// INSERT DATA INTO DROP TARGET
	console.log("GridWorkflow.setStages     this.dropTarget: " + this.dropTarget);
	this.dropTarget.insertNodes(false, dataArray);

	// SET GridStage WIDGET FOR EACH STAGE
	allNodes = this.dropTarget.getAllNodes();
	var thisObject = this;
	dojo.forEach(allNodes, function (node, i)
	{
		//console.log("GridWorkflow.setStages     Doing node for stages[" + i + "]: " + dojo.toJson(stages[i]));

		// ENSURE NON-NULL ENTRIES
		stages[i].description = stages[i].stagedescription || '';
		stages[i].submit = stages[i].submit || '';
		
		// INSTANTIATE ROW 
		var gridStage = new plugins.workflow.GridStage(stages[i]);

		// SET gridStage.parentWidget = GridWorkflow
		gridStage.parentWidget = thisObject;
		//console.log("GridWorkflow.setStages     gridStage.parentWidget: " + gridStage.parentWidget);

		// APPEND TO NODE
		node.innerHTML = '';
		node.appendChild(gridStage.domNode);

		// PUSH ONTO ARRAY OF CHILD WIDGETS
		thisObject.childWidgets.push(gridStage);
		
		
	});	// END OF allNodes

}, // end of Stages.setStages

setNumber : function (number) {
// SET THE NUMBER NODE TO THE stage.number 
	//console.log("GridStage.setNumber    plugins.workflow.GridStage.setNumber(" + number + ")");

	this.number = number;
	this.titlePane.set('number', number);
},

clearStages : function () {
// EMPTY dropTargetContainer
	while ( this.dropTargetContainer.firstChild )
	{
		this.dropTargetContainer.removeChild(this.dropTargetContainer.firstChild);
	}	
},

getStagesStandby : function () {
	console.log("GridWorkflow.getStagesStandby    Stages.getStagesStandby()");
	if ( this.standby == null ) {

		var id = dijit.getUniqueId("dojox_widget_Standby");
		this.standby = new dojox.widget.Standby (
			{
				target: this.dropTargetContainer,
				onClick: "reload",
				text: "Checking stage inputs",
				id : id,
				url: "plugins/core/images/agua-biwave-24.png"
			}
		);
		document.body.appendChild(this.standby.domNode);
	}

	console.log("GridWorkflow.getStagesStandby    this.standby: " + this.standby);

	return this.standby;
}


}); // plugins.workflow.GridWorkflow

}

if(!dojo._hasResource["plugins.workflow.Grid"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.workflow.Grid"] = true;
dojo.provide("plugins.workflow.Grid");





// HAS A




// INHERITS


dojo.declare("plugins.workflow.Grid",
	[ dijit._Widget, dijit._Templated, plugins.core.Common ],
{

//Path to the template of this widget. 
templateString:"<div dojoattachpoint=\"containerNode\">\n\n    <div\n        dojoAttachPoint=\"mainTab\"\n        dojoType=\"dijit.layout.ContentPane\"\n        parseOnLoad=\"false\"\n\t\ttitle=\"Projects\"\n\t\tclass=\"grid\"\n\t\tstyle=\"position: relative; min-height: 100px; height: 100%; max-height: auto !important; width: 320px !important; padding: 0 !important;\"\n    >\n\n        <table width=\"100%\">\n\t\t\t<tr valign=\"top\" width=\"100%\">\n\t\t\t\t<td class=\"tabTitle\" align=\"center\">\n                    Projects\n\t\t\t\t</td>\n\t\t\t</tr>\n\t\t</table>\n\n\t\t<table width=\"100%\">\n\t\t\t<tr width=\"100%\" align=\"center\">\n\t\t\t\t<td>\n\t\n\t\t\t\t\t<table width=\"100%\">\n\t\t\t\t\t\t<tr align=\"center\">\n\t\t\t\t\t\t\t<td class=\"projectIcon\">\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t<div dojoType=\"dijit.form.ComboBox\"\n\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"projectCombo\"\n\t\t\t\t\t\t\t\t\tclass=\"projectCombo\"\n\t\t\t\t\t\t\t\t\tautocomplete=\"false\"\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t</table>\n\t\n\t\t\t\t</td>\n\t\t\t</tr>\n\t\n\t\t\t<tr width=\"100%\" align=\"center\">\n\t\t\t\t<td>\n\t\t\t\t\t<table width=\"100%\">\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td\n\t\t\t\t\t\t\t\tdojoAttachPoint=\"stop\"\n\t\t\t\t\t\t\t\tdojoAttachEvent=\"onclick:confirmStopProject\"\n\t\t\t\t\t\t\t\tclass=\"stop\">\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t<td\n\t\t\t\t\t\t\t\tdojoAttachPoint=\"pause\"\n\t\t\t\t\t\t\t\tdojoAttachEvent=\"onclick:confirmPauseProject\"\n\t\t\t\t\t\t\t\tclass=\"pause\">\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t<td\n\t\t\t\t\t\t\t\tdojoAttachPoint=\"play\"\n\t\t\t\t\t\t\t\tdojoAttachEvent=\"onclick:startProject\"\n\t\t\t\t\t\t\t\tclass=\"play\">\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t</table>\n\t\t\t\t</td>\n\t\t\t</tr>\n\t\n\t\t\t<tr width=\"100%\">\n\t\t\t\t<td width=\"100%\">\n\t\t\t\t\t\n\t\t\t\t\t<div>\n\t\t\t\t\t\t<div \n\t\t\t\t\t\t\tdojoAttachPoint=\"mainPanel\"\n\t\t\t\t\t\t\tdojoType=\"dojox.layout.GridContainer\" \n\t\t\t\t\t\t\tclass=\"workflowContainer\"\n\t\t\t\t\t\t\tnbZones=\"1\"\n\t\t\t\t\t\t\topacity=\"0.7\" \n\t\t\t\t\t\t\tallowAutoScroll=\"true\" \n\t\t\t\t\t\t\thasResizableColumns=\"false\"\n\t\t\t\t\t\t\twithHandles=\"true\"\n\t\t\t\t\t\t\tacceptTypes=\"TitlePane\"\n\t\t\t\t\t\t>\n\t\t\t\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\n\t\t\t\t</td>\n\t\t\t</tr>\n\t\t</table>\n\n\t</div>\n\n</div>\n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

// OR USE @import IN HTML TEMPLATE
cssFiles : [
	dojo.moduleUrl("plugins", "workflow/css/grid.css"),
	dojo.moduleUrl("dojo", "resources/dojo.css"),
	dojo.moduleUrl("dijit", "themes/tundra/tundra.css"),
	dojo.moduleUrl("dojox", "layout/resources/GridContainer.css"),
//	dojo.moduleUrl("dojox", "layout/resources/DndGridContainer.css")
],

// PARENT WIDGET
parentWidget : null,

// ARRAY OF CHILD WIDGETS
childWidgets : null,

// CORE WORKFLOW OBJECTS
core : null,

/////}
constructor : function(args) {
	console.log("Grid.constructor     plugins.workflow.Grid.constructor");		
	this.core = args.core;

	// LOAD CSS
	this.loadCSS();		
},
postCreate : function() {
	this.startup();
},
startup : function () {
// DO inherited, LOAD ARGUMENTS AND ATTACH THE MAIN TAB TO THE ATTACH NODE
	console.log("Grid.startup    plugins.workflow.Grid.startup()");

	// COMPLETE CONSTRUCTION OF OBJECT
	this.inherited(arguments);	 

//	console.log("Grid.startup    this.mainTab: " + this.mainTab);
//	console.log("Grid.startup    this.attachNode: " + this.attachNode);
//	console.dir({mainTab: this.mainTab});
// 	console.dir({attachNode: this.attachNode});

	// ADD TO TAB CONTAINER
	console.log("Grid.startup    Doing this.attachNode.addChild(this.mainTab)");
	this.attachNode.addChild(this.mainTab);

	console.log("Grid.startup    Doing this.attachNode.selectChild(this.mainTab)");
	this.attachNode.selectChild(this.mainTab);
	
	// SET CHILD WIDGETS
	this.childWidgets = new Array;
	
	// SET PROJECT COMBO
	this.setProjectCombo();
	//this.setProjectListeners();
	var thisObject = this;
	setTimeout(function(){thisObject.setProjectListeners();}, 100, this);

	// SUBSCRIBE TO UPDATES
	Agua.updater.subscribe(this, "updateProjects");

	// SET DND SUBSCRIPTIONS
	this.setSubscriptions();
},
updateProjects : function (args) {
// RELOAD RELEVANT DISPLAYS
	console.log("workflow.Stages.updateProjects    workflow.Stages.updateProjects(args)");
	console.log("workflow.Stages.updateProjects    args:");
	console.dir({args:args});

	this.setProjectCombo();
},

/////////////////	PROJECT METHODS      
getProject : function () {
	//console.log("Grid.getProject     plugins.workflow.Workflow.getProject()");

	//console.log("Grid.getProject     this: " + this);
	return this.projectCombo.get('value');
},
setProjectCombo : function (projectName) {
// POPULATE THE PROJECT COMBO AND THEN RELOAD THE WORKFLOW COMBO
	console.log("Grid.setProjectCombo    workflow.Stages.setProjectCombo(projectName)");


	// TO AVOID GRATUITOUS EVENT BY onChange LISTENER
	this.settingProject = true;
	
	//console.log("Grid.setProjectCombo    BEFORE this.inherited(arguments)");
	this.inherited(arguments);
	//console.log("Grid.setProjectCombo    AFTER this.inherited(arguments)");
	
	if ( projectName == null )
		projectName = this.projectCombo.getValue();
	//console.log("Grid.setProjectCombo    projectName: " + projectName);

	// RESET THE WORKFLOW COMBO
	//console.log("Grid.setProjectCombo    END. Doing this.setWorkflowCombo(projectName)");
	this.setWorkflows(projectName);
},
setProjectListeners : function () {
	//console.log("Grid.setProjectListeners    Stages.setProjectListeners()");

	// DOJO.CONNECT TO CHANGE THE workflowCombo
	var thisObject = this;
	dojo.connect(this.projectCombo, "onChange", dojo.hitch(this, function(event) {
		var project = event;
		console.log("Grid.setProjectListeners    onchange event. Doing this.setWorkflowCombo(" + project + ")");
		console.log("Grid.setProjectListeners    thisObject.settingProject: " + thisObject.settingProject);
	
		//// AVOID SELF-TRIGGERING OF onChange EVENT WHEN VALUE OF COMBO
		//// IS CHANGED PROGRAMMATICALLY
		//if ( thisObject.settingProject == true ){
		//	console.log("Grid.setProjectListeners    ONCHANGE fired. thisObject.settingProject is true. Returning");
		//	thisObject.settingProject = false;
		//	return;
		//}
		
		// SET WORKFLOW COMBO
		thisObject.setWorkflows(project);
	}));
},

/////////////////	WORKFLOW METHODS      
setWorkflows : function (projectName) {
	console.log("Grid.setWorkflows    plugins.workflow.Parameters.setWorkflows(projectName)");
	console.log("Grid.setWorkflows    projectName: " + projectName);
	//console.log("Grid.setWorkflows    this.mainPanel: " + this.mainPanel);
	//console.dir({mainPanel: this.mainPanel});
	
	// CLEAR GRID CONTAINER
	this.clearPanel(this.mainPanel);	

	var workflows = Agua.getWorkflowsByProject(projectName);
	//console.log("Grid.setWorkflows    BEFORE ORDER workflows: " + dojo.toJson(workflows));

	// ORDER BY WORKFLOW NUMBER -- NB: REMOVES ENTRIES WITH NO WORKFLOW NUMBER
	workflows = this.sortNumericHasharray(workflows, "number");		
	//console.log("Grid.setWorkflows    workflows.length:" + workflows.length);
	if ( workflows == null || workflows == [] )
	{
		//console.log("Grid.setWorkflows     workflows is null or empty. Returning.");
		return;
	}
	
	var thisObject = this;
	dojo.forEach(workflows, function(workflow, i) {
		////console.log("Grid.setWorkflows    **** workflow " + i + ":" + workflowName);
		var projectNumber = workflow.project;
		var workflowName = workflow.name;
		var workflowNumber = workflow.number;
		//console.log("Grid.setWorkflows    **** workflow " + i + ":" + workflowNumber + " " + workflowName);

		var stages = Agua.getStagesByWorkflow(projectName, workflowName);
		//if ( stages.length == 0 ) return;
		////console.log("Grid.setWorkflows    stages.length:" + stages.length);		

		var projectWorkflow = new plugins.workflow.GridWorkflow({
			title: workflowName,
			project: projectName,
			workflow: workflowName,
			number: workflowNumber,
			stages: stages,
			core: thisObject.core
		});

		thisObject.addChild(projectWorkflow);
	});	
},
addChild : function (projectWorkflow) {
	this.mainPanel.addChild(projectWorkflow);

	// PUSH ONTO ARRAY OF CHILD WIDGETS
	this.childWidgets.push(projectWorkflow);
},
setWorkflowStyles : function () {
	console.log("Grid.setWorkflowStyles     workflow.Parameters.setWorkflowStyles()");
	
	var parameterRows = this.childWidgets;
	var parameterHash = new Object;
	for ( var i = 0; i < parameterRows.length; i++ )
	{
		console.log("Grid.setWorkflowStyles     parameterRows[" + i + "]: "+ parameterRows[i]);
		console.log("Grid.setWorkflowStyles     " + parameterRows[i].name + ", parameterRows[" + i + "].paramtype: " + parameterRows[i].paramtype);
		if ( parameterRows[i].paramtype == "input" ) 
			parameterHash[parameterRows[i].name] = parameterRows[i];
	}
	console.dir(parameterHash);
	console.log("Grid.setWorkflowStyles     parameterHash:");
	//for ( var key in parameterHash )
	//{
	//	console.log(key + ": " + parameterHash[key]);
	//}

	console.log("Grid.setWorkflowStyles     this.application: " + dojo.toJson(this.application, true));
	var stageParameters = Agua.getStageParameters(this.application);
	console.log("Grid.setWorkflowStyles     stageParameters: " + dojo.toJson(stageParameters, true));
	console.log("Grid.setWorkflowStyles     stageParameters.length: " + stageParameters.length);
	for ( var i = 0; i < stageParameters.length; i++ )
	{
		if ( stageParameters[i].paramtype != "input" ) continue;

		var parameterRow = parameterHash[stageParameters[i].name];
		console.log("Grid.setWorkflowStyles    stageParameters[i] " + stageParameters[i].name + " (paramtype: " + stageParameters[i].paramtype + ") parameterRow: " + parameterRow);

		var isValid = Agua.getParameterValidity(stageParameters[i]);
		console.log("Grid.setWorkflowStyles     stageParameters[" + i + "] '" + stageParameters[i].name + "' isValid: " + isValid);
		if ( isValid == true || isValid == null )
		{
			console.log("Grid.setWorkflowStyles     Doing parameterRows[" + i +  "].setValid()");
			parameterRow.setValid(parameterRow.domNode);
		}
		else
		{
			parameterRow.setInvalid(parameterRow.domNode);
		}
	}	
},
clearPanel : function (panel) {
// CLEAR GRID CONTAINER CONTENTS
	//console.log("Grid.clearPanel    clearPanel()")
	children = panel.getChildren(); 
	while ( children != null && children.length != 0 )
	{
		//console.log("Grid.setWorkflows    removing child:");
		//console.dir({child: children[0]});
		panel.removeChild(children[0]);
		children = panel.getChildren();
	}	
},
getWorkflowNumber : function (projectName, workflowName) {
	//console.log("Grid.getWorkflow     plugins.workflow.Grid.getWorkflowNumber(projectName, workflowName)");
	if ( projectName == null || workflowName == null ) {
		console.log("Grid.getWorkflow    project or workflow is null. Returning null");
		return;
	}

	return Agua.getWorkflowNumber(projectName, workflowName);
},
updateWorkflowNumber : function (workflowObject, previousNumber) {
// UPDATE THE number OF A STAGE IN this.workflows
// AND ON THE REMOTE SERVER

	console.log("Workflows.updateWorkflowNumber     Workflow.updateWorkflowNumber(workflowObject)");
	console.log("Workflows.updateWorkflowNumber    workflowObject.project: " + workflowObject.project);
	console.log("Workflows.updateWorkflowNumber    workflowObject.workflow: " + workflowObject.workflow);
	console.log("Workflows.updateWorkflowNumber    workflowObject.name: " + workflowObject.name);
	console.log("Workflows.updateWorkflowNumber    workflowObject.number: " + workflowObject.number);
	
	// REMOVE FROM Agua DATA
	var addOk = Agua.updateWorkflowNumber(workflowObject, previousNumber);
	if ( ! addOk ) {
		//console.log("Workflows.updateWorkflowNumber    Failed to add workflow to Agua data");
		return;
	}
	////console.log("Workflows.updateWorkflowNumber     addOk: " + addOk);
},
resetNumbers : function (node, targetArea, indexChild) {	
	console.log("Grid.resetNumbers    plugins.workflow.GridWorkflow.resetNumbers(node, targetArea, indexChild)");
	//console.log("Grid.resetNumbers    node: ");
	//console.dir({node: node})
	//console.log("Grid.resetNumbers    targetArea: ");
	//console.dir({targetArea: targetArea})
	console.log("Grid.resetNumbers    indexChild: " + indexChild);
	var projectWorkflow = dijit.byNode(node);
	var workflowObject = {
		project:	projectWorkflow.project, 
		name: 		projectWorkflow.title,
		number:		projectWorkflow.number
	};
	//console.log("Grid.resetNumbers    workflowObject: " + dojo.toJson(workflowObject, true)); 
	// UPDATE ALL WORKFLOWS IN PROJECT
	Agua.moveWorkflow(workflowObject, indexChild + 1);

	// UPDATE ALL projectWorkflow OBJECTS AND THEIR workflowStage OBJECTS
	console.log("Grid.updateWorkflowNumber    DOING renumberWorkflows()");
	this.renumberWorkflows();
	
	// RELOAD RELEVANT DISPLAYS
	console.log("Grid.updateWorkflowNumber    DOING Agua.updater.update('updateProjects')");
	Agua.updater.update("updateProjects", { originator: this, reload: false});
},
renumberWorkflows : function () {
// RESET number IN ALL projectWorkflows AND THEIR workflowStages
	console.log("Grid.renumberWorkflows     renumberWorkflows()");
	
	var workflows = this.mainPanel.getChildren();
	for ( var i = 0; i < workflows.length; i++ )
	{
		var workflow = workflows[i];
		workflow.setNumber(i + 1);

		var stages = workflow.childWidgets;
		if ( stages == null )	continue;
		for ( var j = 0; j < stages.length; j++ )
		{
			stages[j].workflownumber = i + 1;
		}
	}
},

/////////////////	CONTROL METHODS
confirmStopProject : function () {
	
},
confirmPauseProject : function () {
	
},
startProject : function () {
	
},

/////////////////	DEBUG METHODS
setSubscriptions : function () {
	var thisObject = this;
	// example subscribe to events	
	dojo.subscribe("/dojox/mdnd/adapter/dndToDojo/over", null,  function(arg) {
		console.log("dndToDojo/over");
	});
	dojo.subscribe("/dojox/mdnd/adapter/dndToDojo/out", null, function(arg) {
		console.log("dndToDojo/out");
	});
	dojo.subscribe("/dojox/mdnd/adapter/dndToDojo/drop", null, function(arg) {
		console.log("dndToDojo/drop");
	});
	dojo.subscribe("/dojox/mdnd/adapter/dndToDojo/cancel", null, function(arg) {
		console.log("dndToDojo/cancel");
	});
	
	dojo.subscribe("/dojo/dnd/manager/overSource", function(source){
		console.debug("/dojo/dnd/manager/overSource", source);
	});
	
	dojo.subscribe("/dojox/mdnd/drag/start", function(node, targetArea, indexChild){
		console.dir({node: node});
		console.log("Doing /dojox/mdnd/drag/start    targetArea: ");
		console.dir({targetArea: targetArea})
		console.log("Doing /dojox/mdnd/drag/start    indexChild: " + indexChild);
	});
	
	dojo.subscribe("/dojox/mdnd/drop", null, function(node, targetArea, indexChild){
		console.log("Doing /dojox/mdnd/drop    node: " + node);
		console.log("Doing /dojox/mdnd/drop    targetArea: " + targetArea);
		console.dir({targetArea: targetArea})
		console.log("Doing /dojox/mdnd/drop    indexChild: " + indexChild);

		thisObject.resetNumbers(node, targetArea, indexChild);
	});
	
	dojo.subscribe("/dojox/mdnd/dropMode.OverDropMode/getDragPoint", function(node, targetArea, indexChild){
		console.log("Doing /dojox/mdnd/dropMode.OverDropMode/getDragPoint    node: " + node);
		console.log("Doing /dojox/mdnd/drop    targetArea: " + targetArea);
		console.dir({targetArea: targetArea})
		console.log("Doing /dojox/mdnd/drop    indexChild: " + indexChild);
	});


	/*
	//dojo.subscribe("/dojox/mdnd/drag/over", function(source){
	//	console.debug("over", source);
	//});
	
	//dojo.subscribe("/dojox/mdnd/drag/cancel", function(source, nodes, copy, target) {
	//	console.debug("cancel", source);
	//});
	
	//dojo.subscribe("/dojox/mdnd/out", function(source){
	//	console.debug("out", source);
	//});
	//dojo.subscribe("/dojox/mdnd/cancel", function(source){
	//	console.debug("cancel", source);
	//});
	*/
}


}); // plugins.workflow.Grid


}

if(!dojo._hasResource["plugins.workflow.HistoryPane"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.workflow.HistoryPane"] = true;
dojo.provide("plugins.workflow.HistoryPane");

// DISPLAY THE STATUS OF A WORKFLOW STAGE

dojo.declare( "plugins.workflow.HistoryPane",
	[ dijit._Widget, dijit._Templated ], {
//Path to the template of this widget. 
templateString:"<div dojoAttachPoint=\"containerNode\">\n\n\t<table class=\"historyPaneTable\">\n\t\t<tr>\n\t\t\t<td colspan=\"2\"\n\t\t\t\tclass='displayStatusHeader'\n\t\t\t\tdojoAttachEvent=\"onclick:openWorkflow\"\n\t\t\t\talign=left>${project} ${workflow}</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>\n\t\t\t\t<div dojoAttachPoint=\"rowsNode\"></div>\n\t\t\t</td>\n\t\t</tr>\n\t\n\t</table>\n\n</div>\n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

//srcNodeRef: null,

// ROWS OF ENTRIES
rows : null,

// CORE WORKFLOW OBJECTS
core : null,

/////}
constructor : function(args) { 	
	//console.log("HistoryPane.constructor    plugins.workflow.HistoryPane.constructor(args)");
	//console.log("HistoryPane.constructor    args: " + dojo.toJson(args));
	//this.project = rows[0].project;
	//this.workflow = rows[0].workflow;
	this.rows = args.rows;

	this.core = args.core;

},

postMixInProperties: function() {
	////console.log("HistoryPane.postMixInProperties    plugins.workflow.HistoryPane.postMixInProperties()");
	////console.log("HistoryPane.postMixInProperties    this.containerNode: " + this.containerNode);
},

postCreate: function() {
	////console.log("HistoryPane.postCreate    plugins.workflow.HistoryPane.postCreate()");
	////console.log("HistoryPane.postCreate    this.domNode: " + this.domNode);

	this.startup();		
},

startup : function () {
	//console.log("HistoryPane.startup    plugins.workflow.HistoryPane.startup()");

	// SET UP THE ELEMENT OBJECTS AND THEIR VALUE FUNCTIONS
	this.inherited(arguments);

	for ( var i = 0; i < this.rows.length; i++ )
	{
		////console.log("HistoryPane.startup    dojo.toJson(this.rows[" + i + "]): " + dojo.toJson(this.rows[i]));
		var historyPaneRow = new plugins.workflow.HistoryPaneRow(this.rows[i]);
		////console.log("HistoryPane.startup    historyPaneRow: " + historyPaneRow);
		////console.log("HistoryPane.startup    this.rowsNode: " + this.rowsNode);

		this.rowsNode.innerHTML += historyPaneRow.domNode.innerHTML;

	}
},

openWorkflow : function () {
	var projectName = this.project;
	var workflowName = this.workflow;
	console.log("HistoryPane.openWorkflow    projectName: " + projectName);
	console.log("HistoryPane.openWorkflow    workflowName: " + workflowName);
	
	// OPEN WORKFLOW TAB
	if ( Agua.controllers["workflow"] ) 
		Agua.controllers["workflow"].createTab({project: projectName, workflow: workflowName});
}

}); // end of plugins.workflow.HistoryPane


dojo.declare( "plugins.workflow.HistoryPaneRow",
	[ dijit._Widget, dijit._Templated ], {

//Path to the template of this widget. 
templateString:"<div dojoAttachPoint=\"containerNode\">\n    <table>\n    <tr>\n        <td colspan=\"2\" class='displayStatusRow value' width='200px'>${number}. ${name} ${status}</td>\n    </tr>\n    <tr>\n        <td class='displayStatusRow key' width='100px' align='right'>Started</td>\n        <td class='displayStatusRow value' width='200px'>${started}</td>\n    </tr>\n    <tr>\n        <td class='displayStatusRow key' width='100px' align='right'>Completed</td>\n        <td class='displayStatusRow value' width='200px'>${completed}</td>\n    </tr>\n    </table>\n</div>\n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

//srcNodeRef: null,

// CORE WORKFLOW OBJECTS
core : null,

/////}
constructor : function(args) {
	////console.log("HistoryPaneRow.constructor    plugins.workflow.HistoryPaneRowRow.constructor(args)");
	////console.log("HistoryPaneRow.constructor    args: " + dojo.toJson(args));
	this.core = args.core;
},

postCreate : function() {
	this.startup();
},

startup : function () {
	//console.log("HistoryPaneRow.startup    plugins.workflow.HistoryPaneRow.startup()");

	this.inherited(arguments);
}

});

}

if(!dojo._hasResource["plugins.workflow.History"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.workflow.History"] = true;
dojo.provide("plugins.workflow.History");

// EXTERNAL MODULES



// INTERNAL MODULES


// HAS A


dojo.declare("plugins.workflow.History",
	[ dijit._Widget, dijit._Templated, plugins.core.Common ], {

//Path to the template of this widget. 
templateString:"<div dojoAttachPoint=\"containerNode\">\n\n    <!-- HISTORY TAB -->\n    <div\n        dojoAttachPoint=\"mainTab\" \n        dojoType=\"dijit.layout.ContentPane\"\n        title=\"History\"\n        parseOnLoad=\"false\"\n        class=\"history\"\n        style=\" height: 100%; width: 100%; padding: 0 !important;\"\n    >\n\n        <table width=\"100%\">\n            <tr>\n                <td colspan=\"5\" class=\"tabTitle\" align=\"center\">History</td>\n            </tr>\n            <tr>\n                <td width=\"20%\"></td>\n                <td\n                    dojoAttachPoint=\"downloadHistoryButton\"\n                    dojoAttachEvent=\"onclick:downloadHistory\"\n                    class=\"downloadHistoryButton\"\t\t\t\t\t\t\t\t\t\t\t\t\t\t\twidth=\"20%\"\n                    align=\"center\" >\n                </td>\n                <td width=\"20%\"></td>\n                <td\n                    dojoAttachPoint=\"refreshHistoryButton\"\n                    dojoAttachEvent=\"onclick:showHistory\"\n                    class=\"refreshHistoryButton\" \t\t\t\t\t\t\t\t\t\t\t\t\t\t\twidth=\"20%\"\n                    align=\"center\" >\n                </td>\n                <td width=\"20%\"></td>\n            </tr>\n            <tr class=\"titles\">\n                <td width=\"20%\"></td>\n                <td width=\"20%\" height=\"12px\" align=\"center\">Download</td>\n                <td width=\"20%\"></td>\n                <td width=\"20%\" height=\"12px\" align=\"center\">Refresh</td>\n                <td width=\"20%\"></td>\n            </tr>\n\n        </table>\n\n        <div\n            dojoAttachPoint=\"historyTable\" \n            style=\"height:100%;width:100%;\"\n            parseOnLoad=\"false\"\n            >\n        </div>\n\n    </div>\n    <!-- END OF HISTORY TAB -->\n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

// OR USE @import IN HTML TEMPLATE
cssFiles : [ dojo.moduleUrl("plugins", "workflow/css/history.css") ],

// PARENT WIDGET
parentWidget : null,

// ARRAY OF CHILD WIDGETS
childWidgets : null,

// isVALID BOOLEAN: ALL PARAMETERS ARE VALID
isValid : null,

// CORE WORKFLOW OBJECTS
core : null,

/////}

constructor : function(args) {
	//////console.log("History.constructor     plugins.workflow.History.constructor");			
	this.core = args.core;

	// LOAD CSS
	this.loadCSS();		
},

postCreate : function() {
	//////console.log("Controller.postCreate    plugins.workflow.Controller.postCreate()");

	this.startup();
},


// DO inherited, LOAD ARGUMENTS AND ATTACH THE MAIN TAB TO THE ATTACH NODE
startup : function () {
	//////console.log("History.startup    plugins.workflow.History.startup()");

	// COMPLETE CONSTRUCTION OF OBJECT
	this.inherited(arguments);	 

	//////console.log("History.startup    this.application: " + this.application);
	//////console.log("History.startup    this.attachNode: " + this.attachNode);

	// ADD TO TAB CONTAINER		
	this.attachNode.addChild(this.mainTab);
	
	// GET WORKFLOW HISTORY AND DISPLAY IN HISTORY TAB
	this.showHistory();
},

// GET WORKFLOW HISTORY AND DISPLAY IN HISTORY TAB
showHistory : function () {
	//console.log("History.showHistory    plugins.workflow.Workflow.showHistory()");

	// SELECT HISTORY TAB IN TAB CONTAINER
	//this.controlPane.selectChild(this.history);

	// EMPTY CURRENT TABLE IF PRESENT
	while ( this.historyTable.firstChild )
	{
		this.historyTable.removeChild(this.historyTable.firstChild);
	}
	
	// GET URL 
	var url = Agua.cgiUrl + "workflow.cgi";
	//console.log("History.showHistory    url: " + url);		

	// GENERATE QUERY JSON FOR THIS WORKFLOW IN THIS PROJECT
	var query = new Object;
	query.username = Agua.cookie('username');
	query.sessionid = Agua.cookie('sessionid');
	query.mode = "getHistory";
	//console.log("History.showHistory    query: " + dojo.toJson(query));

	var thisObject = this;
	dojo.xhrPut(
		{
			url: url,
			putData: dojo.toJson(query),
			handleAs: "json",
				//handleAs: "json-comment-optional",
			sync: false,
			handle: function(response)
			{
				////console.log("History.showHistory    response: " + dojo.toJson(response));
				// BUILD TABLE
				var table = document.createElement('table');
				thisObject.historyTable.appendChild(table);
				dojo.addClass(table, 'historyTable');
		
				// SET THE NODE CLASSES BASED ON STATUS
				for ( var i = 0; i < response.length; i++ )
				{
					var tr = document.createElement('tr');
					table.appendChild(tr);

					var td = document.createElement('td');
					tr.appendChild(td);

					var project = response[i][0].project;
					var workflow = response[i][0].workflow;
					var historyPane = new plugins.workflow.HistoryPane(
						{
							project: project,
							workflow : workflow,
							rows: response[i]
						}
					);
					td.appendChild(historyPane.domNode); 
				}
			}
		}
	);
},

downloadHistory: function (event) {
	// STOP EVENT
	event.stopPropagation();
	
	// GENERATE HISTORY QUERY AND SEND TO SERVER
	var query = "?username=" + Agua.cookie('username');
	query += "&sessionid=" + Agua.cookie('sessionid');
	query += "&mode=downloadHistory";
	var url = Agua.cgiUrl + "download.cgi";
	console.log("History.setHistoryButtons     downloadHistoryButton.onclick    query: " + query);
	console.log("History.setHistoryButtons     downloadHistoryButton.onclick    url: " + url);

	////// GENERATE QUERY JSON FOR THIS WORKFLOW IN THIS PROJECT
	////var query = new Object;
	////query.username = Agua.cookie('username');
	////query.sessionid = Agua.cookie('sessionid');
	//query.mode = "getHistory";
	//console.log("History.showHistory    query: " + dojo.toJson(query));

	//var thisObject = this;
	//dojo.xhrPut(
	//	{
	//		url: url,
	//		putData: dojo.toJson(query),
	//		handleAs: "text",
	//		sync: false,
	//		handle: function(response) {
	//			console.log("History.showHistory    response: ");
	//			console.dir({response:response});
	//		}
	//	}
	//);


	//var thisObject = this;
	//dojo.xhrPut(
	//	{
	//		url: url,
	//		putData: dojo.toJson(query),
	//		handleAs: "text",
	//		sync: false,
	//		handle: function(response) {
	//			console.log("History.showHistory    response: ");
	//			console.dir({response:response});
	//		}
	//	}
	//);

	// DO AN IFrame REQUEST TO DOWNLOAD THE FILE
	/* NB: dojo.io.iframe.send SUPPORTS ONLY 'GET' OR 'POST */
	var args = {
		method: "POST",
		url: url + query,
		handleAs: "html",
		//timeout: 10000
		//load: dojo.hitch(this, "onDownloadComplete"),
		//error: dojo.hitch(this, "onDownloadError")
	};
	dojo.io.iframe.send(args);
}


	
}); // plugins.workflow.History


}

if(!dojo._hasResource["plugins.workflow.IO"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.workflow.IO"] = true;
dojo.provide("plugins.workflow.IO");

/* 

SET THE DEFAULT CHAINED VALUES FOR INPUTS AND OUTPUTS FOR AN
APPLICATION BASED ON THOSE OF THE PREVIOUS APPLICATIONS

E.G., THE NAME OF THE OUTPUT FILE FOR AN APPLICATION CAN BE MADE
TO DEPEND ON THE INPUTS FOR THE APPLICATION. IN THIS CASE, THE
args, inputParams AND paramFunction ENTRIES PROVIDE THE MEANS
TO INFER THE NAME OF THE OUTPUT FILE:

	stageParameters = [ 	    
	{
		"owner": "admin",
		"value": "",
		"args": "input.inputfile.value",
		"inputParams": "inputfile",
		"appname": "eland2ace.pl",
		"apptype": "converter",
		"argument": "",
		"category": "acefile",
		"valuetype": "file",
		"project": "Project1",
		"workflow": "Workflow1",
		"appnumber": "2"
		name: "acefile",
		paramtype: "output",
		format: "ace",
		args: [ 'arguments.inputfile.value' ],
		inputParams : [inputfile],
		paramFunction: "var acefile = inputfile; acefile = acefile.replace(/\\.txt/, \".ace\"); return acefile;"
	},
	...
*/


// INHERITS


dojo.declare( "plugins.workflow.IO",
	[ plugins.core.Common ],
{

////}

// PARENT WIDGET
parentWidget : null,

// CORE WORKFLOW OBJECTS
core : null,

constructor : function(args) {
	//console.log("IO.constructor     args:");
	//console.dir({args:args});
	
	// GET INFO FROM ARGS
	this.core = args.core;
	this.parentWidget = args.parentWidget;

	// LOAD CSS
	this.loadCSS();		
},

postCreate : function() {
	this.startup();
},

startup : function () {
	//console.log("IO.startup    plugins.workflow.IO.startup()");
	// COMPLETE CONSTRUCTION OF OBJECT
	this.inherited(arguments);	 
},


chainStage : function (application, force) {
// 		1. SET INPUTS DEPENDENT ON THE OUTPUTS OF THE PREVIOUS STAGE
// 		2. SET RESOURCES DEPENDENT ON INPUTS OF THIS STAGE
// 		3. SET OUTPUTS DEPENDENT ON INPUTS AND RESOURCES OF THIS STAGE
//      (NB: REPEAT STEP 3 IF USER CHANGES RESOURCES MANUALLY)
	//console.log("IO.chainStage     plugins.workflow.IO.chainStage(application, force)");
	//console.log("IO.chainStage     application: " + dojo.toJson(application));
	//console.log("IO.chainStage     force: " + force);

	var chained = new Object;

	// SET INPUTS
	//console.log("IO.chainStage     Doing INPUTS for application: " + application.name);
	// RETURN IF NO PRECEDING APPLICATIONS
	if ( application.number != 1 )
	{
		chained.inputs = this.chainInputs(application, force);
	}
	
	//// SET RESOURCESsf 
	////console.log("IO.chainStage     Doing RESOURCES for application: " + application.name);
	//application = this.chainResources(application.arguments, application);
	//

	// SET OUTPUTS 
	//console.log("IO.chainStage     Doing OUTPUTS for application: " + application.name);
	chained.outputs = this.chainOutputs(application, force);

	// UPDATE VALID/INVALID CSS IN PARAMETERS PANE
	if ( this.core.parameters != null 
		&& this.core.parameters.isCurrentApplication(application) )
			this.core.parameters.setParameterRowStyles();

	//console.log("IO.chainStage     END");

	return chained;
},

chainInputs: function (application, force) {
// GET INPUTS FOR AN APPLICATION, BASED ON THE INPUTS, OUTPUTS
// AND OR RESOURCES OF THE PREVIOUS APPLICATION

	//console.log("IO.chainInputs     plugins.workflow.IO.chainInputs(application)");
	//console.log("IO.chainInputs     application: " + dojo.toJson(application));

	// GET THE input STAGE PARAMETERS FOR THIS STAGE        
	var stageParameters = Agua.getStageParameters(application);
	var inputParameters = this.filterByKeyValues(stageParameters, ["paramtype"], ["input"]);
	//console.log("IO.chainInputs     stageParameters: " + dojo.toJson(stageParameters));
	
	// GET THE STAGE PARAMETERS FOR THE PRECEDING STAGE
	var appnumber = application.appnumber;
	if ( appnumber == null )
	{
		//console.log("IO.chainInputs     appnumber is null. Returning");
		return;
	}
	//console.log("IO.chainInputs     appnumber: " + appnumber);

	var stages = Agua.getStagesByWorkflow(application.project, application.workflow);
	//console.log("IO.chainInputs     stages: " + dojo.toJson(stages));
	//console.log("IO.chainInputs     no. stages: " + stages.length);
	if ( stages == null )
	{
		//console.log("IO.chainInputs     stages is null. Returning");
		return;
	}
	
	//console.log("IO.chainInputs     previousStage = stages[" + (appnumber - 2) + "]");
	var previousStage = stages[appnumber - 2];
	if ( previousStage == null )
	{
		//console.log("IO.chainInputs     previousStage is null. Returning");
		return;
	}
	//console.log("IO.chainInputs     previousStage: " + dojo.toJson(previousStage));

	var previousStageParameters = Agua.getStageParameters(previousStage);
	if ( previousStageParameters == null )
	{
		//console.log("IO.chainInputs     previousStageParameters is null. Returning");
		return;
	}
	//console.log("IO.chainInputs     previousStageParameters: " + dojo.toJson(previousStageParameters));
	
	for ( var i = 0; i < inputParameters.length; i++ )
	{
		//console.log("IO.chainInputs     Doing chainStageParameter " + i + ": " + inputParameters[i].name + "(" + dojo.toJson(inputParameters[i]));
		this.chainStageParameter(inputParameters[i], previousStageParameters, force);
	}
	//console.log("IO.chainInputs     Doing chainStageParameter " + i);
	
	//console.log("IO.chainInputs     inputParameters: " + dojo.toJson(inputParameters));
	return inputParameters;

},  //  chainInputs

chainResources: function (application, force) {
/*  GET RESOURCES FOR AN APPLICATION, BASED ON THE INPUTS, OUTPUTS

	AND/OR RESOURCES OF THE CURRENT APPLICATION
*/

},

chainOutputs : function (application, force) {
// GET OUTPUTS FOR AN APPLICATION, BASED ON THE INPUTS AND/OR
//	RESOURCES OF THE APPLICATION
	//console.log("IO.chainOutputs     plugins.workflow.IO.chainOutputs(application, force)");
	//console.log("IO.chainOutputs     application: " + dojo.toJson(application));

	// GET THE input STAGE PARAMETERS FOR THIS STAGE        
	var stageParameters = Agua.getStageParameters(application);
	//console.log("IO.chainOutputs     stageParameters: " + dojo.toJson(stageParameters));
	
	// GET OUTPUT STAGE PARAMETERS ONLY
	var outputParameters = dojo.clone(stageParameters);
	outputParameters = this.filterByKeyValues(outputParameters, ["paramtype"], ["output"]);
	//console.log("IO.chainOutputs     outputParameters: " + dojo.toJson(outputParameters));
	
	for ( var i = 0; i < outputParameters.length; i++ )
	{
		//console.log("IO.chainOutputs     Doing chainStageParameter " + i);
		this.chainStageParameter(outputParameters[i], stageParameters, force);
	}
	//console.log("IO.chainOutputs     Returning outputParameters: " + dojo.toJson(outputParameters, true));

	return outputParameters;
},

chainStageParameter : function (stageParameter, sourceParameters, force) {
	//console.log("IO.chainStageParameter     plugins.workflow.IO.chainStageParameter(stageParameter, sourceParameters, force)");
	////console.log("IO.chainStageParameter     stageParameter: " + dojo.toJson(stageParameter));
	//console.log("IO.chainStageParameter     stageParameter.name: " + stageParameter.name);
	//console.log("IO.chainStageParameter     force: " + force);
	
	// RETURN IF args IS NULL
	if ( stageParameter.args == null || stageParameter.args == '' )
	{
		//console.log("IO.chainStageParameter     stageParameters.args is null or empty. Returning.");
		return;
	}

	var valuesArray = this.getValuesArray(stageParameter, dojo.clone(sourceParameters));
	//console.log("IO.chainStageParameter     valuesArray: " + dojo.toJson(valuesArray));	
	var value = this.getValue(valuesArray, stageParameter.inputParams, stageParameter.paramFunction);
	//console.log("IO.chainStageParameter     value: " + value);

	// REPLACE EMPTY STAGE PARAMETER VALUE IN Agua AND REMOTE DATABASE 
	// OR OVERWRITE EXISTING VALUE IF force IS TRUE
	if ( (force == true && value != null && value != '' )
		|| (value != null && value != '' && stageParameter.value == '') )
	{
		//console.log("IO.chainStageParameter     Adding chained value to stageParameter: " + value);
		
		stageParameter.value = value;
		stageParameter.chained = 1;
		Agua._removeStageParameter(stageParameter);
		Agua.addStageParameter(stageParameter);
		Agua.setParameterValidity(stageParameter, true);
	}
},

getValuesArray : function(parameter, sourceParameters) {
// GET THE ARRAY OF VALUES FOR THE args TO BE INPUT INTO THE paramFunction
	//console.log("IO.getValuesArray     plugins.workflow.WorfklowIO.getValuesArray(parameter, sourceParameters)");
	//console.log("IO.getValuesArray     parameter : " + dojo.toJson(parameter));
	//console.log("IO.getValuesArray     sourceParameters : " + dojo.toJson(sourceParameters));
	// SANITY CHECK		
	if ( parameter.args == null || sourceParameters == null )
	{
		return;
	}
	// CONVERT args TO argsArray
	var argsArray = parameter.args.split(/,/);
	//console.log("IO.getValuesArray     argsArray: " + dojo.toJson(argsArray));

	// RETURN AN ARRAY
	var valuesArray = new Array;

	var thisObject = this;
	//dojo.forEach(argsArray, function(args, i) {

	for ( var i = 0; i < argsArray.length; i++ ) {
		var args = argsArray[i];
		
		//console.log("IO.getValuesArray     argsArray[" + i + "]: " + argsArray[i]);
		//console.log("IO.getValuesArray     args: " + args);

		// EXTRACT ARGUMENT VALUE FROM APPLICATION OBJECT
		var array = args.split("\.");
		var paramtypeToken = array[0];
		var nameToken = array[1];
		var valueToken = array[2];
		//console.log("IO.getValuesArray     paramtypeToken: " + paramtypeToken);
		//console.log("IO.getValuesArray     nameToken: " + nameToken);
		//console.log("IO.getValuesArray     valueToken: " + valueToken);

		// FILTER BY PARAMTYPE TYPE (input|resource|output)
		var sources = dojo.clone(sourceParameters);
		sources = thisObject.filterByKeyValues(sources, ["paramtype"], [paramtypeToken]);
		//console.log("IO.getValuesArray     '" + paramtypeToken + "' sources: " + dojo.toJson(sources));

		// IF SOURCE PARAMETERS NOT PRESENT, SET VALUE TO ''
		if ( sources == null || sources.length == 0 )
		{
			valuesArray.push(null);
			continue;
		}
		// IF THE ARRAY OF SOURCE PARAMETERS WAS WANTED, STORE IT AND NEXT
		if ( nameToken == null || nameToken == '' )
		{
			valuesArray.push(sources);
			continue;
		}
		// GET THE SOURCE PARAMETER
		//console.log("IO.getValuesArray     BEFORE GET sourceParameter, nameToken: " + nameToken);
		var source = thisObject.filterByKeyValues(dojo.clone(sources), ["name"], [nameToken])[0];
		//console.log("IO.getValuesArray     " + nameToken + " source: " + dojo.toJson(source, true));

		// IF SOURCE PARAMETER NOT DEFINED, SET VALUE TO ''
		if ( source == null || source == '' )
		{
			valuesArray.push(null);
			continue;
		}

		// IF THE WHOLE PARAMETER HASH WAS WANTED, STORE IT AND NEXT
		if ( valueToken == null )
		{
			valuesArray.push(source);
			continue;
		}

		// OTHERWISE, GET THE PARAMETER'S VALUE
		var value = source.value;
		//console.log("IO.getValuesArray     value: " + value);
		valuesArray.push(value);
	}
//);
	//////console.log("IO.getValuesArray     Returning valuesArray: " + dojo.toJson(valuesArray));
	return valuesArray;
},

getValue : function (valuesArray, inputParams, paramFunction) {
// GET THE PARAMETER VALUE USING THE paramFunction IF PRESENT.
// OTHERWISE, RETURN A SCALAR OF THE FIRST ENTRY IN valuesArray
	//console.log("IO.getValue     plugins.workflow.Workflow.value(valuesArray, inputParams, paramFunction)");
	//console.log("IO.getValue     valuesArray: " + dojo.toJson(valuesArray));
	//console.log("IO.getValue     inputParams: " + dojo.toJson(inputParams));
	//console.log("IO.getValue     paramFunction: " + dojo.toJson(paramFunction));

	var value;
	if ( inputParams == null || inputParams == ''
		|| paramFunction == null || paramFunction == '' )
	{
		//console.log("IO.getValue     inputParams NOT DEFINED. Returning first entry in valuesArray: " + dojo.toJson(valuesArray));
		for ( var i = 0; i < valuesArray.length; i++ )
		{
			if ( valuesArray[i] == null || valuesArray[i] == '' )	continue;
			return valuesArray[i];
		}
	}
	
	// SET THE FUNCTION
	var inputParamsArray = inputParams.slice(',');
	var argumentFunction = new Function( inputParamsArray , paramFunction );
	
	// RUN THE FUNCTION WITH THE INPUT PARAMETER VALUES
	// HACK TO INPUT PARAMETER VALUES
	value = argumentFunction(valuesArray[0], valuesArray[1], valuesArray[2], valuesArray[3], valuesArray[4]);
	// THIS DOESN'T WORK
	//value = argumentFunction(valuesArray);
	//console.log("IO.getValue     value: " + value);

	return value;
}



});


}

if(!dojo._hasResource["plugins.workflow.RunStatus.ClusterStatus"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.workflow.RunStatus.ClusterStatus"] = true;
dojo.provide("plugins.workflow.RunStatus.ClusterStatus");

// TITLE PANE


// HAS A


// INHERITS


dojo.declare( "plugins.workflow.RunStatus.ClusterStatus", 
	[ dijit._Widget, dijit._Templated, plugins.core.Common ], {

//Path to the template of this widget. 
templateString:"<div dojoAttachPoint=\"containerNode\">\n\n    <div\n        dojoAttachPoint=\"mainTab\"\n        dojoType=\"dijit.layout.ContentPane\"\n        parseOnLoad=\"false\"\n\t\toverflow=\"auto\"\n\t\ttitle=\"Cluster\"\n\t\tclass=\"clusterstatus\"\n\t\tstyle=\"position: relative; top: 0px !important; height: 100%; max-height: auto !important; min-width: 400px !important; width: auto !important; padding: 0 !important; background: #FFF;\"\n        >\n\n\t\t<table width=\"100%\">\n\t\t\t<tr>\n\t\t\t\t<td\n\t\t\t\t\tdojoAttachPoint=\"statusTitle\"\n\t\t\t\t\tclass=\"tabTitle\"\n\t\t\t\t\talign=\"center\">Cluster</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td align=\"left\">\n\t\t\t\t\t<table align=\"left\" width=\"100%\">\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td align=\"center\">\n\t\t\t\t\t\t\t\t<!--<div>-->\n\t\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"stop\"\n\t\t\t\t\t\t\t\t\t\tdojoAttachEvent=\"onclick:stopCluster\"\n\t\t\t\t\t\t\t\t\t\tclass=\"stop\">\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t<!--<div-->\n\t\t\t\t\t\t\t\t\t<!--\tdojoAttachPoint=\"pause\"-->\n\t\t\t\t\t\t\t\t\t<!--\tdojoAttachEvent=\"onclick:pauseCluster\"-->\n\t\t\t\t\t\t\t\t\t<!--\tclass=\"pause\">-->\n\t\t\t\t\t\t\t\t\t<!--</div>-->\n\t\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"start\"\n\t\t\t\t\t\t\t\t\t\tdojoAttachEvent=\"onclick:startCluster\"\n\t\t\t\t\t\t\t\t\t\tclass=\"play\">\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t<div class=\"clusterHeading\">Cluster</div>\n\t\t\t\t\t\t\t\t\t<div dojoAttachPoint=\"clusterName\"\n\t\t\t\t\t\t\t\t\t\tclass=\"clusterText\">\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t<div class=\"clusterHeading\">Status</div>\n\t\t\t\t\t\t\t\t\t<div dojoAttachPoint=\"clusterStatus\"\n\t\t\t\t\t\t\t\t\t\tclass=\"clusterText\">\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t<!--</div>-->\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t</table>\n\t\t\t\t</td>\n\t\t\t</tr>\n\n\t\t\t<tr>\n\t\t\t\t<td>\n\t\t\t\t\t<div\n\t\t\t\t\t\tdojoType=\"dijit.TitlePane\"\n\t\t\t\t\t\ttitle=\"Cluster List\"\n\t\t\t\t\t\tclass=\"clusterStatus\"\n\t\t\t\t\t\tstyle=\"background: #FFF; height: auto; width: 100% !important; font-size: 10px !important\"\n\t\t\t\t\t\t>\n\t\t\t\t\t\t<div\n\t\t\t\t\t\t\tdojoAttachPoint=\"list\"\n\t\t\t\t\t\t\tclass=\"clusterStatusContainer\"\n\t\t\t\t\t\t>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</td>\n\t\t\t</tr>\n\n\t\t\t<tr>\n\t\t\t\t<td>\n\t\t\t\t\t<div\n\t\t\t\t\t\tdojoType=\"dijit.TitlePane\"\n\t\t\t\t\t\ttitle=\"Cluster Log\"\n\t\t\t\t\t\tclass=\"clusterStatus\"\n\t\t\t\t\t\tstyle=\"background: #FFF; height: auto; width: 100% !important; font-size: 10px !important\"\n\t\t\t\t\t\t>\n\t\t\t\t\t\t<div\n\t\t\t\t\t\t\tdojoAttachPoint=\"log\"\n\t\t\t\t\t\t\tclass=\"clusterStatusContainer\"\n\t\t\t\t\t\t>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</td>\n\t\t\t</tr>\n\n\t\t\t<tr>\n\t\t\t\t<td>\n\t\t\t\t\t<div\n\t\t\t\t\t\tdojoType=\"dijit.TitlePane\"\n\t\t\t\t\t\ttitle=\"Balancer Log\"\n\t\t\t\t\t\tclass=\"balancerStatus\"\n\t\t\t\t\t\tstyle=\"background: #FFF; height: auto; width: 100% !important; font-size: 10px !important\"\n\t\t\t\t\t\t>\n\t\t\t\t\t\t<div\n\t\t\t\t\t\t\tdojoAttachPoint=\"balancer\"\n\t\t\t\t\t\t\tclass=\"clusterStatusContainer\"\n\t\t\t\t\t\t>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</td>\n\t\t\t</tr>\n\n\t\t</table>\n\n\t</div>\n\n\n\n</div>\n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

// OR USE @import IN HTML TEMPLATE
cssFiles : [ dojo.moduleUrl("plugins") + "/workflow/RunStatus/css/clusterstatus.css" ],

// CORE WORKFLOW OBJECTS
core : null,

// status: string
// CLUSTER STATUS ('', 'starting', 'running', 'pausing', 'paused', 'stopping', 'stopped')
status : '',

// runner: object
// RUNNER OBJECT SET IN RunStatus
runner : null,

/////}

constructor : function(args) {
	console.log("ClusterStatus.constructor    args:");
	console.dir({args:args});

	// GET ARGS
	this.core = args.core;
	this.attachNode = args.attachNode;

	if ( args.cgiUrl != null )
		this.cgiUrl = args.cgiUrl;
	else
		this.cgiUrl = 	Agua.cgiUrl + "workflow.cgi";
	
	// LOAD CSS
	this.loadCSS();		
},
postCreate: function() {
	console.log("ClusterStatus.postCreate    plugins.workflow.RunStatus.ClusterStatus.postCreate()");

	this.startup();
},
startup : function () {
	console.log("ClusterStatus.startup    plugins.workflow.RunStatus.ClusterStatus.startup()");

	// SET UP THE ELEMENT OBJECTS AND THEIR VALUE FUNCTIONS
	this.inherited(arguments);
	
	console.log("ClusterStatus.startup    this.attachNode: " + this.attachNode);
	console.log("ClusterStatus.startup    this.stagesTab: " + this.stagesTab);
	console.log("ClusterStatus.startup    this.queueTab: " + this.queueTab);
	
	// ADD TO TAB CONTAINER		
	if ( this.attachNode.addChild != null )
		this.attachNode.addChild(this.mainTab);

    // OTHERWISE, WE ARE TESTING SO APPEND TO DOC BODY
	else {
		var div = dojo.create('div');
		document.body.appendChild(div);
		div.appendChild(this.mainTab.domNode);
	}
	this.attachNode.selectChild(this.mainTab);	
	
	// START UP CONFIRM DIALOGUE
	this.setConfirmDialog();
},
// SHOW STATUS
displayStatus : function (clusterstatus) {
	console.log("ClusterStatus.displayStatus      clusterstatus:");
	console.dir({clusterstatus:clusterstatus});
	if ( ! clusterstatus ) {
		clusterstatus = {
			cluster: "",
			status: "",
			list : "No nodes running",
			log: "No cluster log available",
			balancer: "No lbalancer log available"
		};
	}
	
	// REMOVE EXISTING STATUS 	
	this.clearStatus();

	// DISPLAY STATUS
	this.list.innerHTML = "<PRE>" + clusterstatus.list + "</PRE>";
	this.log.innerHTML = "<PRE>" + clusterstatus.log + "</PRE>";
	this.balancer.innerHTML = "<PRE>" + clusterstatus.balancer + "</PRE>";
	this.clusterName.innerHTML = clusterstatus.cluster;
	this.status = clusterstatus.status;
	this.clusterStatus.innerHTML = clusterstatus.status;
},
clearStatus : function () {
	console.log("ClusterStatus.clearStatus      plugins.workflow.RunStatus.ClusterStatus.clearStatus()");
	this.clusterStatus.innerHTML = "";
	this.list.innerHTML = "";
	this.log.innerHTML = "";
	
	while ( this.list.firstChild )
		this.list.removeChild(this.list.firstChild);
	while ( this.log.firstChild )
		this.log.removeChild(this.log.firstChild);
	while ( this.balancer.firstChild )
		this.balancer.removeChild(this.balancer.firstChild);
},
// WORKFLOW CONTROLS
pauseCluster : function () {
	console.log("ClusterStatus.pauseCluster    ");
	var project = this.core.userWorkflows.getProject();
	var workflow = this.core.userWorkflows.getCluster();
	this.checkRunning(project, workflow, "confirmPauseCluster");
},
stopCluster : function () {
	console.log("ClusterStatus.stopCluster    this.status: " + this.status);
	var cluster = this.runner.cluster;
	console.log("ClusterStatus.stopCluster    cluster: " + cluster);
	
	if ( ! cluster )
		Agua.toastInfo("Cluster not defined");
	else if ( ! this.status
		|| this.status == "stopping"
		|| this.status == "stopped" ) {
		Agua.toastInfo("Cluster is already stopped");
	}
	else
		this.confirmStopCluster(cluster);
},
startCluster : function () {
	var cluster = this.runner.cluster;
	console.log("ClusterStatus.startCluster    cluster: " + cluster);
	console.log("ClusterStatus.startCluster    this.status: " + this.status);
	
	if ( ! cluster )
		Agua.toastInfo("Cluster not defined");
	else if ( this.status == "running" ) {
		Agua.toastInfo("Cluster is already running");
	}
	else if ( this.status == "starting" ) {
		Agua.toastInfo("Cluster is already starting");
	}
	else
		this.confirmStartCluster(cluster);
},
confirmPauseCluster : function (project, workflow, isRunning) {
	// EXIT IF NO STAGES ARE CURRENTLY RUNNING
	console.log("ClusterStatus.confirmPauseCluster    project: " + project);
	console.log("ClusterStatus.confirmPauseCluster    workflow: " + workflow);
	console.log("ClusterStatus.confirmPauseCluster    isRunning: " + isRunning);
	if ( ! isRunning )	return;

	// ASK FOR CONFIRMATION TO STOP THE WORKFLOW
	var noCallback = function (){
		console.log("ClusterMenu.confirmPauseCluster    noCallback()");
	};
	var yesCallback = dojo.hitch(this, function()
		{
			console.log("ClusterMenu.confirmPauseCluster    yesCallback()");
			this.doPauseCluster();
		}								
	);

	// GET THE INDEX OF THE FIRST RUNNING STAGE
	var indexOfRunningStage = this.core.userWorkflows.indexOfRunningStage();
	console.log("ClusterStatus.confirmPauseCluster   indexOfRunningStage: " + indexOfRunningStage);
	this.runner = this.core.runStatus.createRunner(indexOfRunningStage);	

	// SET TITLE AND MESSAGE
	var title = project + "." + workflow + " is running";
	var message = "Are you sure you want to stop it?";

	// SHOW THE DIALOG
	this.loadConfirmDialog(title, message, yesCallback, noCallback);
},
confirmStartCluster : function (cluster) {
	console.log("ClusterStatus.confirmStartCluster    cluster: " + cluster);

	// ASK FOR CONFIRMATION TO STOP THE WORKFLOW
	var noCallback = function () {};
	var yesCallback = dojo.hitch(this, function() {
		console.log("ClusterStatus.startCluster    yesCallback()");
		this.doStartCluster();
	});

	// SET TITLE AND MESSAGE
	var title = "Are you sure you want to start cluster '" + cluster + "'?";
	var message = "Cloud fees apply as soon as the cluster is started";

	// SHOW THE DIALOG
	this.loadConfirmDialog(title, message, yesCallback, noCallback);
},
confirmStopCluster : function (cluster) {
	console.log("ClusterStatus.confirmStopCluster    cluster " + cluster);

	// CALLBACKS
	var noCallback = function (){};
	var yesCallback = dojo.hitch(this, function() {
		this.doStopCluster();
	});

	// SET TITLE AND MESSAGE
	var title = "Are you sure you want to stop cluster '" + cluster + "'?";
	var message = "Any workflows currently running on it will be stopped";

	// SHOW THE DIALOG
	this.loadConfirmDialog(title, message, yesCallback, noCallback);
},
doPauseCluster : function () {
	console.log("ClusterStatus.doPauseCluster    plugins.workflow.RunStatus.ClusterStatus.doPauseCluster");
	this.pauseRun();	
},
doStartCluster : function () {
	console.log("ClusterStatus.doStartCluster    this.runner:");
	console.dir({this_runner:this.runner});
	var project		=	this.runner.project 	|| '';
	var workflow	=	this.runner.workflow 	|| '';
	var cluster		=	this.runner.cluster 	|| '';
	var start		=	this.runner.start 		|| '';
	var username 	= 	this.runner.username	|| '';
	var sessionid 	= 	this.runner.sessionid	|| '';

	// SET MESSAGE
	this.clusterStatus.innerHTML = "starting";

	// SET STATUS
	this.status = "starting";
	
	// GET URL 
	var url = Agua.cgiUrl + "workflow.cgi";
	
	// GENERATE QUERY JSON FOR THIS WORKFLOW IN THIS PROJECT
	var query = new Object;
	query.username = username;
	query.sessionid = sessionid;
	query.project = project;
	query.workflow = workflow;
	query.cluster = username + "-" + cluster;
	query.mode = "startCluster";
	query.start = start;
	console.log("ClusterStatus.startCluster     query: " + dojo.toJson(query));
	
	var deferred = dojo.xhrPut(
		{
			url: url,
			putData: dojo.toJson(query),
			handleAs: "json",
			sync: false,
			load: function(response){
				Agua.toast(response);
			}
		}
	);
},
doStopCluster : function () {
	console.log("ClusterStatus.doStopCluster    this.runner:");
	console.dir({this_runner:this.runner});

	var project		=	this.runner.project 	|| '';
	var workflow	=	this.runner.workflow 	|| '';
	var cluster		=	this.runner.cluster 	|| '';
	var start		=	this.runner.start 		|| '';
	var username 	= 	this.runner.username	|| '';
	var sessionid 	= 	this.runner.sessionid	|| '';

	// SET MESSAGE
	this.clusterStatus.innerHTML = "stopping";

	// SET STATUS
	this.status = "stopping";
	
	// GET URL 
	var url = Agua.cgiUrl + "workflow.cgi";
	
	// GENERATE QUERY JSON FOR THIS WORKFLOW IN THIS PROJECT
	var query = new Object;
	query.username = username;
	query.sessionid = sessionid;
	query.project = project;
	query.workflow = workflow;
	query.cluster = username + "-" + cluster;
	query.mode = "stopCluster";
	query.start = start;
	console.log("ClusterStatus.stopCluster     query: " + dojo.toJson(query));
	
	var deferred = dojo.xhrPut(
		{
			url: url,
			putData: dojo.toJson(query),
			handleAs: "json",
			sync: false,
			load: function(response){
				Agua.toast(response);
			}
		}
	);
},
// CONFIRM DIALOG
setConfirmDialog : function () {
	var yesCallback = function (){};
	var noCallback = function (){};
	var title = "Dialog title";
	var message = "Dialog message";
	
	this.confirmDialog = new plugins.dijit.ConfirmDialog(
		{
			title 				:	title,
			message 			:	message,
			parentWidget 		:	this,
			yesCallback 		:	yesCallback,
			noCallback 			:	noCallback
		}			
	);
},
loadConfirmDialog : function (title, message, yesCallback, noCallback) {
	console.log("FileMenu.loadConfirmDialog    yesCallback.toString(): " + yesCallback.toString());
	console.log("FileMenu.loadConfirmDialog    title: " + title);
	console.log("FileMenu.loadConfirmDialog    message: " + message);
	console.log("FileMenu.loadConfirmDialog    yesCallback: " + yesCallback);
	console.log("FileMenu.loadConfirmDialog    noCallback: " + noCallback);

	this.confirmDialog.load(
		{
			title 				:	title,
			message 			:	message,
			yesCallback 		:	yesCallback,
			noCallback 			:	noCallback
		}			
	);
}

});	// plugins.workflow.RunStatus.ClusterStatus



}

if(!dojo._hasResource["plugins.workflow.RunStatus.QueueStatus"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.workflow.RunStatus.QueueStatus"] = true;
dojo.provide("plugins.workflow.RunStatus.QueueStatus");

// TITLE PANE


// HAS A


// INHERITS


dojo.declare( "plugins.workflow.RunStatus.QueueStatus",
	[ dijit._Widget, dijit._Templated, plugins.core.Common ], {

//Path to the template of this widget. 
templateString:"<div dojoAttachPoint=\"containerNode\">\n\n    <div\n        dojoAttachPoint=\"mainTab\"\n        dojoType=\"dijit.layout.ContentPane\"\n        parseOnLoad=\"false\"\n\t\toverflow=\"auto\"\n\t\ttitle=\"Queues\"\n\t\tclass=\"queuestatus\"\n\t\tstyle=\"position: relative; top: 0px !important; height: 100%; max-height: auto !important; min-width: 400px !important; width: auto !important; padding: 0 !important; background: #FFF;\"\n        >\n\n\t\t<table width=\"100%\">\n\t\t\t<tr>\n\t\t\t\t<td\n\t\t\t\t\tdojoAttachPoint=\"statusTitle\"\n\t\t\t\t\tclass=\"tabTitle\"\n\t\t\t\t\talign=\"center\">Queues</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td>\n\t\t\t\t\t<div\n\t\t\t\t\t\tdojoType=\"dijit.TitlePane\"\n\t\t\t\t\t\ttitle=\"Queue\"\n\t\t\t\t\t\tclass=\"queueStatus\"\n\t\t\t\t\t\tstyle=\"background: #FFF; height: auto; width: 100% !important; font-size: 10px !important\"\n\t\t\t\t\t\t>\n\t\t\t\t\t\t<div\n\t\t\t\t\t\t\tdojoAttachPoint=\"statusList\"\n\t\t\t\t\t\t\tclass=\"statusList\"\n\t\t\t\t\t\t>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</td>\n\t\t\t</tr>\n\t\t</table>\n\t\t\t\t\n\t</div>\n\n</div>\n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

// OR USE @import IN HTML TEMPLATE
cssFiles : [ dojo.moduleUrl("plugins") + "/workflow/RunStatus/css/queuestatus.css" ],

// CORE WORKFLOW OBJECTS
core : null,

// status: string
// Queue status ('', 'starting', 'running', 'pausing', 'paused', 'stopping', 'stopped')
status : '',

// runner: object
// RUNNER OBJECT SET IN RunStatus
runner : null,

/////}
constructor : function(args) {
	console.log("QueueStatus.constructor    args:");
	console.dir({args:args});

	// GET ARGS
	this.core = args.core;
	this.attachNode = args.attachNode;

	if ( args.cgiUrl != null )
		this.cgiUrl = args.cgiUrl;
	else
		this.cgiUrl = 	Agua.cgiUrl + "workflow.cgi";
	
	// LOAD CSS
	this.loadCSS();		
},
postCreate: function() {
	console.log("QueueStatus.postCreate    plugins.workflow.RunStatus.QueueStatus.postCreate()");

	this.startup();
},
startup : function () {
	console.log("QueueStatus.startup    plugins.workflow.RunStatus.QueueStatus.startup()");

	// SET UP THE ELEMENT OBJECTS AND THEIR VALUE FUNCTIONS
	this.inherited(arguments);
	
	console.log("QueueStatus.startup    this.attachNode: " + this.attachNode);
	//console.log("QueueStatus.startup    this.stagesTab: " + this.stagesTab);
	//console.log("QueueStatus.startup    this.queueTab: " + this.queueTab);
	
	// ADD TO TAB CONTAINER		
	if ( this.attachNode.addChild != null )
		this.attachNode.addChild(this.mainTab);

    // OTHERWISE, WE ARE TESTING SO APPEND TO DOC BODY
	else {
		var div = dojo.create('div');
		document.body.appendChild(div);
		div.appendChild(this.mainTab.domNode);
	}
	this.attachNode.selectChild(this.mainTab);	
},
displayStatus : function (queuestatus) {
	console.log("QueueStatus.displayStatus      queuestatus:");
	console.dir({queuestatus:queuestatus});
	
	// REMOVE EXISTING STATUS 	
	this.clearStatus();

	// LEAVE EMPTY AND RETURN IF NO STATUS
	if ( ! queuestatus || ! queuestatus.status ) {
		this.statusList.innerHTML = "No queue information available";
		return;
	}
	
	// DISPLAY STATUS
	this.statusList.innerHTML = "<PRE>" + queuestatus.status + "</PRE>";
},
clearStatus : function () {
	console.log("QueueStatus.clearStatus      clearing this.statusList");
	this.statusList.innerHTML = "";
	
	while ( this.statusList.firstChild )
		this.statusList.removeChild(this.statusList.firstChild);

}

});	// plugins.workflow.RunStatus.QueueStatus


}

if(!dojo._hasResource["plugins.workflow.RunStatus.StageStatusRow"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.workflow.RunStatus.StageStatusRow"] = true;
dojo.provide("plugins.workflow.RunStatus.StageStatusRow");


dojo.declare( "plugins.workflow.RunStatus.StageStatusRow",
[ dijit._Widget, dijit._Templated, plugins.core.Common ], {
//Path to the template of this widget. 
templateString:"<div dojoAttachPoint=\"containerNode\" class=\"stageTable\">\n\n\t<!-- NB: EXTRA dojoAttachPointS ADDED FOR TESTING -->\n\n\t<table class=\"stageTable ${status}\" width=\"100%\">\n\n\t\t<tr width=\"100%\" class='stageRow'>\n\t\t\t<td class='${status}Icon header'\n\t\t\t\talign=\"left\" width=\"100px\">${number} </td>\n\t\t\t<td dojoAttachPoint=\"nameNode\" class='name'>${name}</td>\n\t\t\t<td class='key'>Queued</td>\n\t\t\t<td dojoAttachPoint=\"queuedNode\" class='value'>${queued}</td>\n\t\t\t<td class='key'>Lapsed</td>\n\t\t\t<td dojoAttachPoint=\"lapsedNode\" dojoAttachPoint=\"lapsed\"\n\t\t\t\tclass='value'>${lapsed}</td>\n\t\t</tr>\n\n\t\t<tr width=\"100%\" class='stageRow'>\n\t\t\t<td class='key'>Status</td>\n\t\t\t<td dojoAttachPoint=\"statusNode\" class='value ${status}'>${status}</td>\n\t\t\t<td class='key'>Started</td>\n\t\t\t<td dojoAttachPoint=\"startedNode\" class='value'>${started}</td>\n\t\t\t<td class='key'>Output</td>\n\t\t\t<td dojoAttachPoint=\"stdoutNode\"\n\t\t\t\tclass='stdout'\n\t\t\t\twidth=\"50%\"\n\t\t\t\ttitle=\"Click to view run output\">STDOUT file</td>\n\t\t</tr>\n\n\t\t<tr width=\"100%\" class='stageRow'>\n\t\t\t<td class='key'>Duration</td>\n\t\t\t<td dojoAttachPoint=\"durationNode\" class='value'>${duration}</td>\n\t\t\t<td class='key'>Ended</td>\n\t\t\t<td dojoAttachPoint=\"completedNode\" class='value'>${completed}</td>\n\t\t\t<td class='key'>Errors</td>\n\t\t\t<td dojoAttachPoint=\"stderrNode\"\n\t\t\t\tclass='stderr'\n\t\t\t\twidth=\"50%\"\n\t\t\t\ttitle=\"Click to view error messages\">STDERR file</td>\n\t\t</tr>\n\n\t</table>\n\t\n</div>\n\n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

//srcNodeRef: null,

////}}}
constructor : function(args) {	
	// GET ARGS
	this.core = args.core;
},
postCreate : function() {
	this.startup();
},
startup : function () {
	//console.log("StageStatusRow.startup    plugins.workflow.RunStatus.StageStatusRow.startup()");

	this.inherited(arguments);

	if ( this.stderrfile != null && this.stderrfile != '' )
		this.setFileDownload("stderr");

	if ( this.stdoutfile != null && this.stdoutfile != '' )
		this.setFileDownload("stdout");

	////console.log("StageStatusRow.startup    this: " + this);
	////console.log("StageStatusRow.startup    this.domNode.innerHTML: " + this.domNode.innerHTML);
},
setFileDownload : function(filetype) {
	//console.log("StageStatusRow.setFileDownload    plugins.report.ParameterRow.setFileDownload(filetype)");
	//console.log("StageStatusRow.setFileDownload    filetype: " + filetype);
	var nodeName = filetype + "Node";
	var fileName = filetype + "file";
	this[nodeName].innerHTML = this[fileName];
	//console.log("StageStatusRow.setFileDownload    this[nodeName]: " + this[nodeName]);
	//console.log("StageStatusRow.setFileDownload    this[" + nodeName + "].innerHTML: " + this[nodeName].innerHTML);	
	
	dojo.connect(this[nodeName], "onclick", this, dojo.hitch( this, function(event)
		{
			//console.log("ParameterRow.setFileDownload    download onclick fired, this[nodeName].innerHTML: " + this[nodeName].innerHTML);
			this.downloadFile(this[nodeName].innerHTML);
		}
	));
},
handleDownload : function (response, ioArgs) {
	//console.log("ParameterRow.handleDownload     plugins.workflow.ParameterRow.handleDownload(response, ioArgs)");
	//console.log("ParameterRow.handleDownload     response: " + dojo.toJson(response));
	//console.log("ParameterRow.handleDownload     response.message: " + response.message);

	if ( response.message == "ifd.getElementsByTagName(\"textarea\")[0] is undefined" )
	{
		Agua.toastMessage({
			message: "Download failed: File is not present",
			type: "error"
		});	////console.log("ParameterRow.downloadFile     value: " + dojo.toJson(value));

	}	
}
}); // plugins.workflow.RunStatus.StageStatusRow

}

if(!dojo._hasResource["plugins.workflow.RunStatus.StageStatus"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.workflow.RunStatus.StageStatus"] = true;
dojo.provide("plugins.workflow.RunStatus.StageStatus");



dojo.declare("plugins.workflow.RunStatus.StageStatus",
[ dijit._Widget, dijit._Templated ], {
templateString:"<div dojoAttachPoint=\"containerNode\">\n\n\t<table class=\"stageTable\"\n\t\tdojoAttachPoint=\"stageTable\"\n\t\twidth=\"100%\">\n\t\t\n\t</table>\t\n</div>\n",

widgetsInTemplate : true,

stages : null,

rows: new Array(),

////}}}}
constructor : function(args) {	
	console.log("StageStatus.constructor    plugins.workflow.RunStatus.StageStatusRow.constructor(args)");
},
postCreate : function() {
	this.startup();
},
startup : function () {
	this.inherited(arguments);
	console.log("StageStatus.startup    this.stages: ");
	console.dir({stages:this.stages});

	this.attachNode.appendChild(this.stageTable);
},
displayStatus : function (stagestatus) {
	console.group("StageStatus-" + this.id + "    displayStatus");
	console.log("StageStatus.displayStatus      stagestatus:");
	console.dir({stagestatus:stagestatus});
	
	// REMOVE PREVIOUS STATUS 	
	this.clearStatus();
	
	// RETURN IF STATUS IS NULL
	if ( ! stagestatus  ) {
		console.log("StageStatus.displayStatus    stagestatus is null. Returning");
		return;
	}

	// SET this.status
	this.status = stagestatus.status;

	// DISPLAY NAME AND STATUS
	this.core.runStatus.workflowName.innerHTML = stagestatus.workflow + '.' + stagestatus.project;
	this.core.runStatus.workflowStatus.innerHTML = stagestatus.status;

	
	// DISPLAY STAGES STATUS	
	var stages = stagestatus.stages;
	console.log("StageStatus.displayStatus    DOING this.displayStagesStatus()");
	this.displayStagesStatus(stages);
},
clearStatus : function () {
	console.log("StageStatus.clearStatus    BEFORE clear this.stageTable");

	this.core.runStatus.innerHTML = "";

    while ( this.stageTable.childNodes && this.stageTable.childNodes.length ) {
    console.log("StageStatus.clearStatus    REMOVING node " + this.stageTable.childNodes[0]);
        this.stageTable.removeChild(this.stageTable.childNodes[0]);
    }
	console.log("StageStatus.clearStatus    AFTER clear this.stageTable");
},
displayStagesStatus : function (stages) {
	console.log("StageStatus.displayStagesStatus    stages:");
	console.dir({stages:stages});
	
    if ( ! stages )  return;
    
	// SET THE NODE CLASSES BASED ON STATUS
    this.rows = [];
	for ( var i = 0; i < stages.length; i++ )
	{
		console.log("StageStatus.displayStatus     Doing stages[" + i + "]: ");
		console.dir({stage:stages[i]});

		var tr = document.createElement('tr');
		this.stageTable.appendChild(tr);
		
		stages[i].duration = this.calculateDuration(stages[i]);
		console.log("StageStatus.displayStatus     stages[i].duration: " + stages[i].duration);

		stages[i].lapsed = this.calculateLapsed(stages[i]);
		console.log("StageStatus.displayStatus     stages[i].lapsed: " + stages[i].lapsed);

		if ( stages[i].completed == "0000-00-00 00:00:00" )
			stages[i].completed = '';
		if ( stages[i].queued == "0000-00-00 00:00:00" )
			stages[i].queued = '';
		
		stages[i].core = this.core;
		var stagestatusRow = new plugins.workflow.RunStatus.StageStatusRow(stages[i]);
		
		console.log("StageStatus.displayStatus     stagestatusRow:");
		console.dir({stagestatusRow:stagestatusRow});
		
        this.rows.push(stagestatusRow);

		var td = document.createElement('td');
		tr.appendChild(td);
		td.appendChild(stagestatusRow.domNode);
	}
	console.groupEnd("StageStatus-" + this.id + "    displayStatus");
},
stringToDate : function (string) {
// CONVERT 2010-02-21 10:45:46 TO year, month, day, hour, minutes, seconds

	console.log("StageStatus.stringToDate    string: " + string);
	// FORMAT: 2012-02-2604:24:14
	var array = string.match(/^(\d{4})\D+(\d+)\D+(\d+)\D+(\d+)\D+(\d+)\D+(\d+)/);
	console.log("StageStatus.arrayToDate    array: ");
	console.dir({array:array});
	
	// REMOVE FIRST MATCH (I.E., ALL OF MATCHED STRING)
	array.shift();
	
	// MONTH IS ZERO-INDEXED
	array[1]--;

	// GENERATE NEW DATE
	return new Date(array[0],array[1],array[2],array[3],array[4],array[5]);
},
secondsToDuration : function (milliseconds) {
// CONVERT MILLISECONDS TO hours, mins AND secs 
	var duration = '';
	var remainder = 0;

	// IGNORE MILLISECONDS	
	remainder = milliseconds % 1000;
	milliseconds -= remainder;
	milliseconds /= 1000;

	// GET SECONDS	
	remainder = milliseconds % 60;
	if (remainder)
		duration = remainder.toString();
	else
		duration = "0";
	duration = duration + " sec";

	// Strip off last component
	milliseconds -= remainder;
	milliseconds /= 60;

	// GET HOURS	
	remainder = milliseconds % 60;
	duration = remainder.toString() + " min " + duration;

	// Strip off last component
	milliseconds -= remainder;
	milliseconds /= 60;

	// GET DAYS
	return milliseconds.toString() + " hours " + duration;
},
calculateDuration : function (stage) {
	console.log("StageStatus.calculateDuration    stage.started: " + stage.started);

	var duration = '';
	// IF STARTED, GET THE DURATION
	if ( stage.started
		&& stage.started != "0000-00-00 00:00:00" )
	{
		// GET DURATION BY SUBSTRACTING started FROM completed OR now
		var startedDate = this.stringToDate(stage.started);
		var currentDate;
		if ( ! stage.completed 
			|| stage.completed == "0000-00-00 00:00:00" ) {
			currentDate = this.stringToDate(stage.now);
		}
		else {
			currentDate = this.stringToDate(stage.completed);
		}
		
		// CONVERT DIFFERENCE TO DURATION
		var seconds = currentDate - startedDate;
		duration = this.secondsToDuration(seconds);
	}

	return duration;
},
calculateLapsed : function (stage) {
	console.log("StageStatus.calculateLapsed    stage.completed: " + stage.completed);

	var lapsed = '';
	if ( ! stage || ! stage.completed || stage.completed == "0000-00-00 00:00:00" )
		return lapsed;
	
	var completedDate = this.stringToDate(stage.completed);
	var currentDate	= new Date;
	console.log("StageStatus.calculateLapsed    currentDate: " + currentDate);
	console.dir({currentDate:currentDate});
	
	// GET DURATION BY SUBSTRACTING completed FROM CURRENT TIME
	var seconds = currentDate - completedDate;
	console.log("StageStatus.calculateLapsed    seconds: " + seconds);

	lapsed = this.secondsToDuration(seconds);
	console.log("StageStatus.calculateLapsed    lapsed: " + lapsed);
	
	return lapsed;
}



}); // plugins.workflow.RunStatus.StageStatus

}

if(!dojo._hasResource["plugins.workflow.RunStatus.Status"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.workflow.RunStatus.Status"] = true;
dojo.provide("plugins.workflow.RunStatus.Status");

/* PURPOSE: POLL SERVER FOR UPDATED INFORMATION ON
 * CLUSTER AND WORKFLOW STATUS

	xhrPut RESPONSE FORMAT:

	{
		stagestatus 	=> 	{
			project		=>	String,
			workflow	=>	String,
			stages		=>	HashArray,
			status		=>	String
		},
		clusterstatus	=>	{
			project		=>	String,
			workflow	=>	String,
			list		=>	String,
			log			=> 	String,
			status		=>	String
		},
		queuestatus		=>	{
			queue		=>	String,
			status		=>	String			
		}
	}
*/


// TITLE PANE


// HAS A





// INHERITS


dojo.declare( "plugins.workflow.RunStatus.Status",
	[ dijit._Widget, dijit._Templated, plugins.core.Common ], {

//Path to the template of this widget. 
templateString:"<div dojoattachpoint=\"containerNode\">\n\n    <div\n        dojoAttachPoint=\"stagesTab\"\n        dojoType=\"dijit.layout.ContentPane\"\n        parseOnLoad=\"false\"\n\t\toverflow=\"auto\"\n\t\ttitle=\"Status\"\n\t\tclass=\"runstatus\"\n\t\tstyle=\"position: relative; top: 0px !important; height: 100%; max-height: auto !important; min-width: 400px !important; width: auto !important; padding: 0 !important; background: #FFF;\"\n        >\n\n\t\t<table width=\"100%\">\n\t\t\t<tr>\n\t\t\t\t<td\n\t\t\t\t\tdojoAttachPoint=\"statusTitle\"\n\t\t\t\t\tclass=\"tabTitle\"\n\t\t\t\t\talign=\"center\">Status</td>\n\t\t\t</tr>\n\n\t\t\t<tr>\n\t\t\t\t<td>\n\t\t\t\t\t<table width=\"100%\">\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td align=\"center\">\n\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"toggle\"\n\t\t\t\t\t\t\t\t\tdojoAttachEvent=\"onclick:togglePoller\"\n\t\t\t\t\t\t\t\t\tclass=\"pollingStopped\"\n\t\t\t\t\t\t\t\t\ttitle=\"Click to start or stop run status polling\">\n\t\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"pollCountdown\"\n\t\t\t\t\t\t\t\t\t\tclass=\"pollCountdown\">\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"stop\"\n\t\t\t\t\t\t\t\t\tdojoAttachEvent=\"onclick:stopWorkflow\"\n\t\t\t\t\t\t\t\t\tclass=\"stop\">\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"pause\"\n\t\t\t\t\t\t\t\t\tdojoAttachEvent=\"onclick:pauseWorkflow\"\n\t\t\t\t\t\t\t\t\tclass=\"pause\">\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"play\"\n\t\t\t\t\t\t\t\t\tdojoAttachEvent=\"onclick:startWorkflow\"\n\t\t\t\t\t\t\t\t\tclass=\"play\">\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t<div class=\"workflowHeading\">Workflow</div>\n\t\t\t\t\t\t\t\t<div dojoAttachPoint=\"workflowName\"\n\t\t\t\t\t\t\t\t\tclass=\"workflowText\">\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t<div class=\"workflowHeading\">Status</div>\n\t\t\t\t\t\t\t\t<div dojoAttachPoint=\"workflowStatus\"\n\t\t\t\t\t\t\t\t\tclass=\"workflowText\">\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t<div dojoAttachPoint=\"workflowTime\"\n\t\t\t\t\t\t\t\t\tclass=\"workflowTime\">\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t</table>\n\t\t\t\t</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td>\n\t\t\t\t\t<div \n\t\t\t\t\t\tdojoType=\"dijit.TitlePane\"\n\t\t\t\t\t\ttitle=\"Stages\"\n\t\t\t\t\t\tstyle=\"background: #FFF; height: auto; width: 100% !important;\"\n\t\t\t\t\t\t>\n\n\t\t\t\t\t\t<div\n\t\t\t\t\t\t\tdojoAttachPoint=\"stagesStatusContainer\"\n\t\t\t\t\t\t\tclass=\"status\"\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t</div>\n\n\t\t\t\t\t</div>\n\t\t\t\t</td>\n\t\t\t\t<td>\n\t\t\t</tr>\n\t\t</table>\n\t</div>\n\t\n</div> \n\n\n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

// OR USE @import IN HTML TEMPLATE
cssFiles : [ dojo.moduleUrl("plugins") + "/workflow/RunStatus/css/runstatus.css" ],

// TIMER OBJECT
timer: null,

// timerInterval: integer
// Pause in ms between polls
timerInterval: 20000,

// polling : Boolean
// If false, stop polling
polling : false,

// core : hash
// Workflow-related objects
core : null,

// delay: integer
// Default delay between polls
delay : 21000,

// deferreds: array
// Array of xhr deferred objects
deferreds : [],

/////}}}}]]}}}
constructor : function(args) {
	console.log("Status.constructor    plugins.workflow.RunStatus.constructor(args)");

	// GET ARGS
	this.core = args.core || {};
	this.core.runStatus = this;
	console.log("Status.constructor    args.parentWidget: " + args.parentWidget);
	console.log("Status.constructor    args.attachNode: " + args.attachNode);

	if ( args.parentWidget	)	this.parentWidget = args.parentWidget;
	if ( args.attachNode	)	this.attachNode = args.attachNode;

	if ( args.cgiUrl != null )
		this.cgiUrl = args.cgiUrl;
	if ( this.cgiUrl == null )
		this.cgiUrl = 	Agua.cgiUrl + "workflow.cgi";

	if ( args.timerInterval	)	this.timerInterval = args.timerInterval;
	
	// LOAD CSS
	this.loadCSS();		
},
postMixInProperties: function() {
	console.log("Status.postMixInProperties    plugins.workflow.RunStatus.postMixInProperties()");
},
postCreate: function() {
	console.log("Status.postCreate    plugins.workflow.RunStatus.postCreate()");

	this.startup();
},
startup : function () {
	console.log("Status.startup    plugins.workflow.RunStatus.startup()");

	// SET UP THE ELEMENT OBJECTS AND THEIR VALUE FUNCTIONS
	this.inherited(arguments);
	
	console.log("Status.startup    this.attachNode: " + this.attachNode);
	console.log("Status.startup    this.stagesTab: " + this.stagesTab);
	//console.log("Status.startup    this.clusterTab: " + this.clusterTab);
	//console.log("Status.startup    this.queueTab: " + this.queueTab);
	
	// ADD TO TAB CONTAINER		
	if ( this.attachNode.addChild != null ) {
		this.attachNode.addChild(this.stagesTab);
		//this.attachNode.addChild(this.queueTab);
	}
    // OTHERWISE, WE ARE TESTING SO APPEND TO DOC BODY
	else {
		var div = dojo.create('div');
		document.body.appendChild(div);
		div.appendChild(this.stagesTab.domNode);
		//div.appendChild(this.queueTab.domNode);
	}
	//this.attachNode.selectChild(this.mainTab);	
	
	// START UP CONFIRM DIALOGUE
	this.setConfirmDialog();

	// INSTANTIATE SEQUENCE (POLLING DELAY)
	this.setSequence();

	// SET STAGE STATUS
	this.setStageStatus();

	// SET CLUSTER STATUS
	this.setClusterStatus();

	// SET QUEUE STATUS
	this.setQueueStatus();

	// SET INPUTS AS SELECTED
	this.attachNode.selectChild(this.core.parameters);
},

// RUN WORKFLOW
runWorkflow : function (runner) {
// RUN WORKFLOW, QUIT IF ERROR, PROMPT FOR stopRun IF ALREADY RUNNING
	console.group("runStatus-" + this.id + "    runWorkflow");
	console.log("XXXXXXXXXXXXXXXXXXXx RunStatus.runWorkflow      runner: ");
	console.dir(runner);

	// SELECT THIS TAB NODE
	this.attachNode.selectChild(this.stagesTab);

	// SET this.runner AS RUNNER IF PROVIDED
	if ( runner != null ){
		delete this.runner;
		this.runner = runner;
	}
	
	var project		=	runner.project;
	var workflow	=	runner.workflow;
	var start		=	runner.start;	
	console.log("Status.runWorkflow      project: " + project);
	console.log("Status.runWorkflow      workflow: " + workflow);
	console.log("Status.runWorkflow      start: " + start);

	// SET MESSAGE
	this.displayWorkflowStatus("starting");

	// GET URL 
	var url = Agua.cgiUrl + "workflow.cgi";
	console.log("Status.runWorkflow      url: " + url);		

	// GET submit
	var submit = Agua.getWorkflowSubmit(this.runner);

	// GENERATE QUERY JSON FOR THIS WORKFLOW IN THIS PROJECT
	var query = new Object;
	query.project			=	this.runner.project;
	query.workflow			=	this.runner.workflow;
	query.workflownumber	=	this.runner.workflownumber;
	query.start				=	this.runner.start;
	query.stop				=	this.runner.stop;
	query.username 			= 	Agua.cookie('username');
	query.sessionid	 		= 	Agua.cookie('sessionid');
	query.mode 				= 	"executeWorkflow";
	query.submit			=	submit;
	
	// SET CLUSTER 
	query.cluster			=	this.runner.cluster;
	if ( query.cluster != '' )	query.cluster = query.username + "-" + query.cluster;
    else query.cluster = '';
	console.log("Status.runWorkflow     query: " + dojo.toJson(query));

	//// CLEAR DEFERREDS
	//this.clearDeferreds();
	
	// RUN WORKFLOW
	var thisObject = this;
	var deferred = dojo.xhrPut({
		url: url,
		putData: dojo.toJson(query),
		handleAs: "json",
		sync: false,
		handle: function(response){
			console.log("Status.runWorkflow     response: ");
			console.dir({response:response});
			
			// QUIT IF ERROR
			if ( response.error ) {
				// CLEAR DEFERREDS (KILL PENDING POLL STATUS)
				thisObject.clearDeferreds();
				thisObject.polling = false;
				thisObject.displayNotPolling();
				
				if ( response.error == "running" ) {
			console.log("Status.runWorkflow    Doing this.confirmStopWorkfkow()");
					thisObject.displayWorkflowStatus("running");
					thisObject.confirmStopWorkflow(project, workflow);
				}
				
				console.groupEnd("runStatus-" + thisObject.id + "    runWorkflow");
				return;
			}
			else {
				// SET NODE CLASS TO running
				console.log("0000000000000000000000    RunStatus.runWorkflow     DOING this.setNodeClass(runner.childNodes[" + start + "])");
				thisObject.setNodeClass(runner.childNodes[start - 1], 'running');
			}
			
			Agua.toast(response);
		}
	});

	this.deferreds.push(deferred);

	// SET POLLING TO TRUE
	this.polling = true;

	// DO DELAYED POLL WORKFLOW STATUS
	// (KILLED IF runWorkflow xhrPut CALL ABOVE RETURNS ERROR)
	var singleton = false;
	var magicNumber = 2000;
	//this.delayedQueryStatus(this.runner, singleton);
	this.delayCountdownTimeout = setTimeout( function() {
			thisObject.displayActive();
			thisObject.queryStatus(thisObject.runner, singleton);
			//thisObject.delayCountdown(countdown, project, workflow);
		},
		magicNumber,
		this
	);
},
checkRunning : function (project, workflow, callback) {
// PERIODICALLY CHECK THE STATUS OF THE WORKFLOW
	console.group("runStatus-" + this.id + "    checkRunning");

	console.log("Status.checkRunning     project: " + project);
	console.log("Status.checkRunning     workflow: " + workflow);
	console.log("Status.checkRunning     callback: " + callback);

	// GET URL 
	var url = Agua.cgiUrl + "workflow.cgi";
	console.log("Status.checkRunning     url: " + url);		

	// GENERATE QUERY
	var query = new Object;
	query.username 	= Agua.cookie('username');
	query.sessionid = Agua.cookie('sessionid');
	query.project 	= project;
	query.workflow 	= workflow;
	query.mode 		= "getStatus";
	console.log("Status.checkRunning    query: " + dojo.toJson(query));

	// DO DELAYED POLL WORKFLOW STATUS
	// (KILLED IF runWorkflow CALL RETURNS ERROR)
	var thisObject = this;
	var deferred = dojo.xhrPut(
		{
			url: url,
			putData: dojo.toJson(query),
			handleAs: "json",
			sync: false,
			handle: function(response) {
				console.log("Status.checkRunning    response: ");
				console.dir({response:response});
				
				var isRunning = false;
				if ( response.stagestatus == null )	return false;

				for ( var i = 0; i < response.stagestatus.length; i++ ) {
					if ( response.stagestatus[i].status == "running" ) {
						isRunning = true;
						console.log("Status.checkRunning    stage " + i + " (" + response.stagestatus[i].name + ") is running.");
						break;
					}
				}
				console.log("Status.checkRunning    Doing  callback " + callback + "(" + isRunning + ")");

				thisObject[callback](project, workflow, isRunning);

				console.groupEnd("runStatus-" + thisObject.id + "    checkRunning");
				return null;
			}
		}
	);

	// CLEAR DEFERREDS
	this.clearDeferreds(deferred);
		
	this.deferreds.push(deferred);
},
createRunner : function (startNumber, stopNumber) {
	console.group("RunStatus-" + this.id + "    createRunner");
	if ( ! this.core.userWorkflows.dropTarget ) {
		console.log("workflow.RunStatus.createRunner    Returning without childNodes because this.core.userWorkflows.dropTarget is null");
		console.groupEnd("RunStatus-" + this.id + "    createRunner");
		return runner;
	}
	
	var childNodes = this.core.userWorkflows.dropTarget.getAllNodes();
	
	if ( startNumber == null )	startNumber = 1;
	if ( stopNumber == null )	stopNumber = childNodes.length;
    console.log("workflow.RunStatus.createRunner    startNumber: " + startNumber);
    console.log("workflow.RunStatus.createRunner    stopNumber: " + stopNumber);

	var projectName 	= this.core.userWorkflows.getProject();
	var workflowName 	= this.core.userWorkflows.getWorkflow();
	var workflowNumber 	= Agua.getWorkflowNumber(projectName, workflowName);
    console.log("workflow.RunStatus.createRunner    workflowNumber: " + workflowNumber);

	var clusterName		= this.core.userWorkflows.getCluster();
    console.log("workflow.RunStatus.createRunner    clusterName: " + clusterName);
	
	var runner 			= new Object;
    runner.username 	= Agua.cookie('username');
    runner.sessionid 	= Agua.cookie('sessionid');
    runner.project 		= projectName;
	runner.workflow 	= workflowName;
	runner.cluster 		= clusterName;
	runner.start 		= startNumber;
	runner.stop 		= stopNumber;
	runner.workflownumber = workflowNumber;
	runner.childNodes = childNodes;
	
    console.log("workflow.RunStatus.createRunner    runner: ");
	console.dir({runner:runner});
	
	console.groupEnd("RunStatus-" + this.id + "    createRunner");
	return runner;
},

// GET STATUS
getStatus : function (runner, singleton) {
// KEEP POLLING SERVER FOR RUN STATUS UNTIL COMPLETE
	console.group("RunStatus-" + this.id + "    getStatus");
	console.log("Status.getStatus    runner: ");
	console.dir({runner:runner});
	console.log("Status.getStatus      singleton: " + singleton);
	console.log("Status.getStatus     this.polling: " + this.polling);

	if ( this.polling == true ) {
		console.log("Status.getStatus     Returning because this.polling is TRUE");
		console.groupEnd("RunStatus-" + this.id + "    getStatus");
		return;
	}
	this.polling = true;
	
	// SET this.runner FOR LATER USE (E.G., IN ClusterStatus.js)
	this.runner = runner;
	if ( ! this.runner )  {
		console.log("Status.getStatus    Doing this.runner	= this.createRunner(stageNumber)");
		var stageNumber = 1;
		this.runner	= this.createRunner(stageNumber);
	}
	this.clusterStatus.runner = this.runner;

	if ( ! this.runner.childNodes && this.core.userWorkflows.dropTarget) {
		this.runner.childNodes = this.core.userWorkflows.dropTarget.getAllNodes();
	}

	if ( singleton ) {
		dojo.addClass(this.toggle, 'pollingActive');
	}
	else {
		dojo.addClass(this.toggle, 'pollingStarted');
	}
	
	var project		=	this.runner.project;
	var workflow	=	this.runner.workflow;
	var start		=	this.runner.start;
	var childNodes	=	this.runner.childNodes;
	console.log("Status.getStatus      project: " + project);
	console.log("Status.getStatus      workflow: " + workflow);
	console.log("Status.getStatus      start: " + start);
	console.log("Status.getStatus      childNodes.length: " + childNodes.length);

	// SET NOTIFIER
	this.displayWorkflowStatus("loading...");

	// SANITY CHECKS
	if ( project == null
		||	workflow == null
		||	start == null ) {
		console.groupEnd("RunStatus-" + this.id + "    getStatus");
		return;
	}
	if ( childNodes == null || ! childNodes || childNodes.length == 0 )
	{
		console.log("Status.getStatus      No childNodes in dropTarget. Returning...");
		console.groupEnd("RunStatus-" + this.id + "    getStatus");
		return;
	}

    // FIRST QUERY
    this.queryStatus(this.runner, singleton);

//	console.groupEnd("RunStatus-" + this.id + "    getStatus");
},
queryStatus : function (runner, singleton) {
// QUERY RUN STATUS ON SERVER
	if ( this.queryStatus.caller )
		console.log("Status.queryStatus    caller: " + this.queryStatus.caller.nom);

	console.log("Status.queryStatus    passed runner: ");
	console.dir({runner:runner});
	console.log("Status.queryStatus    passed singleton: " + singleton);

	// GENERATE QUERY FOR THIS WORKFLOW
	var url 		= this.cgiUrl;
	var query 		= new Object;
	query.username  = runner.username;
	query.sessionid = runner.sessionid;
	query.project   = runner.project;
	query.workflow  = runner.workflow;
	query.mode = "getStatus";
	console.log("Status.queryStatus    query: " + dojo.toJson(query));

	var thisObject = this;
	var deferred = dojo.xhrPut(
	{
		url: url,
		putData: dojo.toJson(query),
		handleAs: "json",
		sync: false,
		handle: function(response) {
			if ( thisObject.runCompleted(response) ) {
				console.log("Status.getStatus    response:");
				console.dir({response:response});

				// RUN handleStatus
					console.log("Status.queryStatus     DOING thisObject.handleStatus(runner, response)");
					thisObject.handleStatus(runner, response);
				
				console.groupEnd("RunStatus-" + thisObject.id + "    getStatus");
				if ( ! singleton )
					thisObject.delayedQueryStatus(runner, singleton);
				else
					thisObject.stopPolling();
			}
			else if ( ! singleton ) {
				thisObject.delayedQueryStatus(runner, singleton);
			}
			else
				thisObject.stopPolling();
		}
	});

	// CLEAR DEFERREDS
	this.clearDeferreds();	

	this.deferreds.push(deferred);
},
clearDeferreds : function (ignore) {
	console.log("Status.clearDeferreds    ignore: ");
	console.dir({ignore:ignore});
	console.log("Status.clearDeferreds    No. deferreds: " + this.deferreds.length);
	
	dojo.forEach(this.deferreds, function(deferred, index) {
		if ( deferred == ignore )	{
			console.log("Status.clearDeferreds    ignoring deferred: ");
			console.dir({ignore:ignore});
			return;
		}
		
		console.log("Status.clearDeferreds    Clearing deferred " + index + ": " + deferred.callback.toString());
		
		deferred.callback = function() {
			console.log("Status.clearDeferreds    deleted callback");
		}
		
		console.log("Status.clearDeferreds    BEFORE deferred.destroy deferred:");
		console.dir({deferred:deferred});
		
		//deferred.destroy();
	});
	
	this.deferreds = [];
	
	// STOP this.sequence IF ALREADY SET
	console.log("Status.clearDeferreds    Doing this.sequence.stop()");
	this.sequence.stop();

},
showMessage : function (message) {
	console.log("Status.showMessage    message: " + message);	
	console.log("Status.showMessage    Doing queryStatus after delay: " + this.delay);	
},
delayedQueryStatus : function (runner, singleton) {
	console.log("_GroupDragPane.delayedQueryStatus    runner:");
	console.dir({runner:runner});
	console.log("_GroupDragPane.delayedQueryStatus    singleton: " + singleton);
	console.log("_GroupDragPane.delayedQueryStatus    this.polling: " + this.polling);
	
	if ( ! this.polling ) {
		console.log("_GroupDragPane.delayedQueryStatus    this.polling is FALSE. Returning");
		return;
	}
	
	var delay = this.delay;

	// CLEAR COUNTDOWN
	this.clearCountdown();
		
	// START COUNTDOWN
	var project = runner.project;
	var workflow = runner.workflow;
	var delayInteger = parseInt(delay/1000);
	this.delayCountdown(delayInteger, project, workflow);
	
	// DO DELAY
	var commands = [
		{ func: [ this.showMessage, this, "RunStatus.delayedQueryStatus"], pauseAfter: delay },
		{ func: [ this.queryStatus, this, runner, singleton ] } 
	];
	console.log("_GroupDragPane.delayedPollCopy    commands: ");
	console.dir({commands:commands});
	
	this.sequence.go(commands, function() {
		console.log('RunStatus.delayedQueryStatus    Doing this.sequence.go(commands)');
	});	
},
runCompleted : function (response) {
	var completed = true;
	for ( var i = 0; i < response.length; i++ ) {
		console.log("Status.runCompleted    response.stagestatus.stages[" + i + "].status: " + response.stagestatus.stages[i].status);
		if ( response.stagestatus.stages[i].status == "completed" )
			completed = false;
	}
	
	return completed;
},
handleStatus : function (runner, response) {
	console.group("RunStatus-" + this.id + "    handleStatus");
	var project		=	this.runner.project;
	var workflow	=	this.runner.workflow;
	var start		=	this.runner.start;
	var childNodes	=	this.runner.childNodes;

	console.log("Status.handleStatus     response: ");
	console.dir({response:response});
	
	console.log("Status.handleStatus      this.polling: " + this.polling);
	if ( ! this.polling )	return false;

	// REPORT NO RESPONSE
	if ( ! response ) {
		this.displayWorkflowStatus("error: no response");
		return;
	}

	// REPORT ERROR
	if ( response.error ) {
		this.displayWorkflowStatus("error");
		return;
	}
	
	// SET MESSAGE
	this.displayWorkflowStatus("processing");

	// SAVE RESPONSE
	this.response = response;

	// SET COMPLETED FLAG
	this.completed = true;
	
	// SET THE NODE CLASSES BASED ON STATUS
	console.log("Status.handleStatus    Setting class of " + response.stagestatus.stages.length  + " stage nodes");
	
	// CHANGE CSS ON RUN NODES
	var status = "completed";
	var startIndex = runner.start - 1;
	if ( startIndex < 0 ) startIndex = 0;
	console.log("Status.handleStatus    startIndex: " + startIndex);
	for ( var i = startIndex; i < response.stagestatus.stages.length; i++ ) {
		var nodeClass = response.stagestatus.stages[i].status;
		console.log("Status.handleStatus   response.stagestatus.stages[" + i + "].status: " + response.stagestatus.stages[i].status);
		//console.log("Status.handleStatus    response nodeClass " + i + ": " + nodeClass);
		//console.log("Status.handleStatus    runner.childNodes[" + i + "]: " + runner.childNodes[i]);

		// SKIP IF NODE NOT DEFINED
		if ( ! runner.childNodes[i] )
			continue;

		this.setNodeClass(runner.childNodes[i], nodeClass);
		
		// UNSET COMPLETED FLAG IF ANY NODE IS NOT COMPLETED
		if ( nodeClass != "completed" && status == "completed" ) {
			console.log("Status.handleStatus    Setting this.completed = false");
			this.completed = false;
			status = nodeClass;
		}
	}
	console.log("Status.handleStatus    this.completed: " + this.completed);
	this.displayWorkflowStatus(status);

	if ( this.completed == true ) {
		this.stopPolling();
	}

	console.log("Status.handleStatus     BEFORE Agua.updateStagesStatus(startIndex, response)");
	Agua.updateStagesStatus(response.stagestatus);
	console.log("Status.handleStatus     AFTER Agua.updateStagesStatus(startIndex, response)");

	console.log("Status.handleStatus     BEFORE this.showStatus(startIndex, response)");
	this.showStatus(response);
	console.log("Status.handleStatus     AFTER this.showStatus(startIndex, response)");

	console.groupEnd("RunStatus-" + this.id + "    handleStatus");
	
	return null;
},
setNodeClass : function(node, nodeClass) {
	console.log("XXXXX RunStatus.setNodeClass    nodeClass: " + nodeClass);
	dojo.removeClass(node, 'stopped');
	dojo.removeClass(node, 'waiting');
	dojo.removeClass(node, 'running');
	dojo.removeClass(node, 'completed');
	dojo.addClass(node, nodeClass);	
},
// POLLING
clearCountdown : function () {
	if ( this.delayCountdownTimeout )
		clearTimeout(this.delayCountdownTimeout);
	this.pollCountdown.innerHTML = "";
},
delayCountdown : function (countdown, project, workflow) {
	//console.log("Status.delayCountdown    countdown: " + countdown);
	if ( countdown == 1 ) {
		// DOING POLL
		this.displayWorkflowStatus("loading...");
		this.displayActive();
	}
	
	countdown -= 1;
	this.pollCountdown.innerHTML = countdown;
	if ( countdown < 1 )	return;
	
	var magicNumber = 850; // 1 sec. ADJUSTED FOR RUN DELAY
	var thisObject = this;
	this.delayCountdownTimeout = setTimeout( function() {
			thisObject.displayPolling();
			thisObject.delayCountdown(countdown, project, workflow);
		},
		magicNumber,
		this
	);
},
togglePoller : function () {
// START TIME IF STOPPED OR STOP IT IF ITS RUNNING 
	console.log("Status.togglePoller      plugins.workflow.RunStatus.togglePoller()");
	console.log("Status.togglePoller      this.polling: " + this.polling);

	if ( this.polling )
	{
		console.log("Status.togglePoller      Setting this.polling to FALSE and this.completed to FALSE");
		this.polling = false;
		this.completed = false;
		this.stopPolling();
	}
	else {
		console.log("Status.togglePoller      Setting this.polling to TRUE and this.completed to TRUE");
		this.polling = true;
		this.completed = true;
		if ( ! this.runner ) {
			this.runner = this.createRunner(1, null);
		}
		
		this.startPolling();
	}
},
displayActive : function () {
	console.log("Status.displayActive");
	dojo.removeClass(this.toggle, 'pollingStopped');
	dojo.removeClass(this.toggle, 'pollingStarted');
	dojo.addClass(this.toggle, 'pollingActive');
},
displayPolling : function () {
	//console.log("Status.displayPolling    caller: " + this.displayPolling.caller.nom);
	dojo.removeClass(this.toggle, 'pollingStopped');
	dojo.removeClass(this.toggle, 'pollingActive');
	dojo.addClass(this.toggle, 'pollingStarted');
},
displayNotPolling : function () {
	console.log("Status.displayStarted");
	dojo.removeClass(this.toggle, 'pollingStarted');
	dojo.removeClass(this.toggle, 'pollingActive');
	dojo.addClass(this.toggle, 'pollingStopped');
},
stopPolling : function () {
// STOP POLLING THE SERVER FOR RUN STATUS
	console.log("Status.stopPolling      plugins.workflow.RunStatus.stopPolling()");

	console.log("Status.stopPolling      Setting this.polling to FALSE");
	this.polling = false;

	// CLEAR COUNTDOWN
	this.clearCountdown();
	this.clearDeferreds();
	
	// UPDATE DISPLAY
	this.displayNotPolling();
},
startPolling : function () {
// RESTART POLLING THE SERVER FOR RUN STATUS
	console.log("Status.startPolling      plugins.workflow.RunStatus.startPolling()");
	console.log("Status.startPolling      this.polling: " + this.polling);
	console.log("Status.togglePoller      Setting this.polling to FALSE (ahead of check this.polling in getStatus)");
    this.polling = false;

	if ( ! this.runner ) {
		console.log("Status.startPolling      this.runner is null. Returning");
		this.polling = false;
		return;
	}

	// UPDATE DISPLAY
	this.displayPolling();

	console.log("Status.togglePoller      Doing this.getStatus(null, false)");
	this.getStatus(null, false);
},

// SHOW STATUS
showStatus : function (response) {
// POPULATE THE 'STATUS' PANE WITH RUN STATUS INFO
	console.log("Status.showStatus      response: ");
	console.dir({response:response});
    if ( ! response ) return;
	
	// SHOW STAGES STATUS
	console.log("Status.showStatus      Doing this.displayStageStatus(response.stages)");
	this.displayStageStatus(response.stagestatus);

	// SHOW CLUSTER STATUS
	console.log("Status.showStatus      Doing this.displayClusterStatus(response.clusterstatus)");
	this.displayClusterStatus(response.clusterstatus);

	// SHOW QUEUE STATUS
	console.log("Status.showStatus      Doing this.displayQueueStatus(response.queuestatus)");
	this.displayQueueStatus(response.queuestatus);

	// SELECT TAB BASED ON CLUSTER STATUS
	this.selectTab(response);

	// GET SELECTED TAB
	var selectedTab = this.getSelectedTab();
	console.log("Status.showStatus    -------------------------- selectedTab : " + selectedTab);
},
selectTab : function (response) {
	// SELECT THIS TAB IF CLUSTER OR BALANCER STILL STARTING
	console.log("Status.selectTab      response: ");
	console.dir({response:response});

	if ( ! response || ! response.clusterstatus ) {
		console.log("Status.selectTab      response or response.clusterstatus is null. SELECTING 'STAGE' TAB");
		this.attachNode.selectChild(this.stagesTab);
		return;
	}

	var status = response.clusterstatus.status;
	console.log("Status.selectTab      status: " + status);	
	
	if ( status == null ) {
		console.log("Status.selectTab      clusterstatus.status is null. SELECTING 'STAGE' TAB");
		this.attachNode.selectChild(this.stagesTab);	
	}
	else if ( status.match(/^cluster/)
		|| status.match(/^balancer/) ) {
		console.log("Status.selectTab      SELECTING 'CLUSTER' TAB");
		this.attachNode.selectChild(this.clusterStatus.mainTab);	
	}
	else if ( status.match(/sge/ ) ) {
		console.log("Status.selectTab      SELECTING 'QUEUE' TAB");
		this.attachNode.selectChild(this.queueStatus.mainTab);	
	}
	else {
		console.log("Status.selectTab      SELECTING 'STAGE' TAB");
		this.attachNode.selectChild(this.stagesTab);	
	}
},
getSelectedTab : function () {
	console.log("Status.getSelectedTab    this.attachNode: " + this.attachNode);
	console.dir({this_attachNode:this.attachNode});

	console.log("Status.getSelectedTab    this.stageTab: " + this.stagesTab);
	
	console.log("Status.getSelectedTab    this.attachNode.selectedChildWidget: " + this.attachNode.selectedChildWidget);
	console.dir({selectedChildWidget:this.attachNode.selectedChildWidget});
	
	if ( this.attachNode.selectedChildWidget == this.stagesTab )
		return "stageStatus";
	if ( this.attachNode.selectedChildWidget == this.clusterStatus.mainTab)
		return "clusterStatus";
	if ( this.attachNode.selectedChildWidget == this.queueStatus.mainTab)
		return "queueStatus";
	
	return null;
},
displayWorkflowStatus: function (status) {
	this.workflowStatus.innerHTML = "";
},
displayStageStatus : function (status) {
	console.log("Status.displayStageStatus      status:");
	console.dir({status:status});
	this.stageStatus.displayStatus(status);
},
displayClusterStatus : function (status) {
	console.log("Status.displayClusterStatus      status:");
	console.dir({status:status});
	this.clusterStatus.displayStatus(status);
},
displayQueueStatus : function (status) {
	console.log("Status.displayQueueStatus      status:");
	console.dir({status:status});
	this.queueStatus.displayStatus(status);
},
clear : function () {
	console.log("Status.clear      plugins.workflow.RunStatus.clear()");

	this.queueStatus.clearStatus();
	this.clusterStatus.clearStatus();
	while ( this.stagesStatusContainer.firstChild ) {
		this.stagesStatusContainer.removeChild(this.stagesStatusContainer.firstChild);
	}	
},
setTime : function (stage) {
	console.log("Status.setTime    stage: "  + dojo.toJson(stage));

	this.displayWorkflowTime(stage.now);
},
displayWorkflowTime : function(time) {
	console.log("Status.displayWorkflowTime    time: " + time);

	
},

// WORKFLOW CONTROLS
pauseWorkflow : function () {
	console.log("Status.pauseWorkflow    ");
	var project = this.core.userWorkflows.getProject();
	var workflow = this.core.userWorkflows.getWorkflow();

	this.displayWorkflowStatus("pausing");

	this.checkRunning(project, workflow, "confirmPauseWorkflow");
},
stopWorkflow : function () {
	console.log("Status.stopWorkflow    ");
	var project = this.core.userWorkflows.getProject();
	var workflow = this.core.userWorkflows.getWorkflow();

	this.displayWorkflowStatus("stopping");

	this.checkRunning(project, workflow, "confirmStopWorkflow");
},
startWorkflow : function () {
	console.log("Status.startWorkflow    ");
	var project = this.core.userWorkflows.getProject();
	var workflow = this.core.userWorkflows.getWorkflow();

	this.displayWorkflowStatus("starting");

	this.checkRunning(project, workflow, "confirmStartWorkflow");
},
confirmPauseWorkflow : function (project, workflow, isRunning) {
	// EXIT IF NO STAGES ARE CURRENTLY RUNNING
	console.log("Status.confirmPauseWorkflow    project: " + project);
	console.log("Status.confirmPauseWorkflow    workflow: " + workflow);
	console.log("Status.confirmPauseWorkflow    isRunning: " + isRunning);
	if ( ! isRunning )	{
		this.displayWorkflowStatus("cancelled pause");
		return;
	}

	// ASK FOR CONFIRMATION TO STOP THE WORKFLOW
	var noCallback = function (){
		console.log("WorkflowMenu.confirmPauseWorkflow    noCallback()");
	};
	var yesCallback = dojo.hitch(this, function()
		{
			console.log("WorkflowMenu.confirmPauseWorkflow    yesCallback()");
			this.doPauseWorkflow();
		}								
	);

	// GET THE INDEX OF THE FIRST RUNNING STAGE
	var indexOfRunningStage = this.core.userWorkflows.indexOfRunningStage();
	console.log("Status.confirmPauseWorkflow   indexOfRunningStage: " + indexOfRunningStage);
	this.runner = this.core.runStatus.createRunner(indexOfRunningStage);	

	// SET TITLE AND MESSAGE
	var title = project + "." + workflow + " is running";
	var message = "Are you sure you want to stop it?";

	// SHOW THE DIALOG
	this.loadConfirmDialog(title, message, yesCallback, noCallback);
},
confirmStartWorkflow : function (project, workflow, isRunning) {
	console.log("Status.confirmStartWorkflow    project: " + project);
	console.log("Status.confirmStartWorkflow    workflow: " + workflow);
	console.log("Status.confirmStartWorkflow    isRunning: " + isRunning);

	// EXIT IF STAGES ARE CURRENTLY RUNNING
	if ( isRunning )	{
		this.displayWorkflowStatus("cancelled start");
		return;
	}

	// ASK FOR CONFIRMATION TO STOP THE WORKFLOW
	var noCallback = function (){
		console.log("Status.startWorkflow    noCallback()");
	};
	var yesCallback = dojo.hitch(this, function()
		{
			console.log("Status.startWorkflow    yesCallback()");
			this.doStartWorkflow();
		}								
	);

	// SET TITLE AND MESSAGE
	var title = "Run " + project + "." + workflow + " from start to finish";
	var message = "Please confirm (click Yes to run)";

	// SHOW THE DIALOG
	this.loadConfirmDialog(title, message, yesCallback, noCallback);

},
confirmStopWorkflow : function (project, workflow, isRunning) {
	console.log("Status.confirmStopWorkflow    project: " + project);
	console.log("Status.confirmStopWorkflow    workflow: " + workflow);
	console.log("Status.confirmStopWorkflow    isRunning: " + isRunning);
	
	// EXIT IF NO STAGES ARE CURRENTLY RUNNING
	if ( ! isRunning )	{
		this.displayWorkflowStatus("cancelled stop");
		return;
	}
	
	// OTHERWISE, ASK FOR CONFIRMATION TO STOP THE WORKFLOW
	var noCallback = function (){
		console.log("Status.stopWorkflow    noCallback()");
	};
	var yesCallback = dojo.hitch(this, function()
		{
			console.log("Status.stopWorkflow    yesCallback()");
			this.doStopWorkflow();
		}								
	);
	
	// SET TITLE AND MESSAGE
	var title = "Stop workflow " + project + "." + workflow + "?";
	var message = "Please confirm (click Yes to run)";

	// SHOW THE DIALOG
	this.loadConfirmDialog(title, message, yesCallback, noCallback);
},
doPauseWorkflow : function () {
	console.log("Status.doPauseWorkflow    plugins.workflow.RunStatus.pauseWorkflow");
	this.pauseRun();	
},
doStartWorkflow : function () {
	console.log("Status.doStartWorkflow    plugins.workflow.RunStatus.startWorkflow");
	this.runner = this.core.runStatus.createRunner(1);	
	this.runWorkflow(this.runner);		
},
doStopWorkflow : function () {
	console.log("Status.doStopWorkflow    plugins.workflow.RunStatus.doStopWorkflow()");	
	var project		=	this.runner.project;
	var workflow	=	this.runner.workflow;
	var cluster		=	this.runner.cluster;
	var start		=	this.runner.start;

	var username = Agua.cookie('username');
	var sessionid = Agua.cookie('sessionid');

	// SET TIMER CSS 
	dojo.removeClass(this.toggle, 'pollingStopped');
	dojo.addClass(this.toggle, 'pollingStarted');

	// SET MESSAGE
	this.displayWorkflowStatus("stopping");

	// GET URL 
	var url = Agua.cgiUrl + "workflow.cgi";
	console.log("Status.doStopWorkflow      url: " + url);		
	
	// GENERATE QUERY JSON FOR THIS WORKFLOW IN THIS PROJECT
	var query = new Object;
	query.username = username;
	query.sessionid = sessionid;
	query.project = project;
	query.workflow = workflow;
	query.cluster = username + "-" + cluster;
	query.mode = "stopWorkflow";
	query.start = start;
	console.log("Status.doStopWorkflow     query: " + dojo.toJson(query));
	
	var deferred = dojo.xhrPut(
		{
			url: url,
			putData: dojo.toJson(query),
			handleAs: "json",
			sync: false,
			load: function(response){
				Agua.toast(response);
			}
		}
	);
	
	//// CLEAR DEFERREDS
	//this.clearDeferreds();

	this.deferreds.push(deferred);
},
stopRun : function () {
	// STOP POLLING
	console.log("Status.stopRun    DOING this.stopPolling()");
	this.stopPolling();

	if ( ! this.core.userWorkflows.dropTarget ) {
		console.log("workflow.RunStatus.stopRun    Returning because this.core.userWorkflows.dropTarget is null");
		return;
	}

	console.log("Status.stopRun      this.stageStatus: " + this.stageStatus);
	console.dir({stageStatus: this.stageStatus});

	if ( this.stageStatus == null
		|| this.stageStatus.rows == null
		|| this.stageStatus.rows.length == 0 )	return;

	// SET ROWS IN STAGE TABLE
	for ( var i = 0; i < this.stageStatus.rows; i++ )
	{
		var row  = this.stageStatus.rows[i];
		console.log("Status.stopRun    row.status " + i + ": " + row.status);
		if ( row.status == 'running' )
			row.status = "stopped";
	}

	// SET CSS IN STAGES dropTarget
	var stageNodes = this.core.userWorkflows.dropTarget.getAllNodes();
	for ( var i = 0; i < this.stageNodes; i++ )
	{
		var node = this.stageNodes[i];
		console.log("Status.stopRun    node " + i + ": " + node);
		if ( dojo.hasClass(node, 'running') )
		{
			dojo.removeClass(node, 'running');
			dojo.addClass(node, 'stopped');
		}
	}

	// SEND STOP SIGNAL TO SERVER
	this.stopWorkflow();	
},	
pauseRun : function () {
// STOP AT THE CURRENT STAGE. TO RESTART FROM  STAGE, HIT 'START' BUTTON
	// STOP POLLING
	console.log("Status.pauseRun      DOING this.stopPolling()");
	this.stopPolling();

	// SEND STOP SIGNAL TO SERVER
	this.stopWorkflow();	

	if ( this.response == null )	return;
	
	// SET THE NODE CLASSES BASED ON STATUS
	console.log("Status.pauseRun    Checking " + this.response.length  + " stage nodes");
	for ( var i = 0; i < this.response.length; i++ )
	{
		// SET this.runner.start TO FIRST RUNNING OR WAITING STAGE
		// SO THAT IF 'RUN' BUTTON IS HIT, WORKFLOW WILL RESTART FROM
		// THAT STAGE (I.E., IT WON'T START OVER FROM THE BE)
		if ( this.response[i].status == "completed" )	continue;
		this.runner.start = (startIndex + 1);

		dojo.removeClass(childNodes[i], 'waiting');
		dojo.removeClass(childNodes[i], 'running');
		dojo.removeClass(childNodes[i], 'completed');
		dojo.addClass(childNodes[i], 'waiting');
		break;
	}
},
setConfirmDialog : function () {
	var yesCallback = function (){};
	var noCallback = function (){};
	var title = "Dialog title";
	var message = "Dialog message";
	
	this.confirmDialog = new plugins.dijit.ConfirmDialog(
		{
			title 				:	title,
			message 			:	message,
			parentWidget 		:	this,
			yesCallback 		:	yesCallback,
			noCallback 			:	noCallback
		}			
	);
},
loadConfirmDialog : function (title, message, yesCallback, noCallback) {
	console.log("FileMenu.loadConfirmDialog    yesCallback.toString(): " + yesCallback.toString());
	console.log("FileMenu.loadConfirmDialog    title: " + title);
	console.log("FileMenu.loadConfirmDialog    message: " + message);
	console.log("FileMenu.loadConfirmDialog    yesCallback: " + yesCallback);
	console.log("FileMenu.loadConfirmDialog    noCallback: " + noCallback);

	this.confirmDialog.load(
		{
			title 				:	title,
			message 			:	message,
			yesCallback 		:	yesCallback,
			noCallback 			:	noCallback
		}			
	);
},

// SETTERS
setSequence : function () {
	this.sequence = new dojox.timing.Sequence({});
},
setStageStatus : function () {
	console.log("Status.setStageStatus    DOING new plugins.workflow.RunStatus.StageStatus()");
	this.stageStatus = new plugins.workflow.RunStatus.StageStatus({
		core		: this.core,
		attachNode	: this.stagesStatusContainer
	});	
},
setClusterStatus : function () {
	console.log("Status.setClusterStatus    DOING new plugins.workflow.RunStatus.ClusterStatus()");
	this.clusterStatus = new plugins.workflow.RunStatus.ClusterStatus({
		core: this.core,
		attachNode	: this.attachNode
	});	
},
setQueueStatus : function () {
	console.log("Status.setQueueStatus    DOING new plugins.workflow.RunStatus.QueueStatus()");
	this.queueStatus = new plugins.workflow.RunStatus.QueueStatus({
		core: this.core,
		attachNode	: this.attachNode
	});	
}

});	// plugins.workflow.RunStatus


}

if(!dojo._hasResource["plugins.workflow.SharedApps"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.workflow.SharedApps"] = true;
dojo.provide("plugins.workflow.SharedApps");

// ALLOW THE USER TO SELECT APPLICATIONS BELONGING TO OTHER USERS AND DRAG THEM INTO WORKFLOWS

// NB: USERS CAN MANAGE THEIR APPS IN THE 'ADMIN' TAB

// INTERNAL MODULES


dojo.declare("plugins.workflow.SharedApps",
	[ plugins.workflow.Apps ],
{

//Path to the template of this widget. 
templateString:"<div dojoAttachPoint=\"containerNode\">\n\n    <div\n        dojoAttachPoint=\"mainTab\"\n        class=\"apps\"\n        dojoType=\"dijit.layout.ContentPane\"\n        parseOnLoad=\"false\"\n        title=\"Bioapps\"\n\t\tstyle=\"position: relative; height: 100%; max-height: auto !important; width: 400px !important; padding: 0 !important;\"\n    >\n\n        <!-- NEED margin-bottom TO COMPENSATE FOR 29px MARGIN-TOP OFFSET FOR TABLE-->\n        <table width=\"200px\">\n\t\t\t<tr valign=\"top\" width=\"100%\">\n\t\t\t\t\n\t\t\t\t<td colspan=\"3\" class=\"tabTitle\" align=\"center\">\n\t\t\t\t\t<div\n\t\t\t\t\t\tclass=\"refreshButton\"\n\t\t\t\t\t\tdojoAttachPoint=\"refreshButton\"\n\t\t\t\t\t\tdojoAttachEvent=\"onclick:refresh\">\n\t\t\t\t\t\t\n\t\t\t\t\t</div>\n\t\t\t\t\t<div class=\"header\">\n\t\t\t\t\t    Applications\n\t\t\t\t\t</div>\n\t\t\t\t</td>\n\t\t\t</tr>\n            <tr>\n                <td>\n                    <div\n                        dojoAttachPoint=\"appSourcesContainer\"\n\t\t\t\t\t>\n                    </div>\n                    \n                </td>\n            </tr>\n        </table>\n    \n    </div>\n</div>\n",

/////}

startup : function() {
	console.log("SharedApps.startup    workflow.SharedApps.startup()");

	this.inherited(arguments);
},

setRefreshButton : function () {
	dojo.connect(this.refreshButton, "onclick", this, "refresh");	
},

refresh : function () {
	////console.log("SharedApps.refresh     plugins.workflow.SharedApps.refresh()");

	this.updateApps();
},

updateApps : function (args) {
	////console.log("SharedApps.refresh     plugins.workflow.SharedApps.refresh()");
	console.log("SharedApps.updateApps    Doing Agua.getTable(sharedapps)");
	this.closePanes();

	// ALLOW TIME FOR PANES TO CLOSE THEN GET TABLE DATA	
	setTimeout(function(thisObj) {
		Data.getTable("sharedApps,sharedParameters");
		//Agua.warning("Completed reloading shared applications");
		thisObj.loadAppSources();
	}, 500, this);
},

getApps : function () {
	return Agua.getSharedApps();
}
	
}); // plugins.workflow.SharedApps

/*

loadAppSources : function () {
	console.log("SharedApps.loadAppSources     plugins.workflow.SharedApps.loadAppSources()");	
	console.log("SharedApps.loadAppSources     caller: " + this.loadAppSources.caller.nom);

	// DELETE EXISTING CONTENT
	//while ( this.dragSource.firstChild )
	//	this.dragSource.removeChild(this.dragSource.firstChild);
	this.clearDragSource();

	var apps = this.getApps();
	console.log("SharedApps.loadAppSources     apps: " + dojo.toJson(apps));
	var types = Agua.getAppTypes(apps);
	console.log("SharedApps.loadAppSources     types: " + dojo.toJson(types));

	//for ( var i = 0; i < types.length; i++ )
	for ( var i = 0; i < 1; i++ )
	{
		var type = types[i];
		console.log("SharedApps.loadAppSources     Doing type: " + dojo.toJson(type));		
		var itemArray = Agua.getAppsByType(type, apps);
		console.log("SharedApps.loadAppSources     itemArray: " + dojo.toJson(itemArray));		
		if ( itemArray == null || itemArray.length == 0 )	continue;
		console.log("SharedApps.loadAppSources     type '" + type + "' itemArray: " + dojo.toJson(itemArray));

		// CREATE TITLE PANE
		var appSource = new plugins.workflow.AppSource(
		{
			title		: 	type,
			itemArray 	:	itemArray,
			contextMenu	:	this.contextMenu
		});
		this.appSourcesContainer.appendChild(appSource.domNode);
	}
}
*/

}

if(!dojo._hasResource["plugins.workflow.StageRow"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.workflow.StageRow"] = true;
dojo.provide("plugins.workflow.StageRow");



dojo.declare( "plugins.workflow.StageRow",
	[ dijit._Widget, dijit._Templated, plugins.core.Common ],
{
//Path to the template of this widget. 
templateString:"<div dojoAttachPoint=\"containerNode\">\n    <table\n        class=\"stagerow\"\n        cellspacing=\"0px\"\n        height=\"16px\" width=\"100%\" style=\"padding: 0; margin: 0; height: 16px !important;\">\n        <tr>\n            <td\n                colspan=\"2\"\n                dojoAttachPoint=\"nameNode\"\n                class=\"name\"\n                >${name}</td>\n            <td\n                colspan=\"1\"\n                dojoAttachPoint=\"numberNode\"\n                class=\"number\">\n            </td>\n        </tr>\n        <tr>\n            <td\n                colspan=\"1\"\n                dojoAttachPoint=\"executorNode\"\n                class=\"executor\"\n                style=\"display: none;\" >${executor}\n            </td>\n\n            <td \n                colspan=\"2\"\n                dojoAttachPoint=\"submitNode\"\n                class=\"\"\n                style=\"display: none;\" >\n            </td>\n            \n        </tr>\n        <tr>\n            <td colspan=\"3\"\n                dojoAttachPoint=\"locationNode\"\n                class='location'\n                style=\"display: none;\" >${location}\n            </td>\n        </tr>\n        <tr>\n            <td colspan=\"3\"\n                dojoAttachPoint=\"descriptionNode\"\n                class='description'\n                style=\"display: none;\" >${description}\n            </td>\n        </tr>\n    </table>\n</div>\n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

// OR USE @import IN HTML TEMPLATE
cssFiles : [ dojo.moduleUrl("plugins") + "/workflow/css/stagerow.css" ],

// PARENT plugins.workflow.Apps WIDGET
parentWidget : null,

// APPLICATION OBJECT
application : null,

// CORE WORKFLOW OBJECTS
core : null,

/////}}}}}
constructor : function(args) {
	////console.log("StageRow.constructor    " + this.id);
	
	this.loadCSS();

	this.core = args.core;
	this.parentWidget = args.parentWidget;

	this.application = new Object;
	for ( var key in args )
	{
		if ( key != "parentWidget" )
		{
			this.application[key] = args[key];
		}
	}
	//////////console.log("StageRow.constructor    this.application: " + dojo.toJson(this.application));
	
	//this.inherited(arguments);
},
postCreate : function() {
	this.startup();
},
startup : function () {
/* SET this.name.parentWidget = this
  
	FOR RETRIEVAL OF this.application WHEN MENU IS CLICKED
	
	REM: remove ONCLICK BUBBLES ON stageRow.name NODE RATHER THAN ON node. 

	I.E., CONTRARY TO DESIRED, this.name IS THE TARGET INSTEAD OF THE node.
	
	ALSO ADDED node.parentWidget = stageRow IN Workflows.updateDropTarget()

*/
	//console.group("stageRow-" + this.id + "    startup");
	//console.dir({application:this.application});
	//////////console.log("StageRow.startup    this.parentWidget: " + this.parentWidget);

	this.inherited(arguments);
	
	this.name.parentWidget = this;
	//////////console.log("StageRow.startup    this.name.parentWidget: " + this.name.parentWidget);
	
	this.setNumber(this.application.number);

	this.setSubmitStyle(this.application.submit);

	//console.groupEnd("stageRow-" + this.id + "    startup");
},
setSubmitStyle : function (submit) {
	//console.log("StageRow.setSubmitStyle     submit: " + submit)
	if ( submit == 1 ) {
		//console.log("StageRow.setSubmitStyle     DOING dojo.addClass(this.domNode, 'submit')")
		dojo.addClass(this.domNode, "submit");
	}
	else {
		//console.log("StageRow.setSubmitStyle     DOING dojo.removeClass(this.domNode, 'submit')")
		dojo.removeClass(this.domNode, "submit");
	}
	
},
checkValidParameters : function (force) {
	//console.group("stageRow-" + this.id + "    checkValidParameters");
	//console.log("StageRow.checkValidParameters    caller: " + this.checkValidParameters.caller.nom);

	// CHECK ALL PARAMETERS. COLLECT FILES IN this.fileStageParameters
	this.checkAllParameters(force);
	
	//console.log("StageRow.checkValidParameters    AFTER this.checkAllParameters(force)");
	//console.log("StageRow.checkValidParameters    this.fileStageParameters.length: " + this.fileStageParameters.length);
	
	if ( this.fileStageParameters.length != 0 )
		this.checkFiles();
	else
		this.checkRunStatus();

	//console.groupEnd("stageRow-" + this.id + "    checkValidParameters");
},
checkRunStatus : function() {
	//console.log("StageRow.checkRunStatus    plugins.workflow.StageRow.checkRunStatus");
	
	// DEBUG:
	if ( this.core.runStatus == null )	return;

	// CHECK IF STAGES ARE RUNNING
	//console.log("Parameters.load     BEFORE this.core.userWorkflows.indexOfRunningStage()");
	var indexOfRunningStage = this.core.userWorkflows.indexOfRunningStage();
	//console.log("Parameters.load     indexOfRunningStage: " + indexOfRunningStage);
	var runner = this.core.runStatus.createRunner(indexOfRunningStage);	
	var singleton = true;
	
	//console.log("Parameters.load     DOING runStatus.getStatus");
	this.core.runStatus.getStatus(runner, singleton);
},
checkAllParameters : function (force) {
/*	CHECK ALL THE PARAMETERS HAVE VALID INPUTS AND CHANGE CSS ACCORDINGLY.
 	
 	RETURN VALUE OF validInputs AS true IF ALL PARAMETERS ARE SATISFIED.
 	
 	OTHERWISE, RETURN false.
 	
	PROCESS FOR CHECKING VALIDITY FOR EACH PARAMETER

		1. SET this.validInputs TO TRUE, UPDATE ALONG THE WAY

		2. CHECK ONLY inputs (IGNORE outputs AND resources).
		
		3. FOR EACH INPUT:
	
			3.1 CHECK IF VALIDITY HAS ALREADY BEEN COMPUTED AND STORED
			
				IN Agua.getParameterValidity BOOLEAN. USE IF AVAILABLE AND NEXT 
		
			3.2 OTHERWISE, SET Agua.setParameterValidity FOR EACH
			
				PARAMETER AS FOLLOWS:
				
				a. IF FILE/DIR, IGNORE IF OPTIONAL UNLESS FILEPATH SPECIFIED
			
				b. IF NON-OPTIONAL FILE/DIR, ADD TO ARRAY OF FILES TO BE
				
					PASSED TO checkFiles
				
				c. IGNORE FLAGS, CHECK INTS AND NON-OPTIONAL TEXT
				
			3.3 RUN checkFiles FOR UNKNOWN FILES/DIRS:
			
				a. DO A BATCH FILE CHECK ON THE REMOTE SERVER. 
			
				b. SET validInputs TO FALSE IF ANY FILES/DIRS ARE MISSING
				
		4. ADJUST CSS CLASS OF StageRow ACCORDING TO VALUE OF validInputs
		
		5. RETURN BOOLEAN VALUE OF validInputs
		
*/

	//console.group("stageRow-" + this.id + "    checkAllParameters");
	//console.log("StageRow.checkAllParameters    caller: " + this.checkAllParameters.caller.nom);
	//console.log("StageRow.checkAllParameters    this.force: " + this.force);

	// SET this.isValid TO DEFAULT true
	this.isValid = true;

	// GET STAGE PARAMETERS
	var parameterRows = new Array;
	var stageParameters = new Array;
	//console.log("StageRow.checkAllParameters    this.application: ");
	//console.dir({application:this.application});
	//console.log("StageRow.checkAllParameters    this.core.parameters.application:");
	//console.dir({parameters_application:this.core.parameters.application});

	if ( this.core.parameters != null 
		&& this.core.parameters.isCurrentApplication(this.application) ) {
		parameterRows = this.core.parameters.childWidgets;
		//console.log("StageRow.checkAllParameters    APPLICATIONS IS CURRENT APPLICATION [" + this.application.name + "].     parameterRows.length: " + parameterRows.length);
		for ( var i = 0; i < this.core.parameters.childWidgets.length; i++ )
		{
			stageParameters.push(this.core.parameters.childWidgets[i].parameterObject);
		}
	}
	else {
		//console.log("StageRow.checkAllParameters    APPLICATION IS NOT CURRENT APPLICATION");
		stageParameters = Agua.getStageParameters(this.application);
	}
	//console.log("StageRow.checkAllParameters    stageParameters.length: " + stageParameters.length);

	if ( stageParameters == null ) {
		//console.groupEnd("stageRow-" + this.id + "    checkAllParameters");
		return false;
	}
	
	// GET ALL REQUIRED/ESSENTIAL INPUT FILE/DIRECTORY PARAMETERS
	this.fileStageParameters = new Array;
	this.fileParameterRows = new Array;
	for ( var i = 0; i < stageParameters.length; i++ )
	{
		//console.log("StageRow.checkAllParameters    Processing parameter: " + stageParameters[i].name + " (discretion: " + stageParameters[i].discretion + ")");

		// ADD SYSTEM VARIABLES
		stageParameters[i].value = this.systemVariables(stageParameters[i].value, stageParameters[i]);

		// UNLESS force SPECIFIED, GET VALIDITY IF EXISTS
		// AND MOVE ON TO NEXT STAGE PARAMETER
		var isValid = Agua.getParameterValidity(stageParameters[i]);
		if ( force != true && isValid != null && isValid != false )
		{
			//console.log("StageRow.checkAllParameters   inside required/essential isValid: " + isValid);

			//console.log("StageRow.checkAllParameters    isValid IS DEFINED and force != true");
			if ( parameterRows[i] != null )
			{
				//console.log("StageRow.checkValidFile    DOING parameterRow.setValid(node)");
				if ( isValid == true )
					parameterRows[i].setValid(parameterRows[i].containerNode);
				else {
					parameterRows[i].setInvalid(parameterRows[i].containerNode);
					this.isValid = false;
				}
			}
			//console.log("StageRow.checkAllParameters    End of processing parameter: " + stageParameters[i].name);

			continue;
		}

		// FLAGS ARE AUTOMATICALLY VALID
		else if ( stageParameters[i].valuetype == "flag" )
			continue;
		
		// SAVE UNKNOWN FILE/DIRECTORY FOR checkFiles LATER ON
		if ( stageParameters[i].valuetype == "file"
			||  stageParameters[i].valuetype == "directory" )
			this.checkValidFile(stageParameters[i], parameterRows[i]);

		// CHECK INTEGERS
		else if ( stageParameters[i].valuetype == "integer" )
			this.checkValidInteger(stageParameters[i], parameterRows[i]);

		// CHECK TEXT INPUTS
		else
			this.checkValidText(stageParameters[i], parameterRows[i]);
	}

	if ( this.fileStageParameters.length == 0 )
	{
		//console.log("StageRow.checkAllParameters    'this.fileStageParameters' is empty. Returning");	
		//console.log("StageRow.checkAllParameters    No filecheck required. FINAL this.isValid: " + this.isValid);
		
		if ( this.isValid == false || this.isValid == null )
			this.setInvalid();
		else this.setValid();

		//console.groupEnd("stageRow-" + this.id + "    checkFileParameters");
		return this.isValid;
	}

	//console.log("StageRow.checkAllParameters    this.fileStageParameters.length: " + this.fileStageParameters.length);
	//console.log("StageRow.checkAllParameters    this.fileParameterRows.length: " + this.fileParameterRows.length);
	//console.log("StageRow.checkAllParameters    END. this.fileParameterRows:");
	//console.dir({fileParameterRows:this.fileParameterRows});			
	//console.log("StageRow.checkAllParameters    END. this.fileStageParameters:");
	//console.dir({fileStageParameters:this.fileStageParameters});			


	//console.groupEnd("stageRow-" + this.id + "    checkAllParameters");
},
currentParametersApplication : function (application) {
	////console.log("StageRow.currentParametersApplication    StageRow.currentParametersApplication(application)");

	var keys = ["project", "workflow", "workflownumber", "name", "number"];
	return this._objectsMatchByKey(application, this.core.parameters.application, keys);	
},
checkFiles : function (files) {
	//console.group("stageRow-" + this.id + "    checkFiles");
	////console.log("StageRow.checkFiles    caller: " + this.checkFiles.caller.nom);
	////console.log("StageRow.checkFiles    StageRow.checkFiles(files)");
	////console.log("StageRow.checkFiles    this.checkFiles.caller.nom: " + this.checkFiles.caller.nom);
	////console.dir({caller: this.checkFiles.caller});
	////console.log("StageRow.checkFiles    this.fileStageParameters.length: " + this.fileStageParameters.length);
	////console.log("StageRow.checkFiles    this.fileParameterRows.length: " + this.fileParameterRows.length);

	if ( files == null )	files = this.fileStageParameters;
	////console.log("StageRow.checkFiles    this.fileStageParameters: " + this.fileStageParameters.length);
	//////console.log("StageRow.checkFiles    'this.fileStageParameters': " + dojo.toJson(this.fileStageParameters, true));
	////console.log("StageRow.checkFiles    BEFORE xhrPut this.isValid: " + this.isValid);
	
	// GET FILEINFO FROM REMOTE FILE SYSTEM
	var url = Agua.cgiUrl + "workflow.cgi";
	var query = new Object;
	query.username = Agua.cookie('username');
	query.sessionid = Agua.cookie('sessionid');
	query.project = this.application.project;
	query.workflow = this.application.workflow;
	query.mode = "checkFiles";
	query.files = files;
	//console.log("StageRow.checkFiles    query: ");
	//console.dir({query:query});

	// SEND TO SERVER
	var thisObject = this;
	var xhrputReturn = dojo.xhrPut({
		url				: url,
		contentType		: "text",
		sync 			: false,
		handleAs		: "json",
		putData			: dojo.toJson(query),
		handle			: function(fileinfos, ioArgs) {
			thisObject.validateFiles(files, fileinfos);
			//console.log("StageRow.checkFiles    fileinfos: ");
			//console.dir({fileinfos:fileinfos});
			
			if ( thisObject.core.parameters != null 
				&& thisObject.core.parameters.isCurrentApplication(thisObject.application) ) {
				//console.log("StageRow.checkFiles    Doing checkRunStatus()");
				thisObject.checkRunStatus();
			}
		
			//console.groupEnd("stageRow-" + thisObject.id + "    checkFiles");
		}
	});	

	////console.log("StageRow.checkFiles    BEFORE setting stageRow CSS, FINAL this.isValid: " + this.isValid);	
	if ( this.isValid == false || this.isValid == null ) this.setInvalid();
	else this.setValid();

	return this.isValid;
},
validateFiles : function (fileinfos) {
	//console.group("stageRow-" + this.id + "    validateFiles");
	//console.log("StageRow.validateFiles    caller: " + this.validateFiles.caller.nom);
	//console.log("StageRow.validateFiles    fileinfos: ");
	//console.dir({fileinfos:fileinfos});
	//console.log("StageRow.validateFiles    this.fileParameterRows:");
	//console.dir({parameterRows:this.parameterRows});
	//console.log("StageRow.validateFiles    this.fileParameterRows:");
	//console.dir({fileParameterRows:this.fileParameterRows});			

	if ( fileinfos == null
		|| fileinfos.length == null
		|| ! fileinfos.length )
		return;
		
	for ( var i = 0; i < fileinfos.length; i++ )
	{
		//console.log("StageRow.validateFiles    fileinfos[" + i + "]: ");
		//console.dir({fileinfo:fileinfos[0]});
		var parameterRow = this.fileParameterRows[i];
		//console.log("StageRow.validateFiles    parameterRow: " + parameterRow);
//		if ( ! parameterRow || ! this.fileStageParameters )	return;
		
		// SET FILE INFO
		if ( this.fileStageParameters && this.fileStageParameters[i])
			Agua.setFileInfo(this.fileStageParameters[i], fileinfos[i]);
		
		if ( fileinfos[i].exists == "true" )
		{
			if ( fileinfos[i].type != this.fileStageParameters[i].valuetype )
			{
				// SET PARAMETER VALIDITY AS FALSE
				//console.log("StageRow.validateFiles    File/dir mismatch. Setting parameter validity as FALSE");
				Agua.setParameterValidity(this.fileStageParameters[i], false);
				this.isValid = false;
				if ( parameterRow != null )
				{
					//console.log("StageRow.validateFiles    DOING parameterRow.setInvalid(node)");
					parameterRow.setInvalid(parameterRow.containerNode);
				}
			}
			else {
				// SET PARAMETER VALIDITY AS TRUE
				//console.log("StageRow.validateFiles    paramtype matches. Setting parameter validity as TRUE");
				Agua.setParameterValidity(this.fileStageParameters[i], true);
				if ( parameterRow != null )
				{
					//console.log("StageRow.validateFiles    DOING parameterRow.setValid(containerNode)");
					//console.dir({containerNode:parameterRow.containerNode});
					parameterRow.setValid(parameterRow.containerNode);
				}
			}
		}
		else
		{
			if ( this.fileStageParameters[i].discretion == "essential" )
			{
				//console.log("StageRow.validateFiles    file '" + this.fileStageParameters[i].name + "' (discretion: " + this.fileStageParameters[i].discretion + ") does not exist. Setting stageParameter.isValid to FALSE");
				
				this.isValid = false;

				// DO Agua.setParameterValidity
				Agua.setParameterValidity(this.fileStageParameters[i], false);
				if ( parameterRow != null )
				{
					//console.log("StageRow.validateFiles    DOING parameterRow.setInvalid(node)");
					//console.dir({containerNode:parameterRow.containerNode});
					parameterRow.setInvalid(parameterRow.containerNode);
				}
			}
			else
			{
				// DO Agua.setParameterValidity
				Agua.setParameterValidity(this.fileStageParameters[i], true);
				if ( parameterRow != null )
				{
					//console.log("StageRow.validateFiles    DOING parameterRow.setValid(node)");
					//console.dir({containerNode:parameterRow.containerNode});
					parameterRow.setValid(parameterRow.containerNode);
				}
			}
		}
	}
	//console.log("StageRow.validateFiles    FINAL (w/o fileCheck) this.isValid: " + this.isValid);

	if ( this.isValid == false )
		this.setInvalid();
	else
		this.setValid();

	//console.groupEnd("stageRow-" + this.id + "    validateFiles");
},
checkValidFile : function (stageParameter, parameterRow) {
// LOAD UNKNOWN FILES INTO this.fileStageParameters AND this.fileParameterRows

	////console.group("StageRow-" + this.id + "    checkValidFile");
	//console.log("StageRow.checkValidFile     StageRow.checkValidFile(stageParameter)");
	//console.log("StageRow.checkValidFile     stageParameter: ");
	//console.dir({stageParameter:stageParameter});
	//console.log("StageRow.checkValidFile    stageParameter.name: " + stageParameter.name);
	
	var filepath = stageParameter.value;
	//console.log("StageRow.checkValidFile     Checking files/dirs");

	// CHECK NON-OPTIONAL FILEPATHS
	// required: FILE PATH MUST BE NON-EMPTY
	// essential: FILE/DIRECTORY MUST BE PHYSICALLY PRESENT
	if ( stageParameter.discretion == "required"
		|| stageParameter.discretion == "essential" )
	{
		//console.log("StageRow.checkValidFile     Parameter is required/essential");

		// SET this.isValid = false IF FILE/DIR IS NULL OR EMPTY
		if ( filepath == null || filepath == '' )
		{
			//console.log("StageRow.checkValidFile    Non-optional file/dir is null or empty.");
			//console.log("StageRow.checkValidFile    Setting stageParameter.parameterIsValid to FALSE.");
			this.setInvalidParameter(stageParameter, parameterRow);
		}

		// ADD TO this.fileStageParameters ARRAY IF NO fileinfo
		else if ( stageParameter.fileinfo == null )
		{
			//console.log("StageRow.checkValidFile    stageParameter.fileinfo is null. Pushing to fileStageParameters");
			//console.log("StageRow.checkValidFile    stageParameter: ");
			//console.dir({stageParameter:stageParameter});
			//console.log("StageRow.checkValidFile    parameterRow: ");
			//console.dir({parameterRow:parameterRow});
			
			this.fileStageParameters.push(stageParameter);
			this.fileParameterRows.push(parameterRow);
		}

		// FILE/DIR IS SPECIFIED BUT KNOWN TO NOT EXIST
		else if ( stageParameter.fileinfo.exists == "false" )
		{
			//console.log("StageRow.checkValidFile    Non-optional file/dir stageParameter.fileinfo.exists: " + stageParameter.fileinfo.exists);

			// PUSH ONTO this.fileStageParameters IF CHAINED = 0
			if ( stageParameter.chained == null
				|| stageParameter.chained == 0 )
			{
				//console.log("StageRow.checkValidFile    stageParameter.chained is 0 or null");
	 			//console.log("StageRow.checkValidFile    Pushing onto this.fileStageParameters");
				//console.log("StageRow.checkValidFile    stageParameter: ");
				//console.dir({stageParameter:stageParameter});
				//console.log("StageRow.checkValidFile    parameterRow: ");
				//console.dir({parameterRow:parameterRow});
				this.fileStageParameters.push(stageParameter);
				this.fileParameterRows.push(parameterRow);
			}
			
			// OTHERWISE, USE EXISTING PARAMETER VALIDITY INFO
			// TO SET THE VALIDITY OF THE PARAMETER ROW AND IGNORE
			// WHETHER OR NOT IT EXISTS (CHAINING IS THE PROMISE
			// THAT IT WILL EXIST ONCE THE PREVIOUS STAGE IS DONE.)
			else {
				//console.log("StageRow.checkValidFile    stageParameter.chained: " + stageParameter.chained);
				//console.log("StageRow.checkValidFile    Doing this.setValidParameter()");
				this.setValidParameter(stageParameter, parameterRow);
			}
		}
		
		// FILE/DIR IS SPECIFIED AND KNOWN TO EXIST
		else {
			//console.log("StageRow.checkValidFile    File/dir exists.");
			if ( stageParameter.fileinfo.type != stageParameter.valuetype )
			{
				// SET PARAMETER VALIDITY AS FALSE
				//console.log("StageRow.checkValidFile    File/dir mismatch. Setting parameter validity as FALSE");
				this.setInvalidParameter(stageParameter, parameterRow);
			}
			else {
				// SET PARAMETER VALIDITY AS TRUE
				//console.log("StageRow.checkValidFile    Paramtype matches. Setting parameter validity as TRUE");
				this.setValidParameter(stageParameter, parameterRow);
			}
		}
	}
	
	// IT'S AN OPTIONAL PARAMETER SO IT'S VALID IF EMPTY.
	// BUT IF ITS NOT EMPTY, CHECK IT EXISTS.
	else 
	{
		// IF EMPTY 
		if ( stageParameter.value == null
			|| stageParameter.value == '' )
		{
			//console.log("StageRow.checkValidFile    Ignoring empty optional file/dir parameter");
			this.setValidParameter(stageParameter, parameterRow);
		}
		else
		{
			//console.log("StageRow.checkValidFile    Optional file/dir parameter is specified. Pushing onto this.fileStageParameters array");
			//console.log("StageRow.checkValidFile    stageParameter: ");
			//console.dir({stageParameter:stageParameter});
			//console.log("StageRow.checkValidFile    parameterRow: ");
			//console.dir({parameterRow:parameterRow});
			this.fileStageParameters.push(stageParameter);
			this.fileParameterRows.push(parameterRow);
		}
	}

	////console.log("StageRow.checkValidFile    END. this.fileParameterRows:");
	////console.dir({fileParameterRows:this.fileParameterRows});			
	////console.log("StageRow.checkValidFile    END. this.fileStageParameters:");
	////console.dir({fileStageParameters:this.fileStageParameters});			
		
	//console.groupEnd("StageRow-" + this.id + "    checkValidFile");
},
checkValidInteger : function (stageParameter, parameterRow) {
	//console.log("StageRow.checkValidInteger     StageRow.checkValidInteger(stageParameter)");
	////console.log("StageRow.checkValidInteger     stageParameter: " + dojo.toJson(stageParameter));
	if ( stageParameter.discretion != "optional" )
	{
		// SET EMPTY NON-OPTIONAL INTEGER AS FALSE
		if ( stageParameter.value == null
				|| stageParameter.value == '' )
		{
			////console.log("StageRow.checkValidParameters      '" + stageParameter.name + "' Non-optional INTEGER input is empty. Setting this.isValid to FALSE");
			this.setInvalidParameter(stageParameter, parameterRow);
		}
		// NON-OPTIONAL INTEGER BUT IS NOT A PROPER NUMBER
		// ////SO SET TO false
		else if (! stageParameter.value.match(/^\s*[\d\.]+\s*$/) )
		{
			////console.log("StageRow.checkValidParameters      '" + stageParameter.name + "' Non-optional INTEGER input not valid. Setting this.isValid to FALSE");
			this.isValid = false;
			Agua.setParameterValidity(stageParameter, false);
		}
		// OTHERWISE, ITS A CORRECT OPTIONAL INTEGER SO SET TO true
		else
		{
			this.setValidParameter(stageParameter, parameterRow);
		}
	}
	else
	{
		// SET OPTIONAL INTEGER TO false IF ITS NON-EMPTY BUT NOT
		// AN INTEGER
		if ( stageParameter.value != null
				&& stageParameter.value != ''
				&& ! stageParameter.value.match(/^\s*[\d\.]+\s*$/) )
		{
			////console.log("StageRow.checkValidParameters      '" + stageParameter.name + "' Optional INTEGER input not valid. Setting this.isValid to FALSE");
			this.setInvalidParameter(stageParameter, parameterRow);
		}
		
		// OTHERWISE, ITS EITHER EMPTY OR AN INTEGER SO SET TO true
		else
		{
			////console.log("StageRow.checkValidParameters      '" + stageParameter.name + "' Optional INTEGER input is empty. Setting this.isValid to TRUE");
			this.setValidParameter(stageParameter, parameterRow);
		}
	}
},
checkValidText : function (stageParameter, parameterRow) {
	////console.log("StageRow.checkValidText     StageRow.checkValidText(stageParameter)");
	////console.log("StageRow.checkValidText     stageParameter: " + dojo.toJson(stageParameter));
	if ( stageParameter.discretion != "optional" )
	{
		if ( stageParameter.value == null
			|| stageParameter.value == '' )
		{
			////console.log("StageRow.checkValidText      '" + stageParameter.name + "' Required text input is null or empty. Setting this.isValid to FALSE");
			this.setInvalidParameter(stageParameter, parameterRow);
		}
		else
		{
			////console.log("StageRow.checkValidText      '" + stageParameter.name + "' Required text input is satisfied. Setting this.isValid to TRUE");
			this.setValidParameter(stageParameter, parameterRow);
		}
	}
	else
	{
		// THIS IS AN OPTIONAL PARAMETER SO, EMPTY OR NOT, ITS VALID
		////console.log("StageRow.checkValidText      '" + stageParameter.name + "' Optional text parameter. Setting stageParameter.isValid to TRUE");
		this.setValidParameter(stageParameter, parameterRow);
	}
},
toggle : function () {
	//////console.log("StageRow.toggle    plugins.workflow.StageRow.toggle()");
	//////console.log("StageRow.toggle    this.description: " + this.description);

	var array = [ "executor", "localonly", "location", "description", "notes" ];
	for ( var i in array )
	{
		if ( this[array[i]].style.display == 'table-cell' ) this[array[i]].style.display='none';
		else this[array[i]].style.display = 'table-cell';
	}
},
setInvalidParameter : function (stageParameter, parameterRow) {
	//console.log("StageRow.setInvalidParameter    stageParameter.name: " + stageParameter.name);
	//console.log("StageRow.setInvalidParameter    parameterRow: " + parameterRow);

	this.isValid = false;
	Agua.setParameterValidity(stageParameter, false);
	if ( parameterRow != null)
		parameterRow.setInvalid(parameterRow.containerNode);
},
setValidParameter : function (stageParameter, parameterRow) {
	////console.log("StageRow.setValidParameter    stageParameter.name: " + stageParameter.name);
	Agua.setParameterValidity(stageParameter, true);
	if ( parameterRow != null)
		parameterRow.setValid(parameterRow.containerNode);
},
setValid : function () {
	//console.log("StageRow.setValid    SETTING node to SATISFIED: " + this.id);
	//console.log("StageRow.setValid    this.setValid.caller.nom: " + this.setValid.caller.nom);
	
	dojo.removeClass(this.domNode, 'unsatisfied');
	dojo.addClass(this.domNode, 'satisfied');
	
	this.isValid = true;
	var stagesWidget = this.core.userWorkflows;
	//console.log("StageRow.setValid    this.stagesWidget: " + this.stagesWidget);
	stagesWidget.updateRunButton();	
},
setInvalid : function () {
	//console.log("StageRow.setInvalid    SETTING node to UNSATISFIED: " + this.id);
	//console.log("StageRow.setInvalid    this.setInvalid.caller.nom: " + this.setInvalid.caller.nom);
	
	dojo.removeClass(this.domNode, 'satisfied');
	dojo.addClass(this.domNode, 'unsatisfied');
	
	this.isValid = false;
	var stagesWidget = this.core.userWorkflows;
	//console.log("StageRow.setInvalid    this.stagesWidget: " + this.stagesWidget);
	stagesWidget.updateRunButton();	
},
getApplication : function () {
// RETURN A COPY OF this.application
	return dojo.clone(this.application);
},
setApplication : function (application) {
// SET this.application TO THE SUPPLIED APPLICATION OBJECT
	this.application = application;

	return this.application;
},
setNumber : function (number) {
// SET THE NUMBER NODE TO THE stage.number 
	//console.log("StageRow.setNumber    plugins.workflow.StageRow.setNumber(" + number + ")");
	this.application.number = number;
	this.application.appnumber = number;
	this.numberNode.innerHTML = number;
}

});

}

if(!dojo._hasResource["plugins.workflow.StageMenu"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.workflow.StageMenu"] = true;
dojo.provide("plugins.workflow.StageMenu");

// PROVIDE A POPUP CONTEXT MENU AND IMPLEMENT ITS 
// ONCLICK FUNCTIONS

//Open a context menu	On Windows: shift-f10 or the Windows context menu key On Firefox on the Macintosh: ctrl-space. On Safari 4 on Mac: VO+shift+m (VO is usually control+opton)
//Navigate menu items	Up and down arrow keys
//Activate a menu item	Spacebar or enter
//Open a submenu	Spacebar, enter, or right arrow
//Close a context menu or submenu	Esc or left arrow
//Close a context menu and all open submenus	Tab

// // optimize: load dijit layer


// HAS A


// INHERITS



dojo.declare("plugins.workflow.StageMenu",
	[ dijit._Widget, dijit._Templated, plugins.core.Common ],
{
//Path to the template of this widget. 
templateString:"<div dojoAttachPoint=\"containerNode\">\n\n<div\n    dojoAttachPoint=\"menu\"\n    class=\"stagemenu\"\n    dojoType=\"plugins.menu.Menu\">\n\n    <div\n        dojoAttachPoint=\"runNode\"\n        dojoType=\"dijit.MenuItem\"\n        class=\"runIcon\"\n        dojoAttachEvent=\"onClick:run\"    \n        >\n        Run\n    </div>\n\n    <div\n        dojoAttachPoint=\"runAllNode\"\n        dojoType=\"dijit.MenuItem\"\n        class=\"runAllIcon\"\n        dojoAttachEvent=\"onClick:runAll\"    \n        >\n        Run All\n    </div>\n\n    <div\n        dojoAttachPoint=\"chainNode\"\n        dojoType=\"dijit.MenuItem\"\n        class=\"chainIcon\"\n        dojoAttachEvent=\"onClick:chain\"    \n        >\n        Chain\n    </div>\n\n    <div\n        dojoAttachPoint=\"refreshNode\"\n        dojoType=\"dijit.MenuItem\"\n        class=\"refreshIcon\"\n        dojoAttachEvent=\"onClick:refresh\"    \n        >\n        Refresh\n    </div>\n\n    <div\n        dojoAttachPoint=\"stopNode\"\n        dojoType=\"dijit.MenuItem\"\n        class=\"stopIcon\"\n        dojoAttachEvent=\"onClick:stop\"    \n        >\n        Stop\n    </div>\n\n    <div\n        dojoAttachPoint=\"removeNode\"\n        dojoType=\"dijit.MenuItem\"\n        class=\"deleteIcon\"\n        dojoAttachEvent=\"onClick:remove\"    \n        >\n        Delete\n    </div>\n\n</div>\n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

//addingApp STATE2
addingApp : false,

// OR USE @import IN HTML TEMPLATE
cssFiles : [ dojo.moduleUrl("plugins") + "/workflow/css/stagemenu.css" ],

// PARENT WIDGET
parentWidget : null,

// CORE WORKFLOW OBJECTS
core : null,

////////}

constructor : function(args) {
	console.log("StageMenu.constructor     plugins.workflow.StageMenu.constructor");			
	this.core = args.core;
	console.log("StageMenu.constructor     this.core: " + this.core);
	
	// GET INFO FROM ARGS
	this.parentWidget = args.parentWidget;

	// LOAD CSS
	this.loadCSS();		
},
postCreate : function() {
	this.startup();
},
startup : function () {
	////console.log("StageMenu.startup    plugins.workflow.StageMenu.startup()");

	// COMPLETE CONSTRUCTION OF OBJECT
	this.inherited(arguments);	 

	// SET DRAG APP - LIST OF APPS
	this.setMenu();
},
setMenu : function () {
// CONNECT LISTENERS FOR MENU
	////console.log("StageMenu.setMenu     plugins.workflow.StageMenu.setMenu()");
	
	//dojo.connect(this.removeNode, "onClick", dojo.hitch(this, function(event)
	//{
	//	////console.log("StageMenu.setMenu     onClick remove");
	//	this.remove(event);
	//	event.stopPropagation();
	//}));
	//
	//dojo.connect(this.runNode, "onClick", dojo.hitch(this, function(event)
	//{
	//	////console.log("StageMenu.setMenu     onClick run");
	//	this.run(event);
	//}));
},
bind : function (node) {
// BIND THE MENU TO A NODE
	////console.log("StageMenu.bind     plugins.workflow.StageMenu.bind(node)");
	////console.log("StageMenu.bind     node: " + node);

	if ( node == null )
	{
		////console.log("StageMenu.bind     node is null. Returning...");
	}
	return this.menu.bindDomNode(node);	
},
remove : function (event) {
// REMOVE THE STAGE FROM THE WORKFLOW
	console.log("StageMenu.remove     plugins.workflow.StageMenu.remove(event)");

	// REM: WE ARE NOT INTERESTED IN event.target 
	// BECAUSE ITS THE CLICKED MENU NODE. WE WANT
	// THE NODE UNDERNEATH
	var node = this.menu.currentTarget;
	var widget = dijit.getEnclosingWidget(node);
	var application = widget.getApplication();
	//console.log("StageMenu.remove     application: " + dojo.toJson(application));

	if ( widget == null )	return;

	// PHYSICALLY REMOVE THE CLICKED NODE
	var itemNode = widget.domNode.parentNode;
	this.parentWidget.dropTarget.delItem(itemNode.id);
	dojo.destroy(itemNode);

	// SET username
	var username = Agua.cookie(username);

	// REMOVE THE CLICKED STAGE FROM THE WORKFLOW
	var stageObject = {
		username: username,
		project: this.parentWidget.projectCombo.getValue(),
		workflow: this.parentWidget.workflowCombo.getValue(),
		name: application.name,
		owner: application.owner,
		number: application.number,
		type: application.type
	};
	////console.log("StageMenu.remove     stageObject: " + dojo.toJson(stageObject));

	// REMOVE STAGE IN AGUA ON CLIENT AND ON REMOTE SERVER
	setTimeout(function(thisObj) {
			console.log("StageMenu.remove     Doing Agua.spliceStage(stageObject); }, 100, this)");
			Agua.spliceStage(stageObject);
		},
		100,
		this
	);
	

	// UPDATE ANY NODES COMING AFTER THE INSERTION POINT OF THE NEW NODE
	// NB: THE SERVER SIDE UPDATES ARE DONE AUTOMATICALLY
	////console.log("StageMenu.remove     this.parentWidget: " + this.parentWidget);
	////console.log("StageMenu.remove     this.parentWidget.dropTarget: " + this.parentWidget.dropTarget);
	var childNodes = this.parentWidget.dropTarget.getAllNodes();
	for ( var i = application.number; i < childNodes.length; i++ )
	{
		childNodes[i].application.number = (i + 1).toString();
	}

	// RESETTING number IN ALL CHILDNODES
	////console.log("StageMenu.remove     Resetting number in all childNodes. childNodes.length: " + childNodes.length);
	for ( var i = 0; i < childNodes.length; i++ )
	{
		var node = childNodes[i];
		////console.log("StageMenu.remove     //console.dir(childNodes[" + i + "]):" + node);
		////console.dir(node);

		// GET WIDGET
		////console.log("StageMenu.remove     Getting widget.");
		var widget = dijit.byNode(node.firstChild);
		//var widget = node.parentWidget;
		////console.log("StageMenu.remove     childNodes[" + i + "].widget: " + widget);			
		if ( widget == null )
		{
			widget = dijit.getEnclosingWidget(childNodes[i]);
		}
		////console.log("StageMenu.remove     Resetting stageRow number to: " + (i + 1));
		node.application.number = (i + 1).toString();
		node.application.appnumber = (i + 1).toString();

		widget.setNumber(node.application.number);

		console.log("StageMenu.remove     Reset widget childNodes[" + i + "].application.name " + node.application.name + ", node.application.number: " + node.application.number);
	}

	console.log("StageMenu.remove    this.parentWidget: " + this.parentWidget);
	
	// DO INFOPANE
	if ( childNodes.length )
	{
		this.parentWidget.loadParametersPane(childNodes[0]);
	}
	else
	{
		this.parentWidget.clearParameters();
	}
	
	// CALL Stages TO CHECK VALID STAGES		
	this.parentWidget.updateRunButton();
	
	// UPDATE RUN STATUS
	console.log("StageMenu.remove    Doing this.core.userWorkflows.checkRunStatus()");
	this.core.runStatus.polling = false;
	this.core.userWorkflows.checkRunStatus();
	
},	//	remove
run : function () {
// RUN STAGE
	console.log("StageMenu.run     plugins.workflow.StageMenu.run()");
	var node = this.menu.currentTarget;
	var widget = dijit.getEnclosingWidget(node);
	var application = widget.getApplication();
	////console.log("StageMenu.run     application: " + dojo.toJson(application));
	if ( application == null )
	{
		////console.log("StageMenu.run     application == null");
		var widget = node.parentWidget;
		////console.log("StageMenu.run     widget: " + widget);
		application = widget.getApplication();
	}
	////console.log("StageMenu.run     application: " + dojo.toJson(application));

	// START RUN
	var runner = this.core.runStatus.createRunner(application.number, application.number);
	this.core.runStatus.runWorkflow(runner);
},
stop : function () {
// STOP STAGE
	console.log("StageMenu.stop     plugins.workflow.StageMenu.stop()");
	var node = this.menu.currentTarget;
	var widget = dijit.getEnclosingWidget(node);
	var application = widget.getApplication();
	console.log("StageMenu.stop     application: " + dojo.toJson(application));
	if ( application == null )
	{
		////console.log("StageMenu.stop     application == null");
		var widget = node.parentWidget;
		////console.log("StageMenu.stop     widget: " + widget);
		application = widget.getApplication();
	}
	console.log("StageMenu.stop    application: " + dojo.toJson(application));

	// START RUN
	var runner = this.core.runStatus.createRunner(application.number, application.number);
	this.core.runStatus.confirmStopWorkflow();
},
runAll : function () {
// ADD PROGRAMMATIC CONTEXT MENU
	console.log("StageMenu.runAll     plugins.workflow.StageMenu.runAll()");
	var node = this.menu.currentTarget;
	var widget = dijit.getEnclosingWidget(node);
	var application = widget.getApplication();
	if ( application == null )
	{
		var widget = node.parentWidget;
		application = widget.getApplication();
	}
	////console.log("StageMenu.runAll     application: " + dojo.toJson(application));

	// START run
	var runner = this.core.runStatus.createRunner(application.number);
	this.core.runStatus.runWorkflow(runner);
},
chain : function () {
// CHAIN THE INPUTS AND OUTPUTS OF THIS STAGE TO THE PARAMETER VALUES
// OF THE PRECEDING STAGE
	////console.log("StageMenu.chain     plugins.workflow.StageMenu.chain()");

	// REM: WE ARE NOT INTERESTED IN event.target 
	// BECAUSE ITS THE CLICKED MENU NODE. WE WANT
	// THE NODE UNDERNEATH
	var node = this.menu.currentTarget;
	var widget = dijit.getEnclosingWidget(node);
	var application = widget.getApplication();
	////console.log("StageMenu.chain     application: " + dojo.toJson(application));

	// PREPARE STAGE OBJECT
	var stageObject = {
		project: this.parentWidget.projectCombo.getValue(),
		workflow: this.parentWidget.workflowCombo.getValue(),
		owner: application.owner,
		appname: application.name,
		appnumber: application.number,
		name: application.name,
		number: application.number
	};
	////console.log("StageMenu.chain     stageObject: " + dojo.toJson(stageObject));

	// CHANGE THE STAGE PARAMETERS FOR THIS APPLICATION
	// IF THE args FIELD IS NOT NULL (ALSO params AND paramFunction)
	console.log("StageMenu.chain     DOING this.parentWidget.core.io.chainstage()");
	console.log("StageMenu.chain     this.parentWidget.core.io: " + this.parentWidget.core.io);
	var force = true;
	this.core.io.chainStage(stageObject, force);
	
	// SET INFO PANE FOR DROPPED NODE
	var actualNode = widget.domNode.parentNode;
	this.core.userWorkflows.loadParametersPane(actualNode);
},
refresh : function () {
// REFRESH VALIDATION OF STAGE PARAMETERS
	console.log("StageMenu.refresh     plugins.workflow.StageMenu.refresh()");
	var node = this.menu.currentTarget;
	console.dir({node:node});
	console.log("StageMenu.refresh     plugins.workflow.StageMenu.refresh()");
	var widget = dijit.getEnclosingWidget(node);
	var application = widget.getApplication();
	var username = Agua.cookie('username');
	var shared = false;
	if ( application.username != username )
		shared = true;
	var force = true;
	this.core.parameters.load(node, shared, force);
}
	

}); // plugins.workflow.StageMenu


}

if(!dojo._hasResource["plugins.workflow.Workflows"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.workflow.Workflows"] = true;
dojo.provide("plugins.workflow.Workflows");

/* 
	USE CASE SCENARIO 1: INPUT VALIDITY CHECKING WHEN USER LOADS NEW WORKFLOW 

	1. updateDropTarget: load stages

	2. updateDropTarget: CALL -> first stage)

		   load multiple ParameterRows, each checks isValid (async xhr request for each file)
			   CALL -> Agua.setParameterValidity(boolean) to set stageParameter.isValid
	
	3. updateDropTarget: (concurrently with 2.) CALL -> updateRunButton()

		   check isValid for each StageRow:

				CALL-> checkValidParameters (async batch xhr request for multiple files)

				   CALL -> Agua.getParameterValidity(), and if empty check input and then

						CALL -> Agua.setParameterValidity(boolean) to set stageParameter.isValid


	USE CASE SCENARIO 2: USER CREATES NEW WORKFLOW BY TYPING IN WORKFLOW COMBO
	
	Workflows.setWorkflowListeners:
	
	this.workflowCombo._onKey LISTENER FIRES
		
		--> Agua.isWorkflow (returns TRUE/FALSE)

			FALSE 	--> Agua.addWorkflow
						
						--> Agua.getMaxWorkflowNumber
						--> Agua._addWorkflow

					-->  Workflows.setWorkflowCombo
		

	USE CASE SCENARIO 3: USER CLICKS 'Copy Workflow' BUTTON
	
	copyWorkflow
	
		-->	Agua.isWorkflow (returns TRUE/FALSE)
		
			TRUE 	-->	Message to dialogWidget and quit
		
			FALSE	-->	Message to dialogWidget and copy
			
				--> Workflows._copyWorkflow

					-->	Agua.copyWorkflow (returns TRUE/FALSE)
					
						TRUE	--> Workflows.setProjectCombo with new workflow

*/

// REQUIRE MODULES
if ( 1 ) {
// // optimize: load dijit layer






// WIDGETS AND TOOLS FOR EXPANDO PANE












	
// DnD
 // Source & Target




// TIMER


// TOOLTIP


// TOOLTIP DIALOGUE




// STANDBY


// WIDGETS IN TEMPLATE



// INHERITS


// HAS A







// INPUT DIALOG



}

dojo.declare("plugins.workflow.Workflows",
	[ dijit._Widget, dijit._Templated, plugins.core.Common ], {

//Path to the template of this widget. 
templatePath: null,

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

// addingApp STATE
addingApp : false,

// OR USE @import IN HTML TEMPLATE
cssFiles : [ dojo.moduleUrl("plugins", "workflow/css/workflows.css") ],

// PARENT WIDGET
parentWidget : null,

// TAB CONTAINER
attachNode : null,

// CONTEXT MENU
contextMenu : null,

// CORE WORKFLOW OBJECTS
core : null,

// PREVENT DOUBLE CALL ON LOAD
workflowLoaded : null,
dropTargetLoaded : null,

// FINISHED LOADING COMBOBOXES, ETC.
ready: false,

// ARRAY OF STAGE ROWS
stageRows : null,

// workflowType : string
// E.g., 'userWorkflows', 'sharedWorkflows'
workflowType : null,

/////}}}}
constructor : function (args) {
	console.log("Workflows.constructor     plugins.workflow.Workflows.constructor");			

	// GET ARGS
	this.core 						= args.core;
	this.core[this.workflowType]	= this;
	this.parentWidget 				= args.parentWidget;
	this.attachNode 				= args.attachNode;
	console.log("Workflows.constructor     core.userWorkflows: " + this.core.userWorkflows);			
	console.log("Workflows.constructor     core.sharedWorkflows: " + this.core.sharedWorkflows);			



	// LOAD CSS
	this.loadCSS();		
},
postCreate : function () {

	// PRE STARTUP
	if ( this.preStartup )	this.preStartup();
	
	this.startup();

	// POST STARTUP
	if ( this.postStartup )	this.postStartup();
},
startup : function () {
	console.log("Workflows.startup    plugins.workflow.Workflows.startup()");
	console.group("Workflows-" + this.id + "    startup");

	//console.log("Workflows.startup    Setting this.ready = false");
	this.ready = false;

	// COMPLETE CONSTRUCTION OF OBJECT
	this.inherited(arguments);	 

	// ADD TO TAB CONTAINER		
	this.attachNode.addChild(this.mainTab);
	this.attachNode.selectChild(this.mainTab);

	// SET INPUT/OUTPUT CHAINER
	this.setWorkflowIO();
	
	// SET SELECTIVE DIALOG FOR copyWorkflow	
	this.setSelectiveDialog();
	
	// SET INTERACTIVE DIALOG FOR copyProject
	this.setInteractiveDialog();
		
	// CREATE SOURCE MENU
	this.setContextMenu();

	// CREATE DROP TARGET
	this.setDropTarget();

	// START CASCADE OF COMBO LOADING:
	// PROJECT COMBO, WORKFLOW COMBO, DROP TARGET
	this.setProjectCombo();
	
	// SET ONCLICK FOR PROJECT AND WORKFLOW BUTTONS
	this.setComboButtons();

	// SET LISTENERS
	this.setProjectListeners();
	this.setWorkflowListeners();

	// SUBSCRIBE TO UPDATES
	Agua.updater.subscribe(this, "updateProjects");

	// SUBSCRIBE TO UPDATES
	Agua.updater.subscribe(this, "updateWorkflows");

	// SUBSCRIBE TO UPDATES
	Agua.updater.subscribe(this, "updateClusters");

	console.log("Workflows.startup    END");
	console.groupEnd("Workflows-" + this.id + "    startup");
},
updateProjects : function (args) {
// RELOAD RELEVANT DISPLAYS
	console.warn("workflow.Workflows.updateProjects    args:");
	console.dir({args:args});

	this.setProjectCombo();
},
updateWorkflows : function (args) {
// RELOAD RELEVANT DISPLAYS
	console.warn("workflow.Workflows.updateWorkflows    args:");
	console.dir({args:args});

	this.setProjectCombo();
},
updateClusters : function (args) {
// RELOAD RELEVANT DISPLAYS
	console.warn("admin.Clusters.updateClusters    args:");
	console.dir({args:args});

	this.setClusterCombo();
},
setContextMenu : function () {
// GENERATE CONTEXT MENU

	////console.log("Workflows.setContextMenu     plugins.workflow.Workflows.setContextMenu()");
	this.contextMenu = new plugins.workflow.StageMenu(
		{
			parentWidget: this,
			core: this.core
		}
	);
},
/////////////////// 	 DROP TARGET METHODS
setDroppingApp : function (value) {
// SET this.droppingApp

	////console.log("Workflows.setDroppingApp     plugins.workflow.Workflows.setDroppingApp(" + value + ")");	
	this.droppingApp = value; 
},
setDropTarget : function () {
// CREATE DROP TARGET
	this.dropTarget = new plugins.dnd.Target(
		this.dropTargetContainer,
		{
			accept: ["draggableItem"],
			contextMenu : this.contextMenu,
			parentWidget : this,
			core: this.core
		}
	);

	if ( this.dropTarget == null ) {
		console.log("Workflows._setDropTargetNodes    this.dropTarget is null. Returning");
		return;
	}
},
updateDropTarget : function (project, workflow) {
// SET DND DROP TARGET AND ITS CONTEXT MENU.
// ADD application OBJECT TO EACH NODE, CONTAINING
// THE STAGE INFORMATION INCLUDING number
	//console.group("Workflows-" + this.id + "    updateDropTarget");
	//console.log("Workflows.updateDropTarget    project: " + project);
	//console.log("Workflows.updateDropTarget    workflow: " + workflow);
	//console.log("Workflows.updateDropTarget    caller: " + this.updateDropTarget.caller.nom);
	//console.log("Workflows.updateDropTarget   this.ready: " + this.ready);
	
	// CREATE DROP TARGET
	if ( this.dropTarget == null )
	{
		this.dropTarget = new plugins.dnd.Target( this.dropTargetContainer,
			{
				accept: ["draggableItem"],
				contextMenu : this.contextMenu,
				parentWidget : this,
				core: this.core
			}
		);
	}
	if ( this.dropTarget == null ) {
		console.log("Workflows._updateDropTargetNodes    this.dropTarget is null. Returning");
		return;
	}

	// GET STAGES FOR THIS WORKFLOW
	var stages = Agua.getStagesByWorkflow(project, workflow);
	if ( stages == null )	stages = [];
	//console.log("Workflows.updateDropTarget    stages: ");
	//console.dir({stages:stages});

	this._updateDropTarget(stages);

	//console.groupEnd("Workflows-" + this.id + "    updateDropTarget");	
},
_updateDropTarget : function (stages) {
	console.group("Workflows-" + this.id + "    _updateDropTarget");
	console.log("Workflows._updateDropTarget    stages.length: " + stages.length);
	
	var allNodes = this._updateDropTargetNodes(stages);
	this._updateDropTargetStageRows(stages, allNodes);	
	
	// IF SHARED AND STAGES PRESENT, JUST LOAD THE PARAMETERS PANE
	if ( allNodes.length != 0 && this.shared ) {
		
		console.log("Workflows._updateDropTarget    Shared. Doing this.loadParametersPane(node_0)");
		this.loadParametersPane(allNodes[0]);

		// SET READY TO TRUE
		var thisObject = this;		
		setTimeout(
			function() {
				console.log("Workflows._updateDropTarget    setTimeout; SET this.ready TO TRUE");
				thisObject.ready = true;
			},
			1000
		);
	}

	// IF NOT SHARED AND STAGES PRESENT, SET THE PARAMETERS FOR THE 
	// FIRST STAGE AND CHECK VALIDITY OF PARAMETERS FOR REMAINING STAGES
	else if ( allNodes.length != 0 && ! this.shared )	this.checkStages(allNodes);

	// OTHERWISE, JUST HIDE STANDBY
	else {
		// HIDE LOADING STANDBY
		if ( this.standby )
			this.standby.hide();
		
		// UPDATE RUNBUTTON 
		console.log("Workflows._updateDropTarget    Doing this.updateRunButton()");
		this.updateRunButton();
	}

	////console.log("Workflows._updateDropTarget    END");
	console.groupEnd("Workflows-" + this.id + "    _updateDropTarget");
	
}, // end of Stages._updateDropTarget
_clearTarget : function () {
	while ( this.dropTargetContainer.firstChild ) {
		this.dropTargetContainer.removeChild(this.dropTargetContainer.firstChild);
	}	

	//if ( this.appSources == null || this.appSources.length == 0 )	return;
	//
	//for ( var i = 0; i < this.appSources.length; i++ )
	//{
	//	//console.log("Apps.clearAppSources     Destroying this.appSources[" + i + "]: " + this.appSources[i]);
	//	this.appSources[i].clearDragSource();
	//	this.appSourcesContainer.removeChild(this.appSources[i].domNode);
	//	this.appSources[i].destroy();
	//}

},
_updateDropTargetNodes : function(stages) {
	
	// EMPTY dropTargetContainer
	this._clearTarget();
	
	// SORT STAGES
	stages = this.sortNumericHasharray(stages, "number");

	// GENERATE APPLICATIONS ARRAY FOR DRAG AND DROP
	// FROM WORKFLOW APPLICATIONS LIST
	var dataArray = new Array;
	for ( var i = 0; i < stages.length; i++ )
	{
		var hash = new Object;
		hash.data = stages[i].name;
		hash.type = [ "draggableItem" ];
		dataArray.push(hash);
	}
	////console.log("Workflows._updateDropTargetNodes     dataArray: " + dojo.toJson(dataArray));

	// INSERT DATA INTO DROP TARGET
	console.log("Workflows._updateDropTargetNodes     Inserting dataArray: ");
	console.dir({dataArray:dataArray});
	console.log("Workflows._updateDropTargetNodes    this.dropTarget: " + this.dropTarget);
	this.dropTarget.insertNodes(false, dataArray);

	// SET NODE CHARACTERISTICS - ONCLICK, CLASS, ETC.
	console.log("Workflows._updateDropTargetNodes    this.dropTarget: " + this.dropTarget);
	allNodes = this.dropTarget.getAllNodes();
	if ( ! allNodes )	allNodes = [];

	//console.log("Workflows._updateDropTarget     Workflow.allNodes.length: " + allNodes.length);
	dojo.forEach(allNodes, function (node, i) {
		////console.log("Workflows._updateDropTarget     Doing node for stages[" + i + "]: " + dojo.toJson(stages[i]));
		var nodeClass = dataArray[i].type;
	});
	
	return allNodes;
},
_updateDropTargetStageRows : function (stages, allNodes) {
	// SET this.stageRows
	this.stageRows = new Array;
	
	var thisObject = this;
	console.log("Workflows._updateDropTargetStageRows     Workflow.allNodes.length: " + allNodes.length);
	dojo.forEach(allNodes, function (node, i)
	{
		console.log("Workflows._updateDropTargetStageRows     Doing node for stages[" + i + "]: ");
		console.dir({stage:stages[i]});

		// GET APP NAME
		var applicationName = node.innerHTML;
		
		// ADD infoId TO NODE
		node.setAttribute('infoId', thisObject.infoId);

		// ADD application TO NODE
		node.application = stages[i];
		console.log("Workflows._updateDropTargetStageRows     stages[" + i + "]: ");
		console.dir({stage:stages[i]});
		
		// DON'T SHOW DESCRIPTION ONCLICK FOR NOW
		// BECAUSE WE ALREADY HAVE AN ONCLICK
		// LISTENER FOR REFRESHING THE INFOPANE
		node.application.description = '';

		// NO DESCRIPTION OR NOTES FOR NOW IN STAGE
		stages[i].description = '';
		stages[i].notes = '';

		// CAN'T SET CLUSTER FOR STAGE YET
		if ( stages[i]["cluster"] == null )	stages[i]["cluster"] = '';
			
		// INSTANTIATE ROW 
		console.log("Workflows._updateDropTargetStageRows    stages[i]: ");
		console.dir({stage:stages[i]});
		
		var stageRow = new plugins.workflow.StageRow(stages[i]);
		stageRow.core = thisObject.core;
		stageRow.parentWidget = thisObject;

		// PUSH TO this.stageRows
		thisObject.stageRows.push(stageRow);

		// CLEAR NODE CONTENT
		node.innerHTML = '';

		// APPEND TO NODE
		node.appendChild(stageRow.domNode);

		// SET stageRow AS node.parentWidget FOR LATER RESETTING OF
		// number ON REMOVAL OR INSERTION OF NODES
		//
		// REM: remove ONCLICK BUBBLES ON stageRow.name NODE RATHER THAN ON node. 
		// I.E., CONTRARY TO DESIRED, this.name IS THE TARGET INSTEAD OF THE node.
		//
		// ALSO ADDED this.name.parentWidget = this IN StageRow.startup()
		node.parentWidget = stageRow;

		// ADD CONTEXT MENU TO NODE
		thisObject.contextMenu.bind(node);

		// SHOW APPLICATION INFO WHEN CLICKED
		dojo.connect(node, "onclick",  dojo.hitch(thisObject, function(event)
			{
				console.log("Workflows._updateDropTargetStageRows    ONCLICK call to this.loadParametersPane()");
				console.log("Workflows._updateDropTargetStageRows    thisObject.ready: " + thisObject.ready);
				event.stopPropagation();
				
				if ( ! thisObject.ready ) {
					console.log("Workflows._updateDropTargetStageRows    QUTTING because thisObject.ready: " + thisObject.ready);
					return;
				}
				
				this.loadParametersPane(node);
			}
		));

	});	// END OF allNodes
	
},
checkStages : function (allNodes) {
/* CHECK STAGES AND SET INFOPANE IF STAGES ARE PRESENT IN WORKFLOW:
 	 
 	 1. SET THE INFOPANE FOR THE FIRST STAGE:
			- CHECK VALIDITY OF PARAMETERS
			- CHANGE PARAMETER NODE STYLES ACCORDINGLY
	 2. CHECK VALIDITY OF PARAMETERS FOR REMAINING STAGES

	 FIRST STAGE:
	 Workflow.loadParametersPane
	     --> CALLS Parameters.load
	         --> CALLS StageRow.checkValidParameters
	 CARRIED OUT SYNCHRONOUSLY (I.E., WAITS TIL DONE)
	
	 OTHER STAGES:
			--> CALL StageRow.checkValidParameters
*/

	console.group("Workflows-" + this.id + "    checkStages");
	console.log("Workflows.checkStages    caller: " + this.checkStages.caller.nom);

	var standby = this.getStandby();
	standby.show();

	var thisObject = this;
	setTimeout(function () {
		//console.group("Workflows-" + thisObject.id + "    checkStages (inside setTimeout)");
		// VALIDATE PARAMETERS FOR FIRST STAGE
		thisObject.loadParametersPane(allNodes[0]);
		
		// FOR THE REMAINING STAGES, DO THE QUERY FOR ALL FILES AT ONCE
		var stageFiles = new Array;
		stageFiles[0] = [];
		if ( allNodes.length >= 1 )
		{
			var filesPresent = 0;
			for ( var i = 1; i < allNodes.length; i++ )
			{
				var stageRow = allNodes[i].parentWidget;
				console.log("Workflows.checkStages    stageRows[" + i + "]: " + stageRow);

				// NB: DON'T FORCE IN CASE STAGE PARAMETER INFORMATION 
				// HAS ALREADY BEEN GENERATED EARLIER IN THIS SESSION
				var force = false;
				stageRow.checkAllParameters(force);
				var files = stageRow.fileStageParameters;
				console.log("Workflows.checkStages    files: ");
				console.dir({files:files});
				if ( ! files )	files = [];
				if ( files != [] && files.length > 0 ) {
					console.log("Workflows.checkStages    Setting filesPresent to 1");
					filesPresent = 1;
				}
				stageFiles[i] = files;
			}
			
			console.log("Workflows.checkStages    No. stageFiles to be checked: " + stageFiles.length);
			console.dir({stageFiles:stageFiles});
			if ( filesPresent == 1 )
				thisObject.checkStageFiles(stageFiles);
			
			console.log("Workflows.checkStages    DOING this.standby.hide()");
			thisObject.standby.hide();
			
			// SET READY TO TRUE
			thisObject.ready = true;
			console.log("Workflows.checkStages    SET this.ready TO TRUE");
		}

		// UPDATE RUNBUTTON 
		console.log("Workflows.checkStages    Doing this.updateRunButton()");
		thisObject.updateRunButton();

		thisObject.ready = true;
		console.log("Workflows.checkStages    SET this.ready: " + thisObject.ready);		
		console.groupEnd("Workflows-" + thisObject.id + "    checkStages (inside setTimeout)");

	}, 100);	
},
checkStageFiles : function (stageFiles) {
	console.group("Workflows-" + this.id + "    checkStageFiles");
	console.dir({stageFiles:stageFiles});
	
	// GET FILEINFO FROM REMOTE FILE SYSTEM
	var url = Agua.cgiUrl + "workflow.cgi";
	var query = new Object;
	query.username = Agua.cookie('username');
	query.sessionid = Agua.cookie('sessionid');
	query.project = this.getProject();
	query.workflow = this.getWorkflow();
	query.mode = "checkStageFiles";
	query.stagefiles = stageFiles;

	// SEND TO SERVER
	var thisObject = this;
	dojo.xhrPut({
		url: url,
		contentType: "text",
		sync : false,
		handleAs: "json",
		putData: dojo.toJson(query),
		//timeout: 20000,
		handle : function(stageFileInfos, ioArgs) {
			if ( stageFileInfos.error ) {
				Agua.toastError(stageFileInfos.error);
			}
			else {
				console.log("Workflows.checkStageFiles    Returned stageFileInfos:");
				console.dir({stageFileInfos:stageFileInfos});
				
				thisObject.validateStageFiles(stageFileInfos, stageFiles);
				console.groupEnd("Workflows-" + this.id + "    checkStageFiles");
			}				

			// HIDE LOADING STANDBY
			thisObject.standby.hide();

			// CHECK RUN STATUS		
			console.log("StagescheckStageFiles    BEFORE Do checkRunStatus()");
			if ( thisObject.core.parameters != null 
				&& thisObject.core.parameters.isCurrentApplication(thisObject.application) ) {
				console.log("StagescheckStageFiles    Doing checkRunStatus()");
				thisObject.checkRunStatus();
			}
		}
	});	
},
validateStageFiles : function (stageFileInfos, stageFiles) {
	console.group("Workflows-" + this.id + "    validateStageFiles")
	console.dir({stageFileInfos:stageFileInfos});
	
	// SET NODE CHARACTERISTICS - ONCLICK, CLASS, ETC.
	console.log("Workflows.validateStageFiles    this.dropTarget: " + this.dropTarget);
	var allNodes = this.dropTarget.getAllNodes();
	for ( var i = 1; i < allNodes.length; i++ )
	{
		var stageRow = allNodes[i].parentWidget;
		var files = stageFiles[i];
		var infofiles = stageFileInfos[i];

		console.log("Workflows.validateStageFiles    files: ");
		console.dir({files:files});
		console.log("Workflows.validateStageFiles    infofiles: ");
		console.dir({infofiles:infofiles});

		if ( ! files )	return;
	
		if ( files != null && files.length )
			stageRow.validateFiles(stageFileInfos[i]);
	}

	console.groupEnd("Workflows-" + this.id + "    validateStageFiles")
},
checkRunStatus : function() {
	console.log("Workflows.checkRunStatus    plugins.workflow.Workflows.checkRunStatus");
	
	// DEBUG:
	if ( this.core.runStatus == null )	return;

	// CHECK IF STAGES ARE RUNNING
	console.log("Parameters.load     BEFORE this.indexOfRunningStage()");
	var indexOfRunningStage = this.indexOfRunningStage();
	console.log("Parameters.load     indexOfRunningStage: " + indexOfRunningStage);
	var runner = this.core.runStatus.createRunner(indexOfRunningStage);	
	var singleton = true;
	
	console.log("Parameters.load     DOING runStatus.getStatus");
	this.core.runStatus.getStatus(runner, singleton);
},
getStandby : function () {
	console.log("Workflows.getStandby    this.standby");
	if ( this.standby ) return this.standby;
		
	console.log("Workflows.getStandby    Creating this.standby");
	var id = dijit.getUniqueId("dojox_widget_Standby");
	this.standby = new dojox.widget.Standby (
		{
			target: this.dropTargetContainer,
			onClick: "reload",
			text: "Checking stage inputs",
			id : id,
			url: "plugins/core/images/agua-biwave-24.png"
		}
	);
	document.body.appendChild(this.standby.domNode);

	return this.standby;
},
resetNumbers : function () {
	//console.log("Workflows.resetNumbers    plugins.workflow.Workflows.resetNumbers()");

	//console.log("Workflows.resetNumbers    this.dropTarget: " + this.dropTarget);
	var childNodes = this.dropTarget.getAllNodes();
	//console.log("Workflows.resetNumbers     Resetting number in all childNodes. childNodes.length: " + childNodes.length);
	
	// RESETTING number IN ALL CHILDNODES
	for ( var i = 0; i < childNodes.length; i++ )
	{
		var node = childNodes[i];
		//console.log("Workflows.resetNumbers     //console.dir(childNodes[" + i + "]):");
		//console.dir({node: node});

		// GET WIDGET
		//console.log("Workflows.resetNumbers     Getting widget.");
		var widget = dijit.byNode(node.firstChild);
		//var widget = node.parentWidget;
		//console.log("Workflows.resetNumbers     childNodes[" + i + "].widget: " + widget);			
		if ( widget == null )
		{
			widget = dijit.getEnclosingWidget(childNodes[i]);
		}
		//console.log("Workflows.resetNumbers     Resetting stageRow number to: " + (i + 1));
		node.application.number = (i + 1).toString();
		node.application.appnumber = (i + 1).toString();

		// SET DISPLAYED NUMBER
		//console.log("Workflows.resetNumbers     Doing widget.setNumber(node.application.number)");
		widget.setNumber(node.application.number);
		//console.log("Workflows.resetNumbers     New widget.numberNode.innerHTML: " + widget.numberNode.innerHTML);

		//console.log("Workflows.resetNumbers     Reset widget childNodes[" + i + "].application.name " + node.application.name + ", node.application.number: " + node.application.number);
	}
},
////////////////// 		CLUSTER METHODS
getCluster : function () {
	////console.log("Workflows.getCluster     plugins.workflow.Cluster.getCluster()");
	
	if ( this.clusterCombo == null )	return '';

	return this.clusterCombo.get('value');
},
setClusterCombo : function () {
// POPULATE THE WORKFLOW COMBO BASED ON SELECT VALUE IN PROJECT COMBO
	////console.log("Workflows.setClusterCombo     plugins.workflow.Cluster.setClusterCombo()");

	// AVOID SELF-TRIGGERING OF onChange EVENT WHEN CHANGED PROGRAMMATICALLY
	this.settingCluster = true;

	// QUIT IF SHARED
	if ( this.shared == true )	return;
	
	////console.log("Workflows.setClusterCombo    plugins.workflowCluster.setClusterCombo()");
	var projectName = this.getProject();
	var workflowName = this.getWorkflow();
	////console.log("Workflows.setClusterCombo    projectName: " + projectName);
	////console.log("Workflows.setClusterCombo    workflowName: " + workflowName);

	var clusters = Agua.getClusters();
	////console.log("Workflows.setClusterCombo    clusters: " + dojo.toJson(clusters, true));
    var clusterName = Agua.getClusterByWorkflow(projectName, workflowName);
	if ( clusterName == null )	clusterName = '';
	var regex = Agua.cookie('username') + "-";
	clusterName = clusterName.replace(regex, '');
	////console.log("Workflows.setClusterCombo    clusterName: " + clusterName);
	
	var clusterNames = this.hashArrayKeyToArray(clusters, "cluster");
	clusterNames.splice(0,0, '');
	////console.log("Workflows.setClusterCombo    clusterNames: " + dojo.toJson(clusterNames));

	// REMOVE USERNAME FROM BEGINNING OF CLUSTER NAME
	for ( var i = 0; i < clusterNames.length; i++ )
	{
		clusterNames[i] = clusterNames[i].replace(regex, '');
	}
	clusterNames = clusterNames.sort();
	////console.log("Workflows.setClusterCombo    SORTED clusterNames: " + dojo.toJson(clusterNames));

	// DO data FOR store
	var data = {identifier: "name", items: []};
	for ( var i in clusterNames )
	{
		data.items[i] = { name: clusterNames[i]	};
	}
	////console.log("Workflows.setClusterCombo    data: " + dojo.toJson(data));

	// CREATE store
	var store = new dojo.data.ItemFileReadStore( { data: data } );

	this.clusterCombo.store = store;
	this.clusterCombo.startup();
	this.clusterCombo.set('value', clusterName);			
	
	var longClusterName = clusterName;
	var username = Agua.cookie('username');
	if ( clusterName )	longClusterName = username + "-" + clusterName;

	this.setClusterNodes(longClusterName);
},
checkClusterNodes : function (event) {
	////console.log("Workflows.checkClusterNodes    plugins.core.Common.checkClusterNodes(event)");
	////console.log("Workflows.checkClusterNodes    event.keyCode: " + event.keyCode);
	//var key = event.charOrCode;
	////console.log("Workflows.checkClusterNodes    key: " + key);

	if (event.keyCode == dojo.keys.ENTER)
	{
		////console.log("Workflows.checkClusterNodes    setting document.body.focus()");
		document.body.focus();
		this.checkNodeNumbers();
		this.updateClusterNodes();
		dojo.stopEvent(event);
	}
},
setClusterNodes : function (clusterName) {
//	RETRIEVE MIN/MAX NODES FOR THE CLUSTER
	console.log("Workflows.setClusterNodes    clusterName: " + clusterName);
	if ( clusterName == null || ! clusterName )
	{
		this.minNodes.set('value', 0);	
		this.maxNodes.set('value', 0);	
		return;
	}
	
	var clusters = Agua.getClusters();
	console.log("Workflows.setClusterNodes    clusters: ");
	console.dir({clusters:clusters});
	clusters = this.filterByKeyValues(clusters, ["cluster"], [clusterName]);
	if ( clusters == null )	return;
	
	if ( clusters[0] != null
		&& clusters[0].minnodes != null
		&& clusters[0].maxnodes != null )
	{
		var minNodes = clusters[0].minnodes;
		var maxNodes = clusters[0].maxnodes;
		console.log("Workflows.setClusterNodes    minNodes: " + minNodes);
		console.log("Workflows.setClusterNodes    maxNodes: " + maxNodes);
		this.minNodes.set('value', minNodes);	
		this.maxNodes.set('value', maxNodes);	
	}
},
checkNodeNumbers : function () {
// SET MIN NODES VALUE TO SENSIBLE NUMBER 
	////console.log("Workflows.checkNodeNumbers     this: " + this);
	////console.log("Workflows.checkNodeNumbers     this.minNodes.get('value'): " + this.minNodes.get('value'));
	////console.log("Workflows.checkNodeNumbers     this.maxNodes.get('value'): " + this.maxNodes.get('value'));
	
	if (this.minNodes.get('value') > this.maxNodes.get('value') )
	{
		////console.log("Workflows.checkNodeNumbers     this.minNodes.get('value') > this.maxNodes.get('value')");
		this.minNodes.set('value', this.maxNodes.get('value'));
	}
},
updateClusterNodes : function () {
	//console.log("Workflows.updateClusterNodes    this.ready: " + this.ready);
	if ( ! this.ready )	return;
	
	var cluster = this.getCluster();
	//console.log("Workflows.updateClusterNodes    cluster: " + cluster);
	
	if ( ! cluster )	return;

	var clusterName = Agua.getClusterLongName(cluster);
	
	if ( this.savingCluster == true )	return;
	this.savingCluster = true;

	var clusterName = Agua.getClusterLongName(cluster);
	var clusterObject = Agua.getClusterObject(clusterName);

	// GET MIN
	var minValue = this.minNodes.get('value');
	//console.log("Workflows.updateClusterNodes    minValue: " + minValue);
	if ( ! minValue )	{
		this.minNodes.set('value', clusterObject.minnodes);
		return;
	}
	else
		clusterObject.minnodes = minValue;	

	// GET MAX
	var maxValue = this.maxNodes.get('value');
	//console.log("Workflows.updateClusterNodes    maxValue: " + maxValue);
	if ( ! maxValue )	{
		this.maxNodes.set('value', clusterObject.maxnodes);
		return;
	}
	else
		clusterObject.maxnodes = maxValue;
		
	//console.log("Workflows.updateClusterNodes    clusterObject: ");
	//console.dir({clusterObject:clusterObject});

	Agua._removeCluster(clusterObject);
	Agua._addCluster(clusterObject);

	this.savingCluster = false;

	// SAVE ON REMOTE DATABASE
	var query = dojo.clone(clusterObject);
	query.username = Agua.cookie('username');	
	query.sessionid = Agua.cookie('sessionid');	
	var url = Agua.cgiUrl + "admin.cgi?";
	query.mode = "updateClusterNodes";
	//console.log("Workflows.updateClusterNodes    query: " + dojo.toJson(query));
	
	// SEND TO SERVER
	dojo.xhrPut(
		{
			url: url,
			contentType: "text",
			putData: dojo.toJson(query),
			handle: function(response, ioArgs) {
				//console.log("Workflows.updateClusterNodes    response: ");
				//console.dir({response:response});
				if ( response.error ) {
					Agua.toast(response);
				}
			}
		}
	);

	// RELOAD RELEVANT DISPLAYS
	Agua.updater.update("updateClusters");	

}, // Clusters.updateClusterNodes
saveClusterWorkflow : function (event) {
//	SAVE A PARAMETER TO Agua.parameters AND TO REMOTE DATABASE

	// AVOID SELF-TRIGGERING OF onChange EVENT WHEN CHANGED PROGRAMMATICALLY
	if ( this.savingCluster == true )	return;
	this.savingCluster = true;

	var cluster = this.getCluster();
	var clusterName = Agua.getClusterLongName(cluster);
	var project = this.getProject();
	var workflow = this.getWorkflow();
	
	if ( project == null || ! project )	return;
	if ( workflow == null || ! workflow )	return;
	
	var clusterObject = new Object;
	clusterObject.cluster = clusterName;
	clusterObject.project = project;
	clusterObject.workflow = workflow;
	////console.log("Workflows.saveClusterWorkflow    clusterObject: " + dojo.toJson(clusterObject));

	if ( Agua.isClusterWorkflow(clusterObject) )
	{
		this.savingCluster = false;
		return;
	}
	
	Agua._removeClusterWorkflow(clusterObject);
	if ( ! Agua._addClusterWorkflow(clusterObject) )
	{
		this.savingCluster = false;
		return;
	}
	
	this.savingCluster = false;

	// SAVE ON REMOTE DATABASE
	var query = dojo.clone(clusterObject);
	query.username = Agua.cookie('username');	
	query.sessionid = Agua.cookie('sessionid');	
	query.mode = "saveClusterWorkflow";
	var url = Agua.cgiUrl + "workflow.cgi?";
	console.log("Workflows.saveClusterWorkflow    query: " + dojo.toJson(query));
	
	// SEND TO SERVER
	Agua.doPut({
		query: query,
		url: url
	});
	
	var longClusterName = cluster;
	var username = Agua.cookie('username');	
	if ( cluster )	longClusterName = username + "-" + cluster;

	this.setClusterNodes(longClusterName);
	
}, 
/////////////////		INFOPANE METHODS         
clearParameters : function () {
// CLEAR INFO PANE
	////console.log("Workflows.clearParameters    plugins.workflow.Workflows.clearParameters()");

	if ( this.core.parameters == null )
	{
		////console.log("Workflows.clearParameters    this.core.parameters is null. Returning");
		return;
	}

	////console.log("Workflows.clearParameters    DOING this.core.parameters.clear()");
	this.core.parameters.clear();
},
loadParametersPane : function (node) {
// LOAD DATA INTO INFO PANE FROM THE APPLICATION ASSOCIATED WITH THIS NODE
// OVERLOAD THIS TO PASS ADDITIONAL ARGUMENTS TO Parameters.load()
	console.group("Workflows-" + this.id + "    loadParametersPane");
	console.log("Workflows.loadParametersPane    plugins.workflow.Workflows.loadParametersPane(node)");
	
	// WARN AND QUIT IF NO NODE PASSED, E.G., IF WORKFLOW HAS NO STAGES
	if ( node == null )
	{
		//console.log("Workflows.loadParametersPane     Passed node is null (no applications in dropTarget). Returning.");
		console.groupEnd("Workflows-" + this.id + "    loadParametersPane");
		return;
	}
	console.log("Workflows.loadParametersPane    node.application: ");
	console.dir({application:node.application});

	if ( this.core.parameters != null )
	{
		console.log("Workflows.loadParametersPane    Doing this.core.parameters.load(node)");
		this.core.parameters.load(node);
	}
	else
	{
		//console.log("Workflows.loadParametersPane    this.core.parameters is null. Skipping this.core.parameters.load()");
	}
	console.groupEnd("Workflows-" + this.id + "    loadParametersPane");
},
/////////////////		IO METHODS      
setWorkflowIO : function () {
// INITIATE this.core.io OBJECT

	////console.log("Workflows.setWorkflowIO    plugins.workflow.Workflows.setWorkflowIO()");
	if ( this.core.io == null )
	{
		this.core.io = new plugins.workflow.IO(
			{
				parentWidget: this,
				core: this.core
			}
		);
		////console.log("Workflows.setWorkflowIO    this.core.io: " + this.core.io);
	}
},
getChainedValues : function (node) {
// SET THE input, resource AND output PARAMETERS OF THIS STAGE USING
// ANY CORRESPONDING PARAMETERS IN THE PRECEDING STAGE

	//console.group("Workflows-" + this.id + "    getChainedValues");
	////console.log("Workflows.getChainedValues    plugins.workflow.Workflows.getChainedValues(node)");
	////console.log("Workflows.getChainedValues    node: " + node);
	////console.log("Workflows.getChainedValues    node.application: " + dojo.toJson(node.application));
	////console.log("Workflows.getChainedValues    this.core.io: " + this.core.io);

	// CHECK node.application AND node.application.number ARE DEFINED
	////console.log("Workflows.getChainedValues    application: " + dojo.toJson(node.application));
	// GET THE INDEX OF THIS APPLICATION
	if ( node.application == null )
	{
		////console.log("Workflows.getChainedValues    node.application is null. Returning.");
		//console.groupEnd("Workflows-" + this.id + "    getChainedValues");
		return;
	}

	// GET THE INDEX OF THIS APPLICATION
	if ( node.application.number == null )
	{
		this.quit("Workflows.getChainedValues    node.application.number is null. Returning.");
		//console.groupEnd("Workflows-" + this.id + "    getChainedValues");
		return;
	}

	// CHANGE THE STAGE PARAMETERS FOR THIS APPLICATION
	// IF THE args FIELD IS NOT NULL (ALSO params AND paramFunction)
	var force = true;
	this.core.io.chainStage(node.application, force);

	//console.groupEnd("Workflows-" + this.id + "    getChainedValues");
},
chainStages : function (force) {
// CHAIN THE INPUTS/OUTPUTS OF ALL APPLICATIONS IN THE WORKFLOW
// NB: NOT USED YET, JUST IN CASE

	console.log("Workflows.chainStages     plugins.workflow.Workflow.chainStages(force)");
	console.log("Workflows.chainStages     force: " + force);
	
	console.log("Workflows.chainStages    this.dropTarget: " + this.dropTarget);

	var nodes = this.dropTarget.getAllNodes();
	console.log("Workflows.chainStages     nodes.length: " + nodes.length);

	for ( var i = 0; i < nodes.length; i++ )
	{
		////console.log("Workflows.chainStages     nodes[i].application: " + nodes[i].application);
		this.core.io.chainInputs(nodes[i].application, force);
		
		// UPDATE VALID/INVALID CSS IN PARAMETERS PANE
		if ( this.core.parameters != null )
		{
			var keys = ["project", "workflow", "workflownumber", "name", "number"];
			if ( this._objectsMatchByKey(nodes[i].application,
				this.core.parameters.application, keys) )
				this.core.parameters.setParameterRowStyles();
		}
	} 
	
},
/////////////////		PROJECT METHODS      
getProject : function () {
	////console.log("Workflows.getProject     plugins.workflow.Workflow.getProject()");

	////console.log("Workflows.getProject     this: " + this);
	return this.projectCombo.get('value');
},
setProjectCombo : function (projectName, workflow) {
// POPULATE THE PROJECT COMBO AND THEN RELOAD THE WORKFLOW COMBO
	////console.log("Workflows.setProjectCombo    workflow.Workflows.setProjectCombo(projectName, workflow)");
	////console.log("Workflows.setProjectCombo    projectName: " + projectName);
	////console.log("Workflows.setProjectCombo    workflow: " + workflow);

	// TO AVOID GRATUITOUS EVENT BY onChange LISTENER
	this.settingProject = true;
	
	////console.log("Workflows.setProjectCombo    BEFORE this.inherited(arguments)");
	this.inherited(arguments);
	////console.log("Workflows.setProjectCombo    AFTER this.inherited(arguments)");
	
	if ( projectName == null )
	{
		projectName = this.projectCombo.getValue();
	}

	// RESET THE WORKFLOW COMBO
	////console.log("Workflows.setProjectCombo    END. Doing this.setWorkflowCombo(projectName, workflow)");
	this.setWorkflowCombo(projectName, workflow);
},
setProjectListeners : function () {
	//console.log("Workflows.setProjectListeners    plugins.workflow.Workflows.setProjectListeners()");
	
	// DOJO.CONNECT TO CHANGE THE workflowCombo
	var thisObject = this;
	dojo.connect(this.projectCombo, "onChange", dojo.hitch(this, function(event) {
		var project = event;
		console.log("Workflows.setProjectListeners    this.projectCombo onchange event. DOING this.setWorkflowCombo(" + project + ")");
		//console.log("Workflows.setProjectListeners    thisObject.ready: " + thisObject.ready);

		//if ( thisObject.ready == false) {
		//	console.log("Workflows.setProjectListeners    ONCHANGE fired. thisObject.ready is FALSE. Returning");
		//	//thisObject.settingProject = false;
		//	return;
		//}
		
		// CLEAR THE INFO PANE
		//console.log("Workflows.setProjectListeners    thisObject.clearParameters()");
		thisObject.clearParameters();

		// RESET THE RUNSTATUS PANE		
		//console.log("Workflows.setProjectListeners    thisObject.clearParameters()");
		thisObject.clearRunStatus();
		
		// SET WORKFLOW COMBO
		////console.log("Workflows.setProjectListeners    DOING thisObject.setWorkflowCombo(" + project + ")");
		thisObject.setWorkflowCombo(project);
		//event.stopPropagation();
	}));

	// SET NEW PROJECT LISTENER
	var thisObject = this;
	this.projectCombo._onKey = function(evt){
		////console.log("Workflows.setProjectListeners._onKey	dijit.form.ComboBox._onKey(/*Event*/ evt)");
		
		// summary: handles keyboard events
		var key = evt.charOrCode;
		////console.log("Workflows.setProjectListeners._onKey	key: " + key);
		
		if ( key == 13 )
		{
			//thisObject.projectCombo._hideResultList();
			
			var sourceProject = thisObject.projectCombo.getValue();
			sourceProject = sourceProject.replace(/\s+/g, '');
			thisObject.projectCombo.set('value', sourceProject);

			var projectObject = new Object;
			projectObject.name = sourceProject;
			////console.log("Workflows.setProjectListeners._onKey	   projectObject: " + dojo.toJson(projectObject));
			
			if ( Agua.isProject(sourceProject) == false )
			{
				// CLEAR THE INFO PANE
				thisObject.clearParameters();

				// ADD THE PROJECT
				////console.log("Workflows.setProjectListeners._onKey	   Doing Agua.addProject(projectObject)");
				Agua.addProject(projectObject);
				
				// RELOAD RELEVANT DISPLAYS
				Agua.updater.update("updateProjects");
			}

			if ( thisObject.projectCombo._popupWidget != null )
			{
				thisObject.projectCombo._showResultList();
			}
		}
	};

},
deleteProject : function (event) {
// DELETE A PROJECT AFTER ONCLICK deleteProject BUTTON
	////console.log("Workflows.deleteProject    plugins.workflow.Workflows.deleteProject(event)");
	
	// SET this.doingDelete OR EXIT IF BUSY
	if ( this.doingDelete == true )
	{
		////console.log("Workflows.deleteProject    this.doingDelete is true. Returning.");
		return;
	}
	this.doingDelete = true;

	if ( ! Agua.getStages() )
	{
		////console.log("Workflows.deleteProject    Agua.stages not defined. Returning.");
		return;
	}
	
	// GET DELETED PROJECT NAME OR QUIT IF EMPTY
	var project = this.projectCombo.getValue();
	////console.log("Workflows.deleteProject    project: " + project);
	if ( project == null || ! project )
	{
		////console.log("Workflows.deleteWorkflow    deleted project is null. Returning.");
		this.doingDelete = false;
		return;
	}

	// SET ARGS FOR CONFIRM DELETE
	var args = new Object;
	args.project = project;
	args.workflow = null;
	
	// DO CONFIRM DELETE
	this.confirmDelete(args);
	
	// UNSET this.doingDelete
	this.doingDelete = false;
},
/////////////////		WORKFLOW METHODS      
getWorkflow : function () {
	////console.log("Workflows.getWorkflow     plugins.workflow.Workflow.getWorkflow()");
	////console.log("Workflows.getWorkflow     this: " + this);
	return this.workflowCombo.get('value');
},
getWorkflowNumber : function () {
	////console.log("Workflows.getWorkflow     plugins.workflow.Workflow.getWorkflow()");
	var project = this.getProject();
	var workflow = this.getWorkflow();
	if ( project == null || workflow == null )
	{
		////console.log("Workflows.getWorkflow    project or workflow is null. Returning null");
		return;
	}

	return Agua.getWorkflowNumber(project, workflow);
},
setWorkflowCombo : function (projectName, workflowName) {
// POPULATE THE WORKFLOW COMBO BASED ON SELECT VALUE IN PROJECT COMBO
	//console.group("Workflows-" + this.id + "    setWorkflowCombo");
	//console.log("Workflows.setWorkflowCombo    caller: " + this.setWorkflowCombo.caller.nom);
	//console.log("Workflows.setWorkflowCombo    this.ready: " + this.ready);

	// POPULATE THE WORKFLOW COMBO AND SET FIRST VALUE TO
	// workflowName OR THE FIRST WORKFLOW IF workflowName NOT DEFINED
	this.inherited(arguments);

	// SET DROP TARGET (LOAD MIDDLE PANE, BOTTOM)
	if ( workflowName == null )
		workflowName = this.workflowCombo.getValue();
	
	////console.log("Workflows.setWorkflowCombo    DOING this.setClusterCombo(" + projectName + ", " + workflowName + ")");
	this.setClusterCombo(projectName, workflowName);

	////console.log("Workflows.setWorkflowCombo    DOING this.updateDropTarget(" + projectName + ", " + workflowName + ")");
	this.updateDropTarget(projectName, workflowName);

	//console.groupEnd("Workflows-" + this.id + "    setWorkflowCombo");
},
setWorkflowListeners : function () {
////console.log("Workflows.setWorkflowListeners    plugins.workflow.Workflows.setWorkflowListeners()");
	// DOJO.CONNECT TO POPULATE APPLICATIONS IN DROP TARGET
	// WHICH THEN POPULATES THE INFO PANE 

	var thisObject = this;
	dojo.connect(thisObject.workflowCombo, "onChange", dojo.hitch(this, function(event) {
		//console.log("Workflows.setWorkflowListeners    onchange event. Workflow is: " + event);
		//console.log("Workflows.setWorkflowListeners    this.ready: " + this.ready);
		var workflowName = event;
		var projectName = thisObject.getProject();

		if ( thisObject.ready == false) {
			//console.log("Workflows.setWorkflowListeners    ONCHANGE fired. thisObject.ready is FALSE. Returning");
			return;
		}

		// RESET THE RUNSTATUS PANE		
		thisObject.clearRunStatus();
		
		////console.log("Workflows.setWorkflowListeners    DOING this.setClusterCombo(" + projectName + ", " + workflowName + ")");
		thisObject.setClusterCombo(projectName, workflowName);

		////console.log("Workflows.setWorkflowListeners    connect onchange. Doing thisObject.updateDropTarget(" + projectName + ", " + workflowName + ")");		
		thisObject.updateDropTarget(projectName, workflowName);
	}));


	// SET NEW PROJECT LISTENER
	var thisObject = this;
	this.workflowCombo._onKey = function(evt){
		////console.log("Workflows.setWorkflowCombo._onKey	dijit.form.ComboBox._onKey(/*Event*/ evt)");
		
		// summary: handles keyboard events
		var key = evt.charOrCode;			
		////console.log("Workflows.setWorkflowCombo._onKey	key: " + key);
		if ( key == 13 )
		{
			//thisObject.workflowCombo._hideResultList();
			
			var projectName = thisObject.getProject();
			var workflowName = thisObject.getWorkflow();
			workflowName = workflowName.replace(/\s+/g, '');
			thisObject.workflowCombo.set('value', workflowName);
			////console.log("Workflows.setWorkflowCombo._onKey	   projectName: " + projectName);
			////console.log("Workflows.setWorkflowCombo._onKey	   workflowName: " + workflowName);
			
			// STOP PROPAGATION
			evt.stopPropagation();
			
			var isWorkflow = Agua.isWorkflow({ project: projectName, name: workflowName });
			if ( isWorkflow == false )
			{
				Agua.addWorkflow({ project: projectName, name: workflowName });
				////console.log("Workflows.setWorkflowCombo._onKey	isWorkflow is FALSE. Doing thisObject.setWorkflowCombo(projectName, workflowName)");
				thisObject.setWorkflowCombo(projectName, workflowName);
			}
				
			if ( thisObject.workflowCombo._popupWidget != null )
			{
				thisObject.workflowCombo._showResultList();
			}
		}
	};
},
newWorkflow : function (sourceProject, workflowName) {
// CREATE A NEW WORKFLOW ON TRIGGER this.workflowCombo._onKey ENTER

	////console.log("Common.newWorkflow    plugins.workflow.Common.addWorkflow(workflowObject)");
	////console.log("Common.newWorkflow    sourceProject: " + sourceProject);
	////console.log("Common.newWorkflow    workflowName: " + workflowName);

	if ( this.doingNewWorkflow == true )
	{
		////console.log("Common.newWorkflow    this.doingNewWorkflow is true. Returning.");
		return;
	}
	
	// SET this.doingNewWorkflow
	this.doingNewWorkflow = true;

	// SEND TO SERVER
	Agua.addWorkflow({ project: sourceProject, name: workflowName });
	
	// UNSET this.doingNewWorkflow
	this.doingNewWorkflow = false;

	// RESET THE WORKFLOW COMBO
	////console.log("Common.newWorkflow    Doing this.setWorkflowCombo(sourceProject, workflowName)");
	this.setWorkflowCombo(sourceProject, workflowName);

	// SEND TO SERVER
	Agua.addProjectWorkflow(sourceProject, workflowName);
},
setComboButtons : function () {
// SET ONLICK LISTENERS FOR PROJECT AND WORKFLOW DELETE BUTTONS
	
	// SET download BUTTON ONCLICK TO OPEN FILE MANAGER
	var thisObject = this;
	
	dojo.connect(this.deleteProjectButton, "onclick", function(event)
	{
		thisObject.deleteProject(event);
	});
	
	dojo.connect(this.deleteWorkflowButton, "onclick", function(event)
	{
		thisObject.deleteWorkflow(event);
	});
},
deleteWorkflow : function (event) {
// DELETE A WORKFLOW AFTER ONCLICK deleteWorkflow BUTTON

	////console.log("Workflows.deleteWorkflow    plugins.workflow.Workflows.deleteWorkflow(event)");

	// SET this.doingDelete OR EXIT IF BUSY
	if ( this.doingDelete == true )
	{
		////console.log("Workflows.deleteWorkflow    this.doingDelete is true. Returning.");
		return;
	}
	this.doingDelete = true;
	
	// GET DELETED PROJECT NAME OR QUIT IF EMPTY
	var project = this.projectCombo.getValue();
	if ( project == null || ! project )
	{
		////console.log("Workflows.deleteWorkflow    project is null. Returning.");
		this.doingDelete = false;
		return;
	}
	////console.log("Workflows.deleteWorkflow    project: " + project);
	
	// GET DELETED WORKFLOW NAME OR QUIT IF EMPTY
	var workflow = this.workflowCombo.getValue();
	if ( workflow == null || ! workflow )
	{
		////console.log("Workflows.deleteWorkflow    workflow is null. Returning.");
		this.doingDelete = false;
		return;
	}
	////console.log("Workflows.deleteWorkflow    workflow: " + workflow);

	// SET ARGS FOR CONFIRM DELETE
	var args = new Object;
	args.project = project;
	args.workflow = workflow;
	
	// DO CONFIRM DELETE
	this.confirmDelete(args);

	// UNSET this.doingDelete
	this.doingDelete = false;
},
indexOfRunningStage : function () {
	var project = this.getProject();
	var workflow = this.getWorkflow();
	////console.log("Workflows.indexOfRunningStage    project: " + project);
	////console.log("Workflows.indexOfRunningStage    workflow: " + workflow);

	var stages = Agua.getStagesByWorkflow(project, workflow);
	////console.log("Workflows.indexOfRunningStage    stages: " + dojo.toJson(stages));
	var running = 0;
	for ( var i = 0; i < stages.length; i++ )
	{
		if ( stages[i].status == "running" )	return i + 1;
	}
	
	return 0;
},
/////////////////		STAGE METHODS         
updateStageNumber : function (stageObject, previousNumber) {
// UPDATE THE number OF A STAGE IN this.stages
// AND ON THE REMOTE SERVER

	////console.log("Workflows.updateStageNumber     Workflow.updateStageNumber(stageObject)");
	////console.log("Workflows.updateStageNumber    stageObject.project: " + stageObject.project);
	////console.log("Workflows.updateStageNumber    stageObject.workflow: " + stageObject.workflow);
	////console.log("Workflows.updateStageNumber    stageObject.name: " + stageObject.name);
	////console.log("Workflows.updateStageNumber    stageObject.number: " + stageObject.number);
	
	// REMOVE FROM Agua DATA
	var addOk = Agua.updateStageNumber(stageObject, previousNumber);
	if ( ! addOk )
	{
		////console.log("Workflows.updateStageNumber    Failed to add stage to Agua data");
		return;
	}
	////console.log("Workflows.updateStageNumber     addOk: " + addOk);
},
/////////////////		RUN STATUS METHODS         
clearRunStatus : function () {
	////console.log("Workflows.clearRunStatus    plugins.workflow.Workflows.clearRunStatus()");
	if ( this.core.runStatus == null )	return;

	////console.log("Workflows.clearRunStatus    this.core.runStatus: " + this.core.runStatus);
	this.core.runStatus.clear();
	this.core.runStatus.polling = false;
},
/////////////////		RUN BUTTON METHODS         
updateRunButton : function () {
// CHECK ALL STAGE INPUTS ARE VALID, ADJUST 'RUN' BUTTON CSS ACCORDINGLY

	console.log("Workflows.updateRunButton    plugins.workflow.Workflows.updateRunButton()");
	console.log("Workflows.updateRunButton    this.dropTarget: " + this.dropTarget);
	if ( ! this.dropTarget ) {
		console.log("Workflows.updateRunButton    Returning because this.dropTarget not defined");
		return;
	}

	var stageNodes = this.dropTarget.getAllNodes();
	console.log("Workflows.updateRunButton    stageNodes.length: " + stageNodes.length);

	this.isValid = true;
	
	for ( var i = 0; i < stageNodes.length; i++ )
	{
		var stageRow = stageNodes[i].parentWidget;
		//var stageRow = dijit.getEnclosingWidget(stageNodes[i]);
		if ( stageRow == null )
			stageRow = dijit.byNode(stageNodes[i].firstChild);
		
		if ( stageRow == null )
		{
			////console.log("Workflows.updateRunButton    [" + (i + 1) + "]    stageRow is NULL. Setting this.isValid = false and returning");
			this.isValid = false;
			return;
		}

		////console.log("Workflows.updateRunButton    [" + i + "]    StageRow (" + (i + 1) + " of " + stageNodes.length + ") isValid : "  + stageRow.isValid);
		
		if ( stageRow.isValid == false || stageRow.isValid == null )
			this.isValid = false;
	}	
	////console.log("Workflows.updateRunButton    this.isValid: " + this.isValid);
	
	if ( this.isValid == true )	this.enableRunButton();
	else this.disableRunButton();
},
enableRunButton : function () {
// ENABLE RUN BUTTON - ADD ONCLICK AND REMOVE invalid CSS

	////console.log("Workflows.enableRunButton    plugins.workflow.Workflows.enableRunButton()");

	// GET RUN BUTTON AND TITLE NODE		
	var node = this.runButton;
	////console.log("Workflows.enableRunButton    node: " + node);

	// ADD enabled CSS
	dojo.removeClass(node, 'runButtonDisabled');
	dojo.addClass(node, 'runButtonEnabled');

	// REMOVE 'RUN' ONCLICK
	if ( node.onclickListener != null )
	{
		dojo.disconnect(node.onclickListener);
	}

	// SET 'RUN' ONCLICK
	if ( this.shared == true )	return;
	var thisObject = this;
	node.onclickListener = dojo.connect( node, "onclick", function(event)
	{
		console.log("Workflows.enableRunButton     runButton onclick triggered");
		
		// RUN ALL STAGES IN THE WORKFLOW (ASSUMES ALL STAGES ARE VALID)
		if ( thisObject.core.runStatus == null )	return;
		var runner = thisObject.core.runStatus.createRunner(1);	
		thisObject.core.runStatus.runWorkflow(runner);
	});
},
disableRunButton : function () {
// DISABLE RUN BUTTON - REMOVE ONCLICK AND ADD invalid CSS

	////console.log("Workflows.disableRunButton    plugins.workflow.Workflows.disableRunButton()");
	
	// GET RUN BUTTON AND TITLE NODE		
	var node = this.runButton;
	////console.log("Workflows.disableRunButton    node: " + node);

	// REMOVE enabled CSS
	dojo.removeClass(node, 'runButtonEnabled');
	dojo.addClass(node, 'runButtonDisabled');


	// REMOVE 'RUN' ONCLICK
	if ( node.onclickListener != null )
	{
		dojo.disconnect(node.onclickListener);
	}
	
},
/////////////////		CONFIRM DELETE
commitDelete : function (args) {
// DELETE THE WORKFLOW/PROJECT AND UPDATE THE WORKFLOW COMBO BOX
	////console.log("Workflows.commitDelete    plugins.workflow.Workflows.commitDelete(args)");
	////console.log("Workflows.commitDelete    args: " + dojo.toJson(args));
	
	if ( args.project == null )	return;
	
	// DELETE THE WORKFLOW AND UPDATE THE WORKFLOW COMBO BOX
	if ( args.workflow != null )
	{
		Agua.removeWorkflow({ project: args.project, name: args.workflow});
	
		// CLEAR THE INFO PANE
		this.clearParameters();
	
		//  RESET THE WORKFLOW COMBO
		var sourceProject = this.projectCombo.getValue();
		this.setWorkflowCombo(sourceProject);
		Agua.toastMessage({
			message: "Deleted workflow: " + args.project + "." + args.workflow,
			type: "message"
		});
		
		// RELOAD RELEVANT DISPLAYS
		Agua.updater.update("updateWorkflows", {originator:this, reload: false});	
	}
	
	// DELETE THE PROJECT AND UPDATE THE PROJECT COMBO BOX
	else
	{
		Agua.removeProject({ name: args.project });
	
		// RELOAD RELEVANT DISPLAYS
		Agua.updater.update("updateProjects");

		Agua.toastMessage({
			message: "Deleted project '" + args.project + "'",
			type: "warning"
		});

		// RELOAD RELEVANT DISPLAYS
		Agua.updater.update("updateProjects", {originator:this, reload: false});	
	}
},
confirmDelete : function (args) {
	////console.log("Workflows.confirmDelete    plugins.workflow.Workflows.confirmDelete(args)");
	////console.log("Workflows.confirmDelete    args: " + dojo.toJson(args));

	// SET CALLBACKS
	var thisObject = this;
	var yesCallback = function()
	{
		thisObject.commitDelete(args);
	};
	var noCallback = function(){};

	// SET TITLE
	var title = "Delete project: " + args.project + "?";
	if ( args.workflow != null )
		title = "Delete workflow: " + args.workflow + "?";

	// SET MESSAGE
	var message = "All stages and data will be destroyed<br><span style='color: #222;'>Click 'Yes' to delete or 'No' to cancel</span>";
	if ( args.workflow != null )
		message = "All data will be destroyed<br><span style='color: #222;'>Click 'Yes' to delete or 'No' to cancel</span>";

	////console.log("Workflows.confirmDelete    title: " + title);
	////console.log("Workflows.confirmDelete    message: " + message);

	// IF NOT EXISTS, INSTANTIATE WIDGET CONTAINING CONFIRMATION DIALOGUE POPUP
	if ( this.confirm != null ) 	this.confirm.destroy();

	// LOAD THE NEW VALUES AND SHOW THE DIALOGUE
	this.confirm = new plugins.dijit.Confirm({
		parentWidget : this,
		title: title,
		message : message,
		yesCallback : yesCallback,
		noCallback : noCallback
	});
	this.confirm.show();
},
setSelectiveDialog : function () {
	var enterCallback = function (){};
	var cancelCallback = function (){};
	var title = "";
	var message = "";
	var inputMessage = "";
	
	////console.log("Workflows.setSelectiveDialog    plugins.workflow.Workflows.setSelectiveDialog()");
	this.selectiveDialog = new plugins.dijit.SelectiveDialog(
		{
			title 				:	title,
			message 			:	message,
			inputMessage 		:	inputMessage,
			parentWidget 		:	this,
			enterCallback 		:	enterCallback,
			cancelCallback 		:	cancelCallback
		}			
	);
	////console.log("Workflows.setSelectiveDialog    this.selectiveDialog: " + this.selectiveDialog);
},
loadSelectiveDialog : function (title, message, comboValues, inputMessage, comboMessage, checkboxMessage, enterCallback, cancelCallback) {
	////console.log("Workflows.loadSelectiveDialog    plugins.workflow.Workflows.loadSelectiveDialog()");
	////console.log("Workflows.loadSelectiveDialog    enterCallback.toString(): " + enterCallback.toString());
	////console.log("Workflows.loadSelectiveDialog    title: " + title);
	////console.log("Workflows.loadSelectiveDialog    message: " + message);
	////console.log("Workflows.loadSelectiveDialog    enterCallback: " + enterCallback);
	////console.log("Workflows.loadSelectiveDialog    cancelCallback: " + cancelCallback);

	this.selectiveDialog.load(
		{
			title 				:	title,
			message 			:	message,
			comboValues 		:	comboValues,
			inputMessage 		:	inputMessage,
			comboMessage 		:	comboMessage,
			checkboxMessage		:	checkboxMessage,
			parentWidget 		:	this,
			enterCallback 		:	enterCallback,
			cancelCallback 		:	cancelCallback
		}
	);
},
setInteractiveDialog : function () {
	var enterCallback = function (){};
	var cancelCallback = function (){};
	var title = "";
	var message = "";
	var inputMessage = "";
	
	////console.log("FileMenu.setInteractiveDialog    plugins.files.FileMenu.setInteractiveDialog()");
	this.interactiveDialog = new plugins.dijit.InteractiveDialog(
		{
			title 				:	title,
			message 			:	message,
			inputMessage 		:	inputMessage,
			parentWidget 		:	this,
			enterCallback 		:	enterCallback,
			cancelCallback 		:	cancelCallback
		}			
	);
	////console.log("FileMenu.setInteractiveDialog    this.interactiveDialog: " + this.interactiveDialog);
},
loadInteractiveDialog : function (title, message, enterCallback, cancelCallback, checkboxMessage) {
	////console.log("FileMenu.loadInteractiveDialog    plugins.files.FileMenu.loadInteractiveDialog()");
	////console.log("FileMenu.loadInteractiveDialog    enterCallback.toString(): " + enterCallback.toString());
	////console.log("FileMenu.loadInteractiveDialog    title: " + title);
	////console.log("FileMenu.loadInteractiveDialog    message: " + message);
	////console.log("FileMenu.loadInteractiveDialog    checkboxMessage: " + checkboxMessage);
	////console.log("FileMenu.loadInteractiveDialog    enterCallback: " + enterCallback);
	////console.log("FileMenu.loadInteractiveDialog    cancelCallback: " + cancelCallback);

	this.interactiveDialog.load(
		{
			title 				:	title,
			message 			:	message,
			checkboxMessage 	:	checkboxMessage,
			enterCallback 		:	enterCallback,
			cancelCallback 		:	cancelCallback
		}			
	);
},
/////////////////		COPY WORKFLOW / PROJECT
copyWorkflow : function () {
// DISPLAY A 'Copy Workflow' DIALOG THAT ALLOWS THE USER TO SELECT 
// THE DESTINATION PROJECT AND THE NAME OF THE NEW WORKFLOW

	////console.log("Workflows.copyWorkflow    plugins.workflow.Workflows.copyWorkflow()");
	////console.log("Workflows.copyWorkflow    this.selectiveDialog: " + this.selectiveDialog);

	// SET TITLE AND MESSAGE
	var sourceProject = this.projectCombo.get('value');
	var sourceWorkflow = this.workflowCombo.get('value');

	////console.log("Workflows.copyWorkflow     Agua.getProjectNames(): " + dojo.toJson(Agua.getProjectNames()));


	// SET CALLBACKS
	var cancelCallback = function (){
		////console.log("Workflows.copyWorkflow    cancelCallback()");
	};
	var thisObject = this;
	
	var enterCallback = dojo.hitch(this, function (targetWorkflow, targetProject, copyFiles, dialogWidget)
		{
			////console.log("Workflows.copyWorkflow    Doing enterCallback(targetWorkflow, targetProject, copyfiles, dialogWidget)");
			////console.log("Workflows.copyWorkflow    targetWorkflow: " + targetWorkflow);
			////console.log("Workflows.copyWorkflow    targetProject: " + targetProject);
			////console.log("Workflows.copyWorkflow    copyFiles: " + copyFiles);
			////console.log("Workflows.copyWorkflow    dialogWidget: " + dialogWidget);
			
			// SET BUTTON LABELS
			var enterLabel = "Copy";
			var cancelLabel = "Cancel";
			
			// SANITY CHECK
			if ( targetWorkflow == null || targetWorkflow == '' )	return;
			targetWorkflow = targetWorkflow.replace(/\s+/, '');
			////console.log("Workflows.copyWorkflow    targetWorkflow: " + targetWorkflow);

			// QUIT IF WORKFLOW EXISTS ALREADY
			if ( Agua.isWorkflow({ project: targetProject, name: targetWorkflow }) == true )
			{
				////console.log("Workflows.copyWorkflow    Workflow '" + targetWorkflow + "' already exists in project " + targetProject + ". Sending message to dialog.");
				////console.dir({messageNode: dialogWidget.messageNode});
				dialogWidget.messageNode.innerHTML = "/" + targetWorkflow + "' already exists in '" + targetProject + "'";
				return;
			}
			else {
				////console.log("Workflows.copyWorkflow    Workflow '" + targetWorkflow + "' is unique in project " + targetProject + ". Adding workflow.");
				dialogWidget.messageNode.innerHTML = "Creating workflow";
				dialogWidget.close();
			}
			
			thisObject._copyWorkflow(sourceProject, sourceWorkflow, targetProject, targetWorkflow, copyFiles);
		}
	);		

	// SHOW THE DIALOG
	this.selectiveDialog.load(
		{
			title 				:	"Copy Workflow",
			message 			:	"Source: '" + sourceProject + ":" + sourceWorkflow + "'",
			comboValues 		:	Agua.getProjectNames(),
			inputMessage 		:	"Workflow",
			comboMessage 		:	"Project",
			checkboxMessage		:	"Copy files",
			parentWidget 		:	this,
			enterCallback 		:	enterCallback,
			cancelCallback 		:	cancelCallback,
			enterLabel			:	"Copy",
			cancelLabel			:	"Cancel"
		}			
	);
},
_copyWorkflow : function (sourceProject, sourceWorkflow, targetProject, targetWorkflow, copyFiles) {
	////console.log("Workflows._copyWorkflow    plugins.workflow.Workflows._copyWorkflow(sourceProject, sourceWorkflow, targetProject, targetWorkflow, copyFiles)");
	
	var username = Agua.cookie('username');
	var success = Agua.copyWorkflow(username, sourceProject, sourceWorkflow, username, targetProject, targetWorkflow, copyFiles);
	////console.log("Workflows._copyWorkflow    success: " + success);

	if ( success == true )
		this.setProjectCombo(targetProject, targetWorkflow);
},
copyProject : function () {
// ADD A NEW WORKFLOW USING A DIALOG BOX FOR WORKFLOW NAME INPUT

	////console.log("Workflows.copyProject    plugins.workflow.Workflows.copyProject()");
	////console.log("Workflows.copyProject    this.interactiveDialog: " + this.interactiveDialog);

	var sourceProject = this.projectCombo.get('value');
	
	// SET CALLBACKS
	var cancelCallback = function (){
		////console.log("Workflows.copyProject    cancelCallback()");
	};
	
	var thisObject = this;
	var enterCallback = dojo.hitch(this, function (targetProject, copyFiles, interactiveDialog)
		{
			////console.log("Workflows.copyProject    Doing enterCallback(targetProject, interactiveDialog");
			////console.log("Workflows.copyProject    targetProject: " + targetProject);
			////console.log("Workflows.copyProject    interactiveDialog: " + interactiveDialog);
		
			// SANITY CHECK
			if ( targetProject == null || targetProject == '' )	return;
			targetProject = targetProject.replace(/\s+/, '');
			////console.log("Workflows.copyProject    targetProject: " + targetProject);

			// QUIT IF WORKFLOW EXISTS ALREADY
			if ( Agua.isProject(targetProject) == true )
			{
				////console.log("Workflows.copyProject    Project '" + targetProject + "' already exists in project " + targetProject + ". Sending message to dialog.");
				
				interactiveDialog.messageNode.innerHTML = "Project name already exists";
				return;
			}
			else {
				////console.log("Workflows.copyProject    Project '" + targetProject + "' is unique in project " + targetProject + ". Adding project.");

				interactiveDialog.messageNode.innerHTML = "Creating project";
				interactiveDialog.close();
			}

			thisObject._copyProject(sourceProject, targetProject, copyFiles);
		}
	);	

	// SHOW THE DIALOG
	this.interactiveDialog.load(
		{
			title 				:	"Copy Project",
			message 			:	"Please enter project name",
			checkboxMessage 	:	"Copy files",
			enterCallback 		:	enterCallback,
			cancelCallback 		:	cancelCallback
		}			
	);
},
_copyProject : function (sourceProject, targetProject, copyFiles) {
	////console.log("Workflows._copyProject    plugins.workflow.Workflows._copyProject(sourceProject, sourceProject, targetProject, targetProject, copyFiles)");

	var username = Agua.cookie('username');
	// ADD PROJECT
	Agua.copyProject(username, sourceProject, username, targetProject, copyFiles);

	this.setProjectCombo(targetProject);
}

}); // plugins.workflow.Workflows

}

if(!dojo._hasResource["plugins.workflow.SharedWorkflows"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.workflow.SharedWorkflows"] = true;
dojo.provide("plugins.workflow.SharedWorkflows");

/* CLASS SUMMARY: DISPLAY SHARED PROJECTS AND WORKFLOWS
   
   ALLOW THE USER TO:
   
		-	VIEW THE PARAMETERS OF SHARED WORKFLOWS 

		-	VIEW THE OUTPUT FILES OF SHARED WORKFLOWS

		-	COPY SHARED WORKFLOWS TO USER'S OWN PROJECTS
		
   TO DO:

	copyProject
	sharedStatus

*/






dojo.declare("plugins.workflow.SharedWorkflows",
	[ plugins.workflow.Workflows ], {

//Path to the template of this widget. 
templateString:"<div dojoAttachPoint=\"containerNode\">\n\n    <!-- SHARED TAB -->\n    <div\n        dojoAttachPoint=\"mainTab\"\n        dojoAttachEvent=\"onclick:assumeFocus\"\n        dojoType=\"dijit.layout.ContentPane\"\n        title=\"Shared\"\n        class=\"workflows\"\n        parseOnLoad=\"false\"\n        style=\" height: 100%; width: 100%; padding: 0 !important;\"\n        >\n            \n        <table width=\"100%\">\n            <tr>\n                <td colspan=\"4\" class=\"tabTitle\" align=\"center\">Shared Workflows</td>\n            </tr>\n            <tr>\n                <td class=\"projectTitle\" colspan=\"3\">User</td>\n            </tr>\n            <tr>\n                <td class=\"usernameIcon\">\n                </td>\n                \n                <td class=\"comboColumn\">\n                    <div dojoType=\"dijit.form.ComboBox\"\n                        dojoAttachPoint=\"usernameCombo\"\n                        class=\"usernameCombo\"\n                        autocomplete=\"false\"\n                    >\n                    </div>\n                </td>\n\n            </tr>\n            <tr>\n                <td class=\"projectTitle\" colspan=\"3\">Project</td>\n            </tr>\n            <tr>\n\n                <td class=\"projectIcon\">\n                </td>\n                \n                <td class=\"comboColumn\">\n                    <div dojoType=\"dijit.form.ComboBox\"\n                        dojoAttachPoint=\"projectCombo\"\n                        class=\"projectCombo\"\n                        autocomplete=\"false\"\n                    >\n                    </div>\n                </td>\n                \n                <td class=\"buttonColumn\">\n                    <div\n                    dojoAttachPoint=\"copyProjectButton\"\n                    dojoAttachEvent=\"onclick:copyProject\"\n                    class=\"copyProjectButton\" \t\t\t\t\t\t\t\t\t\t\t                        width=\"20%\"\n                    title=\"Copy Project\"\n                    align=\"center\"\n                    >\n                    </div>\n                </td>\n\n            </tr>\n            <tr>\n                <td class=\"workflowTitle\" colspan=\"3\">Workflow</td>\n            </tr>\n            <tr>\n\n                <td class=\"workflowIcon\">\n                </td>\n                \n                <td class=\"comboColumn\">\n                    <div dojoType=\"dijit.form.ComboBox\"\n                        dojoAttachPoint=\"workflowCombo\"\n                        class=\"workflowCombo\"\n                        autocomplete=\"false\"\n                    >\n                    </div>\n                </td>\n\n                <td class=\"buttonColumn\">\n                    <div\n                    dojoAttachPoint=\"copyWorkflowButton\"\n                    dojoAttachEvent=\"onclick:copyWorkflow\"\n                    class=\"copyWorkflowButton\"\n                    title=\"Copy Workflow\"\n                    width=\"20%\"\n                    align=\"center\"\n                    >\n                    </div>\n                </td>\n            </tr>\n            \n            <tr>\n                <td \n                    dojoAttachPoint=\"sharedDisplayStatus\"\n                    class=\"displayStatus\"\n                    colspan=\"3\"\n                    >\n                </td>\n            </tr>\n            \n            <tr>\n                <td align=\"center\" width=\"260px\" colspan=\"3\">\n                    <div\n                        dojoAttachPoint=\"dropTargetContainer\"\n                        class=\"dropTarget\"\n                        style=\"position:relative; top: 20px;\">\n                    </div>\n                </td>\n            </tr>\n\n        </table>\n    \n    </div>\n    <!-- END OF SHARED TAB -->\n\n</div>\n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

// OR USE @import IN HTML TEMPLATE
// **** LOADED IN Workflow.js ****
//cssFiles : [ dojo.moduleUrl("plugins") + "/workflow/css/shared.css" ],

shared : true,

// PARENT WIDGET
parentWidget : null,

// ARRAY OF CHILD WIDGETS
childWidgets : null,

// isVALID BOOLEAN: ALL PARAMETERS ARE VALID
isValid : null,

// CORE WORKFLOW OBJECTS
core : null,

// workflowType : string
// E.g., 'userWorkflows', 'sharedWorkflows'
workflowType : 'sharedWorkflows',

/////}}}}}

startup : function () {
// DO inherited, LOAD ARGUMENTS AND ATTACH THE MAIN TAB TO THE ATTACH NODE
	//console.log("SharedWorkflows.startup    plugins.workflow.SharedWorkflows.startup()");
	//console.log("SharedWorkflows.startup    this.shared: " + this.shared);

	//console.log("SharedWorkflows.startup    Setting this.ready = false");
	this.ready = false;

	// ADD TO TAB CONTAINER		
	this.attachNode.addChild(this.mainTab);
	//this.attachNode.selectChild(this.mainTab);

	// SET SELECTIVE DIALOG FOR copyWorkflow	
	this.setSelectiveDialog();

	// SET INTERACTIVE DIALOG FOR copyProject
	this.setInteractiveDialog();
	
	// CREATE SOURCE MENU
	this.setContextMenu();
	
	// CREATE DROP TARGET
	this.setDropTarget();

	// SET SHARING USER NAMES COMBO
	this.setUsernameCombo();
	
	// SET ONCLICK LISTENERS
	this.setListeners();
	
	// SUBSCRIBE TO UPDATES
	Agua.updater.subscribe(this, "updateProjects");

	this.ready = true;
},

updateProjects : function (args) {
// DO NOTHING
},


setListeners : function () {

	// USERNAME COMBO
	var thisObject = this;
	dojo.connect(this.usernameCombo, "onChange", dojo.hitch(function(event) {
		//console.log("SharedWorkflows.setUsernameCombo    dojo.connect event: " + event);
		thisObject.setProjectCombo(event);
	}));

	// PROJECT COMBO
	dojo.connect(this.projectCombo, "onChange", dojo.hitch(function(event) {
		//console.log("SharedWorkflows.setProjectCombo    dojo.connect event: " + event);
		var username = thisObject.usernameCombo.get('value');
		var projectName = thisObject.projectCombo.get('value');
		
		thisObject.setWorkflowCombo(username, projectName);
	}));
	
	// WORKFLOW COMBO
	var thisObject = this;
	dojo.connect(this.workflowCombo, "onChange", dojo.hitch(function(event) {
		//console.log("SharedWorkflows.setWorkflowCombo    dojo.connect event: " + event);

		var username = thisObject.usernameCombo.get('value');
		var projectName = thisObject.projectCombo.get('value');
		var workflowName = thisObject.workflowCombo.get('value');
		thisObject.updateDropTarget(username, projectName, workflowName);
	}));

},

enableRunButton : function () {
	//console.log("SharedWorkflows.enableRunButton()  EMPTY PLACEHOLDER");
},

disableRunButton : function () {
	//console.log("SharedWorkflows.disableRunButton()  EMPTY PLACEHOLDER");
},

setUsernameCombo : function () {
	//console.log("SharedWorkflows.setUsernameCombo    plugins.workflow.Common.setUsernameCombo()");
	
	//console.log("SharedWorkflows.setUsernameCombo    BEFORE this.inherited(arguments)");
	this.inherited(arguments);
	//console.log("SharedWorkflows.setUsernameCombo    AFTER this.inherited(arguments)");

	var username = this.usernameCombo.get('value');
	//console.log("SharedWorkflows.setUsernameCombo    username: " + username);

	// SET THE PROJECT COMBO
	this.setProjectCombo(username);
},

setProjectCombo : function (username, projectName, workflowName) {
	//console.log("SharedWorkflows.setProjectCombo    plugins.report.Workflow.setProjectCombo(username, project, workflow)");
	
	//console.log("SharedWorkflows.setProjectCombo    username: " + username);
	//console.log("SharedWorkflows.setProjectCombo    projectName: " + projectName);
	//console.log("SharedWorkflows.setProjectCombo    workflowName: " + workflowName);
	//console.log("SharedWorkflows.setProjectCombo    BEFORE this.inherited(arguments)");

	this.setSharedProjectCombo(username, projectName, workflowName);
	//console.log("SharedWorkflows.setProjectCombo    AFTER this.inherited(arguments)");

	if ( projectName == null || ! projectName )
	{
		projectName = this.projectCombo.get('value');
	}
	//console.log("SharedWorkflows.setProjectCombo    projectName: " + projectName);

	// SET THE PROJECT COMBO
	this.setWorkflowCombo(username, projectName);
},

setWorkflowCombo : function (username, projectName, workflowName) {
	//console.log("SharedWorkflows.setWorkflowCombo    workflow.SharedWorkflows.setWorkflowCombo(username, project, workflow)");
	//console.log("SharedWorkflows.setWorkflowCombo    username: " + username);
	//console.log("SharedWorkflows.setWorkflowCombo    projectName: " + projectName);
	//console.log("SharedWorkflows.setWorkflowCombo    workflowName: " + workflowName);

	//console.log("SharedWorkflows.setWorkflowCombo    BEFORE this.inherited(arguments)");
	this.setSharedWorkflowCombo(username, projectName, workflowName);
	//console.log("SharedWorkflows.setWorkflowCombo    AFTER this.inherited(arguments)");

	if ( projectName == null || ! projectName )
		projectName = this.projectCombo.get('value');
	//console.log("SharedWorkflows.setWorkflowCombo    projectName: " + projectName);

	if ( workflowName == null || ! workflowName )
		workflowName = this.workflowCombo.get('value');
	//console.log("SharedWorkflows.setWorkflowCombo    workflowName: " + workflowName);

	this.updateDropTarget(username, projectName, workflowName);
},

setDropTarget : function () {
// CREATE DROP TARGET
	this.dropTarget = new plugins.dnd.Target(
		this.dropTargetContainer,
		{
			accept: [],
			contextMenu : this.contextMenu,
			parentWidget : this,
			core: this.core
		}
	);

	if ( this.dropTarget == null ) {
		//console.log("Workflows._setDropTargetNodes    this.dropTarget is null. Returning");
		return;
	}	
},

updateDropTarget : function (username, projectName, workflowName) {
	//console.log("SharedWorkflows.updateDropTarget     plugins.workflow.SharedWorkflows.updateDropTarget(username, projectName, workflowName)");

	//console.log("SharedWorkflows.updateDropTarget     this.ready: " + this.ready);
	if ( ! this.ready )	return;

	//console.log("SharedWorkflows.updateDropTarget     username: " + username);
	//console.log("SharedWorkflows.updateDropTarget     projectName: " + projectName);
	//console.log("SharedWorkflows.updateDropTarget     workflowName: " + workflowName);
	if ( ! username )	return;
	if ( ! projectName )	return;
	if ( ! workflowName )	return;
	
	// SET THE DROP TARGET
	var sharedStages  = Agua.getSharedStagesByWorkflow(username, projectName, workflowName);
	//console.log("SharedWorkflows.updateDropTarget    sharedStages: ");
	//console.dir({sharedStages:sharedStages});
	
	if ( sharedStages == null )
	{
		//console.log("SharedWorkflows.updateDropTarget    sharedStages == null. Returning");
		return;
	}

	this._updateDropTarget(sharedStages);
},

assumeFocus : function () {
	//console.log("SharedWorkflows.assumeFocus    plugins.workflow.SharedWorkflows.assumeFocus()");

	var username = thisObject.usernameCombo.get('value');
	var projectName = thisObject.projectCombo.get('value');
	var workflowName = thisObject.workflowCombo.get('value');
	this.updateDropTarget(username, projectName, workflowName);
},


loadParametersPane : function (node) {
// LOAD DATA INTO INFO PANE FROM THE APPLICATION ASSOCIATED WITH THIS NODE
// OVERLOAD THIS TO PASS ADDITIONAL ARGUMENTS TO Parameters.load()
	//console.log("SharedWorkflows.loadParametersPane    plugins.workflow.SharedWorkflows.loadParametersPane(node)");
	//console.log("SharedWorkflows.loadParametersPane    node: " + node);
	//console.log("SharedWorkflows.loadParametersPane    this.shared: " + this.shared);
	//console.log("sharedProjects.loadParametersPane    this.core.parameters: " + this.core.parameters);
	
	// WARN AND QUIT IF NO NODE PASSED, E.G., IF WORKFLOW HAS NO STAGES
	if ( node == null )
	{
		//console.log("SharedWorkflows.loadParametersPane    node is null (no applications in dropTarget). Returning.");
		return;
	}
	//console.log("SharedWorkflows.loadParametersPane    node.application: ");
	//console.dir({node_application:node.application});

	if ( this.core.parameters != null )
		this.core.parameters.load(node, this.shared);
		
	
	this.ready = true;
},

_copyWorkflow : function (sourceProject, sourceWorkflow, targetProject, targetWorkflow, copyFiles) {
	//console.log("SharedWorkflows._copyWorkflow    SharedWorkflows._copyWorkflow(sourceProject, sourceWorkflow, targetProject, targetWorkflow, copyFiles)");
	
	var sourceUser = this.usernameCombo.get('value');
	var targetUser = Agua.cookie('username');

	//console.log("SharedWorkflows._copyWorkflow    sourceUser: " + sourceUser);
	//console.log("SharedWorkflows._copyWorkflow    targetUser: " + targetUser);

	// ADD PROJECT
	Agua.copyWorkflow(sourceUser, sourceProject, sourceWorkflow, targetUser, targetProject, targetWorkflow, copyFiles);

	// RELOAD RELEVANT DISPLAYS
	Agua.updater.update("updateProjects");
},

_copyProject : function (sourceProject, targetProject, copyFiles) {
//console.log("SharedWorkflows._copyProject    Stages._copyProject(sourceProject, targetProject, copyFiles)");

	var targetUser = Agua.cookie('username');
	var sourceUser =  this.usernameCombo.get('value');
	
	// ADD PROJECT
	Agua.copyProject(sourceUser, sourceProject, targetUser, targetProject, copyFiles);

	// RELOAD RELEVANT DISPLAYS
	Agua.updater.update("updateProjects");
}




}); // plugins.workflow.SharedWorkflows

/*
_copyWorkflow : function (sourceProject, sourceWorkflow, targetProject, targetWorkflow, copyFiles) {
	//console.log("SharedWorkflows._copyWorkflow    Stages._copyWorkflow(sourceProject, sourceWorkflow, targetProject, targetWorkflow, copyFiles)");
	
		var targetUser = Agua.cookie('username');
		var sourceUser =  thisObject.usernameCombo.get('value');
		
		// ADD PROJECT
		Agua.copyWorkflow(sourceUser, sourceProject, sourceWorkflow, targetUser, targetProject, targetWorkflow, copyFiles);
},
*/

}

if(!dojo._hasResource["plugins.workflow.UserWorkflows"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["plugins.workflow.UserWorkflows"] = true;
dojo.provide("plugins.workflow.UserWorkflows");

/* 
	USE CASE SCENARIO 1: INPUT VALIDITY CHECKING WHEN USER LOADS NEW WORKFLOW 

	1. updateDropTarget: load stages

	2. updateDropTarget: CALL -> first stage)

		   load multiple ParameterRows, each checks isValid (async xhr request for each file)
			   CALL -> Agua.setParameterValidity(boolean) to set stageParameter.isValid
	
	3. updateDropTarget: (concurrently with 2.) CALL -> updateRunButton()

		   check isValid for each StageRow:

				CALL-> checkValidParameters (async batch xhr request for multiple files)

				   CALL -> Agua.getParameterValidity(), and if empty check input and then

						CALL -> Agua.setParameterValidity(boolean) to set stageParameter.isValid


	USE CASE SCENARIO 2: USER CREATES NEW WORKFLOW BY TYPING IN WORKFLOW COMBO
	
	Stages.setWorkflowListeners:
	
	this.workflowCombo._onKey LISTENER FIRES
		
		--> Agua.isWorkflow (returns TRUE/FALSE)

			FALSE 	--> Agua.addWorkflow
						
						--> Agua.getMaxWorkflowNumber
						--> Agua._addWorkflow

					-->  Stages.setWorkflowCombo
		

	USE CASE SCENARIO 3: USER CLICKS 'Copy Workflow' BUTTON
	
	copyWorkflow
	
		-->	Agua.isWorkflow (returns TRUE/FALSE)
		
			TRUE 	-->	Message to dialogWidget and quit
		
			FALSE	-->	Message to dialogWidget and copy
			
				--> Stages._copyWorkflow

					-->	Agua.copyWorkflow (returns TRUE/FALSE)
					
						TRUE	--> Stages.setProjectCombo with new workflow

*/

// REQUIRE MODULES
if ( 1 ) {
// // optimize: load dijit layer






// WIDGETS AND TOOLS FOR EXPANDO PANE












	
// DnD
 // Source & Target




// TIMER


// TOOLTIP


// TOOLTIP DIALOGUE




// STANDBY


// WIDGETS IN TEMPLATE



// INPUT DIALOG




// HAS A







// INHERITS

}

dojo.declare("plugins.workflow.UserWorkflows",
	[ plugins.workflow.Workflows ], {
//Path to the template of this widget. 
templateString:"<div dojoAttachPoint=\"containerNode\">\n\n    <div\n        dojoAttachPoint=\"mainTab\"\n        dojoType=\"dijit.layout.ContentPane\"\n        parseOnLoad=\"false\"\n        class=\"workflows\"\n\t\ttitle=\"Workflows\"\n\t\tstyle=\"height: 100%; width: 100%; padding: 0 !important;\"\n    >\n    \n        <table width=\"100%\">\n\t\t\t<tr valign=\"top\" width=\"100%\">\n\t\t\t\t<td colspan=\"4\"class=\"tabTitle\" align=\"center\">\n                    Workflows\n\t\t\t\t</td>\n\t\t\t</tr>\n\t\t</table>\n\t\t\n        <table align=\"center\" width=\"100%\">\n\t\t<table width=\"100%\">\n\t\t\t<tr>\n\t\t\t\t<td\n\t\t\t\t\tcolspan=\"3\"\n\t\t\t\t\tdojoAttachPoint=\"syncWorkflowsButton\"\n\t\t\t\t\tclass=\"syncWorkflowsButton\"\n\t\t\t\t\ttitle=\"Click to sync workflows to biorepository\"\n\t\t\t\t\tdojoAttachEvent=\"onclick:showSyncDialog\"\n\t\t\t\t>\n\t\t\t\t\tSync\n\t\t\t\t</td>\n\t\t\t</tr>\n            <tr>\n                <td class=\"workflowTitle\" colspan=\"5\">Cluster</td>\n            </tr>\n\n            <tr align=\"center\">\n\n                <td class=\"clusterIcon\"></td>\n\t\t\t\t<td>\n                    <div\n\t\t\t\t\t\tdojoType=\"dijit.form.ComboBox\"\n                        dojoAttachPoint=\"clusterCombo\"\n\t\t\t\t\t\tdojoAttachEvent=\"onChange:saveClusterWorkflow\"\n                        class=\"clusterCombo\"\n                        autocomplete=\"false\"\n\t\t\t\t\t\tdisabled=\"false\"\n                    >\n                    </div>\n\t\t\t\t</td>\n\t\t\t\t<td>\n\t\t\t\t\t<table>\n\t\t\t\t\t\t<tr class=\"headerRow\">\n\t\t\t\t\t\t\t<td colspan=\"2\"><b>Nodes</b></td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t<tr class=\"headerRow\">\n\t\t\t\t\t\t\t<td>Min</td>\n\t\t\t\t\t\t\t<td>Max</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"minNodes\"\n\t\t\t\t\t\t\t\t\tdojoAttachEvent=\"onKeyPress:checkClusterNodes\"\n\t\t\t\t\t\t\t\t\tclass=\"minNodes\"\n\t\t\t\t\t\t\t\t\tdojoType=\"dijit.form.NumberTextBox\"\n\t\t\t\t\t\t\t\t\tvalue=\"0\"\n\t\t\t\t\t\t\t\t\tconstraints=\"{min:0,max:99999,places:0}\"\n\t\t\t\t\t\t\t\t\tmaxlength=\"5\" \n\t\t\t\t\t\t\t\t\tpromptMessage=\"Minimum nodes: from 0 to 99999\" \n\t\t\t\t\t\t\t\t\tinvalidMessage=\"Minimum nodes: from 0 to 99999\"\n\t\t\t\t\t\t\t\t\ttooltipPosition=\"below\"\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"maxNodes\"\n\t\t\t\t\t\t\t\t\tdojoAttachEvent=\"onKeyPress:checkClusterNodes\"\n\t\t\t\t\t\t\t\t\tclass=\"maxNodes\"\n\t\t\t\t\t\t\t\t\tdojoType=\"dijit.form.NumberTextBox\"\n\t\t\t\t\t\t\t\t\tvalue=\"0\"\n\t\t\t\t\t\t\t\t\tconstraints=\"{min:0,max:99999,places:0}\"\n\t\t\t\t\t\t\t\t\tmaxlength=\"5\" \n\t\t\t\t\t\t\t\t\tpromptMessage=\"Maximum nodes: from 0 to 99999\" \n\t\t\t\t\t\t\t\t\tinvalidMessage=\"Maximum nodes: from 0 to 99999\"\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t</table>\n\t\t\t\t</td>\n\t\t\t</tr>\n\t\t</table>\n\t\t\n\t\t\n\t\t<table width=\"100%\">\n            <tr>\n                <td class=\"projectTitle\" colspan=\"4\">Project</td>\n            </tr>\n            <tr>\n\n                <td class=\"projectIcon\">\n                </td>\n                \n                <td>\n                    <div dojoType=\"dijit.form.ComboBox\"\n                        dojoAttachPoint=\"projectCombo\"\n                        class=\"projectCombo\"\n                        autocomplete=\"false\"\n                    >\n                    </div>\n                </td>\n                \n                <td\n                    dojoAttachPoint=\"copyProjectButton\"\n\t\t\t\t\tdojoAttachEvent=\"onclick:copyProject\"\n                    class=\"copyProjectButton\" \t\t\t\t\t\t\t\t\t\t\t\t\t\t\twidth=\"20%\"\n                    align=\"center\"\n                    class=\"fileUpload\" >\n                </td>\n\n                <td\n                    dojoAttachPoint=\"deleteProjectButton\"\n                    class=\"deleteProjectButton\" \t\t\t\t\t\t\t\t\t\t\t\t\t\t\twidth=\"20%\"\n                    align=\"center\"\n                    class=\"fileUpload\" >\n                </td>\n\n            </tr>\n            <tr>\n                <td class=\"workflowTitle\" colspan=\"4\">Workflow</td>\n            </tr>\n            <tr>\n\n                <td class=\"workflowIcon\">\n                </td>\n\n                <td>\n                    <div dojoType=\"dijit.form.ComboBox\"\n                        dojoAttachPoint=\"workflowCombo\"\n                        class=\"workflowCombo\"\n                        autocomplete=\"false\"\n                    >\n                    </div>\n                </td>\n\n                <td \n                    dojoAttachPoint=\"copyWorkflowButton\"\n\t\t\t\t\tdojoAttachEvent=\"onclick:copyWorkflow\"\n                    class=\"copyWorkflowButton\" \t\t\t\t\t\t\t\t\t\t\t\t\t\t\twidth=\"20%\"\n                    align=\"center\"\n                    class=\"fileUpload\" >\n                </td>\n\n                <td \n                    dojoAttachPoint=\"deleteWorkflowButton\"\n                    class=\"deleteWorkflowButton\" \t\t\t\t\t\t\t\t\t\t\t\t\t\t\twidth=\"20%\"\n                    align=\"center\"\n                    class=\"fileUpload\" >\n                </td>\n\n            </tr>\n        </table>\n\t\t\n        <table align=\"center\" width=\"260px\">\n            <tr align=\"center\" >\n\n                <td width=80px\n                    colspan=\"3\"\n                    dojoAttachPoint=\"runButton\"\n                    class=\"runButton runButtonDisabled\"\n                    width=\"100%\"\n                    style=\"-moz-user-select: none !important; padding-left: 0px;\">\n                    Run Workflow\n                </td>\n\n            </tr>\n\n            <tr>\n                <td \n                    dojoAttachPoint=\"displayStatus\"\n                    class=\"displayStatus\"\n                    colspan=\"3\"\n                    >\n                </td>\n            </tr>\n            \n            <tr>\n                <td colspan=\"3\">\n                    <div\n                        dojoAttachPoint=\"dropTargetContainer\"\n                        class=\"dropTarget\" >\n                    </div>\n                </td>\n            </tr>\n\n        </table>\n\n    \n    </div>\n    <!-- END OF WORKFLOWS TAB -->\n    \n\n</div>\n",

// Calls dijit._Templated.widgetsInTemplate
widgetsInTemplate : true,

// CONTEXT MENU
contextMenu : null,

// workflowType : string
// E.g., 'userWorkflows', 'sharedWorkflows'
workflowType : 'userWorkflows',

// syncDialog : plugins.dijit.SyncDialog
syncDialog : null,

/////}}}}
constructor : function (args) {
	console.log("Stages.constructor     plugins.workflow.UserWorkflows.constructor");			
	// GET INFO FROM ARGS
	this.core 						= args.core;
	this.core[this.workflowType]	= this;
	this.parentWidget 				= args.parentWidget;
	this.attachNode 				= args.attachNode;

	// LOAD CSS
	this.loadCSS();		
},
preStartup : function () {
	console.group("UserWorkflows-" + this.id + "    preStartup");
	console.log("HERE");
	console.log("UserWorkflows.preStartup    END");
	console.groupEnd("UserWorkflows-" + this.id + "    preStartup");
},
postStartup : function () {
	console.group("UserWorkflows-" + this.id + "    postStartup");

	// SET SYNC WORKFLOWS BUTTON
	this.setSyncWorkflows();
	
	// SUBSCRIBE TO UPDATES
	Agua.updater.subscribe(this, "updateSyncWorkflows");

	// SET SYNC DIALOG
	this.setSyncDialog();
	
	console.groupEnd("UserWorkflows-" + this.id + "    postStartup");
},
updateSyncWorkflows : function (args) {
	console.warn("UserWorkflows.updateSyncWorkflows    args:");
	console.dir({args:args});

	this.setSyncWorkflows();
},
// DISABLE SYNC WORKFLOWS BUTTON IF NO HUB LOGIN
setSyncWorkflows : function () {
	var hub = Agua.getHub();
	console.log("UserWorkflows.setSyncWorkflows    hub:")
	console.dir({hub:hub});

	if ( ! hub.login || ! hub.token ) {
		this.disableSyncWorkflows();
	}
	else {
		this.enableSyncWorkflows();
	}
},
setSyncDialog : function () {
	console.log("UserWorkflows.loadSyncDialog    plugins.workflows.UserWorkflows.setSyncDialog()");
	
	var enterCallback = function (){};
	var cancelCallback = function (){};
	var title = "Sync";
	var header = "Sync Workflows";
	
	this.syncDialog = new plugins.dijit.SyncDialog(
		{
			title 				:	title,
			header 				:	header,
			parentWidget 		:	this,
			enterCallback 		:	enterCallback
		}			
	);

	console.log("UserWorkflows.loadSyncDialog    this.syncDialog:");
	console.dir({this_syncDialog:this.syncDialog});

},
showSyncDialog : function () {
	var disabled = dojo.hasClass(this.syncWorkflowsButton, "disabled");
	console.log("UserWorkflows.loadSyncDialog    disabled: " + disabled);
	
	if ( disabled ) {
		console.log("UserWorkflows.loadSyncDialog    SyncWorkflows is disabled. Returning");
		return;
	}
	
	var title = "Sync Workflows";
	var header = "";
	var message = "";
	var details = "";
	var enterCallback = dojo.hitch(this, "syncWorkflows");
	this.loadSyncDialog(title, header, message, details, enterCallback)
},
loadSyncDialog : function (title, header, message, details, enterCallback) {
	console.log("UserWorkflows.loadSyncDialog    title: " + title);
	console.log("UserWorkflows.loadSyncDialog    header: " + header);
	console.log("UserWorkflows.loadSyncDialog    message: " + message);
	console.log("UserWorkflows.loadSyncDialog    details: " + details);
	console.log("UserWorkflows.loadSyncDialog    enterCallback: " + enterCallback);

	this.syncDialog.load(
		{
			title 			:	title,
			header 			:	header,
			message 		:	message,
			details 		:	details,
			enterCallback 	:	enterCallback
		}			
	);
},
disableSyncWorkflows : function () {
	dojo.addClass(this.syncWorkflowsButton, "disabled");
	dojo.attr(this.syncWorkflowsButton, "title", "Input AWS private key and public certificate to enable Sync");
},
enableSyncWorkflows : function () {
	dojo.removeClass(this.syncWorkflowsButton, "disabled");
	dojo.attr(this.syncWorkflowsButton, "title", "Click to sync workflows to biorepository");
},
// SYNC WORKFLOWS
syncWorkflows : function (inputs) {
	console.log("Hub.syncWorkflows    inputs: ");
	console.dir({inputs:inputs});
	
	if ( this.syncingWorkflows == true ) {
		console.log("Hub.syncWorkflows    this.syncingWorkflows: " + this.syncingWorkflows + ". Returning.");
		return;
	}
	this.syncingWorkflows = true;
	
	var query = new Object;
	query.username 			= Agua.cookie('username');
	query.sessionid 		= Agua.cookie('sessionid');
	query.message			= inputs.message;
	query.details			= inputs.details;
	query.hubtype			= "github";
	query.mode 				= "syncWorkflows";
	console.log("Hub.syncWorkflows    query: ");
	console.dir({query:query});
	
	// SEND TO SERVER
	var url = Agua.cgiUrl + "workflow.cgi?";
	var thisObj = this;
	dojo.xhrPut(
		{
			url: url,
			contentType: "json",
			putData: dojo.toJson(query),
			load: function(response, ioArgs) {
				thisObj.syncingWorkflows = false;

				console.log("Workflows.syncWorkflows    OK. response:")
				console.dir({response:response});

				Agua.toast(response);
			},
			error: function(response, ioArgs) {
				thisObj.syncingWorkflows = false;

				console.log("Workflows.syncWorkflows    ERROR. response:")
				console.dir({response:response});
				Agua.toast(response);
			}
		}
	);
}

}); // plugins.workflow.UserWorkflows

}


dojo.i18n._preloadLocalizations("dojo.nls.", ["ROOT","ar","ca","cs","da","de","de-de","el","en","en-gb","en-us","es","es-es","fi","fi-fi","fr","fr-fr","he","he-il","hu","it","it-it","ja","ja-jp","ko","ko-kr","nb","nl","nl-nl","pl","pt","pt-br","pt-pt","ru","sk","sl","sv","th","tr","xx","zh","zh-cn","zh-tw"]);
