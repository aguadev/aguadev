.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTTP::Server::Simple 3"
.TH HTTP::Server::Simple 3 "2011-04-04" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTTP::Server::Simple \- Lightweight HTTP server
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& use warnings;
\& use strict;
\& 
\& use HTTP::Server::Simple;
\& 
\& my $server = HTTP::Server::Simple\->new();
\& $server\->run();
.Ve
.PP
However, normally you will sub-class the HTTP::Server::Simple::CGI
module (see HTTP::Server::Simple::CGI);
.PP
.Vb 2
\& package Your::Web::Server;
\& use base qw(HTTP::Server::Simple::CGI);
\& 
\& sub handle_request {
\&     my ($self, $cgi) = @_;
\&
\&     #... do something, print output to default
\&     # selected filehandle...
\&
\& }
\& 
\& 1;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a simple standalone \s-1HTTP\s0 server. By default, it doesn't thread
or fork. It does, however, act as a simple frontend which can be used
to build a standalone web-based application or turn a \s-1CGI\s0 into one.
.PP
It is possible to use Net::Server classes to create forking,
pre-forking, and other types of more complicated servers; see
\&\*(L"net_server\*(R".
.PP
By default, the server traps a few signals:
.IP "\s-1HUP\s0" 4
.IX Item "HUP"
When you \f(CW\*(C`kill \-HUP\*(C'\fR the server, it lets the current request finish being
processed, then uses the \f(CW\*(C`restart\*(C'\fR method to re-exec itself. Please note that
in order to provide restart-on-SIGHUP, HTTP::Server::Simple sets a \s-1SIGHUP\s0
handler during initialisation. If your request handling code forks you need to
make sure you reset this or unexpected things will happen if somebody sends a
\&\s-1HUP\s0 to all running processes spawned by your app (e.g. by \*(L"kill \-HUP <script>\*(R")
.IP "\s-1PIPE\s0" 4
.IX Item "PIPE"
If the server detects a broken pipe while writing output to the client, 
it ignores the signal. Otherwise, a client closing the connection early 
could kill the server.
.SH "EXAMPLE"
.IX Header "EXAMPLE"
.Vb 3
\& #!/usr/bin/perl
\& {
\& package MyWebServer;
\& 
\& use HTTP::Server::Simple::CGI;
\& use base qw(HTTP::Server::Simple::CGI);
\& 
\& my %dispatch = (
\&     \*(Aq/hello\*(Aq => \e&resp_hello,
\&     # ...
\& );
\& 
\& sub handle_request {
\&     my $self = shift;
\&     my $cgi  = shift;
\&   
\&     my $path = $cgi\->path_info();
\&     my $handler = $dispatch{$path};
\& 
\&     if (ref($handler) eq "CODE") {
\&         print "HTTP/1.0 200 OK\er\en";
\&         $handler\->($cgi);
\&         
\&     } else {
\&         print "HTTP/1.0 404 Not found\er\en";
\&         print $cgi\->header,
\&               $cgi\->start_html(\*(AqNot found\*(Aq),
\&               $cgi\->h1(\*(AqNot found\*(Aq),
\&               $cgi\->end_html;
\&     }
\& }
\& 
\& sub resp_hello {
\&     my $cgi  = shift;   # CGI.pm object
\&     return if !ref $cgi;
\&     
\&     my $who = $cgi\->param(\*(Aqname\*(Aq);
\&     
\&     print $cgi\->header,
\&           $cgi\->start_html("Hello"),
\&           $cgi\->h1("Hello $who!"),
\&           $cgi\->end_html;
\& }
\& 
\& } 
\& 
\& # start the server on port 8080
\& my $pid = MyWebServer\->new(8080)\->background();
\& print "Use \*(Aqkill $pid\*(Aq to stop server.\en";
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "HTTP::Server::Simple\->new($port)"
.IX Subsection "HTTP::Server::Simple->new($port)"
\&\s-1API\s0 call to start a new server.  Does not actually start listening
until you call \f(CW\*(C`\->run()\*(C'\fR.  If omitted, \f(CW$port\fR defaults to 8080.
.SS "lookup_localhost"
.IX Subsection "lookup_localhost"
Looks up the local host's \s-1IP\s0 address, and returns it.  For most hosts,
this is \f(CW127.0.0.1\fR.
.SS "port [\s-1NUMBER\s0]"
.IX Subsection "port [NUMBER]"
Takes an optional port number for this server to listen on.
.PP
Returns this server's port. (Defaults to 8080)
.SS "host [address]"
.IX Subsection "host [address]"
Takes an optional host address for this server to bind to.
.PP
Returns this server's bound address (if any).  Defaults to \f(CW\*(C`undef\*(C'\fR
(bind to all interfaces).
.SS "background [\s-1ARGUMENTS\s0]"
.IX Subsection "background [ARGUMENTS]"
Runs the server in the background, and returns the process \s-1ID\s0 of the
started process.  Any arguments will be passed through to \*(L"run\*(R".
.SS "run [\s-1ARGUMENTS\s0]"
.IX Subsection "run [ARGUMENTS]"
Run the server.  If all goes well, this won't ever return, but it will
start listening for \f(CW\*(C`HTTP\*(C'\fR requests.  Any arguments passed to this
will be passed on to the underlying Net::Server implementation, if
one is used (see \*(L"net_server\*(R").
.SS "net_server"
.IX Subsection "net_server"
User-overridable method. If you set it to a Net::Server subclass,
that subclass is used for the \f(CW\*(C`run\*(C'\fR method.  Otherwise, a minimal
implementation is used as default.
.SS "restart"
.IX Subsection "restart"
Restarts the server. Usually called by a \s-1HUP\s0 signal, not directly.
.SS "stdio_handle [\s-1FILEHANDLE\s0]"
.IX Subsection "stdio_handle [FILEHANDLE]"
When called with an argument, sets the socket to the server to that arg.
.PP
Returns the socket to the server; you should only use this for actual socket-related
calls like \f(CW\*(C`getsockname\*(C'\fR.  If all you want is to read or write to the socket,
you should use \f(CW\*(C`stdin_handle\*(C'\fR and \f(CW\*(C`stdout_handle\*(C'\fR to get the in and out filehandles
explicitly.
.SS "stdin_handle"
.IX Subsection "stdin_handle"
Returns a filehandle used for input from the client.  By default,
returns whatever was set with \f(CW\*(C`stdio_handle\*(C'\fR, but a subclass could do
something interesting here.
.SS "stdout_handle"
.IX Subsection "stdout_handle"
Returns a filehandle used for output to the client.  By default, 
returns whatever was set with \f(CW\*(C`stdio_handle\*(C'\fR, but a subclass
could do something interesting here.
.SH "IMPORTANT SUB-CLASS METHODS"
.IX Header "IMPORTANT SUB-CLASS METHODS"
A selection of these methods should be provided by sub-classes of this
module.
.SS "handler"
.IX Subsection "handler"
This method is called after setup, with no parameters.  It should
print a valid, \fIfull\fR \s-1HTTP\s0 response to the default selected
filehandle.
.ie n .SS "setup(name => $value, ...)"
.el .SS "setup(name => \f(CW$value\fP, ...)"
.IX Subsection "setup(name => $value, ...)"
This method is called with a name => value list of various things
to do with the request.  This list is given below.
.PP
The default setup handler simply tries to call methods with the names
of keys of this list.
.PP
.Vb 12
\&  ITEM/METHOD   Set to                Example
\&  \-\-\-\-\-\-\-\-\-\-\-  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  method       Request Method        "GET", "POST", "HEAD"
\&  protocol     HTTP version          "HTTP/1.1"
\&  request_uri  Complete Request URI  "/foobar/baz?foo=bar"
\&  path         Path part of URI      "/foobar/baz"
\&  query_string Query String          undef, "foo=bar"
\&  port         Received Port         80, 8080
\&  peername     Remote name           "200.2.4.5", "foo.com"
\&  peeraddr     Remote address        "200.2.4.5", "::1"
\&  peerport     Remote port           42424
\&  localname    Local interface       "localhost", "myhost.com"
.Ve
.ie n .SS "headers([Header => $value, ...])"
.el .SS "headers([Header => \f(CW$value\fP, ...])"
.IX Subsection "headers([Header => $value, ...])"
Receives \s-1HTTP\s0 headers and does something useful with them.  This is
called by the default \f(CW\*(C`setup()\*(C'\fR method.
.PP
You have lots of options when it comes to how you receive headers.
.PP
You can, if you really want, define \f(CW\*(C`parse_headers()\*(C'\fR and parse them
raw yourself.
.PP
Secondly, you can intercept them very slightly cooked via the
\&\f(CW\*(C`setup()\*(C'\fR method, above.
.PP
Thirdly, you can leave the \f(CW\*(C`setup()\*(C'\fR header as-is (or calling the
superclass \f(CW\*(C`setup()\*(C'\fR for unknown request items).  Then you can define
\&\f(CW\*(C`headers()\*(C'\fR in your sub-class and receive them all at once.
.PP
Finally, you can define handlers to receive individual \s-1HTTP\s0 headers.
This can be useful for very simple \s-1SOAP\s0 servers (to name a
crack-fueled standard that defines its own special \s-1HTTP\s0 headers).
.PP
To do so, you'll want to define the \f(CW\*(C`header()\*(C'\fR method in your subclass.
That method will be handed a (key,value) pair of the header name and the value.
.SS "accept_hook"
.IX Subsection "accept_hook"
If defined by a sub-class, this method is called directly after an
accept happens.  An accept_hook to add \s-1SSL\s0 support might look like this:
.PP
.Vb 3
\&    sub accept_hook {
\&        my $self = shift;
\&        my $fh   = $self\->stdio_handle;
\&
\&        $self\->SUPER::accept_hook(@_);
\&
\&        my $newfh =
\&        IO::Socket::SSL\->start_SSL( $fh, 
\&            SSL_server    => 1,
\&            SSL_use_cert  => 1,
\&            SSL_cert_file => \*(Aqmyserver.crt\*(Aq,
\&            SSL_key_file  => \*(Aqmyserver.key\*(Aq,
\&        )
\&        or warn "problem setting up SSL socket: " . IO::Socket::SSL::errstr();
\&
\&        $self\->stdio_handle($newfh) if $newfh;
\&    }
.Ve
.SS "post_setup_hook"
.IX Subsection "post_setup_hook"
If defined by a sub-class, this method is called after all setup has
finished, before the handler method.
.SS "print_banner"
.IX Subsection "print_banner"
This routine prints a banner before the server request-handling loop
starts.
.PP
Methods below this point are probably not terribly useful to define
yourself in subclasses.
.SS "parse_request"
.IX Subsection "parse_request"
Parse the \s-1HTTP\s0 request line.  Returns three values, the request
method, request \s-1URI\s0 and the protocol.
.SS "parse_headers"
.IX Subsection "parse_headers"
Parses incoming \s-1HTTP\s0 headers from \s-1STDIN\s0, and returns an arrayref of
\&\f(CW\*(C`(header => value)\*(C'\fR pairs.  See \*(L"headers\*(R" for possibilities on
how to inspect headers.
.SS "setup_listener"
.IX Subsection "setup_listener"
This routine binds the server to a port and interface.
.SS "after_setup_listener"
.IX Subsection "after_setup_listener"
This method is called immediately after setup_listener. It's here just
for you to override.
.SS "bad_request"
.IX Subsection "bad_request"
This method should print a valid \s-1HTTP\s0 response that says that the
request was invalid.
.SS "valid_http_method($method)"
.IX Subsection "valid_http_method($method)"
Given a candidate \s-1HTTP\s0 method in \f(CW$method\fR, determine if it is valid.
Override if, for example, you'd like to do some WebDAV.  The default
implementation only accepts \f(CW\*(C`GET\*(C'\fR, \f(CW\*(C`POST\*(C'\fR, \f(CW\*(C`HEAD\*(C'\fR, \f(CW\*(C`PUT\*(C'\fR, and
\&\f(CW\*(C`DELETE\*(C'\fR.
.SH "AUTHOR"
.IX Header "AUTHOR"
Copyright (c) 2004\-2008 Jesse Vincent, <jesse@bestpractical.com>.
All rights reserved.
.PP
Marcus Ramberg <drave@thefeed.no> contributed tests, cleanup, etc
.PP
Sam Vilain, <samv@cpan.org> contributed the \s-1CGI\s0.pm split-out and
header/setup \s-1API\s0.
.PP
Example section by almut on perlmonks, suggested by Mark Fuller.
.SH "BUGS"
.IX Header "BUGS"
There certainly are some. Please report them via rt.cpan.org
.SH "LICENSE"
.IX Header "LICENSE"
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
