.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Class::DBI::Lite 3"
.TH Class::DBI::Lite 3 "2012-05-07" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Class::DBI::Lite \- Lightweight ORM for Perl
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Please take a look at Class::DBI::Lite::Tutorial for an introduction to using this module.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Class::DBI::Lite\*(C'\fR offers a simple way to deal with databases in an object-oriented way.
.PP
One class (the \fBModel\fR class) defines your connection to the database (eg: connectionstring, username and password)
and your other classes define interaction with one table each (your \fBentity\fR classes).
.PP
The Entity classes subclass the Model class and automatically inherit its connection.
.PP
\&\f(CW\*(C`Class::DBI::Lite\*(C'\fR relies heavily on Ima::DBI::Contextual, SQL::Abstract and Scalar::Util.
.PP
\&\f(CW\*(C`Class::DBI::Lite\*(C'\fR does not leak memory and is well-suited for use within mod_perl, Fast \s-1CGI\s0, \s-1CGI\s0
and anywhere else you might need it.
.SH "BACKGROUND"
.IX Header "BACKGROUND"
I used Class::DBI for a few years, a few years ago, on a very large project, under mod_perl.
This was back in 2002\-2003 when the \s-1ORM\s0 (Object-Relational Mapper) scene was still fairly new.
.PP
While it saved me a great deal of typing, I was amazed at the complexity of \f(CW\*(C`Class::DBI\*(C'\fR's internal code.
After some time I found myself spending more effort working around problems caused by \f(CW\*(C`Class::DBI\*(C'\fR
than I could stand.
.PP
Many people encountered the same problems I encountered (transactions, database connection sharing issues, performance, etc)
and they all went and began writing DBIx::Class.
.PP
DBIx::Class went in a direction away from the database while I wanted to get closer to
the database.  As close as I could possibly get without wasting time.  I also wanted
to keep some simple logic in my Entity classes (those classes that represent individual tables).
I didn't want my \s-1ORM\s0 to do too much magic, think too much or do anything not immediately apparent.
I didn't care about many-to-many relationships or automatic \s-1SQL\s0 join clauses.  Vendor-specific
\&\s-1LIMIT\s0 expressions simply were not a concern of mine.
.PP
So...I reimplemented (most) of the \f(CW\*(C`Class::DBI\*(C'\fR interface in a way that I preferred.  I left out some
things that didn't matter to me (eg: many-to-many relationships, column groups) and added some things
I needed frequently (eg: transactions, single-field triggers, mod_perl compatibility).
.SH "PHILOSOPHY"
.IX Header "PHILOSOPHY"
\&\f(CW\*(C`Class::DBI::Lite\*(C'\fR is intended to minimize the boiler-plate code typically written
in most applications.  It is not intended to completely insulate developers from
interacting with the database directly.
.PP
\&\f(CW\*(C`Class::DBI::Lite\*(C'\fR is not a way to avoid \fIlearning\fR \s-1SQL\s0 \- it is a way to avoid \fIwriting\fR
boring, repetitive, \*(L"boiler-plate\*(R" \s-1SQL\s0.
.SH "PUBLIC PROPERTIES"
.IX Header "PUBLIC PROPERTIES"
.ie n .SS "connection( $dsn, $username, $password )"
.el .SS "connection( \f(CW$dsn\fP, \f(CW$username\fP, \f(CW$password\fP )"
.IX Subsection "connection( $dsn, $username, $password )"
Sets the \s-1DSN\s0 for your classes.
.PP
.Vb 1
\&  package App::db::model;
\&  
\&  use base \*(AqClass::DBI::Lite::mysql\*(Aq;
\&  
\&  _\|_PACKAGE_\|_\->connection(\*(AqDBI:mysql:dbname:localhost\*(Aq, \*(Aqusername\*(Aq, \*(Aqpassword\*(Aq );
.Ve
.SS "db_Main"
.IX Subsection "db_Main"
Returns the active database handle in use by the class.
.PP
Example:
.PP
.Vb 4
\&  my $dbh = App::db::artist\->db_Main;
\&  my $sth = $dbh\->prepare("select * from artists");
\&  $sth\->execute();
\&  ...
.Ve
.SS "table"
.IX Subsection "table"
Returns the name of the table that the class is assigned to.
.PP
Example:
.PP
.Vb 1
\&  print App::db::artist\->table; # \*(Aqartists\*(Aq
.Ve
.SS "columns"
.IX Subsection "columns"
Returns a list of field names in the table that the class represents.
.PP
Given the following table:
.PP
.Vb 4
\&  create table artists (
\&    artist_id   integer unsigned not null primary key auto_increment,
\&    name        varchar(100) not null,
\&  ) engine=innodb charset=utf8;
.Ve
.PP
We get this:
.PP
.Vb 2
\&  print join ", ", App::db::artist\->columns;
\&  # artist_id, name
.Ve
.SS "trace( 1:0 )"
.IX Subsection "trace( 1:0 )"
(New in version 1.018)
.PP
Setting \f(CW\*(C`trace\*(C'\fR to 1 or 0 will turn on or off \s-1SQL\s0 logging to \s-1STDERR\s0.
.PP
Example:
.PP
.Vb 2
\&  # Start seeing all the SQL:
\&  App::db::artist\->trace( 1 );
\&  
\&  # We will see some SQL when the next line is executed:
\&  my @users = App::db::artist\->search_like( name => \*(AqRob%\*(Aq );
\&  
\&  # Turn it off again:
\&  App::db::artist\->trace( 0 );
.Ve
.PP
By default, \f(CW\*(C`trace\*(C'\fR is turned off.
.SH "STATIC METHODS"
.IX Header "STATIC METHODS"
.ie n .SS "create( %info )"
.el .SS "create( \f(CW%info\fP )"
.IX Subsection "create( %info )"
Creates a new object and returns it.
.PP
Example:
.PP
.Vb 1
\&  my $artist = App::db::artist\->create( name => \*(AqBob Marley\*(Aq );
.Ve
.ie n .SS "find_or_create( %info )"
.el .SS "find_or_create( \f(CW%info\fP )"
.IX Subsection "find_or_create( %info )"
Using \f(CW%info\fR a search will be performed.  If a matching result is found it is returned.  Otherwise
a new record will be created using \f(CW%info\fR as arguments.
.PP
Example:
.PP
.Vb 1
\&  my $artist = App::db::artist\->find_or_create( name => \*(AqBob Marley\*(Aq );
.Ve
.ie n .SS "retrieve( $id )"
.el .SS "retrieve( \f(CW$id\fP )"
.IX Subsection "retrieve( $id )"
Given the id of a record in the database, returns that object.
.PP
Example:
.PP
.Vb 1
\&  my $artist = App::db::artist\->retrieve( 1 );
.Ve
.PP
Same as the following \s-1SQL:\s0
.PP
.Vb 3
\&  SELECT *
\&  FROM artists
\&  WHERE artist_id = 1
.Ve
.SS "retrieve_all( )"
.IX Subsection "retrieve_all( )"
Returns all objects in the database table.
.PP
Example:
.PP
.Vb 1
\&  my @artists = App::db::artist\->retrieve_all;
.Ve
.PP
Same as the following \s-1SQL:\s0
.PP
.Vb 1
\&  SELECT * FROM artists
.Ve
.PP
\&\fB\s-1NOTE:\s0\fR If you want to sort all of the records or do paging, use \f(CW\*(C`search_where\*(C'\fR
like this:
.PP
.Vb 1
\&  my @artists = App::db::artist\->search_where({ 1 => 1}, {order_by => \*(Aqname DESC\*(Aq});
.Ve
.PP
Same as the following \s-1SQL:\s0
.PP
.Vb 4
\&  SELECT *
\&  FROM artists
\&  WHERE 1 = 1
\&  ORDER BY name DESC
.Ve
.PP
That "\f(CW\*(C`WHERE 1 = 1\*(C'\fR\*(L" is a funny way of telling the database \*(R"give them all to me".
.SS "has_many( ... )"
.IX Subsection "has_many( ... )"
Declares a \*(L"one-to-many\*(R" relationship between this two classes.
.PP
.Vb 7
\&  package App::db::artist;
\&  ...
\&  _\|_PACKAGE_\|_\->has_many(
\&    albums  =>
\&      \*(AqApp::db::album\*(Aq =>
\&        \*(Aqalbum_id\*(Aq
\&  );
.Ve
.PP
The syntax is:
.PP
.Vb 5
\&  _\|_PACKAGE_\|_\->has_many(
\&    $what_they_are_called =>
\&      $the_class_name =>
\&        $the_foreign_key_field_from_the_other_class
\&  );
.Ve
.PP
The result is this:
.PP
.Vb 2
\&  my @albums = $artist\->albums;
\&  $artist\->add_to_albums( name => \*(AqLegend\*(Aq );
.Ve
.PP
That's the same as:
.PP
.Vb 3
\&  my @albums = App::db::artist\->search(
\&    artist_id => $artist\->id
\&  );
.Ve
.SS "belongs_to( ... )"
.IX Subsection "belongs_to( ... )"
Declares that instances \*(L"this\*(R" class exists only as a feature of instances of another class.
.PP
For example, \*(L"songs\*(R" exist as features of \*(L"albums\*(R" \- not the other way around.
.PP
Example:
.PP
.Vb 7
\&  package App::db::album;
\&  ...
\&  _\|_PACKAGE_\|_\->belongs_to(
\&    artist  =>
\&      \*(AqApp::db::artist\*(Aq =>
\&        \*(Aqartist_id\*(Aq
\&  );
.Ve
.PP
So that's:
.PP
.Vb 5
\&  _\|_PACKAGE_\|_\->belongs_to(
\&    $the_method_name =>
\&      $the_class_name =>
\&        $my_foreign_key_field
\&  );
.Ve
.ie n .SS "construct( $hashref )"
.el .SS "construct( \f(CW$hashref\fP )"
.IX Subsection "construct( $hashref )"
Blesses the object into the given class, even if we don't have all the information
about the object (as long as we get its primary field value).
.PP
Example:
.PP
.Vb 2
\&  for( 1..5 ) {
\&    my $artist = App::db::artist\->construct({ artist_id => $_ });
\&    
\&    # name is automatically "fleshed out":
\&    print $artist\->name;
\&  }
.Ve
.SS "eval { do_transaction( sub { ... } ) }"
.IX Subsection "eval { do_transaction( sub { ... } ) }"
Executes a block of code within the context of a transaction.
.PP
Example:
.PP
.Vb 3
\&  # Safely update the name of every album:
\&  eval {
\&    App::db::artist\->do_transaction( sub {
\&    
\&      # Your transaction code goes here:
\&      my $artist = App::db::artist\->retrieve( 1 );
\&      foreach my $album ( $artist\->albums ) {
\&        $album\->name( $artist\->name . \*(Aq: \*(Aq . $album\->name );
\&        $album\->update;
\&      }
\&    });
\&  };
\&  
\&  if( $@ ) {
\&    # There was an error:
\&    die $@;
\&  }
\&  else {
\&    # Everything was OK:
\&  }
.Ve
.ie n .SS "search( %args )"
.el .SS "search( \f(CW%args\fP )"
.IX Subsection "search( %args )"
Returns any objects that match all elements in \f(CW%args\fR.
.PP
Example:
.PP
.Vb 1
\&  my @artists = App::db::artist\->search( name => \*(AqBob Marley\*(Aq );
\&  
\&  my $artist_iterator = App::db::artist\->search( name => \*(AqBob Marley\*(Aq );
.Ve
.PP
Returns an array in list context or a Class::DBI::Lite::Iterator in scalar context.
.ie n .SS "search_like( %args )"
.el .SS "search_like( \f(CW%args\fP )"
.IX Subsection "search_like( %args )"
Returns any objects that match all elements in \f(CW%args\fR using the \f(CW\*(C`LIKE\*(C'\fR operator.
.PP
Example:
.PP
.Vb 1
\&  my @artists = App::db::artist\->search_like( name => \*(AqBob%\*(Aq );
\&  
\&  my $artist_iterator = App::db::artist\->search_like( name => \*(AqBob%\*(Aq );
.Ve
.PP
Returns an array in list context or a Class::DBI::Lite::Iterator in scalar context.
.PP
Both examples would execute the following \s-1SQL:\s0
.PP
.Vb 1
\&  SELECT * FROM artists WHERE name LIKE \*(AqBob%\*(Aq
.Ve
.SS "search_where( \e%args, [\e%sort_and_limit] )"
.IX Subsection "search_where( %args, [%sort_and_limit] )"
Returns any objects that match all elements in \f(CW%args\fR as specified by \f(CW%sort_and_limit\fR.
.PP
Returns an array in list context or a Class::DBI::Lite::Iterator in scalar context.
.PP
Example 1:
.PP
.Vb 3
\&  my @artists = App::db::artist\->search_where({
\&    name => \*(AqBob Marley\*(Aq
\&  });
.Ve
.PP
Same as this \s-1SQL:\s0
.PP
.Vb 3
\&  SELECT *
\&  FROM artists
\&  WHERE name = \*(AqBob Marley\*(Aq
.Ve
.PP
Example 2:
.PP
.Vb 5
\&  my @artists = App::db::artist\->search_where({
\&    name => \*(AqBob Marley\*(Aq
\&  }, {
\&    order_by => \*(Aqname ASC LIMIT 0, 10\*(Aq
\&  });
.Ve
.PP
Same as this \s-1SQL:\s0
.PP
.Vb 5
\&  SELECT *
\&  FROM artists
\&  WHERE name = \*(AqBob Marley\*(Aq
\&  ORDER BY name
\&  LIMIT 0, 10
.Ve
.PP
Example 3:
.PP
.Vb 4
\&  my @artists = App::db::artist\->search_where([
\&    name => { \*(Aq!=\*(Aq => \*(AqBob Marley\*(Aq },
\&    genre => \*(AqRock\*(Aq,
\&  ]);
.Ve
.PP
Same as this \s-1SQL:\s0
.PP
.Vb 4
\&  SELECT *
\&  FROM artists
\&  WHERE name != \*(AqBob Marley\*(Aq
\&  OR genre = \*(AqRock\*(Aq
.Ve
.PP
Because \f(CW\*(C`search_where\*(C'\fR uses SQL::Abstract to generate the \s-1SQL\s0 for the database,
you can look there for more detailed examples.
.PP
Specifying OrderBy, Limit and Offset separately:
.PP
.Vb 7
\&  my @artists = App::db::artist\->search_where({
\&    name => \*(AqBob Marley\*(Aq
\&  }, {
\&    order_by  => \*(Aqname ASC\*(Aq,
\&    limit     => $how_many,
\&    offset    => $start_where,
\&  });
.Ve
.PP
So if your \f(CW$how_many\fR were 10, and your \f(CW$start_where\fR were zero (\f(CW0\fR) then that would be the same as:
.PP
.Vb 5
\&  SELECT *
\&  FROM artists
\&  WHERE name = \*(AqBob Marley\*(Aq
\&  ORDER BY name ASC
\&  LIMIT 0, 10
.Ve
.ie n .SS "count_search( %args )"
.el .SS "count_search( \f(CW%args\fP )"
.IX Subsection "count_search( %args )"
Returns the number of records that match \f(CW%args\fR.
.PP
Example:
.PP
.Vb 1
\&  my $count = App::db::album\->count_search( name => \*(AqGreatest Hits\*(Aq );
.Ve
.ie n .SS "count_search_like( %args )"
.el .SS "count_search_like( \f(CW%args\fP )"
.IX Subsection "count_search_like( %args )"
Returns the number of records that match \f(CW%args\fR using the \f(CW\*(C`LIKE\*(C'\fR operator.
.PP
Example:
.PP
.Vb 3
\&  my $count = App::db::artist\->count_search_like(
\&    name  => \*(AqBob%\*(Aq
\&  );
.Ve
.SS "count_search_where( \e%args )"
.IX Subsection "count_search_where( %args )"
Returns the number of records that match \f(CW\*(C`\e%args\*(C'\fR.
.PP
Examples:
.PP
.Vb 3
\&  my $count = App::db::album\->count_search_where({
\&    name  => { LIKE => \*(AqBest Of%\*(Aq }
\&  });
\&  
\&  my $count = App::db::album\->count_search_where({
\&    genre => { \*(Aq!=\*(Aq => \*(AqCountry/Western\*(Aq }
\&  });
.Ve
.PP
As with \f(CW\*(C`search_where()\*(C'\fR, the \f(CW\*(C`count_search_where()\*(C'\fR class method uses SQL::Abstract
to generate the \s-1SQL\s0 for the database.
.ie n .SS "sth_to_objects( $sth )"
.el .SS "sth_to_objects( \f(CW$sth\fP )"
.IX Subsection "sth_to_objects( $sth )"
Takes a statement handle that is ready to fetch records from.  Returns the results
as objects.
.PP
Example:
.PP
.Vb 3
\&  my $sth = App::db::artist\->db_Main\->prepare("SELECT * FROM artists");
\&  $sth\->execute();
\&  my @artists = App::db::artist\->sth_to_objects( $sth );
.Ve
.PP
This method is very useful for when your \s-1SQL\s0 query is too complicated for \f(CW\*(C`search_where()\*(C'\fR.
.ie n .SS "add_trigger( $event => \e&sub )"
.el .SS "add_trigger( \f(CW$event\fP => \e&sub )"
.IX Subsection "add_trigger( $event => &sub )"
Specifies a callback to be executed when a specific event happens.
.PP
Examples:
.PP
.Vb 4
\&  package App::db::artist;
\&  ...
\&  _\|_PACKAGE_\|_\->add_trigger( after_create => sub {
\&    my ($self) = @_;
\&    
\&    warn "You just created a new artist: " . $self\->name;
\&  });
.Ve
.PP
There are 6 main trigger points at the class level and 2 trigger points for
every field:
.PP
\fIClass Triggers\fR
.IX Subsection "Class Triggers"
.PP
before_create( \f(CW$self\fR )
.IX Subsection "before_create( $self )"
.PP
Called just before a new record is created.  \f(CW$self\fR is a hashref blessed into
the object's class and contains only the values that were provided for its creation.
.PP
So, given this trigger:
.PP
.Vb 4
\&  package App::db::album;
\&  ...
\&  _\|_PACKAGE_\|_\->add_trigger( before_create => sub {
\&    my ($self) = @_;
\&    
\&    warn "ID = \*(Aq$self\->{album_id}\*(Aq, Name = \*(Aq$self\->{name}";
\&  });
.Ve
.PP
If we ran this code:
.PP
.Vb 1
\&  my $album = App::db::album\->create( name => \*(AqLegend\*(Aq );
.Ve
.PP
We would see this output:
.PP
.Vb 1
\&  ID = \*(Aq\*(Aq, Name = \*(AqLegend\*(Aq
.Ve
.PP
Because the value for \f(CW\*(C`album_id\*(C'\fR has not been assigned by the database it does
not yet have a value.
.PP
after_create( \f(CW$self\fR )
.IX Subsection "after_create( $self )"
.PP
Called just after a new record is created.  \f(CW$self\fR is the new object itself.
.PP
So given this trigger:
.PP
.Vb 4
\&  package App::db::album;
\&  ...
\&  _\|_PACKAGE_\|_\->add_trigger( after_create => sub {
\&    my ($self) = @_;
\&    
\&    warn "ID = \*(Aq$self\->{album_id}\*(Aq, Name = \*(Aq$self\->{name}";
\&  });
.Ve
.PP
If we ran this code:
.PP
.Vb 1
\&  my $album = App::db::album\->create( name => \*(AqLegend\*(Aq );
.Ve
.PP
We would see this output:
.PP
.Vb 1
\&  ID = \*(Aq1\*(Aq, Name = \*(AqLegend\*(Aq
.Ve
.PP
before_update( \f(CW$self\fR )
.IX Subsection "before_update( $self )"
.PP
Called just before changes are saved to the database.  \f(CW$self\fR is the object
to be updated.
.PP
Example:
.PP
.Vb 4
\&  package App::db::album;
\&  ...
\&  _\|_PACKAGE_\|_\->add_trigger( before_update => sub {
\&    my ($self) = @_;
\&    
\&    warn "About to update album " . $self\->name;
\&  });
.Ve
.PP
after_update( \f(CW$self\fR )
.IX Subsection "after_update( $self )"
.PP
Called just after changes are saved to the database.  \f(CW$self\fR is the object
that was updated.
.PP
Example:
.PP
.Vb 4
\&  package App::db::album;
\&  ...
\&  _\|_PACKAGE_\|_\->add_trigger( after_update => sub {
\&    my ($self) = @_;
\&    
\&    warn "Finished updating album " . $self\->name;
\&  });
.Ve
.PP
\&\fB\s-1NOTE:\s0\fR If you make changes to \f(CW$self\fR from within an \f(CW\*(C`after_update\*(C'\fR you could
enter into a recursive loop in which an update is made that causes an update to
be made which causes an update to be made which causes an update to be made which causes an update to be made which
causes an update to be made which causes an update to be made which causes an update to be made which
causes an update to be made which causes an update to be made which causes an update to be made which
causes an update to be made which causes an update to be made which causes an update to be made which
causes an update to be made which causes an update to be made which causes an update to be made which
causes an update to be made which causes an update to be made which causes an update to be made which...and so on.
.PP
\&\fB\s-1DO\s0 \s-1NOT\s0 \s-1DO\s0 \s-1THIS\s0\fR:
.PP
.Vb 4
\&  package App::db::album;
\&  ...
\&  _\|_PACKAGE_\|_\->add_trigger( after_update => sub {
\&    my ($self) = @_;
\&    
\&    # This will cause problems:
\&    warn "Making a recursive problem:";
\&    $self\->name( \*(AqHello \*(Aq . rand() );
\&    $self\->update;
\&  });
.Ve
.PP
before_delete( \f(CW$self\fR )
.IX Subsection "before_delete( $self )"
.PP
Called just before something is deleted.
.PP
Example:
.PP
.Vb 4
\&  package App::db::album;
\&  ...
\&  _\|_PACKAGE_\|_\->add_trigger( before_delete => sub {
\&    my ($self) = @_;
\&    
\&    warn "About to delete " . $self\->name;
\&  });
.Ve
.PP
after_delete( {$primary_field => \f(CW$id\fR} )
.IX Subsection "after_delete( {$primary_field => $id} )"
.PP
Called just after something is deleted.
.PP
\&\fB\s-1NOTE:\s0\fR Since the object itself is deleted from the database \fBand\fR memory, all
that is left is the id of the original object.
.PP
So, given this trigger...
.PP
.Vb 5
\&  package App::db::album;
\&  ...
\&  use Data::Dumper;
\&  _\|_PACKAGE_\|_\->add_trigger( after_delete => sub {
\&    my ($obj) = @_;
\&    
\&    warn "Deleted an album: " . Dumper($obj);
\&  });
.Ve
.PP
\&...we might see the following output:
.PP
.Vb 3
\&  Deleted an album: $VAR1 = {
\&    album_id => 123
\&  };
.Ve
.PP
\fIField Triggers\fR
.IX Subsection "Field Triggers"
.PP
before_update_<field>( \f(CW$self\fR, \f(CW$old_value\fR, \f(CW$new_value\fR )
.IX Subsection "before_update_<field>( $self, $old_value, $new_value )"
.PP
Called just \fBbefore\fR a field's value is updated.
.PP
So, given the following trigger...
.PP
.Vb 4
\&  package App::db::album;
\&  ...
\&  _\|_PACKAGE_\|_\->add_trigger( before_update_name => sub {
\&    my ($self, $old_value, $new_value) = @_;
\&    
\&    warn "About to change name from \*(Aq$old_value\*(Aq to \*(Aq$new_value\*(Aq";
\&  });
.Ve
.PP
\&...called with the following code...
.PP
.Vb 2
\&  my $artist = App::db::artist\->create( name => \*(AqBob Marley\*(Aq );
\&  my $album = $artist\->add_to_albums( name => \*(AqLegend\*(Aq );
\&  
\&  # Now change the name:
\&  $album\->name( \*(AqGreatest Hits\*(Aq );
\&  $album\->update; # <\-\-\- the trigger is called right here.
.Ve
.PP
\&...we would see the following output:
.PP
.Vb 1
\&  About to change the name from \*(AqLegend\*(Aq to \*(AqGreatest Hits\*(Aq
.Ve
.PP
after_update_<field>( \f(CW$self\fR, \f(CW$old_value\fR, \f(CW$new_value\fR )
.IX Subsection "after_update_<field>( $self, $old_value, $new_value )"
.PP
Called just \fBafter\fR a field's value is updated.
.PP
So, given the following trigger...
.PP
.Vb 4
\&  package App::db::album;
\&  ...
\&  _\|_PACKAGE_\|_\->add_trigger( after_update_name => sub {
\&    my ($self, $old_value, $new_value) = @_;
\&    
\&    warn "Changed name from \*(Aq$old_value\*(Aq to \*(Aq$new_value\*(Aq";
\&  });
.Ve
.PP
\&...called with the following code...
.PP
.Vb 2
\&  my $artist = App::db::artist\->create( name => \*(AqBob Marley\*(Aq );
\&  my $album = $artist\->add_to_albums( name => \*(AqLegend\*(Aq );
\&  
\&  # Now change the name:
\&  $album\->name( \*(AqGreatest Hits\*(Aq );
\&  $album\->update; # <\-\-\- the trigger is called right here.
.Ve
.PP
\&...we would see the following output:
.PP
.Vb 1
\&  Changed the name from \*(AqLegend\*(Aq to \*(AqGreatest Hits\*(Aq
.Ve
.ie n .SS "find_column( $name )"
.el .SS "find_column( \f(CW$name\fP )"
.IX Subsection "find_column( $name )"
Returns the name of the column, if the class has that column.
.PP
Example:
.PP
.Vb 3
\&  if( App::db::artist\->find_column(\*(Aqname\*(Aq) ) {
\&    warn "Artists have names!";
\&  }
.Ve
.SS "get_table_info( )"
.IX Subsection "get_table_info( )"
Returns a Class::DBI::Lite::TableInfo object fully-populated with all of the
information available about the table represented by a class.
.PP
So, given the following table structure:
.PP
.Vb 4
\&  create table artists (
\&    artist_id   integer unsigned not null primary key auto_increment,
\&    name        varchar(100) not null
\&  ) engine=innodb charset=utf8;
.Ve
.PP
Here is the example:
.PP
.Vb 1
\&  my $info = App::db::artist\->get_table_info();
\&  
\&  my $column = $info\->column(\*(Aqname\*(Aq);
\&  warn $column\->name;           # \*(Aqname\*(Aq
\&  warn $column\->type;           # varchar
\&  warn $column\->length;         # 100
\&  warn $column\->is_pk;          # \*(Aq0\*(Aq (because it\*(Aqs not the Primary Key)
\&  warn $column\->is_nullable;    # 0 (because \`not null\` was specified on the table)
\&  warn $column\->default_value;  # undef because no default value was specified
\&  warn $column\->key;            # undef because not UNIQUE or PRIMARY KEY
\&  
\&  foreach my $column ( $info\->columns ) {
\&    warn $column\->name;
\&    warn $column\->type;
\&    warn $column\->length;
\&    warn $column\->is_pk;
\&    ...
\&    # If the column is an \*(Aqenum\*(Aq field:
\&    warn join \*(Aq, \*(Aq, @{ $column\->enum_values };
\&  }
.Ve
.SS "pager( \e%where, { order_by => 'fields \s-1ASC\s0', page_number => 1, page_size => 10 } )"
.IX Subsection "pager( %where, { order_by => 'fields ASC', page_number => 1, page_size => 10 } )"
Returns a Class::DBI::Lite::Pager object.
.PP
Example:
.PP
.Vb 8
\&  # Step 1: Get our pager:
\&  my $pager = App::db::artist\->pager({
\&    name => { LIKE => \*(AqBob%\*(Aq }
\&  }, {
\&    order_by    => \*(Aqname ASC\*(Aq,
\&    page_number => 1,
\&    page_size   => 20,
\&  });
\&  
\&  # Step 2: Show the items in that recordset:
\&  foreach my $artist ( $pager\->items ) {
\&    # Do stuff with $artist:
\&    print $artist\->name;
\&  }
.Ve
.PP
See Class::DBI::Lite::Pager for more details and examples.
.ie n .SS "sql_pager( { data_sql => $str, count_sql => $str, sql_args => \e@array }, { page_number => 1, page_size => 10 } )"
.el .SS "sql_pager( { data_sql => \f(CW$str\fP, count_sql => \f(CW$str\fP, sql_args => \e@array }, { page_number => 1, page_size => 10 } )"
.IX Subsection "sql_pager( { data_sql => $str, count_sql => $str, sql_args => @array }, { page_number => 1, page_size => 10 } )"
Returns a Class::DBI::Lite::Pager object.
.PP
Example:
.PP
.Vb 9
\&  # Step 1: Get our pager:
\&  my $pager = App::db::artist\->sql_pager({
\&    data_sql  => "SELECT * FROM artists WHERE name LIKE ?",
\&    count_sql => "SELECT COUNT(*) FROM artists WHERE name LIKE ?",
\&    sql_args  => [ \*(AqBob%\*(Aq ],
\&  }, {
\&    page_number => 1,
\&    page_size   => 20,
\&  });
\&  
\&  # Step 2: Show the items in that recordset:
\&  foreach my $artist ( $pager\->items ) {
\&    # Do stuff with $artist:
\&    print $artist\->name;
\&  }
.Ve
.PP
See Class::DBI::Lite::Pager for more details and examples.
.SH "OBJECT METHODS"
.IX Header "OBJECT METHODS"
.SS "Field Methods"
.IX Subsection "Field Methods"
For each of the fields in your table, an \*(L"accessor\*(R" method will be created.
.PP
So, given the following table structure:
.PP
.Vb 4
\&  create table artists (
\&    artist_id   integer unsigned not null primary key auto_increment,
\&    name        varchar(100) not null,
\&  ) engine=innodb charset=utf8;
.Ve
.PP
And the following class:
.PP
.Vb 1
\&  package App::db::artist;
\&  
\&  use strict;
\&  use warnings \*(Aqall\*(Aq;
\&  use base \*(AqMy::Model\*(Aq;
\&  
\&  _\|_PACKAGE_\|_\->set_up_table(\*(Aqartists\*(Aq);
\&  
\&  1;# return true:
.Ve
.PP
The \f(CW\*(C`App::db::artist\*(C'\fR class would have the following methods created:
.IP "\(bu" 4
artist_id
.Sp
Returns the value of the \f(CW\*(C`artist_id\*(C'\fR field the database.  This value is read-only
and cannot be changed.
.IP "\(bu" 4
name
.Sp
Gets or sets the value of the \f(CW\*(C`name\*(C'\fR field the database.
.Sp
To get the value of the \f(CW\*(C`name\*(C'\fR field, do this:
.Sp
.Vb 1
\&  my $value = $artist\->name;
.Ve
.Sp
To set the value of the \f(CW\*(C`name\*(C'\fR field, do this:
.Sp
.Vb 1
\&  $artist\->name( "New Name" );
.Ve
.Sp
To save those changes to the database you must call \f(CW\*(C`update\*(C'\fR:
.Sp
.Vb 1
\&  $artist\->update;
.Ve
.SS "Overriding Setters and Getters"
.IX Subsection "Overriding Setters and Getters"
The accessors/mutators (\*(L"setters\*(R" and \*(L"getters\*(R") can be individually overridden
within your entity class by implementing \f(CW\*(C`_set_foo($self, $value)\*(C'\fR or
\&\f(CW\*(C`_get_foo($self)\*(C'\fR methods.
.PP
\&\fB\s-1NOTE:\s0\fR In practice this may be more useful for the \f(CW\*(C`_get_*\*(C'\fR methods, as the \f(CW\*(C`_set_*\*(C'\fR
methods are usually best left to triggers.
.SS "id"
.IX Subsection "id"
Always returns the value of the object's primary column.
.PP
Example:
.PP
.Vb 2
\&  $album\->id == $album\->album_id;
\&  $artist\->id == $artist\->artist_id;
.Ve
.SS "\fIupdate()\fP"
.IX Subsection "update()"
Causes any changes to an object to be saved to the database.
.PP
Example:
.PP
.Vb 2
\&  $artist\->name( \*(AqBig Bob\*(Aq );
\&  $artist\->update;
.Ve
.SS "\fIdelete()\fP"
.IX Subsection "delete()"
Deletes the object from the database.  The object is then re-blessed into the special
class \f(CW\*(C`Class::DBI::Lite::Object::Has::Been::Deleted\*(C'\fR.
.PP
Example:
.PP
.Vb 1
\&  $album\->delete;
.Ve
.SS "\fIdiscard_changes()\fP"
.IX Subsection "discard_changes()"
Causes any changes made to the object that have not been stored in the database
to be forgotten.
.PP
Example:
.PP
.Vb 2
\&  my $artist = App::db::artist\->create( name => \*(AqBob Marley\*(Aq );
\&  $artist\->name( \*(AqBig Bob\*(Aq );
\&  
\&  $artist\->discard_changes;
.Ve
.SH "ADVANCED TOPICS"
.IX Header "ADVANCED TOPICS"
.SS "Master/Slave Configuration"
.IX Subsection "Master/Slave Configuration"
In your My::db::model class:
.PP
Instead of:
.PP
.Vb 1
\&  _\|_PACKAGE_\|_\->connection( $dsn, $user, $pass );
.Ve
.PP
Do this:
.PP
.Vb 1
\&  _\|_PACKAGE_\|_\->set_master( $dsn, $user, $pass );
\&
\&  _\|_PACKAGE_\|_\->set_slaves(
\&    [ $dsn1, $user1, $pass1 ],
\&    [ $dsn2, $user2, $pass2 ],
\&    [ $dsn3, $user3, $pass3 ],
\&  );
.Ve
.PP
Your slaves will be shuffled.
.PP
Writes will always* go to the master, reads will always go to the slaves.
.PP
*Unless you are inside of a transaction, in which case all reads will also go to the master.
.PP
If you want to switch to a different slave, call 'switch_slave' on your main model class:
.PP
.Vb 1
\&  My::db::model\->switch_slave();
.Ve
.PP
In an \s-1ASP4\s0 environment you could add a line like that to an ASP4::RequestFilter.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Class::DBI::Lite::Tutorial
.SH "AUTHOR"
.IX Header "AUTHOR"
Copyright John Drago <jdrago_999@yahoo.com>.  All rights reserved.
.SH "LICENSE"
.IX Header "LICENSE"
This software is \fBFree\fR software and may be used and redistributed under the
same terms as perl itself.
