.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Data::Alias 3"
.TH Data::Alias 3 "2013-09-21" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Data::Alias \- Comprehensive set of aliasing operations
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Data::Alias;
\&
\&    alias {
\&            # aliasing instead of copying whenever possible
\&    };
\&
\&    alias $x = $y;              # alias $x to $y
\&    alias @x = @y;              # alias @x to @y
\&    alias $x[0] = $y;           # similar for array and hash elements
\&    alias push @x, $y;          # push alias to $y onto @x
\&    $x = alias [ $y, $z ];      # construct array of aliases
\&    alias my ($x, $y) = @_;     # named aliases to arguments
\&    alias { ($x, $y) = ($y, $x) };              # swap $x and $y
\&    alias { my @t = @x; @x = @y; @y = @t };     # swap @x and @y
\&
\&    use Data::Alias qw/ alias copy /;
\&
\&    alias { copy $x = $y };     # force copying inside alias\-BLOCK
\&
\&    use Data::Alias qw/ deref /;
\&
\&    my @refs = (\e$x, \e@y, \e%z);
\&    foo(deref @refs)            # same as foo($x, @y, %z)
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Aliasing is the phenomenon where two different expressions actually refer to 
the same thing.  Modifying one will modify the other, and if you take a 
reference to both, the two values are the same.
.PP
Aliasing occurs in Perl for example in for-loops and sub-calls:
.PP
.Vb 3
\&    for $var ($x) {
\&            # here $var is an alias to $x
\&    }
\&
\&    foo($y);
\&    sub foo {
\&            # here $_[0] is an alias to $y
\&    }
.Ve
.PP
Data::Alias is a module that allows you to apply \*(L"aliasing semantics\*(R" to a 
section of code, causing aliases to be made wherever Perl would normally make 
copies instead.  You can use this to improve efficiency and readability, when 
compared to using references.
.PP
The exact details of aliasing semantics are below under \*(L"\s-1DETAILS\s0\*(R".
.SH "SYNTAX"
.IX Header "SYNTAX"
.SS "alias \fI\s-1EXPR\s0\fP | alias \fI\s-1BLOCK\s0\fP"
.IX Subsection "alias EXPR | alias BLOCK"
Exported by default.
.PP
Enables aliasing semantics within the expression or block.  Returns an alias 
to the expression, or the block's return value.
.PP
\&\f(CW\*(C`alias\*(C'\fR is context-transparent, meaning that whichever context it is placed in 
(list, scalar, void), the expression/block is evaluated in the same context.
.SS "copy \fI\s-1EXPR\s0\fP | copy \fI\s-1BLOCK\s0\fP"
.IX Subsection "copy EXPR | copy BLOCK"
Restores normal (copying) semantics within the expression or block, and 
makes a copy of the result value (unless in void context).
.PP
Like \f(CW\*(C`alias\*(C'\fR, \f(CW\*(C`copy\*(C'\fR is context-transparent.
.SS "deref \fI\s-1LIST\s0\fP"
.IX Subsection "deref LIST"
Accepts a list of references to scalars, arrays, or hashes.  Applies the 
applicable dereferencing operator to each.  This means that:
.PP
.Vb 1
\&    deref $scalarref, $arrayref, $hashref
.Ve
.PP
behaves like:
.PP
.Vb 1
\&    $$scalarref, @$arrayref, %$hashref
.Ve
.PP
Where an array or hash reference is given, the returned list does not
include the array or hash as an lvalue; the array/hash is expanded and
the list includes its elements.  Scalars, including the elements of an
array/hash, \fIare\fR treated as lvalues, and can be enreferenced using
the \f(CW\*(C`\e\*(C'\fR operator or aliased to using the \f(CW\*(C`alias\*(C'\fR operator.  This is
slightly different from what you'd get using the built-in dereference
operators: \f(CW@$arrayref\fR references the array as an lvalue, so \f(CW\*(C`\e\*(C'\fR
or \f(CW\*(C`alias\*(C'\fR can operate on the array itself rather than just its elements.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
A common usage of aliasing is to make an abbreviation for an expression, to 
avoid having to repeat that (possibly verbose or ugly) expression over and 
over:
.PP
.Vb 2
\&    alias my $fi = $self\->{FrobnitzIndex};
\&    $fi = $fi > 0 ? $fi \- $adj : $fi + $adj;
\&
\&    sub rc4 {
\&            alias my ($i, $j, $S) = @_;
\&            my $a = $S\->[($i += 1) &= 255];
\&            my $b = $S\->[($j += $S\->[$i]) &= 255];
\&            $S\->[(($S\->[$j] = $a) + ($S\->[$i] = $b)) & 255]
\&    }
.Ve
.PP
In the second example, the rc4 function updates its first two arguments (two 
state values) in addition to returning a value.
.PP
Aliasing can also be used to avoid copying big strings.  This example would 
work fine without \f(CW\*(C`alias\*(C'\fR but would be much slower when passed a big string:
.PP
.Vb 4
\&    sub middlesection ($) {
\&            alias my $s = shift;
\&            substr $s, length($s)/4, length($s)/2
\&    }
.Ve
.PP
You can also apply aliasing semantics to an entire block.  Here this is used to 
swap two arrays in O(1) time:
.PP
.Vb 5
\&    alias {
\&            my @temp = @x;
\&            @x = @y;
\&            @y = @temp;
\&    };
.Ve
.PP
The \f(CW\*(C`copy\*(C'\fR function is typically used to temporarily reinstate normal 
semantics, but can also be used to explicitly copy a value when perl would 
normally not do so:
.PP
.Vb 1
\&    my $ref = \ecopy $x;
.Ve
.SH "DETAILS"
.IX Header "DETAILS"
This section describes exactly what the aliasing semantics are of operations.  
Anything not listed below has unaltered behaviour.
.IP "scalar assignment to variable or element." 4
.IX Item "scalar assignment to variable or element."
Makes the left-side of the assignment an alias to the right-side expression, 
which can be anything.
.Sp
.Vb 4
\&    alias my $lexvar = $foo;
\&    alias $pkgvar = $foo;
\&    alias $array[$i] = $foo;
\&    alias $hash{$k} = $foo;
.Ve
.Sp
An attempt to do alias-assignment to an element of a tied (or \*(L"magical\*(R") array 
or hash will result in a \*(L"Can't put alias into tied array/hash\*(R" error.
.IP "scalar assignment to dereference" 4
.IX Item "scalar assignment to dereference"
If \f(CW$ref\fR is a reference or undef, this simply does \f(CW\*(C`$ref = \e$foo\*(C'\fR.  Otherwise, 
the indicated package variable (via glob or symbolic reference) is made an 
alias to the right-side expression.
.Sp
.Vb 1
\&    alias $$ref = $foo;
.Ve
.IP "scalar assignment to glob" 4
.IX Item "scalar assignment to glob"
Works mostly the same as normal glob-assignment, however it does not set the 
import-flag.  (If you don't know what this means, you probably don't care)
.Sp
.Vb 1
\&    alias *glob = $reference;
.Ve
.IP "scalar assignment to anything else" 4
.IX Item "scalar assignment to anything else"
Not supported.
.Sp
.Vb 2
\&    alias substr(...) = $foo;   # ERROR!
\&    alias lvalsub() = $foo;     # ERROR!
.Ve
.IP "conditional scalar assignment" 4
.IX Item "conditional scalar assignment"
Here \f(CW$var\fR (and \f(CW$var2\fR) are aliased to \f(CW$foo\fR if the applicable condition 
is satisfied.  \f(CW$bool\fR and \f(CW$foo\fR can be any expression.  \f(CW$var\fR and 
\&\f(CW$var2\fR can be anything that is valid on the left-side of an alias-assignment.
.Sp
.Vb 4
\&    alias $bool ? $var : $var2 = $foo;
\&    alias $var &&= $foo;
\&    alias $var ||= $foo;
\&    alias $var //= $foo; # (perl 5.9.x or later)
.Ve
.IP "whole aggregate assignment from whole aggregate" 4
.IX Item "whole aggregate assignment from whole aggregate"
This occurs where the expressions on both sides of the assignment operator
are purely complete arrays or hashes.
The entire aggregate is aliased, not merely the contents.  
This means for example that \f(CW\*(C`\e@lexarray == \e@foo\*(C'\fR.
.Sp
.Vb 4
\&    alias my @lexarray = @foo;
\&    alias my %lexhash = %foo;
\&    alias @pkgarray = @foo;
\&    alias %pkghash = %foo;
.Ve
.Sp
Making the left-side a dereference is also supported:
.Sp
.Vb 2
\&    alias @$ref = @foo;
\&    alias %$ref = %foo;
.Ve
.Sp
and analogously to assignment to scalar dereference, these will change \f(CW$ref\fR 
to reference the aggregate, if \f(CW$ref\fR was undef or already a reference.  If 
\&\f(CW$ref\fR is a string or glob, the corresponding package variable is aliased.
.Sp
Anything more complex than a whole-aggregate expression on either side,
even just enclosing the aggregate expression in parentheses, will prevent
the assignment qualifying for this category.  It will instead go into
one of the following two categories.  Parenthesisation is the recommended
way to avoid whole-aggregate aliasing where it is unwanted.  If you want
to merely replace the contents of the left-side aggregate with aliases
to the contents of the right-side aggregate, parenthesise the left side.
.IP "whole aggregate assignment from list" 4
.IX Item "whole aggregate assignment from list"
If the left-side expression is purely a complete array or hash,
and the right-side expression is not purely a matching aggregate, then a new 
aggregate is implicitly constructed.  This means:
.Sp
.Vb 3
\&    alias my @lexfoo = (@foo);
\&    alias my @array = ($x, $y, $z);
\&    alias my %hash = (x => $x, y => $y);
.Ve
.Sp
is translated to:
.Sp
.Vb 3
\&    alias my @lexfoo = @{ [@foo] };
\&    alias my @array = @{ [$x, $y, $z] };
\&    alias my %hash = %{ {x => $x, y => $y} };
.Ve
.Sp
If you want to merely replace the contents of the aggregate with aliases to the 
contents of another aggregate, rather than create a new aggregate, you can 
force list-assignment by parenthesizing the left side, see below.
.IP "list assignment" 4
.IX Item "list assignment"
List assignment is any assignment where the left-side is an array-slice, 
hash-slice, or list in parentheses.  This behaves essentially like many scalar 
assignments in parallel.
.Sp
.Vb 4
\&    alias my (@array) = ($x, $y, $z);
\&    alias my (%hash) = (x => $x, y => $y);
\&    alias my ($x, $y, @rest) = @_;
\&    alias @x[0, 1] = @x[1, 0];
.Ve
.Sp
Any scalars that appear on the left side must be valid targets for scalar 
assignment.  When an array or hash appears on the left side, normally as the 
last item, its contents are replaced by the list of all remaining right-side 
elements.  \f(CW\*(C`undef\*(C'\fR can also appear on the left side to skip one corresponding 
item in the right-side list.
.Sp
Beware when putting a parenthesised list on the left side.  Just like Perl 
parses \f(CW\*(C`print (1+2)*10\*(C'\fR as \f(CW\*(C`(print(1+2))*10\*(C'\fR, it would parse \f(CW\*(C`alias ($x, $y) 
= ($y, $x)\*(C'\fR as \f(CW\*(C`(alias($x, $y)) = ($y, $x)\*(C'\fR which does not do any aliasing, 
and results in the \*(L"Useless use of alias\*(R" warning, if warnings are enabled.
.Sp
To circumvent this issue, you can either one of the following:
.Sp
.Vb 2
\&    alias +($x, $y) = ($y, $x);
\&    alias { ($x, $y) = ($y, $x) };
.Ve
.IP "Anonymous aggregate constructors" 4
.IX Item "Anonymous aggregate constructors"
Return a reference to a new anonymous array or hash, populated with aliases.  
This means that for example \f(CW\*(C`\e$hashref\->{x} == \e$x\*(C'\fR.
.Sp
.Vb 2
\&    my $arrayref = alias [$x, $y, $z];
\&    my $hashref = alias {x => $x, y => $y};
.Ve
.Sp
Note that this also works:
.Sp
.Vb 2
\&    alias my $arrayref = [$x, $y, $z];
\&    alias my $hashref = {x => $x, y => $y};
.Ve
.Sp
but this makes the lhs an alias to the temporary, and therefore read-only, 
reference made by \f(CW\*(C`[]\*(C'\fR or \f(CW\*(C`{}\*(C'\fR.  Therefore later attempts to assign to 
\&\f(CW$arrayref\fR or \f(CW$hashref\fR results in an error.  The anonymous aggregate that 
is referenced behaves the same in both cases obviously.
.IP "Array insertions" 4
.IX Item "Array insertions"
These work as usual, except the inserted elements are aliases.
.Sp
.Vb 3
\&    alias push @array, $foo;
\&    alias unshift @array, $foo;
\&    alias splice @array, 1, 2, $foo;
.Ve
.Sp
An attempt to do any of these on tied (or \*(L"magical\*(R") array will result in a 
\&\*(L"Can't push/unshift/splice alias onto tied array\*(R" error.
.IP "Returning an alias" 4
.IX Item "Returning an alias"
Returns aliases from the current \f(CW\*(C`sub\*(C'\fR or \f(CW\*(C`eval\*(C'\fR.  Normally this only
happens for lvalue subs, but \f(CW\*(C`alias return\*(C'\fR can be used in any sub.
Lvalue subs only work for scalar return values, but \f(CW\*(C`alias return\*(C'\fR
can handle a list of return values.
.Sp
A sub call will very often copy the return value(s) immediately after
they have been returned.  \f(CW\*(C`alias return\*(C'\fR can't prevent that.  To pass
an alias through a sub return and into something else, the call site
must process the return value using an aliasing operation, or at least a
non-copying one.  For example, ordinary assignment with the sub call on
the right hand side will copy, but if the call site is in the scope of an
\&\f(CW\*(C`alias\*(C'\fR pragma then the assignment will instead alias the return value.
.Sp
When alias-returning a list of values from a subroutine, each individual
value in the list is aliased.  The list as a whole is not aliasable;
it is not an array.  At the call site, a list of aliases can be captured
into separate variables or into an array, by an aliasing list assignment.
.IP "Subroutines and evaluations" 4
.IX Item "Subroutines and evaluations"
Placing a subroutine or \f(CW\*(C`eval STRING\*(C'\fR inside \f(CW\*(C`alias\*(C'\fR causes it to be compiled 
with aliasing semantics entirely.  Additionally, the return from such a sub or 
eval, whether explicit using \f(CW\*(C`return\*(C'\fR or implicitly the last statement, will 
be an alias rather than a copy.
.Sp
.Vb 1
\&    alias { sub foo { $x } };
\&
\&    my $subref = alias sub { $x };
\&    
\&    my $xref1 = \efoo;
\&    my $xref2 = \ealias eval \*(Aq$x\*(Aq;
\&    my $xref3 = \e$subref\->();
.Ve
.Sp
Explicitly returning an alias can also be done using \f(CW\*(C`alias return\*(C'\fR inside any 
subroutine or evaluation.
.Sp
.Vb 2
\&    sub foo { alias return $x; }
\&    my $xref = \efoo;
.Ve
.IP "Localization" 4
.IX Item "Localization"
Use of local inside \f(CW\*(C`alias\*(C'\fR usually behaves the same as local does in general, 
however there is a difference if the variable is tied:  in this case, Perl 
doesn't localise the variable at all but instead preserves the tie by saving a 
copy of the current value, and restoring this value at end of scope.
.Sp
.Vb 1
\&    alias local $_ = $string;
.Ve
.Sp
The aliasing semantics of \f(CW\*(C`local\*(C'\fR avoids copying by always localizing the 
variable itself, regardless of whether it is tied.
.SH "IMPLEMENTATION"
.IX Header "IMPLEMENTATION"
This module does \fBnot\fR use a source filter, and is therefore safe to use 
within eval \s-1STRING\s0.  Instead, Data::Alias hooks into the Perl parser, and 
replaces operations within the scope of \f(CW\*(C`alias\*(C'\fR by aliasing variants.
.PP
For those familiar with perl's internals:  it triggers on a ck_rv2cv which 
resolves to the imported \f(CW\*(C`alias\*(C'\fR sub, and does a parser hack to allow the 
\&\f(CW\*(C`alias BLOCK\*(C'\fR syntax.  When the ck_entersub is triggered that corresponds to 
it, the op is marked to be found later.  The actual work is done in a peep-hook,
which processes the marked entersub 
and its children, replacing the pp_addrs with aliasing replacements.  The peep 
hook will also take care of any subs defined within the lexical (but not 
dynamical) scope between the ck_rv2cv and the ck_entersub.
.SH "KNOWN ISSUES"
.IX Header "KNOWN ISSUES"
.IP "Lexical variables" 4
.IX Item "Lexical variables"
When aliasing existing lexical variables, the effect is limited in scope to the 
current subroutine and any closures create after the aliasing is done, even if 
the variable itself has wider scope.  While partial fixes are possible, it 
cannot be fixed in any reliable or consistent way, and therefore I'm keeping 
the current behaviour.
.Sp
When aliasing a lexical that was declared outside the current subroutine, a 
compile-time warning is generated \*(L"Aliasing of outer lexical variable has 
limited scope\*(R" (warnings category \*(L"closure\*(R").
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
Specials thanks go to Elizabeth Mattijsen, Juerd Waalboer, and other members of 
the Amsterdam Perl Mongers, for their valuable feedback.
.SH "AUTHOR"
.IX Header "AUTHOR"
Matthijs van Duin <xmath@cpan.org> developed the module originally,
and maintained it until 2007.  Andrew Main (Zefram) <zefram@fysh.org>
updated it to work with Perl versions 5.11.0 and later.
.SH "LICENSE"
.IX Header "LICENSE"
Copyright (C) 2003\-2007  Matthijs van Duin.
Copyright (C) 2010, 2011, 2013 Andrew Main (Zefram) <zefram@fysh.org>.
All rights reserved.
This program is free software; you can redistribute it and/or modify 
it under the same terms as Perl itself.
