.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Tail 3pm"
.TH Tail 3pm "2014-04-08" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
File::Tail \- Perl extension for reading from continously updated files
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&  use File::Tail;
\&  $file=File::Tail\->new("/some/log/file");
\&  while (defined($line=$file\->read)) {
\&      print "$line";
\&  }
\&
\&  use File::Tail;
\&  $file=File::Tail\->new(name=>$name, maxinterval=>300, adjustafter=>7);
\&  while (defined($line=$file\->read)) {
\&      print "$line";
\&  }
.Ve
.PP
\&\s-1OR\s0, you could use tie (additional parameters can be passed with the name, or 
can be set using \f(CW$ref\fR):
.PP
.Vb 5
\&    use File::Tail;
\&    my $ref=tie *FH,"File::Tail",(name=>$name);
\&    while (<FH>) {
\&        print "$_";
\&    }
.Ve
.PP
Note that the above script will never exit. If there is nothing being written
to the file, it will simply block.
.PP
You can find more synopsii in the file logwatch, which is included
in the distribution.
.PP
Note: Select functionality was added in version 0.9, and it required 
some reworking of all routines. ***PLEASE*** let me know if you see anything
strange happening.
.PP
You can find two way of using select in the file select_demo which is included
in the ditribution.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The primary purpose of File::Tail is reading and analysing log files while
they are being written, which is especialy usefull if you are monitoring
the logging process with a tool like Tobias Oetiker's \s-1MRTG\s0.
.PP
The module tries very hard \s-1NOT\s0 to \*(L"busy-wait\*(R" on a file that has little 
traffic. Any time it reads new data from the file, it counts the number
of new lines, and divides that number by the time that passed since data
were last written to the file before that. That is considered the average
time before new data will be written. When there is no new data to read, 
\&\f(CW\*(C`File::Tail\*(C'\fR sleeps for that number of seconds. Thereafter, the waiting 
time is recomputed dynamicaly. Note that \f(CW\*(C`File::Tail\*(C'\fR never sleeps for
more than the number of seconds set by \f(CW\*(C`maxinterval\*(C'\fR.
.PP
If the file does not get altered for a while, \f(CW\*(C`File::Tail\*(C'\fR gets suspicious 
and startschecking if the file was truncated, or moved and recreated. If 
anything like that had happened, \f(CW\*(C`File::Tail\*(C'\fR will quietly reopen the file,
and continue reading. The only way to affect what happens on reopen is by 
setting the reset_tail parameter (see below). The effect of this is that
the scripts need not be aware when the logfiles were rotated, they will
just quietly work on.
.PP
Note that the sleep and time used are from Time::HiRes, so this module
should do the right thing even if the time to sleep is less than one second.
.PP
The logwatch script (also included) demonstrates several ways of calling 
the methods.
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.SS "new ([ \s-1ARGS\s0 ])"
.IX Subsection "new ([ ARGS ])"
Creates a \f(CW\*(C`File::Tail\*(C'\fR. If it has only one paramter, it is assumed to 
be the filename. If the open fails, the module performs a croak. I
am currently looking for a way to set $! and return undef.
.PP
You can pass several parameters to new:
.IP "name" 4
.IX Item "name"
This is the name of the file to open. The file will be opened for reading.
This must be a regular file, not a pipe or a terminal (i.e. it must be
seekable).
.IP "maxinterval" 4
.IX Item "maxinterval"
The maximum number of seconds (real number) that will be spent sleeping.
Default is 60, meaning \f(CW\*(C`File::Tail\*(C'\fR will never spend more than sixty
seconds without checking the file.
.IP "interval" 4
.IX Item "interval"
The initial number of seconds (real number) that will be spent sleeping,
before the file is first checked. Default is ten seconds, meaning \f(CW\*(C`File::Tail\*(C'\fR
will sleep for 10 seconds and then determine, how many new lines have appeared 
in the file.
.IP "adjustafter" 4
.IX Item "adjustafter"
The number of \f(CW\*(C`times\*(C'\fR \f(CW\*(C`File::Tail\*(C'\fR waits for the current interval,
before adjusting the interval upwards. The default is 10.
.IP "resetafter" 4
.IX Item "resetafter"
The number of seconds after last change when \f(CW\*(C`File::Tail\*(C'\fR decides 
the file may have been closed and reopened. The default is 
adjustafter*maxinterval.
.IP "maxbuf" 4
.IX Item "maxbuf"
The maximum size of the internal buffer. When File::Tail
suddenly found an enormous ammount of information in the file
(for instance if the retry parameters were set to very
infrequent checking and the file was rotated), File::Tail
sometimes slurped way too much file into memory.  This sets
the maximum size of File::Tail's buffer.
.Sp
Default value is 16384 (bytes).
.Sp
A large internal buffer may result in worse performance (as well as
increased memory usage), since File::Tail will have to do more work
processing the internal buffer.
.IP "nowait" 4
.IX Item "nowait"
Does not block on read, but returns an empty string if there is nothing
to read. \s-1DO\s0 \s-1NOT\s0 \s-1USE\s0 \s-1THIS\s0 unless you know what you are doing. If you 
are using it in a loop, you probably \s-1DON\s0'T know what you are doing.
If you want to read tails from multiple files, use select.
.IP "ignore_nonexistant" 4
.IX Item "ignore_nonexistant"
.Vb 3
\&    Do not complain if the file doesn\*(Aqt exist when it is first 
\&opened or when it is to be reopened. (File may be reopened after 
\&resetafter seconds have passed since last data was found.)
.Ve
.IP "tail" 4
.IX Item "tail"
.Vb 3
\&    When first started, read and return C<n> lines from the file. 
\&If C<n> is zero, start at the end of file. If C<n> is negative, 
\&return the whole file.
\&
\&    Default is C<0>.
.Ve
.IP "reset_tail" 4
.IX Item "reset_tail"
.Vb 4
\&    Same as tail, but applies after reset. (i.e. after the
\&file has been automaticaly closed and reopened). Defaults to
\&C<\-1>, i.e. does not skip any information present in the
\&file when it first checks it.
\&
\&   Why would you want it otherwise? I\*(Aqve seen files which
\&have been cycled like this:
\&
\&   grep \-v lastmonth log >newlog 
\&   mv log archive/lastmonth 
\&   mv newlog log 
\&   kill \-HUP logger
.Ve
.Sp
Obviously, if this happens and you have reset_tail set to
c<\-1>, you will suddenly get a whole bunch of lines \- lines
you already saw. So in this case, reset_tail should probably
be set to a small positive number or even \f(CW0\fR.
.IP "name_changes" 4
.IX Item "name_changes"
Some logging systems change the name of the file 
they are writing to, sometimes to include a date, sometimes a 
sequence number, sometimes other, even more bizarre changes.
.Sp
Instead of trying to implement various clever detection methods, 
File::Tail will call the code reference defined in name_changes. The code reference should return the string which is the new name of the file to try opening.
.Sp
Note that if the file does not exist, File::Tail will report a fatal error (unless ignore_nonexistant has also been specified).
.IP "debug" 4
.IX Item "debug"
Set to nonzero if you want to see more about the inner workings of
File::Tail. Otherwise not useful.
.IP "errmode" 4
.IX Item "errmode"
Modeled after the methods from Net:Telnet, here you decide how the
errors should be handled. The parameter can be a code reference which
is called with the error string as a parameter, an array with a code
reference as the first parameter and other parameters to be passed to 
handler subroutine, or one of the words:
.Sp
return  \- ignore any error (just put error message in errmsg).
warn    \- output the error message but continue
die     \- display error message and exit
.Sp
Default is die.
.SH "METHODS"
.IX Header "METHODS"
.SS "read"
.IX Subsection "read"
\&\f(CW\*(C`read\*(C'\fR returns one line from the input file. If there are no lines
ready, it blocks until there are.
.SS "select"
.IX Subsection "select"
\&\f(CW\*(C`select\*(C'\fR is intended to enable the programmer to simoultaneously wait for
input on normal filehandles and File::Tail filehandles. Of course, you may 
use it to simply read from more than one File::Tail filehandle at a time.
.PP
Basicaly, you call File::Tail::select just as you would normal select,
with fields for rbits, wbits and ebits, as well as a timeout, however, you 
can tack any number of File::Tail objects (not File::Tail filehandles!) 
to the end.
.PP
Usage example:
.PP
.Vb 10
\& foreach (@ARGV) {
\&     push(@files,File::Tail\->new(name=>"$_",debug=>$debug));
\& }
\& while (1) {
\&   ($nfound,$timeleft,@pending)=
\&             File::Tail::select(undef,undef,undef,$timeout,@files);
\&   unless ($nfound) {
\&     # timeout \- do something else here, if you need to
\&   } else {
\&     foreach (@pending) {
\&        print $_\->{"input"}." (".localtime(time).") ".$_\->read;
\&   }
\& }
\&
\& #
\& # There is a more elaborate example in select_demo in the distribution.
\& #
.Ve
.PP
When you do this, File::Tail's select emulates normal select, with two 
exceptions:
.PP
a) it will return if there is input on any of the parameters
(i.e. normal filehandles) _or_ File::Tails.
.PP
b) In addition to \f(CW\*(C`($nfound, $timeleft)\*(C'\fR, the return array will also contain
a list of File::Tail objects which are ready for reading. \f(CW$nfound\fR will
contain the correct number of filehandles to be read (i.e. both normal 
and File::Tails).
.PP
Once select returns, when you want to determine which File::Tail objects
have input ready, you can either use the list of objects select returned,
or you can check each individual object with \f(CW$object\fR\->predict. This returns
the ammount of time (in fractional seconds) after which the handle expects
input. If it returns 0, there is input waiting. There is no guarantee that
there will be input waiting after the returned number of seconds has passed.
However, File::Tail won't do any I/O on the file until that time has passed.
Note that the value of \f(CW$timeleft\fR may or may not be correct \- that depends on 
the underlying operating system (and it's select), so you're better off \s-1NOT\s0
relying on it.
.PP
Also note, if you are determining which files are ready for input by calling
each individual predict, the \f(CW$nfound\fR value may be invalid, because one
or more of File::Tail object may have become ready between the time select
has returned and the time when you checked it.
.SH "TO BE DONE"
.IX Header "TO BE DONE"
Planned for 1.0: Using $/ instead of \en to
separate \*(L"lines\*(R" (which should make it possible to read wtmp type files).
Except that I discovered I have no need for that enhancement If you do, 
feel free to send me the patches and I'll apply them \- if I feel they don't
add too much processing time.
.SH "AUTHOR"
.IX Header "AUTHOR"
Matija Grabnar, matija.grabnar@arnes.si
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIperl\fR\|(1), tail (1), 
\&\s-1MRTG\s0 (http://ee\-staff.ethz.ch/~oetiker/webtools/mrtg/mrtg.html)
