.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "AnyEvent::Impl::POE 3"
.TH AnyEvent::Impl::POE 3 "2012-04-08" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
AnyEvent::Impl::POE \- AnyEvent adaptor for POE
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&   use AnyEvent;
\&   use POE;
\&  
\&   # this module gets loaded automatically as required
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides transparent support for AnyEvent. You don't have to
do anything to make \s-1POE\s0 work with AnyEvent except by loading \s-1POE\s0 before
creating the first AnyEvent watcher. There are some cases where \s-1POE\s0 will
issue spurious (and non-suppressible) warnings. These can be avoided by
loading AnyEvent::Impl::POE before loading any other modules using \s-1POE\s0 and
AnyEvent, i.e. in your main program.
.PP
AnyEvent::Impl::POE will output some spurious message how to work around
\&\s-1POE\s0's spurious messages when it detects these cases.
.PP
Unfortunately, \s-1POE\s0 isn't generic enough to implement a fully working
AnyEvent backend: \s-1POE\s0 is too badly designed, too badly documented and too
badly implemented.
.PP
Here are the details, and what it means to you if you want to be
interoperable with \s-1POE:\s0
.IP "Weird messages" 4
.IX Item "Weird messages"
If you only use \f(CW\*(C`run_one_timeslice\*(C'\fR (as AnyEvent has to for its
condition variables), \s-1POE\s0 will print an ugly, unsuppressible, message at
program exit:
.Sp
.Vb 1
\&   Sessions were started, but POE::Kernel\*(Aqs run() method was never...
.Ve
.Sp
The message is correct, the question is why \s-1POE\s0 prints it in the first
place in a correct program (this is not a singular case though).
.Sp
AnyEvent consequently patches the \s-1POE\s0 kernel so it thinks it already
ran. Other workarounds, even the one cited in the \s-1POE\s0 documentation
itself, have serious side effects, such as throwing away events.
.Sp
The author of \s-1POE\s0 verified that this is indeed true, and has no plans to
change this.
.Sp
\&\s-1POE\s0 has other weird messages, and sometimes weird behaviour, for example,
it doesn't support overloaded code references as callbacks for no apparent
reason.
.IP "One \s-1POE\s0 session per Event" 4
.IX Item "One POE session per Event"
AnyEvent has to create one POE::Session per event watcher, which is
immensely slow and makes watchers very large. The reason for this is
lacking lifetime management (mostly undocumented, too). Without one
session/watcher it is not possible to easily keep the kernel from running
endlessly.
.Sp
This is not just a problem with the way AnyEvent has to interact with
\&\s-1POE\s0, but is a principal issue with POEs lifetime management (namely
that stopping the kernel stops sessions, but AnyEvent has no control
over who and when the kernel starts or stops w.r.t. AnyEvent watcher
creation/destruction).
.Sp
From benchmark data it is not clear that session creation is that costly,
though \- the real inefficiencies with \s-1POE\s0 seem to come from other sources,
such as event handling.
.IP "One watcher per fd/event combo" 4
.IX Item "One watcher per fd/event combo"
\&\s-1POE\s0, of course, suffers from the same bug as Tk and some other badly
designed event models in that it doesn't support multiple watchers per
fd/poll combo. The workaround is the same as with Tk: AnyEvent::Impl::POE
creates a separate file descriptor to hand to \s-1POE\s0, which isn't fast and
certainly not nice to your resources.
.Sp
Of course, without the workaround, \s-1POE\s0 also prints ugly messages again
that say the program *might* be buggy.
.Sp
While this is not good to performance, at least regarding speed, with a
modern Linux kernel, the overhead is actually quite small.
.IP "Timing deficiencies" 4
.IX Item "Timing deficiencies"
\&\s-1POE\s0 manages to not have a function that returns the current time. This is
extremely problematic, as \s-1POE\s0 can use different time functions, which can
differ by more than a second \- and user code is left guessing which one is
used.
.Sp
In addition, most timer functions in \s-1POE\s0 want an absolute timestamp, which
is hard to create if all you have is a relative time and no function to
return the \*(L"current time\*(R".
.Sp
And of course \s-1POE\s0 doesn't handle time jumps at all (not even when using
an event loop that happens to do that, such as \s-1EV\s0, as it does its own
unoptimised timer management).
.Sp
AnyEvent works around the unavailability of the current time using
relative timers exclusively, in the hope that \s-1POE\s0 gets it right at least
internally.
.IP "Lack of defined event ordering" 4
.IX Item "Lack of defined event ordering"
\&\s-1POE\s0 cannot guarantee the order of callback invocation for timers, and
usually gets it wrong. That is, if you have two timers, one timing out
after another (all else being equal), the callbacks might be called in
reverse order.
.Sp
How one manages to even implement stuff that way escapes me.
.IP "Child watchers" 4
.IX Item "Child watchers"
\&\s-1POE\s0 offers child watchers \- which is a laudable thing, as few event loops
do. Unfortunately, they cannot even implement AnyEvent's simple child
watchers: they are not generic enough (the \s-1POE\s0 implementation isn't even
generic enough to let properly designed back-end use their native child
watcher instead \- it insist on doing it itself the broken way).
.Sp
Unfortunately, \s-1POE\s0's child handling is inherently racy: if the child exits
before the handler is created (because e.g. it crashes or simply is quick
about it), then current versions of \s-1POE\s0 (1.352) will \fInever\fR invoke the
child watcher, and there is nothing that can be done about it. Older
versions of \s-1POE\s0 only delayed in this case. The reason is that \s-1POE\s0 first
checks if the child has already exited, and \fIthen\fR installs the signal
handler \- aa classical race.
.Sp
Your only hope is for the fork'ed process to not exit too quickly, in
which case everything happens to work.
.Sp
Of course, whenever \s-1POE\s0 reaps an unrelated child it will also output a
message for it that you cannot suppress (which shouldn't be too surprising
at this point). Very professional.
.Sp
As a workaround, AnyEvent::Impl::POE will take advantage of undocumented
behaviour in POE::Kernel to catch the status of all child processes, but
it cannot guarantee delivery.
.Sp
How one manages to have such a glaring bug in an event loop after ten
years of development escapes me.
.Sp
(There are more annoying bugs, for example, \s-1POE\s0 runs \f(CW\*(C`waitpid\*(C'\fR
unconditionally at finaliser time, so your program will hang until all
child processes have exited.)
.IP "Documentation quality" 4
.IX Item "Documentation quality"
At the time of this writing, \s-1POE\s0 was in its tenth year. Still, its
documentation is extremely lacking, making it impossible to implement
stuff as trivial as AnyEvent watchers without having to resort to
undocumented behaviour or features.
.Sp
For example, the POE::Kernel manpage has nine occurrences of the word \s-1TODO\s0
with an explanation of whats missing. In general, the \s-1POE\s0 man pages are
littered with comments like \*(L"section not yet written\*(R".
.Sp
Some other gems:
.Sp
.Vb 1
\&   This allows many object methods to also be package methods.
.Ve
.Sp
This is nice, but since it doesn't document \fIwhich\fR methods these are,
this is utterly useless information.
.Sp
.Vb 4
\&   Terminal signals will kill sessions if they are not handled by a
\&   "sig_handled"() call. The OS signals that usually kill or dump a
\&   process are considered terminal in POE, but they never trigger a
\&   coredump. These are: HUP, INT, QUIT and TERM.
.Ve
.Sp
Although AnyEvent calls \f(CW\*(C`sig_handled\*(C'\fR, removing it has no apparent
effects on \s-1POE\s0 handling \s-1SIGINT\s0.
.Sp
.Vb 1
\&   refcount_increment SESSION_ID, COUNTER_NAME
.Ve
.Sp
Nowhere is explained which COUNTER_NAMEs are valid and which aren't \- not
all scalars (or even strings) are valid counter names. Take your guess,
failure is of course completely silent. I found this out the hard way, as
the first name I came up with was silently ignored.
.Sp
.Vb 2
\&   get_next_event_time() returns the time the next event is due, in a form
\&   compatible with the UNIX time() function.
.Ve
.Sp
And surely, one would hope that \s-1POE\s0 supports sub-second accuracy as
documented elsewhere, unlike the explanation above implies. Yet:
.Sp
.Vb 2
\&   POE::Kernel timers support subsecond accuracy, but donXt expect too
\&   much here. Perl is not the right language for realtime programming.
.Ve
.Sp
\&... of course, Perl is not the right language to expect sub-second
accuracy \- the manpage author must hate Perl to spread so much \s-1FUD\s0 in
so little space. The Deliantra game server logs with 100Xs\-accuracy
because Perl is fast enough to require this, and is still able to deliver
map updates with little jitter at exactly the right time. It does not,
however, use \s-1POE\s0.
.Sp
.Vb 2
\&   Furthermore, since the Kernel keeps track of everything sessions do, it
\&   knows when a session has run out of tasks to perform.
.Ve
.Sp
This is impossible \- how does the kernel know that a session is no longer
watching for some (external) event (e.g. by some other session)? It
cannot, and therefore this is wrong \- but you would be hard pressed to
find out how to work around this and tell the kernel manually about such
events.
.Sp
It gets worse, though \- the notion of \*(L"task\*(R" or \*(L"resource\*(R", although used
throughout the documentation, is not defined in a usable way. For example,
waiting for a timeout is considered to be a task, waiting for a signal is
not (a session that only waits for a signal is considered finished and
gets removed). The user is left guessing when waiting for an event counts
as task and when not (in fact, the issue with signals is mentioned in
passing in a section about child watchers and directly contradicts earlier
parts in that document).
.Sp
One could go on endlessly \- ten years, no usable documentation.
.Sp
It is likely that differences between documentation, or the one or two
things I had to guess, cause unanticipated problems with this adaptor.
.IP "Fragile and inconsistent \s-1API\s0" 4
.IX Item "Fragile and inconsistent API"
The \s-1POE\s0 \s-1API\s0 is extremely inconsistent \- sometimes you have to pass a
session argument, sometimes it gets ignored, sometimes a session-specific
method must not use a session argument.
.Sp
Error handling is sub-standard as well: even for programming mistakes,
\&\s-1POE\s0 does not \f(CW\*(C`croak\*(C'\fR but, in most cases, just sets \f(CW$!\fR or simply does
nothing at all, leading to fragile programs.
.Sp
Sometimes registering a handler uses the \*(L"eventname, parameter\*(R" ordering
(timeouts), sometimes it is \*(L"parameter, eventname\*(R" (signals). There is
little consistency overall.
.IP "Lack of knowledge" 4
.IX Item "Lack of knowledge"
.Vb 2
\&   The IO::Poll event loop provides an alternative that theoretically
\&   scales better than select().
.Ve
.Sp
The IO::Poll \*(L"event loop\*(R" (who in his right mind would call that an event
loop) of course scales about identically (sometimes it is a bit faster,
sometimes a bit slower) to select in theory, and also in practise, of
course, as both are O(n) in the number of file descriptors, which is
rather bad.
.Sp
This is just one place where it gets obvious how little the author of the
\&\s-1POE\s0 manpage understands.
.IP "No idle events" 4
.IX Item "No idle events"
The POE-recommended workaround to this is apparently to use
\&\f(CW\*(C`fork\*(C'\fR. Consequently, idle watchers will have to be emulated by AnyEvent.
.IP "Questionable maintainer behaviour" 4
.IX Item "Questionable maintainer behaviour"
The author of \s-1POE\s0 is known to fabricate statements and post these to
public mailinglists \- apparently, spreading \s-1FUD\s0 about competing (in his
eyes) projects or their maintainers is acceptable to him.
.Sp
This has (I believe) zero effects on the quality or usefulness of his
code, but it does completely undermine his trustworthyness \- so don't
blindly believe anything he says, he might have just made it up to suit
his needs (benchmark results, the names of my ten wifes, the length of my
penis, etc. etc.). When in doubt, double-check \- not just him, anybody
actually.
.Sp
Example: <http://www.nntp.perl.org/group/perl.perl5.porters/2012/01/msg182141.html>.
I challenged him in that thread to provide evidence for his statement by giving at
least two examples, but of course since he just made it up, he couldn't provide any evidence.
.PP
On the good side, AnyEvent allows you to write your modules in a 100%
POE-compatible way (bug-for-bug compatible even), without forcing your
module to use \s-1POE\s0 \- it is still open to better event models, of which
there are plenty.
.PP
Oh, and one other positive thing:
.PP
.Vb 1
\&   RUNNING_IN_HELL
.Ve
.PP
\&\s-1POE\s0 knows about the nature of the beast!
.SH "SEE ALSO"
.IX Header "SEE ALSO"
AnyEvent, \s-1POE\s0.
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 2
\& Marc Lehmann <schmorp@schmorp.de>
\& http://anyevent.schmorp.de
.Ve
