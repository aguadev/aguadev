.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "AnyEvent::Impl::IOAsync 3"
.TH AnyEvent::Impl::IOAsync 3 "2013-12-10" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
AnyEvent::Impl::IOAsync \- AnyEvent adaptor for IO::Async
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use AnyEvent;
\&  use IO::Async::Loop;
\&
\&  # optionally set another event loop
\&  use AnyEvent::Impl::IOAsync;
\&  my $loop = new IO::Async::Loop;
\&  AnyEvent::Impl::IOAsync::set_loop $loop;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides support for IO::Async as AnyEvent backend. It supports
I/O, timers, signals and child process watchers. Idle watchers are emulated.
I/O watchers need to dup their fh because IO::Async only supports \s-1IO\s0 handles,
not plain file descriptors.
.SH "FUNCTIONS AND VARIABLES"
.IX Header "FUNCTIONS AND VARIABLES"
The only user-servicible part in this module is the \f(CW\*(C`set_loop\*(C'\fR function
and \f(CW$LOOP\fR variable:
.ie n .IP "AnyEvent::Impl::IOAsync::set_loop $new_loop" 4
.el .IP "AnyEvent::Impl::IOAsync::set_loop \f(CW$new_loop\fR" 4
.IX Item "AnyEvent::Impl::IOAsync::set_loop $new_loop"
Unfortunately, IO::Async has no concept of a default loop. Modules using
IO::Async must be told by their caller which loop to use, which makes it
impossible to transparently use IO::Async from a module.
.Sp
This module is no exception. It creates a new IO::Async::Loop object when
it is loaded. This might not be the right loop object, though, and thus
you can replace it by a call to this function with the loop object of your
choice.
.Sp
Note that switching loops while watchers are already initialised can have
unexpected effects, and is not supported unless you can live witht he
consequences.
.ie n .IP "$AnyEvent::Impl::IOAsync::LOOP" 4
.el .IP "\f(CW$AnyEvent::Impl::IOAsync::LOOP\fR" 4
.IX Item "$AnyEvent::Impl::IOAsync::LOOP"
This variable always contains the IO::Async::Loop object used by this
AnyEvent backend. See above for more info.
.Sp
Storing the \*(L"default\*(R" loop makes this module a possible arbiter for other
modules that want to use IO::Async transparently. It's advised to directly
refer to this variable each time you want to use it, without making a
local copy.
.SH "PROBLEMS WITH IO::Async"
.IX Header "PROBLEMS WITH IO::Async"
This section had a long list of problems and shortcomings that made it
almost impossible to support IO::Async. With version 0.33 of IO::Async,
however, most of these have been fixed, so IO::Async can now be used as
easily as many other loops.
.PP
There are a few remaining problems that require emulation or workarounds:
.IP "No support for multiple watchers per event" 4
.IX Item "No support for multiple watchers per event"
In most (all? documentation?) cases you cannot have multiple watchers
for the same event (what's the point of having all these fancy notifier
classes when you cannot have multiple notifiers for the same event? That's
like only allowing one timer per second or so...).
.Sp
For I/O watchers, AnyEvent has to \fIdup()\fR every file handle, as IO::Async
fails to support the same or different file handles pointing to the same
fd (the good thing is that it is documented, but why not fix it instead?).
.PP
Apart from these fatal flaws, there are a number of unpleasent properties
that just need some mentioning:
.IP "Confusing and misleading names" 4
.IX Item "Confusing and misleading names"
Another rather negative point about this module family is its name,
which is deeply confusing: Despite the \*(L"async\*(R" in the name, IO::Async
only does \fIsynchronous\fR I/O, there is nothing \*(L"asynchronous\*(R" about it
whatsoever (when I first heard about it, I thought, "wow, a second async
I/O module, what does it do compared to \s-1IO::AIO\s0\*(L", and was somehow set
back when I learned that the only \*(R"async" aspect of it is the name).
.IP "Inconsistent, incomplete and convoluted \s-1API\s0" 4
.IX Item "Inconsistent, incomplete and convoluted API"
Implementing AnyEvent's rather simple timers on top of IO::Async's timers
was a nightmare (try implementing a timer with configurable interval and
delay value...).
.Sp
The method naming is chaotic: \f(CW\*(C`watch_child\*(C'\fR creates a child watcher,
but \f(CW\*(C`watch_io\*(C'\fR is an internal method; \f(CW\*(C`detach_signal\*(C'\fR removes a signal
watcher, but \f(CW\*(C`detach_child\*(C'\fR forks a subprocess and so on).
.IP "Unpleasant surprises on GNU/Linux" 4
.IX Item "Unpleasant surprises on GNU/Linux"
When you develop your program on FreeBSD and run it on GNU/Linux, you
might have unpleasant surprises, as IO::Async::Loop will by default use
IO::Async::Loop::Epoll, which is incompatible with \f(CW\*(C`fork\*(C'\fR, so your
network server will run into spurious and very hard to debug problems
under heavy load, as IO::Async forks a lot of processes, e.g. for \s-1DNS\s0
resolution. It would be better if IO::Async would only load \*(L"safe\*(R"
backends by default (or fix the epoll backend to work in the presence of
fork, which admittedly is hard \- \s-1EV\s0 does it for you, and also does not use
unsafe backends by default).
.PP
On the positive side, performance with IO::Async is quite good even in my
very demanding eyes.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
AnyEvent, IO::Async.
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 2
\& Marc Lehmann <schmorp@schmorp.de>
\& http://anyevent.schmorp.de
\&
\& Paul Evans <leonerd@leonerd.org.uk>
\& Rewrote the backend for IO::Async version 0.33.
.Ve
