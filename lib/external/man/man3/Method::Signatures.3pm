.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Method::Signatures 3"
.TH Method::Signatures 3 "2014-04-08" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Method::Signatures \- method and function declarations with signatures and no source filter
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    package Foo;
\&
\&    use Method::Signatures;
\&
\&    method new (%args) {
\&        return bless {%args}, $self;
\&    }
\&
\&    method get ($key) {
\&        return $self\->{$key};
\&    }
\&
\&    method set ($key, $val) {
\&        return $self\->{$key} = $val;
\&    }
\&
\&    # Can also get type checking if you like:
\&
\&    method set (Str $key, Int $val) {
\&        return $self\->{$key} = $val;        # now you know $val is always an integer
\&    }
\&
\&    func hello($greeting, $place) {
\&        print "$greeting, $place!\en";
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Provides two new keywords, \f(CW\*(C`func\*(C'\fR and \f(CW\*(C`method\*(C'\fR, so that you can write subroutines with signatures instead of having to spell out \f(CW\*(C`my $self = shift; my($thing) = @_\*(C'\fR
.PP
\&\f(CW\*(C`func\*(C'\fR is like \f(CW\*(C`sub\*(C'\fR but takes a signature where the prototype would
normally go.  This takes the place of \f(CW\*(C`my($foo, $bar) = @_\*(C'\fR and does
a whole lot more.
.PP
\&\f(CW\*(C`method\*(C'\fR is like \f(CW\*(C`func\*(C'\fR but specifically for making methods.  It will
automatically provide the invocant as \f(CW$self\fR.  No more \f(CW\*(C`my $self =
shift\*(C'\fR.
.PP
Also allows signatures, very similar to Perl 6 signatures.
.PP
Also does type checking, understanding all the types that Moose (or Mouse) would understand.
.PP
And it does all this with \fBno source filters\fR.
.SS "Signature syntax"
.IX Subsection "Signature syntax"
.Vb 3
\&    func echo($message) {
\&        print "$message\en";
\&    }
.Ve
.PP
is equivalent to:
.PP
.Vb 4
\&    sub echo {
\&        my($message) = @_;
\&        print "$message\en";
\&    }
.Ve
.PP
except the original line numbering is preserved and the arguments are
checked to make sure they match the signature.
.PP
Similarly
.PP
.Vb 3
\&    method foo($bar, $baz) {
\&        $self\->wibble($bar, $baz);
\&    }
.Ve
.PP
is equivalent to:
.PP
.Vb 5
\&    sub foo {
\&        my $self = shift;
\&        my($bar, $baz) = @_;
\&        $self\->wibble($bar, $baz);
\&    }
.Ve
.PP
again with checks to make sure the arguments passed in match the
signature.
.PP
The full signature syntax for each parameter is:
.PP
.Vb 12
\&          Int|Str  \e:$param!  where $SM_EXPR  is ro  = $AS_EXPR  when $SM_EXPR
\&          \e_\|_\|_\|_\|_/  ^^\e_\|_\|_\|_/^  \e_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_/  \e_\|_\|_/  \e_\|_\|_\|_\|_\|_\|_\|_/  \e_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_/
\&             |     ||   |  |        |           |        |           |
\&       Type_/      ||   |  |        |           |        |           |
\&       Aliased?_\|_\|_/ |   |  |        |           |        |           |
\&       Named?_\|_\|_\|_\|_\|_/    |  |        |           |        |           |
\&       Parameter var_\|_\|_/   |        |           |        |           |
\&       Required?_\|_\|_\|_\|_\|_\|_\|_\|_\|_/         |           |        |           |
\&       Parameter constraint(s)_\|_\|_\|_\|_/            |        |           |
\&       Parameter trait(s)_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_/         |           |
\&       Default value_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_/            |
\&       When default value should be applied_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_/
.Ve
.PP
Every component except the parameter name (with sigil) is optional.
.PP
\&\f(CW$SM_EXPR\fR is any expression that is valid as the \s-1RHS\s0 of a smartmatch,
or else a raw block of code. See \*(L"Value constraints\*(R".
.PP
\&\f(CW$AS_EXPR\fR is any expression that is valid as the \s-1RHS\s0 of an
assignment operator. See \*(L"Defaults\*(R".
.PP
\fI\f(CI@_\fI\fR
.IX Subsection "@_"
.PP
Other than removing \f(CW$self\fR, \f(CW@_\fR is left intact.  You are free to
use \f(CW@_\fR alongside the arguments provided by Method::Signatures.
.PP
\fINamed parameters\fR
.IX Subsection "Named parameters"
.PP
Parameters can be passed in named, as a hash, using the \f(CW\*(C`:$arg\*(C'\fR syntax.
.PP
.Vb 3
\&    method foo(:$arg) {
\&        ...
\&    }
\&
\&    $object\->foo( arg => 42 );
.Ve
.PP
Named parameters are optional by default.
.PP
Required positional parameters and named parameters can be mixed, but
the named params must come last.
.PP
.Vb 1
\&    method foo( $a, $b, :$c )   # legal
.Ve
.PP
Named parameters are passed in as a hash after all positional arguments.
.PP
.Vb 3
\&    method display( $text, :$justify = \*(Aqleft\*(Aq, :$enchef = 0 ) {
\&        ...
\&    }
\&
\&    # $text = "Some stuff", $justify = "right", $enchef = 0
\&    $obj\->display( "Some stuff", justify => "right" );
.Ve
.PP
You cannot mix optional positional params with named params, as that
leads to ambiguities.
.PP
.Vb 1
\&    method foo( $a, $b?, :$c )  # illegal
\&
\&    # Is this $a = \*(Aqc\*(Aq, $b = 42 or $c = 42?
\&    $obj\->foo( c => 42 );
.Ve
.PP
\fIAliased references\fR
.IX Subsection "Aliased references"
.PP
A signature of \f(CW\*(C`\e@arg\*(C'\fR will take an array reference but allow it to
be used as \f(CW@arg\fR inside the method.  \f(CW@arg\fR is an alias to the
original reference.  Any changes to \f(CW@arg\fR will affect the original
reference.
.PP
.Vb 4
\&    package Stuff;
\&    method add_one(\e@foo) {
\&        $_++ for @foo;
\&    }
\&
\&    my @bar = (1,2,3);
\&    Stuff\->add_one(\e@bar);  # @bar is now (2,3,4)
.Ve
.PP
This feature requires Data::Alias to be installed.
.PP
\fIInvocant parameter\fR
.IX Subsection "Invocant parameter"
.PP
The method invocant (i.e. \f(CW$self\fR) can be changed as the first
parameter.  Put a colon after it instead of a comma.
.PP
.Vb 3
\&    method foo($class:) {
\&        $class\->bar;
\&    }
\&
\&    method stuff($class: $arg, $another) {
\&        $class\->things($arg, $another);
\&    }
.Ve
.PP
\&\f(CW\*(C`method\*(C'\fR has an implied default invocant of \f(CW$self:\fR.  \f(CW\*(C`func\*(C'\fR has
no invocant.
.PP
\fIDefaults\fR
.IX Subsection "Defaults"
.PP
Each parameter can be given a default with the \f(CW\*(C`$arg = EXPR\*(C'\fR syntax.
For example,
.PP
.Vb 3
\&    method add($this = 23, $that = 42) {
\&        return $this + $that;
\&    }
.Ve
.PP
Almost any expression can be used as a default.
.PP
.Vb 10
\&    method silly(
\&        $num    = 42,
\&        $string = q[Hello, world!],
\&        $hash   = { this => 42, that => 23 },
\&        $code   = sub { $num + 4 },
\&        @nums   = (1,2,3),
\&    )
\&    {
\&        ...
\&    }
.Ve
.PP
Normally, defaults will only be used if the argument is not passed in at all.
Passing in \f(CW\*(C`undef\*(C'\fR will override the default.  That means...
.PP
.Vb 3
\&    Class\->add();            # $this = 23, $that = 42
\&    Class\->add(99);          # $this = 99, $that = 42
\&    Class\->add(99, undef);   # $this = 99, $that = undef
.Ve
.PP
However, you can specify additional conditions under which a default is
also to be used, using a trailing \f(CW\*(C`when\*(C'\fR. For example:
.PP
.Vb 2
\&    # Use default if no argument passed
\&    method get_results($how_many = 1) {...}
\&
\&    # Use default if no argument passed OR argument is undef
\&    method get_results($how_many = 1 when undef) {...}
\&
\&    # Use default if no argument passed OR argument is empty string
\&    method get_results($how_many = 1 when "") {...}
\&
\&    # Use default if no argument passed OR argument is zero
\&    method get_results($how_many = 1 when 0) {...}
\&
\&    # Use default if no argument passed OR argument is zero or less
\&    method get_results($how_many = 1 when sub{ $_[0] <= 0 }) {...}
\&
\&    # Use default if no argument passed OR argument is invalid
\&    method get_results($how_many = 1 when sub{ !valid($_[0]) }) {...}
.Ve
.PP
In other words, if you include a \f(CW\*(C`when \f(CIvalue\f(CW\*(C'\fR after the default,
the default is still used if the argument is missing, but is also
used if the argument is provided but smart-matches the specified \fIvalue\fR.
.PP
Note that the final two examples above use anonymous subroutines to
conform their complex tests to the requirements of the smartmatch
operator. Because this is useful, but syntactically clumsy, there is
also a short-cut for this behaviour. If the test after \f(CW\*(C`when\*(C'\fR consists
of a block, the block is executed as the defaulting test, with the
actual argument value aliased to \f(CW$_\fR (just like in a \f(CW\*(C`grep\*(C'\fR block).
So the final two examples above could also be written:
.PP
.Vb 2
\&    # Use default if no argument passed OR argument is zero or less
\&    method get_results($how_many = 1 when {$_ <= 0}) {...}
\&
\&    # Use default if no argument passed OR argument is invalid
\&    method get_results($how_many = 1 when {!valid($_)}) } {...}
.Ve
.PP
The most commonly used form of \f(CW\*(C`when\*(C'\fR modifier is almost
certainly \f(CW\*(C`when undef\*(C'\fR:
.PP
.Vb 2
\&    # Use default if no argument passed OR argument is undef
\&    method get_results($how_many = 1 when undef) {...}
.Ve
.PP
which covers the common case where an uninitialized variable is passed
as an argument, or where supplying an explicit undefined value is
intended to indicate: \*(L"use the default instead.\*(R"
.PP
This usage is sufficiently common that a short-cut is provided:
using the \f(CW\*(C`//=\*(C'\fR operator (instead of the regular assignment operator)
to specify the default. Like so:
.PP
.Vb 2
\&    # Use default if no argument passed OR argument is undef
\&    method get_results($how_many //= 1) {...}
.Ve
.PP
Earlier parameters may be used in later defaults.
.PP
.Vb 3
\&    method copy_cat($this, $that = $this) {
\&        return $that;
\&    }
.Ve
.PP
Any variable that has a default is considered optional.
.PP
\fIType Constraints\fR
.IX Subsection "Type Constraints"
.PP
Parameters can also be given type constraints.  If they are, the value
passed in will be validated against the type constraint provided.
Types are provided by Any::Moose which will load Mouse if
Moose is not already loaded.
.PP
Type constraints can be a type, a role or a class.  Each will be
checked in turn until one of them passes.
.PP
.Vb 1
\&    * First, is the $value of that type declared in Moose (or Mouse)?
\&
\&    * Then, does the $value have that role?
\&        $value\->DOES($type);
\&
\&    * Finally, is the $value an object of that class?
\&        $value\->isa($type);
.Ve
.PP
The set of default types that are understood can be found in
Mouse::Util::TypeConstraints (or Moose::Util::TypeConstraints;
they are generally the same, but there may be small differences).
.PP
.Vb 4
\&    # avoid "argument isn\*(Aqt numeric" warnings
\&    method add(Int $this = 23, Int $that = 42) {
\&        return $this + $that;
\&    }
.Ve
.PP
Mouse and Moose also understand some parameterized types; see
their documentation for more details.
.PP
.Vb 5
\&    method add(Int $this = 23, Maybe[Int] $that) {
\&        # $this will definitely be defined
\&        # but $that might be undef
\&        return defined $that ? $this + $that : $this;
\&    }
.Ve
.PP
You may also use disjunctions, which means that you are willing to
accept a value of either type.
.PP
.Vb 8
\&    method add(Int $this = 23, Int|ArrayRef[Int] $that) {
\&        # $that could be a single number,
\&        # or a reference to an array of numbers
\&        use List::Util qw<sum>;
\&        my @ints = ($this);
\&        push @ints, ref $that ? @$that : $that;
\&        return sum(@ints);
\&    }
.Ve
.PP
If the value does not validate against the type, a run-time exception
is thrown.
.PP
.Vb 3
\&    # Error will be:
\&    # In call to Class::add : the \*(Aqthis\*(Aq parameter ("cow") is not of type Int
\&    Class\->add(\*(Aqcow\*(Aq, \*(Aqboy\*(Aq); # make a cowboy!
.Ve
.PP
You cannot declare the type of the invocant.
.PP
.Vb 4
\&    # this generates a compile\-time error
\&    method new(ClassName $class:) {
\&        ...
\&    }
.Ve
.PP
\fIValue Constraints\fR
.IX Subsection "Value Constraints"
.PP
In addition to a type, each parameter can also be specified with one or
more additional constraints, using the \f(CW\*(C`$arg where CONSTRAINT\*(C'\fR syntax.
.PP
.Vb 3
\&    method set_name($name where qr{\eS+ \es+ \eS+}x) {
\&        ...
\&    }
\&
\&    method set_rank($rank where \e%STD_RANKS) {
\&        ...
\&    }
\&
\&    method set_age(Int $age where [17..75] ) {
\&        ...
\&    }
\&
\&    method set_rating($rating where { $_ >= 0 } where { $_ <= 100 } ) {
\&        ...
\&    }
\&
\&    method set_serial_num(Int $snum where {valid_checksum($snum)} ) {
\&        ...
\&    }
.Ve
.PP
The \f(CW\*(C`where\*(C'\fR keyword must appear immediately after the parameter name
and before any trait or default.
.PP
Each \f(CW\*(C`where\*(C'\fR constraint is smartmatched against the value of the
corresponding parameter, and an exception is thrown if the value does
not satisfy the constraint.
.PP
Any of the normal smartmatch arguments (numbers, strings, regexes,
undefs, hashrefs, arrayrefs, coderefs) can be used as a constraint.
.PP
In addition, the constraint can be specified as a raw block. This block
can then refer to the parameter variable directly by name (as in the
definition of \f(CW\*(C`set_serial_num()\*(C'\fR above), or else as \f(CW$_\fR (as in the
definition of \f(CW\*(C`set_rating()\*(C'\fR.
.PP
Unlike type constraints, value constraints are tested \fIafter\fR any
default values have been resolved, and in the same order as they were
specified within the signature.
.PP
\fIParameter traits\fR
.IX Subsection "Parameter traits"
.PP
Each parameter can be assigned a trait with the \f(CW\*(C`$arg is TRAIT\*(C'\fR syntax.
.PP
.Vb 3
\&    method stuff($this is ro) {
\&        ...
\&    }
.Ve
.PP
Any unknown trait is ignored.
.PP
Most parameters have a default traits of \f(CW\*(C`is rw is copy\*(C'\fR.
.IP "\fBro\fR" 4
.IX Item "ro"
Read-only.  Assigning or modifying the parameter is an error.  This trait
requires Const::Fast to be installed.
.IP "\fBrw\fR" 4
.IX Item "rw"
Read-write.  It's ok to read or write the parameter.
.Sp
This is a default trait.
.IP "\fBcopy\fR" 4
.IX Item "copy"
The parameter will be a copy of the argument (just like \f(CW\*(C`my $arg = shift\*(C'\fR).
.Sp
This is a default trait except for the \f(CW\*(C`\e@foo\*(C'\fR parameter (see \*(L"Aliased references\*(R").
.IP "\fBalias\fR" 4
.IX Item "alias"
The parameter will be an alias of the argument.  Any changes to the
parameter will be reflected in the caller.  This trait requires
Data::Alias to be installed.
.Sp
This is a default trait for the \f(CW\*(C`\e@foo\*(C'\fR parameter (see \*(L"Aliased references\*(R").
.PP
\fIMixing value constraints, traits, and defaults\fR
.IX Subsection "Mixing value constraints, traits, and defaults"
.PP
As explained in \*(L"Signature syntax\*(R", there is a defined order when including
multiple trailing aspects of a parameter:
.IP "\(bu" 4
Any value constraint must immediately follow the parameter name.
.IP "\(bu" 4
Any trait must follow that.
.IP "\(bu" 4
Any default must come last.
.PP
For instance, to have a parameter which has all three aspects:
.PP
.Vb 3
\&    method echo($message where { length <= 80 } is ro = "what?") {
\&        return $message
\&    }
.Ve
.PP
Think of \f(CW\*(C`$message where { length <= 80 }\*(C'\fR as being the left-hand side of the
trait, and \f(CW\*(C`$message where { length <= 80 } is ro\*(C'\fR as being the left-hand side
of the default assignment.
.PP
\fISlurpy parameters\fR
.IX Subsection "Slurpy parameters"
.PP
A \*(L"slurpy\*(R" parameter is a list or hash parameter that \*(L"slurps up\*(R" all
remaining arguments.  Since any following parameters can't receive values,
there can be only one slurpy parameter.
.PP
Slurpy parameters must come at the end of the signature and they must
be positional.
.PP
Slurpy parameters are optional by default.
.PP
\fIThe \*(L"yada yada\*(R" marker\fR
.IX Subsection "The yada yada marker"
.PP
The restriction that slurpy parameters must be positional, and must
appear at the end of the signature, means that they cannot be used in
conjunction with named parameters.
.PP
This is frustrating, because there are many situations (in particular:
during object initialization, or when creating a callback) where it
is extremely handy to be able to ignore extra named arguments that don't
correspond to any named parameter.
.PP
While it would be theoretically possible to allow a slurpy parameter to
come after named parameters, the current implementation does not support
this (see \*(L"Slurpy parameter restrictions\*(R").
.PP
Instead, there is a special syntax (colloquially known as the \*(L"yada yada\*(R")
that tells a method or function to simply ignore any extra arguments
that are passed to it:
.PP
.Vb 6
\&    # Expect name, age, gender, and simply ignore anything else
\&    method BUILD (:$name, :$age, :$gender, ...) {
\&        $self\->{name}   = uc $name;
\&        $self\->{age}    = min($age, 18);
\&        $self\->{gender} = $gender // \*(Aqunspecified\*(Aq;
\&    }
\&
\&    # Traverse tree with node\-printing callback
\&    # (Callback only interested in nodes, ignores any other args passed to it)
\&    $tree\->traverse( func($node,...) { $node\->print } );
.Ve
.PP
The \f(CW\*(C`...\*(C'\fR may appear as a separate \*(L"pseudo-parameter\*(R" anywhere in the
signature, but is normally placed at the very end. It has no other
effect except to disable the usual \*(L"die if extra arguments\*(R" test that
the module sets up within each method or function.
.PP
This means that a \*(L"yada yada\*(R" can also be used to ignore positional
arguments (as the second example above indicates). So, instead of:
.PP
.Vb 3
\&    method verify ($min, $max, @etc) {
\&        return $min <= $self\->{val} && $self\->{val} <= $max;
\&    }
.Ve
.PP
you can just write:
.PP
.Vb 3
\&    method verify ($min, $max, ...) {
\&        return $min <= $self\->{val} && $self\->{val} <= $max;
\&    }
.Ve
.PP
This is also marginally more efficient, as it does not have to allocate,
initialize, or deallocate the unused slurpy parameter \f(CW@etc\fR.
.PP
\fIRequired and optional parameters\fR
.IX Subsection "Required and optional parameters"
.PP
Parameters declared using \f(CW\*(C`$arg!\*(C'\fR are explicitly \fIrequired\fR.
Parameters declared using \f(CW\*(C`$arg?\*(C'\fR are explicitly \fIoptional\fR.  These
declarations override all other considerations.
.PP
A parameter is implicitly \fIoptional\fR if it is a named parameter, has a
default, or is slurpy.  All other parameters are implicitly
\&\fIrequired\fR.
.PP
.Vb 2
\&    # $greeting is optional because it is named
\&    method hello(:$greeting) { ... }
\&
\&    # $greeting is required because it is positional
\&    method hello($greeting) { ... }
\&
\&    # $greeting is optional because it has a default
\&    method hello($greeting = "Gruezi") { ... }
\&
\&    # $greeting is required because it is explicitly declared using !
\&    method hello(:$greeting!) { ... }
\&
\&    # $greeting is required, even with the default, because it is
\&    # explicitly declared using !
\&    method hello(:$greeting! = "Gruezi") { ... }
.Ve
.PP
\fIThe \f(CI@_\fI signature\fR
.IX Subsection "The @_ signature"
.PP
The \f(CW@_\fR signature is a special case which only shifts \f(CW$self\fR.  It
leaves the rest of \f(CW@_\fR alone.  This way you can get \f(CW$self\fR but do the
rest of the argument handling manually.
.PP
Note that a signature of \f(CW\*(C`(@_)\*(C'\fR is exactly equivalent to a signature
of \f(CW\*(C`(...)\*(C'\fR.  See \*(L"The yada yada marker\*(R".
.PP
\fIThe empty signature\fR
.IX Subsection "The empty signature"
.PP
If a method is given the signature of \f(CW\*(C`()\*(C'\fR or no signature at
all, it takes no arguments.
.SS "Anonymous Methods"
.IX Subsection "Anonymous Methods"
An anonymous method can be declared just like an anonymous sub.
.PP
.Vb 3
\&    my $method = method ($arg) {
\&        return $self\->foo($arg);
\&    };
\&
\&    $obj\->$method(42);
.Ve
.SS "Options"
.IX Subsection "Options"
Method::Signatures takes some options at `use` time of the form
.PP
.Vb 1
\&    use Method::Signatures { option => "value", ... };
.Ve
.PP
\fIcompile_at_BEGIN\fR
.IX Subsection "compile_at_BEGIN"
.PP
By default, named methods and funcs are evaluated at compile time, as
if they were in a \s-1BEGIN\s0 block, just like normal Perl named subs.  That
means this will work:
.PP
.Vb 1
\&    echo("something");
\&
\&    # This function is compiled first
\&    func echo($msg) { print $msg }
.Ve
.PP
You can turn this off lexically by setting compile_at_BEGIN to a false value.
.PP
.Vb 1
\&    use Method::Signatures { compile_at_BEGIN => 0 };
.Ve
.PP
compile_at_BEGIN currently causes some issues when used with Perl 5.8.
See \*(L"Earlier Perl versions\*(R".
.PP
\fIdebug\fR
.IX Subsection "debug"
.PP
When true, turns on debugging messages about compiling methods and
funcs.  See \s-1DEBUGGING\s0.  The flag is currently global, but this may
change.
.SS "Differences from Perl 6"
.IX Subsection "Differences from Perl 6"
Method::Signatures is mostly a straight subset of Perl 6 signatures.
The important differences...
.PP
\fIRestrictions on named parameters\fR
.IX Subsection "Restrictions on named parameters"
.PP
As noted above, there are more restrictions on named parameters than
in Perl 6.
.PP
\fINamed parameters are just hashes\fR
.IX Subsection "Named parameters are just hashes"
.PP
Perl 5 lacks all the fancy named parameter syntax for the caller.
.PP
\fIParameters are copies.\fR
.IX Subsection "Parameters are copies."
.PP
In Perl 6, parameters are aliases.  This makes sense in Perl 6 because
Perl 6 is an \*(L"everything is an object\*(R" language.  Perl 5 is not, so
parameters are much more naturally passed as copies.
.PP
You can alias using the \*(L"alias\*(R" trait.
.PP
\fICan't use positional params as named params\fR
.IX Subsection "Can't use positional params as named params"
.PP
Perl 6 allows you to use any parameter as a named parameter.  Perl 5
lacks the named parameter disambiguating syntax so it is not allowed.
.PP
\fIAddition of the \f(CI\*(C`\e@foo\*(C'\fI reference alias prototype\fR
.IX Subsection "Addition of the @foo reference alias prototype"
.PP
In Perl 6, arrays and hashes don't get flattened, and their
referencing syntax is much improved.  Perl 5 has no such luxury, so
Method::Signatures added a way to alias references to normal variables
to make them easier to work with.
.PP
\fIAddition of the \f(CI@_\fI prototype\fR
.IX Subsection "Addition of the @_ prototype"
.PP
Method::Signatures lets you punt and use \f(CW@_\fR like in regular Perl 5.
.SH "PERFORMANCE"
.IX Header "PERFORMANCE"
There is no run-time performance penalty for using this module above
what it normally costs to do argument handling.
.PP
There is also no run-time penalty for type-checking if you do not
declare types.  The run-time penalty if you do declare types should be
very similar to using Mouse::Util::TypeConstraints (or
Moose::Util::TypeConstraints) directly, and should be faster than
using a module such as MooseX::Params::Validate.  The magic of
Any::Moose is used to give you the lightweight Mouse if you have
not yet loaded Moose, or the full-bodied Moose if you have.
.PP
Type-checking modules are not loaded until run-time, so this is fine:
.PP
.Vb 4
\&    use Method::Signatures;
\&    use Moose;
\&    # you will still get Moose type checking
\&    # (assuming you declare one or more methods with types)
.Ve
.SH "DEBUGGING"
.IX Header "DEBUGGING"
One of the best ways to figure out what Method::Signatures is doing is
to run your code through B::Deparse (run the code with \-MO=Deparse).
.PP
Setting the \f(CW\*(C`METHOD_SIGNATURES_DEBUG\*(C'\fR environment variable will cause
Method::Signatures to display debugging information when it is
compiling signatures.
.SH "EXAMPLE"
.IX Header "EXAMPLE"
Here's an example of a method which displays some text and takes some
extra options.
.PP
.Vb 1
\&  use Method::Signatures;
\&
\&  method display($text is ro, :$justify = "left", :$fh = \e*STDOUT) {
\&      ...
\&  }
\&
\&  # $text = $stuff, $justify = "left" and $fh = \e*STDOUT
\&  $obj\->display($stuff);
\&
\&  # $text = $stuff, $justify = "left" and $fh = \e*STDERR
\&  $obj\->display($stuff, fh => \e*STDERR);
\&
\&  # error, missing required $text argument
\&  $obj\->display();
.Ve
.PP
The \fIdisplay()\fR method is equivalent to all this code.
.PP
.Vb 2
\&  sub display {
\&      my $self = shift;
\&
\&      croak(\*(Aqdisplay() missing required argument $text\*(Aq) unless @_ > 0;
\&      const my $text = $_[0];
\&
\&      my(%args) = @_[1 .. $#_];
\&      my $justify = exists $args{justify} ? $args{justify} : \*(Aqleft\*(Aq;
\&      my $fh      = exists $args{fh}      ? $args{\*(Aqfh\*(Aq}    : \e*STDOUT;
\&
\&      ...
\&  }
.Ve
.SH "EXPERIMENTING"
.IX Header "EXPERIMENTING"
If you want to experiment with the prototype syntax, start with
\&\f(CW\*(C`Method::Signatures::parse_func\*(C'\fR.  It takes a method prototype
and returns a string of Perl 5 code which will be placed at the
beginning of that method.
.PP
If you would like to try to provide your own type checking, subclass
Method::Signatures and either override \f(CW\*(C`type_check\*(C'\fR or
\&\f(CW\*(C`inject_for_type_check\*(C'\fR.  See \*(L"\s-1EXTENDING\s0\*(R", below.
.PP
This interface is experimental, unstable and will change between
versions.
.SH "EXTENDING"
.IX Header "EXTENDING"
If you wish to subclass Method::Signatures, the following methods are
good places to start.
.SS "too_many_args_error, named_param_error, required_arg, type_error, where_error"
.IX Subsection "too_many_args_error, named_param_error, required_arg, type_error, where_error"
These are class methods which report the various run-time errors
(extra parameters, unknown named parameter, required parameter
missing, parameter fails type check, and parameter fails where
constraint respectively).  Note that each one calls
\&\f(CW\*(C`signature_error\*(C'\fR, which your versions should do as well.
.SS "signature_error"
.IX Subsection "signature_error"
This is a class method which calls \f(CW\*(C`signature_error_handler\*(C'\fR (see
below) and reports the error as being from the caller's perspective.
Most likely you will not need to override this.  If you'd like to have
Method::Signatures errors give full stack traces (similar to
\&\f(CW$Carp::Verbose\fR), have a look at Carp::Always.
.SS "signature_error_handler"
.IX Subsection "signature_error_handler"
By default, \f(CW\*(C`signature_error\*(C'\fR generates an error message and
\&\f(CW\*(C`die\*(C'\fRs with that message.  If you need to do something fancier with
the generated error message, your subclass can define its own
\&\f(CW\*(C`signature_error_handler\*(C'\fR.  For example:
.PP
.Vb 1
\&    package My::Method::Signatures;
\&
\&    use Moose;
\&    extends \*(AqMethod::Signatures\*(Aq;
\&
\&    sub signature_error_handler {
\&        my ($class, $msg) = @_;
\&        die bless { message => $msg }, \*(AqMy::ExceptionClass\*(Aq;
\&    };
.Ve
.SS "type_check"
.IX Subsection "type_check"
This is a class method which is called to verify that parameters have
the proper type.  If you want to change the way that
Method::Signatures does its type checking, this is most likely what
you want to override.  It calls \f(CW\*(C`type_error\*(C'\fR (see above).
.SS "inject_for_type_check"
.IX Subsection "inject_for_type_check"
This is the object method that actually inserts the call to
\&\*(L"type_check\*(R" into your Perl code.  Most likely you will not need to
override this, but if you wanted different parameters passed into
\&\f(CW\*(C`type_check\*(C'\fR, this would be the place to do it.
.SH "BUGS, CAVEATS and NOTES"
.IX Header "BUGS, CAVEATS and NOTES"
Please report bugs and leave feedback at
<bug\-Method\-Signatures> at <rt.cpan.org>.  Or use the
web interface at <http://rt.cpan.org>.  Report early, report often.
.SS "One liners"
.IX Subsection "One liners"
If you want to write \*(L"use Method::Signatures\*(R" in a one-liner, do a
\&\f(CW\*(C`\-MMethod::Signatures\*(C'\fR first.  This is due to a bug/limitation in
Devel::Declare.
.SS "Close parends in quotes or comments"
.IX Subsection "Close parends in quotes or comments"
Because of the way Devel::Declare parses things, an unbalanced
close parend inside a quote or comment could throw off the signature
parsing.  For instance:
.PP
.Vb 4
\&    func foo (
\&        $foo,       # $foo might contain )
\&        $bar
\&    )
.Ve
.PP
is going to produce a syntax error, because the parend inside the
comment is perceived as the end of the signature.  On the other hand,
this:
.PP
.Vb 4
\&    func foo (
\&        $foo,       # (this is the $foo parend)
\&        $bar
\&    )
.Ve
.PP
is fine, because the parends in the comments are balanced.
.PP
If you absolutely can't avoid an unbalanced close parend, such as in
the following signature:
.PP
.Vb 1
\&    func foo ( $foo, $bar = ")" )       # this won\*(Aqt parse correctly
.Ve
.PP
you can always use a backslash to tell the parser that that close
parend doesn't indicate the end of the signature:
.PP
.Vb 1
\&    func foo ( $foo, $bar = "\e)" )      # this is fine
.Ve
.PP
This even works in single quotes:
.PP
.Vb 1
\&    func foo ( $foo, $bar = \*(Aq\e)\*(Aq )      # default is \*(Aq)\*(Aq, *not* \*(Aq\e)\*(Aq!
.Ve
.PP
although we don't recomment that form, as it may be surprising to
readers of your code.
.SS "No source filter"
.IX Subsection "No source filter"
While this module does rely on the black magic of Devel::Declare to
access Perl's own parser, it does not depend on a source filter.  As
such, it doesn't try to parse and rewrite your source code and there
should be no weird side effects.
.PP
Devel::Declare only affects compilation.  After that, it's a normal
subroutine.  As such, for all that hairy magic, this module is
surprisingly stable.
.SS "Earlier Perl versions"
.IX Subsection "Earlier Perl versions"
The most noticeable is if an error occurs at compile time, such as a
strict error, perl might not notice until it tries to compile
something else via an \f(CW\*(C`eval\*(C'\fR or \f(CW\*(C`require\*(C'\fR at which point perl will
appear to fail where there is no reason to fail.
.PP
We recommend you use the compile_at_BEGIN flag to turn off
compile-time parsing.
.PP
You can't use any feature that requires a smartmatch expression (i.e.
conditional \*(L"Defaults\*(R" and \*(L"Value Constraints\*(R") in Perl 5.8.
.PP
Method::Signatures cannot be used with Perl versions prior to 5.8
because Devel::Declare does not work with those earlier versions.
.SS "What about class methods?"
.IX Subsection "What about class methods?"
Right now there's nothing special about class methods.  Just use
\&\f(CW$class\fR as your invocant like the normal Perl 5 convention.
.PP
There may be special syntax to separate class from object methods in
the future.
.SS "What about the return value?"
.IX Subsection "What about the return value?"
Currently there is no support for declaring the type of the return
value.
.SS "How does this relate to Perl's built-in prototypes?"
.IX Subsection "How does this relate to Perl's built-in prototypes?"
It doesn't.  Perl prototypes are a rather different beastie from
subroutine signatures.  They don't work on methods anyway.
.PP
A syntax for function prototypes is being considered.
.PP
.Vb 1
\&    func($foo, $bar?) is proto($;$)
.Ve
.SS "Error checking"
.IX Subsection "Error checking"
Here's some additional checks I would like to add, mostly to avoid
ambiguous or non-sense situations.
.PP
* If one positional param is optional, everything to the right must be optional
.PP
.Vb 1
\&    method foo($a, $b?, $c?)  # legal
\&
\&    method bar($a, $b?, $c)   # illegal, ambiguous
.Ve
.PP
Does \f(CW\*(C`\->bar(1,2)\*(C'\fR mean \f(CW$a\fR = 1 and \f(CW$b\fR = 2 or \f(CW$a\fR = 1, \f(CW$c\fR = 3?
.PP
* Positionals are resolved before named params.  They have precedence.
.SS "Slurpy parameter restrictions"
.IX Subsection "Slurpy parameter restrictions"
Slurpy parameters are currently more restricted than they need to be.
It is possible to work out a slurpy parameter in the middle, or a
named slurpy parameter.  However, there's lots of edge cases and
possible nonsense configurations.  Until that's worked out, we've left
it restricted.
.SS "What about..."
.IX Subsection "What about..."
Method traits are in the pondering stage.
.PP
An \s-1API\s0 to query a method's signature is in the pondering stage.
.PP
Now that we have method signatures, multi-methods are a distinct possibility.
.PP
Applying traits to all parameters as a short-hand?
.PP
.Vb 3
\&    # Equivalent?
\&    method foo($a is ro, $b is ro, $c is ro)
\&    method foo($a, $b, $c) is ro
.Ve
.PP
Role::Basic roles are currently not recognized by the type system.
.PP
A \*(L"go really fast\*(R" switch.  Turn off all runtime checks that might
bite into performance.
.PP
Method traits.
.PP
.Vb 3
\&    method add($left, $right) is predictable   # declarative
\&    method add($left, $right) is cached        # procedural
\&                                               # (and Perl 6 compatible)
.Ve
.SH "THANKS"
.IX Header "THANKS"
Most of this module is based on or copied from hard work done by many
other people.
.PP
All the really scary parts are copied from or rely on Matt Trout's,
Florian Ragwitz's and Rhesa Rozendaal's Devel::Declare work.
.PP
The prototype syntax is a slight adaptation of all the
excellent work the Perl 6 folks have already done.
.PP
The type checking and method modifier work was supplied by Buddy
Burden (barefootcoder).  Thanks to this, you can now use
Method::Signatures (or, more properly,
Method::Signatures::Modifiers) instead of
MooseX::Method::Signatures, which fixes many of the problems
commonly attributed to MooseX::Declare.
.PP
Value constraints and default conditions (i.e. \*(L"where\*(R" and \*(L"when\*(R")
were added by Damian Conway, who also rewrote some of the signature
parsing to make it more robust and more extensible.
.PP
Also thanks to Matthijs van Duin for his awesome Data::Alias which
makes the \f(CW\*(C`\e@foo\*(C'\fR signature work perfectly and Sub::Name which
makes the subroutine names come out right in \fIcaller()\fR.
.PP
And thanks to Florian Ragwitz for his parallel
MooseX::Method::Signatures module from which I borrow ideas and
code.
.SH "LICENSE"
.IX Header "LICENSE"
The original code was taken from Matt S. Trout's tests for Devel::Declare.
.PP
Copyright 2007\-2012 by Michael G Schwern <schwern@pobox.com>.
.PP
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.PP
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
.SH "SEE ALSO"
.IX Header "SEE ALSO"
MooseX::Method::Signatures for an alternative implementation.
.PP
Perl6::Signature for a more complete implementation of Perl 6 signatures.
.PP
Method::Signatures::Simple for a more basic version of what Method::Signatures provides.
.PP
Function::Parameters for a subset of Method::Signature's features without using Devel::Declare.
.PP
signatures for \f(CW\*(C`sub\*(C'\fR with signatures.
.PP
Perl 6 subroutine parameters and arguments \-  <http://perlcabal.org/syn/S06.html#Parameters_and_arguments>
.PP
Moose::Util::TypeConstraints or Mouse::Util::TypeConstraints for
further details on how the type-checking works.
