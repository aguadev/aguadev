.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Class::DBI::Lite::Tutorial 3"
.TH Class::DBI::Lite::Tutorial 3 "2011-09-19" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Class::DBI::Lite::Tutorial \- How To Use Class::DBI::Lite
.SH "QUICKSTART"
.IX Header "QUICKSTART"
The following examples are intended to work with MySQL version 5.1.x
.SS "Example Database"
.IX Subsection "Example Database"
.Vb 4
\&  create table artists (
\&    artist_id   integer unsigned not null primary key auto_increment,
\&    name        varchar(100) not null,
\&  ) engine=innodb charset=utf8;
\&
\&  create table albums (
\&    album_id    integer unsigned not null primary key auto_increment,
\&    arist_id    integer unsigned not null,
\&    name        varchar(100) not null,
\&    unique(artist_id, name),
\&    foreign key fk_albums_artists (artist_id) references artists( artist_id ) on delete restrict
\&  ) engine=innodb charset=utf8;
.Ve
.SS "Example Classes"
.IX Subsection "Example Classes"
First you must subclass \f(CW\*(C`Class::DBI::Lite::*\*(C'\fR and define your database connection:
.PP
\fIYour 'Model' Class:\fR
.IX Subsection "Your 'Model' Class:"
.PP
File \f(CW\*(C`lib/App/db/model.pm\*(C'\fR
.PP
.Vb 1
\&  package App::db::model;
\&  
\&  use strict;
\&  use warnings \*(Aqall\*(Aq;
\&  use base \*(AqClass::DBI::Lite::mysql\*(Aq;
\&  
\&  _\|_PACKAGE_\|_\->connection(
\&    \*(AqDBI:mysql:dbname:hostname\*(Aq, \*(Aqusername\*(Aq, \*(Aqpassword\*(Aq
\&  );
\&  
\&  1;# return true:
.Ve
.PP
\fIYour 'Entity' Classes:\fR
.IX Subsection "Your 'Entity' Classes:"
.PP
File \f(CW\*(C`lib/App/db/artist.pm\*(C'\fR
.PP
.Vb 1
\&  package App::db::artist;
\&  
\&  use strict;
\&  use warnings \*(Aqall\*(Aq;
\&  use base \*(AqApp::db::model\*(Aq;
\&  
\&  _\|_PACKAGE_\|_\->set_up_table(\*(Aqartists\*(Aq);
\&  
\&  # Artists have many Albums, referenced by the field \*(Aqartist_id\*(Aq:
\&  _\|_PACKAGE_\|_\->has_many(
\&    albums  =>
\&      \*(AqApp::db::album\*(Aq =>
\&        \*(Aqartist_id\*(Aq
\&  );
\&  
\&  1;# return true:
.Ve
.PP
File \f(CW\*(C`lib/App/db/album.pm\*(C'\fR
.PP
.Vb 1
\&  package App::db::album;
\&  
\&  use strict;
\&  use warnings \*(Aqall\*(Aq;
\&  use base \*(AqApp::db::model\*(Aq;
\&  
\&  _\|_PACKAGE_\|_\->set_up_table(\*(Aqalbums\*(Aq);
\&  
\&  # Albums have an artist, referenced by the field \*(Aqartist_id\*(Aq
\&  _\|_PACKAGE_\|_\->belongs_to(
\&    artist  =>
\&      \*(AqApp::db::artist\*(Aq  =>
\&        \*(Aqartist_id\*(Aq
\&  );
\&  
\&  1;# return true:
.Ve
.SS "Example Usage"
.IX Subsection "Example Usage"
Using \f(CW\*(C`Class::DBI::Lite\*(C'\fR is simple.
.PP
.Vb 1
\&  #!/usr/bin/perl \-w
\&  
\&  use strict;
\&  use warnings \*(Aqall\*(Aq;
\&  
\&  use App::db::artist;
\&  use App::db::album;
\&
\&  # Now you\*(Aqre all set!
.Ve
.SS "Table Relationships"
.IX Subsection "Table Relationships"
If you have relationships between your classes, you can express them like this:
.PP
\fIOne-To-Many Relationships\fR
.IX Subsection "One-To-Many Relationships"
.PP
.Vb 5
\&  _\|_PACKAGE_\|_\->has_many(
\&    <methodname> =>
\&      <classname> =>
\&        <their_fieldname>
\&  );
.Ve
.PP
\fIOne-To-One Relationships\fR
.IX Subsection "One-To-One Relationships"
.PP
.Vb 5
\&  _\|_PACKAGE_\|_\->has_one(
\&    <methodname> =>
\&      <classname> =>
\&        <my_fieldname>
\&  );
.Ve
.PP
\&...or...
.PP
.Vb 5
\&  _\|_PACKAGE_\|_\->belongs_to(
\&    <methodname> =>
\&      <classname> =>
\&        <my_fieldname>
\&  );
.Ve
.PP
So in our example we say:
.PP
.Vb 6
\&  # Artists have many Albums, referenced by the field \*(Aqartist_id\*(Aq:
\&  _\|_PACKAGE_\|_\->has_many(
\&    albums  =>
\&      \*(AqApp::db::album\*(Aq =>
\&        \*(Aqartist_id\*(Aq
\&  );
.Ve
.PP
Which means that given an instance of \f(CW\*(C`My::Artist\*(C'\fR you can do this:
.PP
.Vb 2
\&  # Fetch the artist:
\&  my $artist = App::db::artist\->retrieve( 1 );
\&  
\&  # Fetch the artist\*(Aqs albums:
\&  my @albums = $artist\->albums;
\&  
\&  # Print the artist\*(Aqs name for each of these albums:
\&  foreach my $album ( @albums ) {
\&    print $album\->artist\->name;
\&  }
\&
\&  # As of version 1.005 You can also do the following:
\&  my @best_of = $artist\->albums({name => { LIKE => \*(Aq%Best of%\*(Aq} });
\&  
\&  my @sorted = $artist\->albums(undef, { order_by => \*(Aqname DESC\*(Aq } );
\&  
\&  my @sorted_best = $artist\->albums({
\&    name => { LIKE => \*(Aq%Best of%\*(Aq }
\&  }, {
\&    order_by => \*(Aqname DESC\*(Aq
\&  });
\&  
\&  my @top_five = $artist\->albums({
\&    name => { LIKE => \*(Aq%Best of%\*(Aq }
\&  }, {
\&    order_by => \*(Aqname DESC limit 0, 5\*(Aq
\&  });
.Ve
.PP
That example would look like this if we were doing it with hand-coded \s-1SQL\s0 statements:
.PP
.Vb 2
\&  # **** THE OLD WAY: ****
\&  use DBI;
\&  
\&  my $dbh = DBI\->connect(\*(AqDBI:mysql:dbname:hostname\*(Aq, \*(Aqusername\*(Aq, \*(Aqpassword\*(Aq );
\&  
\&  # Fetch the artist:
\&  my $sth = $dbh\->prepare("SELECT * FROM artists WHERE artist_id = ?");
\&  $sth\->execute( 1 );
\&  my ($artist) = $sth\->fetchrow_hashref;
\&  $sth\->finish();
\&  
\&  # Fetch the artist\*(Aqs albums:
\&  my @albums = ( );
\&  $sth = $dbh\->prepare("SELECT * FROM albums WHERE artist_id = ?");
\&  $sth\->execute( $artist\->{artist_id} );
\&  while( my $album = $sth\->fetchrow_hashref ) {
\&    push @albums, $album;
\&  }
\&  $sth\->finish();
\&  
\&  # Print the artist\*(Aqs name for each of these albums:
\&  $sth = $dbh\->prepare("SELECT * FROM artists WHERE artist_id = ?");
\&  foreach my $album ( @albums ) {
\&    $sth\->execute( $album\->{artist_id} );
\&    my ($artist) = $sth\->fetchrow_hashref;
\&    print $artist\->{name};
\&  }
\&  $sth\->finish();
.Ve
.PP
\fICreating\fR
.IX Subsection "Creating"
.PP
.Vb 2
\&  # Create an artist:
\&  my $artist = App::db::artist\->create( name => \*(AqBob Marley\*(Aq );
\&  
\&  # These both do the same:
\&  print $artist\->id;
\&  print $artist\->artist_id;
.Ve
.PP
\fIList Context vs Scalar Context\fR
.IX Subsection "List Context vs Scalar Context"
.PP
If you execute a search method in list context, you get an array.  Executing a search
method in scalar context returns an iterator.
.PP
\&\fBList Context\fR:
.PP
.Vb 1
\&  my @albums = App::db::album\->search( name => \*(AqLegend\*(Aq );
\&
\&  my @albums = $artist\->albums;
.Ve
.PP
\&\fBScalar Context\fR:
.PP
.Vb 1
\&  my $albums = App::db::album\->search( name => \*(AqLegend\*(Aq );
\&  
\&  my $albums = $artist\->albums;
.Ve
.PP
Iterators can be worked through like this:
.PP
.Vb 4
\&  while( my $album = $albums\->next ) {
\&    # Work with $album:
\&    print $album\->name;
\&  }
\&  
\&  # How many items are in the iterator?
\&  print $albums\->count;
.Ve
.PP
\&\fB**NOTE:\fR Any \f(CW\*(C`has_many\*(C'\fR extension methods are also considered 'search' methods,
so they will conform to this list/scalar context behavior as well.
.PP
\fISearching\fR
.IX Subsection "Searching"
.PP
Returns all results as objects of the correct type:
.PP
\&\fBBasic Searching\fR
.PP
.Vb 4
\&  my @albums = App::db::album\->search( name => \*(AqLegend\*(Aq );
\&  my @albums = App::db::album\->search(
\&    artist_id => $artist\->id,
\&  );
.Ve
.PP
\&\fBAdvanced Searching\fR
.PP
Advanced searching takes 1 or 2 parameters:
.PP
.Vb 1
\&  App::db::album\->search_where( { <args> }, [<order_by and limits>] );
.Ve
.PP
Examples:
.PP
.Vb 3
\&  my @albums = App::db::album\->search_where({
\&    artist_id => { IN => [ 1, 2, 3 ] }
\&  });
\&  
\&  my @albums = App::db::album\->search_where({
\&    name  => { LIKE => \*(AqLege%\*(Aq }
\&  }, {
\&    order_by => \*(Aqname DESC LIMIT 0, 10\*(Aq
\&  });
.Ve
.PP
\&\f(CW\*(C`search_where\*(C'\fR uses SQL::Abstract to generate the \s-1SQL\s0, so look there for more examples.
.PP
\fICounting\fR
.IX Subsection "Counting"
.PP
Sometimes you just need to know how many records match your query:
.PP
.Vb 1
\&  my $count = App::db::album\->count_search( name => \*(AqBob Marley\*(Aq );
.Ve
.PP
Using \f(CW\*(C`count_where\*(C'\fR you can make more interesting queries:
.PP
.Vb 4
\&  my $count = App::db::album\->count_search_where({
\&    name  => { LIKE => \*(AqLegen%\*(Aq },
\&    artist_id => { IN => [ 1, 2, 3 ] }
\&  });
.Ve
.PP
\&\f(CW\*(C`count_search_where\*(C'\fR uses SQL::Abstract to generate the \s-1SQL\s0, so look there for more examples.
.PP
\fIUpdating\fR
.IX Subsection "Updating"
.PP
Example:
.PP
.Vb 1
\&  my $artist = App::db::artist\->create( name => \*(AqBob Marley\*(Aq );
\&  
\&  # Change the name:
\&  $artist\->name( \*(AqBob\*(Aq );
\&  
\&  print $artist\->name; # Bob
\&  
\&  # Save the changes to the database:
\&  $artist\->update;
.Ve
.PP
If you don't call \f(CW\*(C`update\*(C'\fR after making changes to an object, you will get a warning that looks like this:
.PP
.Vb 1
\&  My::Artist #1 DESTROY\*(Aqd without saving changes to name
.Ve
.PP
To cause the object to forget about any unsaved changes you made to it, do this:
.PP
.Vb 2
\&  # Hit the reset button:
\&  $artist\->discard_changes;
.Ve
.PP
\fIDeleting\fR
.IX Subsection "Deleting"
.PP
Removes the item from the database instantly:
.PP
.Vb 1
\&  $artist\->delete;
.Ve
.PP
It's the same as:
.PP
.Vb 3
\&  my $sth = $dbh\->prepare("DELETE FROM artists WHERE artist_id = ?");
\&  $sth\->execute( 1 );
\&  $sth\->finish();
.Ve
.SH "INTERMEDIATE"
.IX Header "INTERMEDIATE"
.SS "Event Triggers"
.IX Subsection "Event Triggers"
You can program triggers from within your application code.  These can be useful
but beware of mixing too much business logic in with your data logic.
.PP
\fIbefore_create\fR
.IX Subsection "before_create"
.PP
.Vb 2
\&  _\|_PACKAGE_\|_\->add_trigger( before_create => sub {
\&    my ($self) = @_;
\&    
\&    # Do something before we are created:
\&  });
.Ve
.PP
\fIafter_create\fR
.IX Subsection "after_create"
.PP
.Vb 2
\&  _\|_PACKAGE_\|_\->add_trigger( after_create => sub {
\&    my ($self) = @_;
\&    
\&    # Do something now that we\*(Aqve been created:
\&  });
.Ve
.PP
\fIbefore_update\fR
.IX Subsection "before_update"
.PP
.Vb 2
\&  _\|_PACKAGE_\|_\->add_trigger( before_update => sub {
\&    my ($self) = @_;
\&    
\&    # Do something before we are updated:
\&  });
.Ve
.PP
\fIafter_update\fR
.IX Subsection "after_update"
.PP
.Vb 2
\&  _\|_PACKAGE_\|_\->add_trigger( after_update => sub {
\&    my ($self) = @_;
\&    
\&    # Do something now that we\*(Aqve been updated:
\&  });
.Ve
.PP
\fIbefore_delete\fR
.IX Subsection "before_delete"
.PP
.Vb 2
\&  _\|_PACKAGE_\|_\->add_trigger( before_delete => sub {
\&    my ($self) = @_;
\&    
\&    # Do something before we are deleted:
\&  });
.Ve
.PP
\fIafter_delete\fR
.IX Subsection "after_delete"
.PP
.Vb 2
\&  _\|_PACKAGE_\|_\->add_trigger( after_delete => sub {
\&    my ($obj) = @_;
\&    
\&    # Obj only contains { artist_id => 1 }
\&    # Do something with $obj:
\&  });
.Ve
.SS "Field Triggers"
.IX Subsection "Field Triggers"
Sometimes you just want to add a trigger to a specific field.
.PP
\fIbefore_update_<fieldname>\fR
.IX Subsection "before_update_<fieldname>"
.PP
.Vb 4
\&  package App::db::artist;
\&  ...
\&  _\|_PACKAGE_\|_\->add_trigger( before_update_name => sub {
\&    my ($self, $old_value, $new_value) = @_;
\&    
\&    warn "About to change this artist\*(Aqs name from \*(Aq$old_value\*(Aq to \*(Aq$new_value\*(Aq";
\&  });
.Ve
.PP
\fIafter_update_<fieldname>\fR
.IX Subsection "after_update_<fieldname>"
.PP
.Vb 4
\&  package App::db::artist;
\&  ...
\&  _\|_PACKAGE_\|_\->add_trigger( after_update_name => sub {
\&    my ($self, $old_value, $new_value) = @_;
\&    
\&    warn "Finished changing this artist\*(Aqs name from \*(Aq$old_value\*(Aq to \*(Aq$new_value\*(Aq";
\&  });
.Ve
.SS "Transactions"
.IX Subsection "Transactions"
This is how transactions are done with \f(CW\*(C`Class::DBI::Lite\*(C'\fR:
.PP
.Vb 3
\&  # Safely update the name of every album:
\&  eval {
\&    App::db::artist\->do_transaction( sub {
\&    
\&      # Your transaction code goes here:
\&      my $artist = App::db::artist\->retrieve( 1 );
\&      foreach my $album ( $artist\->albums ) {
\&        $album\->name( $artist\->name . \*(Aq: \*(Aq . $album\->name );
\&        $album\->update;
\&      }
\&    });
\&  };
\&  
\&  if( $@ ) {
\&    # There was an error:
\&    die $@;
\&  }
\&  else {
\&    # Everything was OK:
\&  }
.Ve
.SS "Getting the Database Handle"
.IX Subsection "Getting the Database Handle"
You can get the normal database handle by calling \f(CW\*(C`db_Main\*(C'\fR on any of your classes.
.PP
.Vb 1
\&  my $dbh = App::db::artist\->db_Main;
.Ve
.SS "Custom \s-1SQL\s0 Queries:"
.IX Subsection "Custom SQL Queries:"
You can call the \f(CW\*(C`sth_to_objects\*(C'\fR method to convert a prepared statement into
objects of a pre-defined type:
.PP
.Vb 2
\&  # Step 1: Prepare the statement:
\&  my $sth = App::db::artist\->db_Main\->prepare("SELECT * FROM artists WHERE name LIKE ?");
\&  
\&  # Step 2: Execute the statement:
\&  $sth\->execute( \*(AqBob%\*(Aq );
\&  
\&  # Step 3: Call sth_to_objects:
\&  my @artists = App::db::artist\->sth_to_objects( $sth );
.Ve
.SH "ADVANCED TOPICS"
.IX Header "ADVANCED TOPICS"
.SS "Running under mod_perl"
.IX Subsection "Running under mod_perl"
\&\f(CW\*(C`Class::DBI::Lite\*(C'\fR is fully-tested and works perfectly under \f(CW\*(C`mod_perl\*(C'\fR.  Because
it uses Ima::DBI::Contextual under the hood, you get all of its benefits.
