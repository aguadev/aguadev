.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "SemaphoreSet 3"
.TH SemaphoreSet 3 "2014-03-04" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Coro::SemaphoreSet \- efficient set of counting semaphores
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Coro;
\&
\& $sig = new Coro::SemaphoreSet [initial value];
\&
\& $sig\->down ("semaphoreid"); # wait for signal
\&
\& # ... some other "thread"
\&
\& $sig\->up ("semaphoreid");
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module implements sets of counting semaphores (see
Coro::Semaphore). It is nothing more than a hash with normal semaphores
as members, but is more efficiently managed.
.PP
This is useful if you want to allow parallel tasks to run in parallel but
not on the same problem. Just use a SemaphoreSet and lock on the problem
identifier.
.PP
You don't have to load \f(CW\*(C`Coro::SemaphoreSet\*(C'\fR manually, it will be loaded 
automatically when you \f(CW\*(C`use Coro\*(C'\fR and call the \f(CW\*(C`new\*(C'\fR constructor.
.IP "new [inital count]" 4
.IX Item "new [inital count]"
Creates a new semaphore set with the given initial lock count for each
individual semaphore. See Coro::Semaphore.
.ie n .IP "$semset\->down ($id)" 4
.el .IP "\f(CW$semset\fR\->down ($id)" 4
.IX Item "$semset->down ($id)"
Decrement the counter, therefore \*(L"locking\*(R" the named semaphore. This
method waits until the semaphore is available if the counter is zero.
.ie n .IP "$semset\->up ($id)" 4
.el .IP "\f(CW$semset\fR\->up ($id)" 4
.IX Item "$semset->up ($id)"
Unlock the semaphore again. If the semaphore reaches the default count for
this set and has no waiters, the space allocated for it will be freed.
.ie n .IP "$semset\->try ($id)" 4
.el .IP "\f(CW$semset\fR\->try ($id)" 4
.IX Item "$semset->try ($id)"
Try to \f(CW\*(C`down\*(C'\fR the semaphore. Returns true when this was possible,
otherwise return false and leave the semaphore unchanged.
.ie n .IP "$semset\->count ($id)" 4
.el .IP "\f(CW$semset\fR\->count ($id)" 4
.IX Item "$semset->count ($id)"
Return the current semaphore count for the specified semaphore.
.ie n .IP "$semset\->waiters ($id)" 4
.el .IP "\f(CW$semset\fR\->waiters ($id)" 4
.IX Item "$semset->waiters ($id)"
Returns the number (in scalar context) or list (in list context) of
waiters waiting on the specified semaphore.
.ie n .IP "$semset\->wait ($id)" 4
.el .IP "\f(CW$semset\fR\->wait ($id)" 4
.IX Item "$semset->wait ($id)"
Same as Coro::Semaphore::wait on the specified semaphore.
.ie n .IP "$guard = $semset\->guard ($id)" 4
.el .IP "\f(CW$guard\fR = \f(CW$semset\fR\->guard ($id)" 4
.IX Item "$guard = $semset->guard ($id)"
This method calls \f(CW\*(C`down\*(C'\fR and then creates a guard object. When the guard
object is destroyed it automatically calls \f(CW\*(C`up\*(C'\fR.
.ie n .IP "$semaphore = $semset\->sem ($id)" 4
.el .IP "\f(CW$semaphore\fR = \f(CW$semset\fR\->sem ($id)" 4
.IX Item "$semaphore = $semset->sem ($id)"
This SemaphoreSet version is based on Coro::Semaphore's. This function
creates (if necessary) the underlying Coro::Semaphore object and returns
it. You may legally call any Coro::Semaphore method on it, but note that
calling \f(CW\*(C`$semset\->up\*(C'\fR can invalidate the returned semaphore.
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 2
\& Marc Lehmann <schmorp@schmorp.de>
\& http://home.schmorp.de/
.Ve
