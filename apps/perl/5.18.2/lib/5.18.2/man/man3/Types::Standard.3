.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Types::Standard 3"
.TH Types::Standard 3 "2014-04-02" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Types::Standard \- bundled set of built\-in types for Type::Tiny
.SH "STATUS"
.IX Header "STATUS"
This module is covered by the
Type-Tiny stability policy.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Type::Tiny bundles a few types which seem to be useful.
.SS "Moose-like"
.IX Subsection "Moose-like"
The following types are similar to those described in
Moose::Util::TypeConstraints.
.ie n .IP """Any""" 4
.el .IP "\f(CWAny\fR" 4
.IX Item "Any"
Absolutely any value passes this type constraint (even undef).
.ie n .IP """Item""" 4
.el .IP "\f(CWItem\fR" 4
.IX Item "Item"
Essentially the same as \f(CW\*(C`Any\*(C'\fR. All other type constraints in this library
inherit directly or indirectly from \f(CW\*(C`Item\*(C'\fR.
.ie n .IP """Bool""" 4
.el .IP "\f(CWBool\fR" 4
.IX Item "Bool"
Values that are reasonable booleans. Accepts 1, 0, the empty string and
undef.
.ie n .IP """Maybe[\`a]""" 4
.el .IP "\f(CWMaybe[\`a]\fR" 4
.IX Item "Maybe[a]"
Given another type constraint, also accepts undef. For example,
\&\f(CW\*(C`Maybe[Int]\*(C'\fR accepts all integers plus undef.
.ie n .IP """Undef""" 4
.el .IP "\f(CWUndef\fR" 4
.IX Item "Undef"
Only undef passes this type constraint.
.ie n .IP """Defined""" 4
.el .IP "\f(CWDefined\fR" 4
.IX Item "Defined"
Only undef fails this type constraint.
.ie n .IP """Value""" 4
.el .IP "\f(CWValue\fR" 4
.IX Item "Value"
Any defined, non-reference value.
.ie n .IP """Str""" 4
.el .IP "\f(CWStr\fR" 4
.IX Item "Str"
Any string.
.Sp
(The only difference between \f(CW\*(C`Value\*(C'\fR and \f(CW\*(C`Str\*(C'\fR is that the former accepts
typeglobs and vstrings.)
.Sp
Other customers also bought: \f(CW\*(C`StringLike\*(C'\fR from Types::TypeTiny.
.ie n .IP """Num""" 4
.el .IP "\f(CWNum\fR" 4
.IX Item "Num"
See \f(CW\*(C`LaxNum\*(C'\fR and \f(CW\*(C`StrictNum\*(C'\fR below.
.ie n .IP """Int""" 4
.el .IP "\f(CWInt\fR" 4
.IX Item "Int"
An integer; that is a string of digits 0 to 9, optionally prefixed with a
hyphen-minus character.
.ie n .IP """ClassName""" 4
.el .IP "\f(CWClassName\fR" 4
.IX Item "ClassName"
The name of a loaded package. The package must have \f(CW@ISA\fR or
\&\f(CW$VERSION\fR defined, or must define at least one sub to be considered
a loaded package.
.ie n .IP """RoleName""" 4
.el .IP "\f(CWRoleName\fR" 4
.IX Item "RoleName"
Like \f(CW\*(C`ClassName\*(C'\fR, but the package must \fInot\fR define a method called
\&\f(CW\*(C`new\*(C'\fR. This is subtly different from Moose's type constraint of the same
name; let me know if this causes you any problems. (I can't promise I'll
change anything though.)
.ie n .IP """Ref[\`a]""" 4
.el .IP "\f(CWRef[\`a]\fR" 4
.IX Item "Ref[a]"
Any defined reference value, including blessed objects.
.Sp
Unlike Moose, \f(CW\*(C`Ref\*(C'\fR is a parameterized type, allowing Scalar::Util::reftype
checks, a la
.Sp
.Vb 1
\&   Ref["HASH"]  # hashrefs, including blessed hashrefs
.Ve
.ie n .IP """ScalarRef[\`a]""" 4
.el .IP "\f(CWScalarRef[\`a]\fR" 4
.IX Item "ScalarRef[a]"
A value where \f(CW\*(C`ref($value) eq "SCALAR" or ref($value) eq "REF"\*(C'\fR.
.Sp
If parameterized, the referred value must pass the additional constraint.
For example, \f(CW\*(C`ScalarRef[Int]\*(C'\fR must be a reference to a scalar which
holds an integer value.
.ie n .IP """ArrayRef[\`a]""" 4
.el .IP "\f(CWArrayRef[\`a]\fR" 4
.IX Item "ArrayRef[a]"
A value where \f(CW\*(C`ref($value) eq "ARRAY"\*(C'\fR.
.Sp
If parameterized, the elements of the array must pass the additional
constraint. For example, \f(CW\*(C`ArrayRef[Num]\*(C'\fR must be a reference to an
array of numbers.
.Sp
Other customers also bought: \f(CW\*(C`ArrayLike\*(C'\fR from Types::TypeTiny.
.ie n .IP """HashRef[\`a]""" 4
.el .IP "\f(CWHashRef[\`a]\fR" 4
.IX Item "HashRef[a]"
A value where \f(CW\*(C`ref($value) eq "HASH"\*(C'\fR.
.Sp
If parameterized, the values of the hash must pass the additional
constraint. For example, \f(CW\*(C`HashRef[Num]\*(C'\fR must be a reference to an
hash where the values are numbers. The hash keys are not constrained,
but Perl limits them to strings; see \f(CW\*(C`Map\*(C'\fR below if you need to further
constrain the hash values.
.Sp
Other customers also bought: \f(CW\*(C`HashLike\*(C'\fR from Types::TypeTiny.
.ie n .IP """CodeRef""" 4
.el .IP "\f(CWCodeRef\fR" 4
.IX Item "CodeRef"
A value where \f(CW\*(C`ref($value) eq "CODE"\*(C'\fR.
.Sp
Other customers also bought: \f(CW\*(C`CodeLike\*(C'\fR from Types::TypeTiny.
.ie n .IP """RegexpRef""" 4
.el .IP "\f(CWRegexpRef\fR" 4
.IX Item "RegexpRef"
A value where \f(CW\*(C`ref($value) eq "Regexp"\*(C'\fR.
.ie n .IP """GlobRef""" 4
.el .IP "\f(CWGlobRef\fR" 4
.IX Item "GlobRef"
A value where \f(CW\*(C`ref($value) eq "GLOB"\*(C'\fR.
.ie n .IP """FileHandle""" 4
.el .IP "\f(CWFileHandle\fR" 4
.IX Item "FileHandle"
A file handle.
.ie n .IP """Object""" 4
.el .IP "\f(CWObject\fR" 4
.IX Item "Object"
A blessed object.
.Sp
(This also accepts regexp refs.)
.SS "Structured"
.IX Subsection "Structured"
\&\s-1OK,\s0 so I stole some ideas from MooseX::Types::Structured.
.ie n .IP """Map[\`k, \`v]""" 4
.el .IP "\f(CWMap[\`k, \`v]\fR" 4
.IX Item "Map[k, v]"
Similar to \f(CW\*(C`HashRef\*(C'\fR but parameterized with type constraints for both the
key and value. The constraint for keys would typically be a subtype of
\&\f(CW\*(C`Str\*(C'\fR.
.ie n .IP """Tuple[...]""" 4
.el .IP "\f(CWTuple[...]\fR" 4
.IX Item "Tuple[...]"
Subtype of \f(CW\*(C`ArrayRef\*(C'\fR, accepting an list of type constraints for
each slot in the array.
.Sp
\&\f(CW\*(C`Tuple[Int, HashRef]\*(C'\fR would match \f(CW\*(C`[1, {}]\*(C'\fR but not \f(CW\*(C`[{}, 1]\*(C'\fR.
.ie n .IP """Dict[...]""" 4
.el .IP "\f(CWDict[...]\fR" 4
.IX Item "Dict[...]"
Subtype of \f(CW\*(C`HashRef\*(C'\fR, accepting an list of type constraints for
each slot in the hash.
.Sp
For example \f(CW\*(C`Dict[name => Str, id => Int]\*(C'\fR allows
\&\f(CW\*(C`{ name => "Bob", id => 42 }\*(C'\fR.
.ie n .IP """Optional[\`a]""" 4
.el .IP "\f(CWOptional[\`a]\fR" 4
.IX Item "Optional[a]"
Used in conjunction with \f(CW\*(C`Dict\*(C'\fR and \f(CW\*(C`Tuple\*(C'\fR to specify slots that are
optional and may be omitted (but not necessarily set to an explicit undef).
.Sp
\&\f(CW\*(C`Dict[name => Str, id => Optional[Int]]\*(C'\fR allows \f(CW\*(C`{ name => "Bob" }\*(C'\fR
but not \f(CW\*(C`{ name => "Bob", id => "BOB" }\*(C'\fR.
.PP
This module also exports a \f(CW\*(C`slurpy\*(C'\fR function, which can be used as follows:
.PP
.Vb 1
\&   my $type = Tuple[Str, slurpy ArrayRef[Int]];
\&   
\&   $type\->( ["Hello"] );                # ok
\&   $type\->( ["Hello", 1, 2, 3] );       # ok
\&   $type\->( ["Hello", [1, 2, 3]] );     # not ok
.Ve
.SS "Objects"
.IX Subsection "Objects"
\&\s-1OK,\s0 so I stole some ideas from MooX::Types::MooseLike::Base.
.ie n .IP """InstanceOf[\`a]""" 4
.el .IP "\f(CWInstanceOf[\`a]\fR" 4
.IX Item "InstanceOf[a]"
Shortcut for a union of Type::Tiny::Class constraints.
.Sp
\&\f(CW\*(C`InstanceOf["Foo", "Bar"]\*(C'\fR allows objects blessed into the \f(CW\*(C`Foo\*(C'\fR
or \f(CW\*(C`Bar\*(C'\fR classes, or subclasses of those.
.Sp
Given no parameters, just equivalent to \f(CW\*(C`Object\*(C'\fR.
.ie n .IP """ConsumerOf[\`a]""" 4
.el .IP "\f(CWConsumerOf[\`a]\fR" 4
.IX Item "ConsumerOf[a]"
Shortcut for an intersection of Type::Tiny::Role constraints.
.Sp
\&\f(CW\*(C`ConsumerOf["Foo", "Bar"]\*(C'\fR allows objects where \f(CW\*(C`$o\->DOES("Foo")\*(C'\fR
and \f(CW\*(C`$o\->DOES("Bar")\*(C'\fR both return true.
.Sp
Given no parameters, just equivalent to \f(CW\*(C`Object\*(C'\fR.
.ie n .IP """HasMethods[\`a]""" 4
.el .IP "\f(CWHasMethods[\`a]\fR" 4
.IX Item "HasMethods[a]"
Shortcut for a Type::Tiny::Duck constraint.
.Sp
\&\f(CW\*(C`HasMethods["foo", "bar"]\*(C'\fR allows objects where \f(CW\*(C`$o\->can("foo")\*(C'\fR
and \f(CW\*(C`$o\->can("bar")\*(C'\fR both return true.
.Sp
Given no parameters, just equivalent to \f(CW\*(C`Object\*(C'\fR.
.SS "More"
.IX Subsection "More"
There are a few other types exported by this function:
.ie n .IP """Overload[\`a]""" 4
.el .IP "\f(CWOverload[\`a]\fR" 4
.IX Item "Overload[a]"
With no parameters, checks that the value is an overloaded object. Can
be given one or more string parameters, which are specific operations
to check are overloaded. For example, the following checks for objects
which overload addition and subtraction.
.Sp
.Vb 1
\&   Overload["+", "\-"]
.Ve
.ie n .IP """Tied[\`a]""" 4
.el .IP "\f(CWTied[\`a]\fR" 4
.IX Item "Tied[a]"
A reference to a tied scalar, array or hash.
.Sp
Can be parameterized with a type constraint which will be applied to
the object returned by the \f(CW\*(C`tied()\*(C'\fR function. As a convenience,
can also be parameterized with a string, which will be inflated to a
Type::Tiny::Class.
.Sp
.Vb 2
\&   use Types::Standard qw(Tied);
\&   use Type::Utils qw(class_type);
\&   
\&   my $My_Package = class_type { class => "My::Package" };
\&   
\&   tie my %h, "My::Package";
\&   \e%h ~~ Tied;                   # true
\&   \e%h ~~ Tied[ $My_Package ];    # true
\&   \e%h ~~ Tied["My::Package"];    # true
\&   
\&   tie my $s, "Other::Package";
\&   \e$s ~~ Tied;                   # true
\&   $s  ~~ Tied;                   # false !!
.Ve
.Sp
If you need to check that something is specifically a reference to
a tied hash, use an intersection:
.Sp
.Vb 1
\&   use Types::Standard qw( Tied HashRef );
\&   
\&   my $TiedHash = (Tied) & (HashRef);
\&   
\&   tie my %h, "My::Package";
\&   tie my $s, "Other::Package";
\&   
\&   \e%h ~~ $TiedHash;     # true
\&   \e$s ~~ $TiedHash;     # false
.Ve
.ie n .IP """StrMatch[\`a]""" 4
.el .IP "\f(CWStrMatch[\`a]\fR" 4
.IX Item "StrMatch[a]"
A string that matches a regular expression:
.Sp
.Vb 2
\&   declare "Distance",
\&      as StrMatch[ qr{^([0\-9]+)\es*(mm|cm|m|km)$} ];
.Ve
.Sp
You can optionally provide a type constraint for the array of subexpressions:
.Sp
.Vb 8
\&   declare "Distance",
\&      as StrMatch[
\&         qr{^([0\-9]+)\es*(.+)$},
\&         Tuple[
\&            Int,
\&            enum(DistanceUnit => [qw/ mm cm m km /]),
\&         ],
\&      ];
.Ve
.ie n .IP """Enum[\`a]""" 4
.el .IP "\f(CWEnum[\`a]\fR" 4
.IX Item "Enum[a]"
As per MooX::Types::MooseLike::Base:
.Sp
.Vb 1
\&   has size => (is => "ro", isa => Enum[qw( S M L XL XXL )]);
.Ve
.ie n .IP """OptList""" 4
.el .IP "\f(CWOptList\fR" 4
.IX Item "OptList"
An arrayref of arrayrefs in the style of Data::OptList output.
.ie n .IP """LaxNum"", ""StrictNum""" 4
.el .IP "\f(CWLaxNum\fR, \f(CWStrictNum\fR" 4
.IX Item "LaxNum, StrictNum"
In Moose 2.09, the \f(CW\*(C`Num\*(C'\fR type constraint implementation was changed from
being a wrapper around Scalar::Util's \f(CW\*(C`looks_like_number\*(C'\fR function to
a stricter regexp (which disallows things like \*(L"\-Inf\*(R" and \*(L"Nan\*(R").
.Sp
Types::Standard provides \fIboth\fR implementations. \f(CW\*(C`LaxNum\*(C'\fR is measurably
faster.
.Sp
The \f(CW\*(C`Num\*(C'\fR type constraint is currently an alias for \f(CW\*(C`LaxNum\*(C'\fR unless you
set the \f(CW\*(C`PERL_TYPES_STANDARD_STRICTNUM\*(C'\fR environment variable to true before
loading Types::Standard, in which case it becomes an alias for \f(CW\*(C`StrictNum\*(C'\fR.
The constant \f(CW\*(C`Types::Standard::STRICTNUM\*(C'\fR can be used to check if
\&\f(CW\*(C`Num\*(C'\fR is being strict.
.Sp
Most people should probably use \f(CW\*(C`Num\*(C'\fR or \f(CW\*(C`StrictNum\*(C'\fR. Don't explicitly
use \f(CW\*(C`LaxNum\*(C'\fR unless you specifically need an attribute which will accept
things like \*(L"Inf\*(R".
.SS "Coercions"
.IX Subsection "Coercions"
None of the types in this type library have any coercions by default.
However some standalone coercions may be exported. These can be combined
with type constraints using the \f(CW\*(C`+\*(C'\fR operator.
.ie n .IP """MkOpt""" 4
.el .IP "\f(CWMkOpt\fR" 4
.IX Item "MkOpt"
A coercion from \f(CW\*(C`ArrayRef\*(C'\fR, \f(CW\*(C`HashRef\*(C'\fR or \f(CW\*(C`Undef\*(C'\fR to \f(CW\*(C`OptList\*(C'\fR. Example
usage in a Moose attribute:
.Sp
.Vb 1
\&   use Types::Standard qw( OptList MkOpt );
\&   
\&   has options => (
\&      is     => "ro",
\&      isa    => OptList + MkOpt,
\&      coerce => 1,
\&   );
.Ve
.ie n .IP """Split[\`a]""" 4
.el .IP "\f(CWSplit[\`a]\fR" 4
.IX Item "Split[a]"
Split a string on a regexp.
.Sp
.Vb 1
\&   use Types::Standard qw( ArrayRef Str Split );
\&   
\&   has name => (
\&      is     => "ro",
\&      isa    => (ArrayRef[Str]) + (Split[qr/\es/]),
\&      coerce => 1,
\&   );
.Ve
.ie n .IP """Join[\`a]""" 4
.el .IP "\f(CWJoin[\`a]\fR" 4
.IX Item "Join[a]"
Join an array of strings with a delimiter.
.Sp
.Vb 1
\&   use Types::Standard qw( Str Join );
\&   
\&   my $FileLines = Str + Join["\en"];
\&   
\&   has file_contents => (
\&      is     => "ro",
\&      isa    => $FileLines,
\&      coerce => 1,
\&   );
.Ve
.SS "Constants"
.IX Subsection "Constants"
.ie n .IP """Types::Standard::STRICTNUM""" 4
.el .IP "\f(CWTypes::Standard::STRICTNUM\fR" 4
.IX Item "Types::Standard::STRICTNUM"
Indicates whether \f(CW\*(C`Num\*(C'\fR is an alias for \f(CW\*(C`StrictNum\*(C'\fR. (It is usually an
alias for \f(CW\*(C`LaxNum\*(C'\fR.)
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs to
<http://rt.cpan.org/Dist/Display.html?Queue=Type\-Tiny>.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Type::Tiny::Manual.
.PP
Type::Tiny, Type::Library, Type::Utils, Type::Coercion.
.PP
Moose::Util::TypeConstraints,
Mouse::Util::TypeConstraints,
MooseX::Types::Structured.
.PP
Types::XSD provides some type constraints based on \s-1XML\s0 Schema's data
types; this includes constraints for ISO8601\-formatted datetimes, integer
ranges (e.g. \f(CW\*(C`PositiveInteger[maxInclusive=>10]\*(C'\fR and so on.
.PP
Types::Encodings provides \f(CW\*(C`Bytes\*(C'\fR and \f(CW\*(C`Chars\*(C'\fR type constraints that
were formerly found in Types::Standard.
.PP
Types::Common::Numeric and Types::Common::String provide replacements
for MooseX::Types::Common.
.SH "AUTHOR"
.IX Header "AUTHOR"
Toby Inkster <tobyink@cpan.org>.
.SH "COPYRIGHT AND LICENCE"
.IX Header "COPYRIGHT AND LICENCE"
This software is copyright (c) 2013\-2014 by Toby Inkster.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
.SH "DISCLAIMER OF WARRANTIES"
.IX Header "DISCLAIMER OF WARRANTIES"
\&\s-1THIS PACKAGE IS PROVIDED \*(L"AS IS\*(R" AND WITHOUT ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.\s0
