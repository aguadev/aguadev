.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Type::Tiny 3"
.TH Type::Tiny 3 "2014-04-02" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Type::Tiny \- tiny, yet Moo(se)\-compatible type constraint
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&   use Scalar::Util qw(looks_like_number);
\&   use Type::Tiny;
\&   
\&   my $NUM = "Type::Tiny"\->new(
\&      name       => "Number",
\&      constraint => sub { looks_like_number($_) },
\&      message    => sub { "$_ ain\*(Aqt a number" },
\&   );
\&   
\&   package Ermintrude {
\&      use Moo;
\&      has favourite_number => (is => "ro", isa => $NUM);
\&   }
\&   
\&   package Bullwinkle {
\&      use Moose;
\&      has favourite_number => (is => "ro", isa => $NUM);
\&   }
\&   
\&   package Maisy {
\&      use Mouse;
\&      has favourite_number => (is => "ro", isa => $NUM);
\&   }
.Ve
.SH "STATUS"
.IX Header "STATUS"
This module is covered by the
Type-Tiny stability policy.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Type::Tiny is a tiny class for creating Moose-like type constraint
objects which are compatible with Moo, Moose and Mouse.
.PP
Maybe now we won't need to have separate MooseX, MouseX and MooX versions
of everything? We can but hope...
.PP
This documents the internals of Type::Tiny. Type::Tiny::Manual is
a better starting place if you're new.
.SS "Constructor"
.IX Subsection "Constructor"
.ie n .IP """new(%attributes)""" 4
.el .IP "\f(CWnew(%attributes)\fR" 4
.IX Item "new(%attributes)"
Moose-style constructor function.
.SS "Attributes"
.IX Subsection "Attributes"
Attributes are named values that may be passed to the constructor. For
each attribute, there is a corresponding reader method. For example:
.PP
.Vb 2
\&   my $type = Type::Tiny\->new( name => "Foo" );
\&   print $type\->name, "\en";   # says "Foo"
.Ve
.PP
\fIImportant attributes\fR
.IX Subsection "Important attributes"
.PP
These are the attributes you are likely to be most interested in
providing when creating your own type constraints, and most interested
in reading when dealing with type constraint objects.
.ie n .IP """constraint""" 4
.el .IP "\f(CWconstraint\fR" 4
.IX Item "constraint"
Coderef to validate a value (\f(CW$_\fR) against the type constraint. The
coderef will not be called unless the value is known to pass any parent
type constraint (see \f(CW\*(C`parent\*(C'\fR below).
.Sp
Defaults to \f(CW\*(C`sub { 1 }\*(C'\fR \- i.e. a coderef that passes all values.
.ie n .IP """parent""" 4
.el .IP "\f(CWparent\fR" 4
.IX Item "parent"
Optional attribute; parent type constraint. For example, an \*(L"Integer\*(R"
type constraint might have a parent \*(L"Number\*(R".
.Sp
If provided, must be a Type::Tiny object.
.ie n .IP """inlined""" 4
.el .IP "\f(CWinlined\fR" 4
.IX Item "inlined"
A coderef which returns a string of Perl code suitable for inlining this
type. Optional.
.Sp
If \f(CW\*(C`constraint\*(C'\fR (above) is a coderef generated via Sub::Quote, then
Type::Tiny \fImay\fR be able to automatically generate \f(CW\*(C`inlined\*(C'\fR for you.
.ie n .IP """name""" 4
.el .IP "\f(CWname\fR" 4
.IX Item "name"
The name of the type constraint. These need to conform to certain naming
rules (they must begin with an uppercase letter and continue using only
letters, digits 0\-9 and underscores).
.Sp
Optional; if not supplied will be an anonymous type constraint.
.ie n .IP """display_name""" 4
.el .IP "\f(CWdisplay_name\fR" 4
.IX Item "display_name"
A name to display for the type constraint when stringified. These don't
have to conform to any naming rules. Optional; a default name will be
calculated from the \f(CW\*(C`name\*(C'\fR.
.ie n .IP """library""" 4
.el .IP "\f(CWlibrary\fR" 4
.IX Item "library"
The package name of the type library this type is associated with.
Optional. Informational only: setting this attribute does not install
the type into the package.
.ie n .IP """message""" 4
.el .IP "\f(CWmessage\fR" 4
.IX Item "message"
Coderef that returns an error message when \f(CW$_\fR does not validate
against the type constraint. Optional (there's a vaguely sensible default.)
.ie n .IP """coercion""" 4
.el .IP "\f(CWcoercion\fR" 4
.IX Item "coercion"
A Type::Coercion object associated with this type.
.Sp
Generally speaking this attribute should not be passed to the constructor;
you should rely on the default lazily-built coercion object.
.Sp
You may pass \f(CW\*(C`coercion => 1\*(C'\fR to the constructor to inherit coercions
from the constraint's parent. (This requires the parent constraint to have
a coercion.)
.PP
\fIAttributes related to parameterizable and parameterized types\fR
.IX Subsection "Attributes related to parameterizable and parameterized types"
.PP
The following additional attributes are used for parameterizable (e.g.
\&\f(CW\*(C`ArrayRef\*(C'\fR) and parameterized (e.g. \f(CW\*(C`ArrayRef[Int]\*(C'\fR) type
constraints. Unlike Moose, these aren't handled by separate subclasses.
.ie n .IP """constraint_generator""" 4
.el .IP "\f(CWconstraint_generator\fR" 4
.IX Item "constraint_generator"
Coderef that generates a new constraint coderef based on parameters.
Alternatively, the constraint generator can return a fully-formed
Type::Tiny object, in which case the \f(CW\*(C`name_generator\*(C'\fR, \f(CW\*(C`inline_generator\*(C'\fR,
and \f(CW\*(C`coercion_generator\*(C'\fR attributes documented below are ignored.
.Sp
Optional; providing a generator makes this type into a parameterizable
type constraint.
.ie n .IP """name_generator""" 4
.el .IP "\f(CWname_generator\fR" 4
.IX Item "name_generator"
A coderef which generates a new display_name based on parameters.
Optional; the default is reasonable.
.ie n .IP """inline_generator""" 4
.el .IP "\f(CWinline_generator\fR" 4
.IX Item "inline_generator"
A coderef which generates a new inlining coderef based on parameters.
.ie n .IP """coercion_generator""" 4
.el .IP "\f(CWcoercion_generator\fR" 4
.IX Item "coercion_generator"
A coderef which generates a new Type::Coercion object based on parameters.
.ie n .IP """deep_explanation""" 4
.el .IP "\f(CWdeep_explanation\fR" 4
.IX Item "deep_explanation"
This \s-1API\s0 is not finalized. Coderef used by Error::TypeTiny::Assertion to
peek inside parameterized types and figure out why a value doesn't pass the
constraint.
.ie n .IP """parameters""" 4
.el .IP "\f(CWparameters\fR" 4
.IX Item "parameters"
In parameterized types, returns an arrayref of the parameters.
.PP
\fILazy generated attributes\fR
.IX Subsection "Lazy generated attributes"
.PP
The following attributes should not be usually passed to the constructor;
unless you're doing something especially unusual, you should rely on the
default lazily-built return values.
.ie n .IP """compiled_check""" 4
.el .IP "\f(CWcompiled_check\fR" 4
.IX Item "compiled_check"
Coderef to validate a value (\f(CW$_[0]\fR) against the type constraint.
This coderef is expected to also handle all validation for the parent
type constraints.
.ie n .IP """complementary_type""" 4
.el .IP "\f(CWcomplementary_type\fR" 4
.IX Item "complementary_type"
A complementary type for this type. For example, the complementary type
for an integer type would be all things that are not integers, including
floating point numbers, but also alphabetic strings, arrayrefs, filehandles,
etc.
.ie n .IP """moose_type"", ""mouse_type""" 4
.el .IP "\f(CWmoose_type\fR, \f(CWmouse_type\fR" 4
.IX Item "moose_type, mouse_type"
Objects equivalent to this type constraint, but as a
Moose::Meta::TypeConstraint or Mouse::Meta::TypeConstraint.
.Sp
It should rarely be necessary to obtain a Moose::Meta::TypeConstraint
object from Type::Tiny because the Type::Tiny object itself should
be usable pretty much anywhere a Moose::Meta::TypeConstraint is expected.
.SS "Methods"
.IX Subsection "Methods"
\fIPredicate methods\fR
.IX Subsection "Predicate methods"
.PP
These methods return booleans indicating information about the type
constraint. They are each tightly associated with a particular attribute.
(See \*(L"Attributes\*(R".)
.ie n .IP """has_parent"", ""has_library"", ""has_inlined"", ""has_constraint_generator"", ""has_inline_generator"", ""has_coercion_generator"", ""has_parameters"", ""has_message"", ""has_deep_explanation""" 4
.el .IP "\f(CWhas_parent\fR, \f(CWhas_library\fR, \f(CWhas_inlined\fR, \f(CWhas_constraint_generator\fR, \f(CWhas_inline_generator\fR, \f(CWhas_coercion_generator\fR, \f(CWhas_parameters\fR, \f(CWhas_message\fR, \f(CWhas_deep_explanation\fR" 4
.IX Item "has_parent, has_library, has_inlined, has_constraint_generator, has_inline_generator, has_coercion_generator, has_parameters, has_message, has_deep_explanation"
Simple Moose-style predicate methods indicating the presence or
absence of an attribute.
.ie n .IP """has_coercion""" 4
.el .IP "\f(CWhas_coercion\fR" 4
.IX Item "has_coercion"
Predicate method with a little extra \s-1DWIM.\s0 Returns false if the coercion is
a no-op.
.ie n .IP """is_anon""" 4
.el .IP "\f(CWis_anon\fR" 4
.IX Item "is_anon"
Returns true iff the type constraint does not have a \f(CW\*(C`name\*(C'\fR.
.ie n .IP """is_parameterized"", ""is_parameterizable""" 4
.el .IP "\f(CWis_parameterized\fR, \f(CWis_parameterizable\fR" 4
.IX Item "is_parameterized, is_parameterizable"
Indicates whether a type has been parameterized (e.g. \f(CW\*(C`ArrayRef[Int]\*(C'\fR)
or could potentially be (e.g. \f(CW\*(C`ArrayRef\*(C'\fR).
.PP
\fIValidation and coercion\fR
.IX Subsection "Validation and coercion"
.PP
The following methods are used for coercing and validating values
against a type constraint:
.ie n .IP """check($value)""" 4
.el .IP "\f(CWcheck($value)\fR" 4
.IX Item "check($value)"
Returns true iff the value passes the type constraint.
.ie n .IP """validate($value)""" 4
.el .IP "\f(CWvalidate($value)\fR" 4
.IX Item "validate($value)"
Returns the error message for the value; returns an explicit undef if the
value passes the type constraint.
.ie n .IP """assert_valid($value)""" 4
.el .IP "\f(CWassert_valid($value)\fR" 4
.IX Item "assert_valid($value)"
Like \f(CW\*(C`check($value)\*(C'\fR but dies if the value does not pass the type
constraint.
.Sp
Yes, that's three very similar methods. Blame Moose::Meta::TypeConstraint
whose \s-1API I\s0'm attempting to emulate. :\-)
.ie n .IP """assert_return($value)""" 4
.el .IP "\f(CWassert_return($value)\fR" 4
.IX Item "assert_return($value)"
Like \f(CW\*(C`assert_valid($value)\*(C'\fR but returns the value if it passes the type
constraint.
.Sp
This seems a more useful behaviour than \f(CW\*(C`assert_valid($value)\*(C'\fR. I would
have just changed \f(CW\*(C`assert_valid($value)\*(C'\fR to do this, except that there
are edge cases where it could break Moose compatibility.
.ie n .IP """get_message($value)""" 4
.el .IP "\f(CWget_message($value)\fR" 4
.IX Item "get_message($value)"
Returns the error message for the value; even if the value passes the type
constraint.
.ie n .IP """validate_explain($value, $varname)""" 4
.el .IP "\f(CWvalidate_explain($value, $varname)\fR" 4
.IX Item "validate_explain($value, $varname)"
Like \f(CW\*(C`validate\*(C'\fR but instead of a string error message, returns an arrayref
of strings explaining the reasoning why the value does not meet the type
constraint, examining parent types, etc.
.Sp
The \f(CW$varname\fR is an optional string like \f(CW\*(Aq$foo\*(Aq\fR indicating the
name of the variable being checked.
.ie n .IP """coerce($value)""" 4
.el .IP "\f(CWcoerce($value)\fR" 4
.IX Item "coerce($value)"
Attempt to coerce \f(CW$value\fR to this type.
.ie n .IP """assert_coerce($value)""" 4
.el .IP "\f(CWassert_coerce($value)\fR" 4
.IX Item "assert_coerce($value)"
Attempt to coerce \f(CW$value\fR to this type. Throws an exception if this is
not possible.
.PP
\fIChild type constraint creation and parameterization\fR
.IX Subsection "Child type constraint creation and parameterization"
.PP
These methods generate new type constraint objects that inherit from the
constraint they are called upon:
.ie n .IP """create_child_type(%attributes)""" 4
.el .IP "\f(CWcreate_child_type(%attributes)\fR" 4
.IX Item "create_child_type(%attributes)"
Construct a new Type::Tiny object with this object as its parent.
.ie n .IP """child_type_class""" 4
.el .IP "\f(CWchild_type_class\fR" 4
.IX Item "child_type_class"
The class that create_child_type will construct by default.
.ie n .IP """parameterize(@parameters)""" 4
.el .IP "\f(CWparameterize(@parameters)\fR" 4
.IX Item "parameterize(@parameters)"
Creates a new parameterized type; throws an exception if called on a
non-parameterizable type.
.ie n .IP """plus_coercions($type1, $code1, ...)""" 4
.el .IP "\f(CWplus_coercions($type1, $code1, ...)\fR" 4
.IX Item "plus_coercions($type1, $code1, ...)"
Shorthand for creating a new child type constraint with the same coercions
as this one, but then adding some extra coercions (at a higher priority than
the existing ones).
.ie n .IP """plus_fallback_coercions($type1, $code1, ...)""" 4
.el .IP "\f(CWplus_fallback_coercions($type1, $code1, ...)\fR" 4
.IX Item "plus_fallback_coercions($type1, $code1, ...)"
Like \f(CW\*(C`plus_coercions\*(C'\fR, but added at a lower priority.
.ie n .IP """minus_coercions($type1, ...)""" 4
.el .IP "\f(CWminus_coercions($type1, ...)\fR" 4
.IX Item "minus_coercions($type1, ...)"
Shorthand for creating a new child type constraint with fewer type coercions.
.ie n .IP """no_coercions""" 4
.el .IP "\f(CWno_coercions\fR" 4
.IX Item "no_coercions"
Shorthand for creating a new child type constraint with no coercions at all.
.PP
\fIType relationship introspection methods\fR
.IX Subsection "Type relationship introspection methods"
.PP
These methods allow you to determine a type constraint's relationship to
other type constraints in an organised hierarchy:
.ie n .IP """equals($other)"", ""is_subtype_of($other)"", ""is_supertype_of($other)"", ""is_a_type_of($other)""" 4
.el .IP "\f(CWequals($other)\fR, \f(CWis_subtype_of($other)\fR, \f(CWis_supertype_of($other)\fR, \f(CWis_a_type_of($other)\fR" 4
.IX Item "equals($other), is_subtype_of($other), is_supertype_of($other), is_a_type_of($other)"
Compare two types. See Moose::Meta::TypeConstraint for what these all mean.
(\s-1OK,\s0 Moose doesn't define \f(CW\*(C`is_supertype_of\*(C'\fR, but you get the idea, right?)
.Sp
Note that these have a slightly \s-1DWIM\s0 side to them. If you create two
Type::Tiny::Class objects which test the same class, they're considered
equal. And:
.Sp
.Vb 3
\&   my $subtype_of_Num = Types::Standard::Num\->create_child_type;
\&   my $subtype_of_Int = Types::Standard::Int\->create_child_type;
\&   $subtype_of_Int\->is_subtype_of( $subtype_of_Num );  # true
.Ve
.ie n .IP """strictly_equals($other)"", ""is_strictly_subtype_of($other)"", ""is_strictly_supertype_of($other)"", ""is_strictly_a_type_of($other)""" 4
.el .IP "\f(CWstrictly_equals($other)\fR, \f(CWis_strictly_subtype_of($other)\fR, \f(CWis_strictly_supertype_of($other)\fR, \f(CWis_strictly_a_type_of($other)\fR" 4
.IX Item "strictly_equals($other), is_strictly_subtype_of($other), is_strictly_supertype_of($other), is_strictly_a_type_of($other)"
Stricter versions of the type comparison functions. These only care about
explicit inheritance via \f(CW\*(C`parent\*(C'\fR.
.Sp
.Vb 3
\&   my $subtype_of_Num = Types::Standard::Num\->create_child_type;
\&   my $subtype_of_Int = Types::Standard::Int\->create_child_type;
\&   $subtype_of_Int\->is_strictly_subtype_of( $subtype_of_Num );  # false
.Ve
.ie n .IP """parents""" 4
.el .IP "\f(CWparents\fR" 4
.IX Item "parents"
Returns a list of all this type constraint's ancestor constraints. For
example, if called on the \f(CW\*(C`Str\*(C'\fR type constraint would return the list
\&\f(CW\*(C`(Value, Defined, Item, Any)\*(C'\fR.
.Sp
\&\fBDue to a historical misunderstanding, this differs from the Moose
implementation of the \f(CB\*(C`parents\*(C'\fB method. In Moose, \f(CB\*(C`parents\*(C'\fB only returns the
immediate parent type constraints, and because type constraints only have
one immediate parent, this is effectively an alias for \f(CB\*(C`parent\*(C'\fB. The
extension module MooseX::Meta::TypeConstraint::Intersection is the only
place where multiple type constraints are returned; and they are returned
as an arrayref in violation of the base class' documentation. I'm keeping
my behaviour as it seems more useful.\fR
.ie n .IP """coercibles""" 4
.el .IP "\f(CWcoercibles\fR" 4
.IX Item "coercibles"
Return a type constraint which is the union of type constraints that can be
coerced to this one (including this one). If this type constraint has no
coercions, returns itself.
.ie n .IP """type_parameter""" 4
.el .IP "\f(CWtype_parameter\fR" 4
.IX Item "type_parameter"
In parameterized type constraints, returns the first item on the list of
parameters; otherwise returns undef. For example:
.Sp
.Vb 2
\&   ( ArrayRef[Int] )\->type_parameter;    # returns Int
\&   ( ArrayRef[Int] )\->parent;            # returns ArrayRef
.Ve
.Sp
Note that parameterizable type constraints can perfectly legitimately take
multiple parameters (several off the parameterizable type constraints in
Types::Standard do). This method only returns the first such parameter.
\&\*(L"Attributes related to parameterizable and parameterized types\*(R"
documents the \f(CW\*(C`parameters\*(C'\fR attribute, which returns an arrayref of all
the parameters.
.PP
\fIInlining methods\fR
.IX Subsection "Inlining methods"
.PP
The following methods are used to generate strings of Perl code which
may be pasted into stringy \f(CW\*(C`eval\*(C'\fRuated subs to perform type checks:
.ie n .IP """can_be_inlined""" 4
.el .IP "\f(CWcan_be_inlined\fR" 4
.IX Item "can_be_inlined"
Returns boolean indicating if this type can be inlined.
.ie n .IP """inline_check($varname)""" 4
.el .IP "\f(CWinline_check($varname)\fR" 4
.IX Item "inline_check($varname)"
Creates a type constraint check for a particular variable as a string of
Perl code. For example:
.Sp
.Vb 1
\&   print( Types::Standard::Num\->inline_check(\*(Aq$foo\*(Aq) );
.Ve
.Sp
prints the following output:
.Sp
.Vb 1
\&   (!ref($foo) && Scalar::Util::looks_like_number($foo))
.Ve
.Sp
For Moose-compat, there is an alias \f(CW\*(C`_inline_check\*(C'\fR for this method.
.ie n .IP """inline_assert($varname)""" 4
.el .IP "\f(CWinline_assert($varname)\fR" 4
.IX Item "inline_assert($varname)"
Much like \f(CW\*(C`inline_check\*(C'\fR but outputs a statement of the form:
.Sp
.Vb 1
\&   die ... unless ...;
.Ve
.Sp
Note that if this type has a custom error message, the inlined code will
\&\fIignore\fR this custom message!!
.PP
\fIOther methods\fR
.IX Subsection "Other methods"
.ie n .IP """qualified_name""" 4
.el .IP "\f(CWqualified_name\fR" 4
.IX Item "qualified_name"
For non-anonymous type constraints that have a library, returns a qualified
\&\f(CW"MyLib::MyType"\fR sort of name. Otherwise, returns the same as \f(CW\*(C`name\*(C'\fR.
.ie n .IP """isa($class)"", ""can($method)"", ""AUTOLOAD(@args)""" 4
.el .IP "\f(CWisa($class)\fR, \f(CWcan($method)\fR, \f(CWAUTOLOAD(@args)\fR" 4
.IX Item "isa($class), can($method), AUTOLOAD(@args)"
If Moose is loaded, then the combination of these methods is used to mock
a Moose::Meta::TypeConstraint.
.Sp
If Mouse is loaded, then \f(CW\*(C`isa\*(C'\fR mocks Mouse::Meta::TypeConstraint.
.ie n .IP """DOES($role)""" 4
.el .IP "\f(CWDOES($role)\fR" 4
.IX Item "DOES($role)"
Overridden to advertise support for various roles.
.Sp
See also Type::API::Constraint, etc.
.ie n .IP """TIESCALAR"", ""TIEARRAY"", ""TIEHASH""" 4
.el .IP "\f(CWTIESCALAR\fR, \f(CWTIEARRAY\fR, \f(CWTIEHASH\fR" 4
.IX Item "TIESCALAR, TIEARRAY, TIEHASH"
These are provided as hooks that wrap Type::Tie. (Type::Tie is distributed
separately, and can be used with non\-Type::Tiny type constraints too.) They
allow the following to work:
.Sp
.Vb 4
\&   use Types::Standard qw(Int);
\&   tie my @list, Int;
\&   push @list, 123, 456;   # ok
\&   push @list, "Hello";    # dies
.Ve
.PP
The following methods exist for Moose/Mouse compatibility, but do not do
anything useful.
.ie n .IP """compile_type_constraint""" 4
.el .IP "\f(CWcompile_type_constraint\fR" 4
.IX Item "compile_type_constraint"
.PD 0
.ie n .IP """hand_optimized_type_constraint""" 4
.el .IP "\f(CWhand_optimized_type_constraint\fR" 4
.IX Item "hand_optimized_type_constraint"
.ie n .IP """has_hand_optimized_type_constraint""" 4
.el .IP "\f(CWhas_hand_optimized_type_constraint\fR" 4
.IX Item "has_hand_optimized_type_constraint"
.ie n .IP """inline_environment""" 4
.el .IP "\f(CWinline_environment\fR" 4
.IX Item "inline_environment"
.ie n .IP """meta""" 4
.el .IP "\f(CWmeta\fR" 4
.IX Item "meta"
.PD
.SS "Overloading"
.IX Subsection "Overloading"
.IP "\(bu" 4
Stringification is overloaded to return the qualified name.
.IP "\(bu" 4
Boolification is overloaded to always return true.
.IP "\(bu" 4
Coderefification is overloaded to call \f(CW\*(C`assert_return\*(C'\fR.
.IP "\(bu" 4
On Perl 5.10.1 and above, smart match is overloaded to call \f(CW\*(C`check\*(C'\fR.
.IP "\(bu" 4
The \f(CW\*(C`==\*(C'\fR operator is overloaded to call \f(CW\*(C`equals\*(C'\fR.
.IP "\(bu" 4
The \f(CW\*(C`<\*(C'\fR and \f(CW\*(C`>\*(C'\fR operators are overloaded to call \f(CW\*(C`is_subtype_of\*(C'\fR
and \f(CW\*(C`is_supertype_of\*(C'\fR.
.IP "\(bu" 4
The \f(CW\*(C`~\*(C'\fR operator is overloaded to call \f(CW\*(C`complementary_type\*(C'\fR.
.IP "\(bu" 4
The \f(CW\*(C`|\*(C'\fR operator is overloaded to build a union of two type constraints.
See Type::Tiny::Union.
.IP "\(bu" 4
The \f(CW\*(C`&\*(C'\fR operator is overloaded to build the intersection of two type
constraints. See Type::Tiny::Intersection.
.PP
Previous versions of Type::Tiny would overload the \f(CW\*(C`+\*(C'\fR operator to
call \f(CW\*(C`plus_coercions\*(C'\fR or \f(CW\*(C`plus_fallback_coercions\*(C'\fR as appropriate.
Support for this was dropped after 0.040.
.SS "Constants"
.IX Subsection "Constants"
.ie n .IP """Type::Tiny::SUPPORT_SMARTMATCH""" 4
.el .IP "\f(CWType::Tiny::SUPPORT_SMARTMATCH\fR" 4
.IX Item "Type::Tiny::SUPPORT_SMARTMATCH"
Indicates whether the smart match overload is supported on your
version of Perl.
.SS "Package Variables"
.IX Subsection "Package Variables"
.ie n .IP "$Type::Tiny::DD" 4
.el .IP "\f(CW$Type::Tiny::DD\fR" 4
.IX Item "$Type::Tiny::DD"
This undef by default but may be set to a coderef that Type::Tiny
and related modules will use to dump data structures in things like
error messages.
.Sp
Otherwise Type::Tiny uses it's own routine to dump data structures.
\&\f(CW$DD\fR may then be set to a number to limit the lengths of the
dumps. (Default limit is 72.)
.Sp
This is a package variable (rather than get/set class methods) to allow
for easy localization.
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs to
<http://rt.cpan.org/Dist/Display.html?Queue=Type\-Tiny>.
.SH "SUPPORT"
.IX Header "SUPPORT"
\&\fB\s-1IRC:\s0\fR support is available through in the \fI#moops\fR channel
on irc.perl.org <http://www.irc.perl.org/channels.html>.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Type::Tiny::Manual, Type::API.
.PP
Type::Library, Type::Utils, Types::Standard, Type::Coercion.
.PP
Type::Tiny::Class, Type::Tiny::Role, Type::Tiny::Duck,
Type::Tiny::Enum, Type::Tiny::Union, Type::Tiny::Intersection.
.PP
Moose::Meta::TypeConstraint,
Mouse::Meta::TypeConstraint.
.PP
Type::Params.
.SH "AUTHOR"
.IX Header "AUTHOR"
Toby Inkster <tobyink@cpan.org>.
.SH "THANKS"
.IX Header "THANKS"
Thanks to Matt S Trout for advice on Moo integration.
.SH "COPYRIGHT AND LICENCE"
.IX Header "COPYRIGHT AND LICENCE"
This software is copyright (c) 2013\-2014 by Toby Inkster.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
.SH "DISCLAIMER OF WARRANTIES"
.IX Header "DISCLAIMER OF WARRANTIES"
\&\s-1THIS PACKAGE IS PROVIDED \*(L"AS IS\*(R" AND WITHOUT ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.\s0
