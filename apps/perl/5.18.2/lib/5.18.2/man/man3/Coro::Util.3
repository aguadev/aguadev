.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Util 3"
.TH Util 3 "2014-03-04" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Coro::Util \- various utility functions.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Coro::Util;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module implements various utility functions, mostly replacing perl
functions by non-blocking counterparts.
.PP
Many of these functions exist for the sole purpose of emulating existing
interfaces, no matter how bad or limited they are (e.g. no IPv6 support).
.PP
This module is an AnyEvent user. Refer to the AnyEvent
documentation to see how to integrate it into your own programs.
.ie n .IP "$ipn = Coro::Util::inet_aton $hostname || $ip" 4
.el .IP "\f(CW$ipn\fR = Coro::Util::inet_aton \f(CW$hostname\fR || \f(CW$ip\fR" 4
.IX Item "$ipn = Coro::Util::inet_aton $hostname || $ip"
Works almost exactly like its \f(CW\*(C`Socket::inet_aton\*(C'\fR counterpart, except
that it does not block other coroutines.
.Sp
Does not handle multihomed hosts or IPv6 \- consider using
\&\f(CW\*(C`AnyEvent::Socket::resolve_sockaddr\*(C'\fR with the Coro rouse functions
instead.
.IP "gethostbyname, gethostbyaddr" 4
.IX Item "gethostbyname, gethostbyaddr"
Work similarly to their Perl counterparts, but do not block. Uses
\&\f(CW\*(C`AnyEvent::Util::inet_aton\*(C'\fR internally.
.Sp
Does not handle multihomed hosts or IPv6 \- consider using
\&\f(CW\*(C`AnyEvent::Socket::resolve_sockaddr\*(C'\fR or \f(CW\*(C`AnyEvent::DNS::reverse_lookup\*(C'\fR
with the Coro rouse functions instead.
.ie n .IP "@result = Coro::Util::fork_eval { ... }, @args" 4
.el .IP "\f(CW@result\fR = Coro::Util::fork_eval { ... }, \f(CW@args\fR" 4
.IX Item "@result = Coro::Util::fork_eval { ... }, @args"
Executes the given code block or code reference with the given arguments
in a separate process, returning the results. The return values must be
serialisable with Coro::Storable. It may, of course, block.
.Sp
Note that using event handling in the sub is not usually a good idea as
you will inherit a mixed set of watchers from the parent.
.Sp
Exceptions will be correctly forwarded to the caller.
.Sp
This function is useful for pushing cpu-intensive computations into a
different process, for example to take advantage of multiple \s-1CPU\s0's. Its
also useful if you want to simply run some blocking functions (such as
\&\f(CW\*(C`system()\*(C'\fR) and do not care about the overhead enough to code your own
pid watcher etc.
.Sp
This function might keep a pool of processes in some future version, as
fork can be rather slow in large processes.
.Sp
You should also look at \f(CW\*(C`AnyEvent::Util::fork_eval\*(C'\fR, which is newer and
more compatible to totally broken Perl implementations such as the one
from ActiveState.
.Sp
Example: execute some external program (convert image to rgba raw form)
and add a long computation (extract the alpha channel) in a separate
process, making sure that never more then \f(CW$NUMCPUS\fR processes are being
run.
.Sp
.Vb 1
\&   my $cpulock = new Coro::Semaphore $NUMCPUS;
\&
\&   sub do_it {
\&      my ($path) = @_;
\&
\&      my $guard = $cpulock\->guard;
\&
\&      Coro::Util::fork_eval {
\&         open my $fh, "convert \-depth 8 \eQ$path\eE rgba:"
\&            or die "$path: $!";
\&
\&         local $/;
\&         # make my eyes hurt
\&         pack "C*", unpack "(xxxC)*", <$fh>
\&      }
\&   }
\&
\&   my $alphachannel = do_it "/tmp/img.png";
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 2
\& Marc Lehmann <schmorp@schmorp.de>
\& http://home.schmorp.de/
.Ve
