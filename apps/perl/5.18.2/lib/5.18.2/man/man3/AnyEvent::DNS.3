.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "AnyEvent::DNS 3"
.TH AnyEvent::DNS 3 "2013-11-28" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
AnyEvent::DNS \- fully asynchronous DNS resolution
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   use AnyEvent::DNS;
\&   
\&   my $cv = AnyEvent\->condvar;
\&   AnyEvent::DNS::a "www.google.de", $cv;
\&   # ... later
\&   my @addrs = $cv\->recv;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module offers both a number of \s-1DNS\s0 convenience functions as well
as a fully asynchronous and high-performance pure-perl stub resolver.
.PP
The stub resolver supports \s-1DNS\s0 over IPv4 and IPv6, \s-1UDP\s0 and \s-1TCP,\s0 optional
\&\s-1EDNS0\s0 support for up to 4kiB datagrams and automatically falls back to
virtual circuit mode for large responses.
.SS "\s-1CONVENIENCE FUNCTIONS\s0"
.IX Subsection "CONVENIENCE FUNCTIONS"
.ie n .IP "AnyEvent::DNS::a $domain, $cb\->(@addrs)" 4
.el .IP "AnyEvent::DNS::a \f(CW$domain\fR, \f(CW$cb\fR\->(@addrs)" 4
.IX Item "AnyEvent::DNS::a $domain, $cb->(@addrs)"
Tries to resolve the given domain to IPv4 address(es).
.ie n .IP "AnyEvent::DNS::aaaa $domain, $cb\->(@addrs)" 4
.el .IP "AnyEvent::DNS::aaaa \f(CW$domain\fR, \f(CW$cb\fR\->(@addrs)" 4
.IX Item "AnyEvent::DNS::aaaa $domain, $cb->(@addrs)"
Tries to resolve the given domain to IPv6 address(es).
.ie n .IP "AnyEvent::DNS::mx $domain, $cb\->(@hostnames)" 4
.el .IP "AnyEvent::DNS::mx \f(CW$domain\fR, \f(CW$cb\fR\->(@hostnames)" 4
.IX Item "AnyEvent::DNS::mx $domain, $cb->(@hostnames)"
Tries to resolve the given domain into a sorted (lower preference value
first) list of domain names.
.ie n .IP "AnyEvent::DNS::ns $domain, $cb\->(@hostnames)" 4
.el .IP "AnyEvent::DNS::ns \f(CW$domain\fR, \f(CW$cb\fR\->(@hostnames)" 4
.IX Item "AnyEvent::DNS::ns $domain, $cb->(@hostnames)"
Tries to resolve the given domain name into a list of name servers.
.ie n .IP "AnyEvent::DNS::txt $domain, $cb\->(@hostnames)" 4
.el .IP "AnyEvent::DNS::txt \f(CW$domain\fR, \f(CW$cb\fR\->(@hostnames)" 4
.IX Item "AnyEvent::DNS::txt $domain, $cb->(@hostnames)"
Tries to resolve the given domain name into a list of text records. Only
the first text string per record will be returned. If you want all
strings, you need to call the resolver manually:
.Sp
.Vb 6
\&   resolver\->resolve ($domain => "txt", sub {
\&      for my $record (@_) {
\&         my (undef, undef, undef, @txt) = @$record;
\&         # strings now in @txt
\&      }
\&   });
.Ve
.ie n .IP "AnyEvent::DNS::srv $service, $proto, $domain, $cb\->(@srv_rr)" 4
.el .IP "AnyEvent::DNS::srv \f(CW$service\fR, \f(CW$proto\fR, \f(CW$domain\fR, \f(CW$cb\fR\->(@srv_rr)" 4
.IX Item "AnyEvent::DNS::srv $service, $proto, $domain, $cb->(@srv_rr)"
Tries to resolve the given service, protocol and domain name into a list
of service records.
.Sp
Each \f(CW$srv_rr\fR is an array reference with the following contents: 
\&\f(CW\*(C`[$priority, $weight, $transport, $target]\*(C'\fR.
.Sp
They will be sorted with lowest priority first, then randomly
distributed by weight as per \s-1RFC 2782.\s0
.Sp
Example:
.Sp
.Vb 2
\&   AnyEvent::DNS::srv "sip", "udp", "schmorp.de", sub { ...
\&   # @_ = ( [10, 10, 5060, "sip1.schmorp.de" ] )
.Ve
.ie n .IP "AnyEvent::DNS::any $domain, $cb\->(@rrs)" 4
.el .IP "AnyEvent::DNS::any \f(CW$domain\fR, \f(CW$cb\fR\->(@rrs)" 4
.IX Item "AnyEvent::DNS::any $domain, $cb->(@rrs)"
Tries to resolve the given domain and passes all resource records found to
the callback.
.ie n .IP "AnyEvent::DNS::ptr $domain, $cb\->(@hostnames)" 4
.el .IP "AnyEvent::DNS::ptr \f(CW$domain\fR, \f(CW$cb\fR\->(@hostnames)" 4
.IX Item "AnyEvent::DNS::ptr $domain, $cb->(@hostnames)"
Tries to make a \s-1PTR\s0 lookup on the given domain. See \f(CW\*(C`reverse_lookup\*(C'\fR
and \f(CW\*(C`reverse_verify\*(C'\fR if you want to resolve an \s-1IP\s0 address to a hostname
instead.
.ie n .IP "AnyEvent::DNS::reverse_lookup $ipv4_or_6, $cb\->(@hostnames)" 4
.el .IP "AnyEvent::DNS::reverse_lookup \f(CW$ipv4_or_6\fR, \f(CW$cb\fR\->(@hostnames)" 4
.IX Item "AnyEvent::DNS::reverse_lookup $ipv4_or_6, $cb->(@hostnames)"
Tries to reverse-resolve the given IPv4 or IPv6 address (in textual form)
into its hostname(s). Handles V4MAPPED and V4COMPAT IPv6 addresses
transparently.
.ie n .IP "AnyEvent::DNS::reverse_verify $ipv4_or_6, $cb\->(@hostnames)" 4
.el .IP "AnyEvent::DNS::reverse_verify \f(CW$ipv4_or_6\fR, \f(CW$cb\fR\->(@hostnames)" 4
.IX Item "AnyEvent::DNS::reverse_verify $ipv4_or_6, $cb->(@hostnames)"
The same as \f(CW\*(C`reverse_lookup\*(C'\fR, but does forward-lookups to verify that
the resolved hostnames indeed point to the address, which makes spoofing
harder.
.Sp
If you want to resolve an address into a hostname, this is the preferred
method: The \s-1DNS\s0 records could still change, but at least this function
verified that the hostname, at one point in the past, pointed at the \s-1IP\s0
address you originally resolved.
.Sp
Example:
.Sp
.Vb 2
\&   AnyEvent::DNS::reverse_verify "2001:500:2f::f", sub { print shift };
\&   # => f.root\-servers.net
.Ve
.SS "LOW-LEVEL \s-1DNS EN\-/DECODING FUNCTIONS\s0"
.IX Subsection "LOW-LEVEL DNS EN-/DECODING FUNCTIONS"
.ie n .IP "$AnyEvent::DNS::EDNS0" 4
.el .IP "\f(CW$AnyEvent::DNS::EDNS0\fR" 4
.IX Item "$AnyEvent::DNS::EDNS0"
This variable decides whether dns_pack automatically enables \s-1EDNS0\s0
support. By default, this is disabled (\f(CW0\fR), unless overridden by
\&\f(CW$ENV{PERL_ANYEVENT_EDNS0}\fR, but when set to \f(CW1\fR, AnyEvent::DNS will use
\&\s-1EDNS0\s0 in all requests.
.ie n .IP "$pkt = AnyEvent::DNS::dns_pack $dns" 4
.el .IP "\f(CW$pkt\fR = AnyEvent::DNS::dns_pack \f(CW$dns\fR" 4
.IX Item "$pkt = AnyEvent::DNS::dns_pack $dns"
Packs a perl data structure into a \s-1DNS\s0 packet. Reading \s-1RFC 1035\s0 is strongly
recommended, then everything will be totally clear. Or maybe not.
.Sp
Resource records are not yet encodable.
.Sp
Examples:
.Sp
.Vb 2
\&   # very simple request, using lots of default values:
\&   { rd => 1, qd => [ [ "host.domain", "a"] ] }
\&  
\&   # more complex example, showing how flags etc. are named:
\&  
\&   {
\&      id => 10000,
\&      op => "query",
\&      rc => "nxdomain",
\&  
\&      # flags
\&      qr => 1,
\&      aa => 0,
\&      tc => 0,
\&      rd => 0,
\&      ra => 0,
\&      ad => 0,
\&      cd => 0,
\&  
\&      qd => [@rr], # query section
\&      an => [@rr], # answer section
\&      ns => [@rr], # authority section
\&      ar => [@rr], # additional records section
\&   }
.Ve
.ie n .IP "$dns = AnyEvent::DNS::dns_unpack $pkt" 4
.el .IP "\f(CW$dns\fR = AnyEvent::DNS::dns_unpack \f(CW$pkt\fR" 4
.IX Item "$dns = AnyEvent::DNS::dns_unpack $pkt"
Unpacks a \s-1DNS\s0 packet into a perl data structure.
.Sp
Examples:
.Sp
.Vb 10
\&   # an unsuccessful reply
\&   {
\&     \*(Aqqd\*(Aq => [
\&               [ \*(Aqruth.plan9.de.mach.uni\-karlsruhe.de\*(Aq, \*(Aq*\*(Aq, \*(Aqin\*(Aq ]
\&             ],
\&     \*(Aqrc\*(Aq => \*(Aqnxdomain\*(Aq,
\&     \*(Aqar\*(Aq => [],
\&     \*(Aqns\*(Aq => [
\&               [
\&                 \*(Aquni\-karlsruhe.de\*(Aq,
\&                 \*(Aqsoa\*(Aq,
\&                 \*(Aqin\*(Aq,
\&                 600,
\&                 \*(Aqnetserv.rz.uni\-karlsruhe.de\*(Aq,
\&                 \*(Aqhostmaster.rz.uni\-karlsruhe.de\*(Aq,
\&                 2008052201, 10800, 1800, 2592000, 86400
\&               ]
\&             ],
\&     \*(Aqtc\*(Aq => \*(Aq\*(Aq,
\&     \*(Aqra\*(Aq => 1,
\&     \*(Aqqr\*(Aq => 1,
\&     \*(Aqid\*(Aq => 45915,
\&     \*(Aqaa\*(Aq => \*(Aq\*(Aq,
\&     \*(Aqan\*(Aq => [],
\&     \*(Aqrd\*(Aq => 1,
\&     \*(Aqop\*(Aq => \*(Aqquery\*(Aq
\&   }
\&   
\&   # a successful reply
\&   
\&   {
\&     \*(Aqqd\*(Aq => [ [ \*(Aqwww.google.de\*(Aq, \*(Aqa\*(Aq, \*(Aqin\*(Aq ] ],
\&     \*(Aqrc\*(Aq => 0,
\&     \*(Aqar\*(Aq => [
\&               [ \*(Aqa.l.google.com\*(Aq, \*(Aqa\*(Aq, \*(Aqin\*(Aq, 3600, \*(Aq209.85.139.9\*(Aq ],
\&               [ \*(Aqb.l.google.com\*(Aq, \*(Aqa\*(Aq, \*(Aqin\*(Aq, 3600, \*(Aq64.233.179.9\*(Aq ],
\&               [ \*(Aqc.l.google.com\*(Aq, \*(Aqa\*(Aq, \*(Aqin\*(Aq, 3600, \*(Aq64.233.161.9\*(Aq ],
\&             ],
\&     \*(Aqns\*(Aq => [
\&               [ \*(Aql.google.com\*(Aq, \*(Aqns\*(Aq, \*(Aqin\*(Aq, 3600, \*(Aqa.l.google.com\*(Aq ],
\&               [ \*(Aql.google.com\*(Aq, \*(Aqns\*(Aq, \*(Aqin\*(Aq, 3600, \*(Aqb.l.google.com\*(Aq ],
\&             ],
\&     \*(Aqtc\*(Aq => \*(Aq\*(Aq,
\&     \*(Aqra\*(Aq => 1,
\&     \*(Aqqr\*(Aq => 1,
\&     \*(Aqid\*(Aq => 64265,
\&     \*(Aqaa\*(Aq => \*(Aq\*(Aq,
\&     \*(Aqan\*(Aq => [
\&               [ \*(Aqwww.google.de\*(Aq, \*(Aqcname\*(Aq, \*(Aqin\*(Aq, 3600, \*(Aqwww.google.com\*(Aq ],
\&               [ \*(Aqwww.google.com\*(Aq, \*(Aqcname\*(Aq, \*(Aqin\*(Aq, 3600, \*(Aqwww.l.google.com\*(Aq ],
\&               [ \*(Aqwww.l.google.com\*(Aq, \*(Aqa\*(Aq, \*(Aqin\*(Aq, 3600, \*(Aq66.249.93.104\*(Aq ],
\&               [ \*(Aqwww.l.google.com\*(Aq, \*(Aqa\*(Aq, \*(Aqin\*(Aq, 3600, \*(Aq66.249.93.147\*(Aq ],
\&             ],
\&     \*(Aqrd\*(Aq => 1,
\&     \*(Aqop\*(Aq => 0
\&   }
.Ve
.SS "\s-1THE\s0 AnyEvent::DNS \s-1RESOLVER CLASS\s0"
.IX Subsection "THE AnyEvent::DNS RESOLVER CLASS"
This is the class which does the actual protocol work.
.IP "AnyEvent::DNS::resolver" 4
.IX Item "AnyEvent::DNS::resolver"
This function creates and returns a resolver that is ready to use and
should mimic the default resolver for your system as good as possible. It
is used by AnyEvent itself as well.
.Sp
It only ever creates one resolver and returns this one on subsequent calls
\&\- see \f(CW$AnyEvent::DNS::RESOLVER\fR, below, for details.
.Sp
Unless you have special needs, prefer this function over creating your own
resolver object.
.Sp
The resolver is created with the following parameters:
.Sp
.Vb 2
\&   untaint          enabled
\&   max_outstanding  $ENV{PERL_ANYEVENT_MAX_OUTSTANDING_DNS}
.Ve
.Sp
\&\f(CW\*(C`os_config\*(C'\fR will be used for OS-specific configuration, unless
\&\f(CW$ENV{PERL_ANYEVENT_RESOLV_CONF}\fR is specified, in which case that file
gets parsed.
.ie n .IP "$AnyEvent::DNS::RESOLVER" 4
.el .IP "\f(CW$AnyEvent::DNS::RESOLVER\fR" 4
.IX Item "$AnyEvent::DNS::RESOLVER"
This variable stores the default resolver returned by
\&\f(CW\*(C`AnyEvent::DNS::resolver\*(C'\fR, or \f(CW\*(C`undef\*(C'\fR when the default resolver hasn't
been instantiated yet.
.Sp
One can provide a custom resolver (e.g. one with caching functionality)
by storing it in this variable, causing all subsequent resolves done via
\&\f(CW\*(C`AnyEvent::DNS::resolver\*(C'\fR to be done via the custom one.
.ie n .IP "$resolver = new AnyEvent::DNS key => value..." 4
.el .IP "\f(CW$resolver\fR = new AnyEvent::DNS key => value..." 4
.IX Item "$resolver = new AnyEvent::DNS key => value..."
Creates and returns a new resolver.
.Sp
The following options are supported:
.RS 4
.IP "server => [...]" 4
.IX Item "server => [...]"
A list of server addresses (default: \f(CW\*(C`v127.0.0.1\*(C'\fR or \f(CW\*(C`::1\*(C'\fR) in network
format (i.e. as returned by \f(CW\*(C`AnyEvent::Socket::parse_address\*(C'\fR \- both IPv4
and IPv6 are supported).
.IP "timeout => [...]" 4
.IX Item "timeout => [...]"
A list of timeouts to use (also determines the number of retries). To make
three retries with individual time-outs of 2, 5 and 5 seconds, use \f(CW\*(C`[2,
5, 5]\*(C'\fR, which is also the default.
.IP "search => [...]" 4
.IX Item "search => [...]"
The default search list of suffixes to append to a domain name (default: none).
.ie n .IP "ndots => $integer" 4
.el .IP "ndots => \f(CW$integer\fR" 4
.IX Item "ndots => $integer"
The number of dots (default: \f(CW1\fR) that a name must have so that the resolver
tries to resolve the name without any suffixes first.
.ie n .IP "max_outstanding => $integer" 4
.el .IP "max_outstanding => \f(CW$integer\fR" 4
.IX Item "max_outstanding => $integer"
Most name servers do not handle many parallel requests very well. This
option limits the number of outstanding requests to \f(CW$integer\fR
(default: \f(CW10\fR), that means if you request more than this many requests,
then the additional requests will be queued until some other requests have
been resolved.
.ie n .IP "reuse => $seconds" 4
.el .IP "reuse => \f(CW$seconds\fR" 4
.IX Item "reuse => $seconds"
The number of seconds (default: \f(CW300\fR) that a query id cannot be re-used
after a timeout. If there was no time-out then query ids can be reused
immediately.
.ie n .IP "untaint => $boolean" 4
.el .IP "untaint => \f(CW$boolean\fR" 4
.IX Item "untaint => $boolean"
When true, then the resolver will automatically untaint results, and might
also ignore certain environment variables.
.RE
.RS 4
.RE
.ie n .IP "$resolver\->parse_resolv_conf ($string)" 4
.el .IP "\f(CW$resolver\fR\->parse_resolv_conf ($string)" 4
.IX Item "$resolver->parse_resolv_conf ($string)"
Parses the given string as if it were a \fIresolv.conf\fR file. The following
directives are supported (but not necessarily implemented).
.Sp
\&\f(CW\*(C`#\*(C'\fR\- and \f(CW\*(C`;\*(C'\fR\-style comments, \f(CW\*(C`nameserver\*(C'\fR, \f(CW\*(C`domain\*(C'\fR, \f(CW\*(C`search\*(C'\fR, \f(CW\*(C`sortlist\*(C'\fR,
\&\f(CW\*(C`options\*(C'\fR (\f(CW\*(C`timeout\*(C'\fR, \f(CW\*(C`attempts\*(C'\fR, \f(CW\*(C`ndots\*(C'\fR).
.Sp
Everything else is silently ignored.
.ie n .IP "$resolver\->os_config" 4
.el .IP "\f(CW$resolver\fR\->os_config" 4
.IX Item "$resolver->os_config"
Tries so load and parse \fI/etc/resolv.conf\fR on portable operating
systems. Tries various egregious hacks on windows to force the \s-1DNS\s0 servers
and searchlist out of the system.
.Sp
This method must be called at most once before trying to resolve anything.
.ie n .IP "$resolver\->timeout ($timeout, ...)" 4
.el .IP "\f(CW$resolver\fR\->timeout ($timeout, ...)" 4
.IX Item "$resolver->timeout ($timeout, ...)"
Sets the timeout values. See the \f(CW\*(C`timeout\*(C'\fR constructor argument (and
note that this method expects the timeout values themselves, not an
array-reference).
.ie n .IP "$resolver\->max_outstanding ($nrequests)" 4
.el .IP "\f(CW$resolver\fR\->max_outstanding ($nrequests)" 4
.IX Item "$resolver->max_outstanding ($nrequests)"
Sets the maximum number of outstanding requests to \f(CW$nrequests\fR. See the
\&\f(CW\*(C`max_outstanding\*(C'\fR constructor argument.
.ie n .IP "$resolver\->request ($req, $cb\->($res))" 4
.el .IP "\f(CW$resolver\fR\->request ($req, \f(CW$cb\fR\->($res))" 4
.IX Item "$resolver->request ($req, $cb->($res))"
This is the main low-level workhorse for sending \s-1DNS\s0 requests.
.Sp
This function sends a single request (a hash-ref formated as specified
for \f(CW\*(C`dns_pack\*(C'\fR) to the configured nameservers in turn until it gets a
response. It handles timeouts, retries and automatically falls back to
virtual circuit mode (\s-1TCP\s0) when it receives a truncated reply. It does not
handle anything else, such as the domain searchlist or relative names \-
use \f(CW\*(C`\->resolve\*(C'\fR for that.
.Sp
Calls the callback with the decoded response packet if a reply was
received, or no arguments in case none of the servers answered.
.ie n .IP "$resolver\->resolve ($qname, $qtype, %options, $cb\->(@rr))" 4
.el .IP "\f(CW$resolver\fR\->resolve ($qname, \f(CW$qtype\fR, \f(CW%options\fR, \f(CW$cb\fR\->(@rr))" 4
.IX Item "$resolver->resolve ($qname, $qtype, %options, $cb->(@rr))"
Queries the \s-1DNS\s0 for the given domain name \f(CW$qname\fR of type \f(CW$qtype\fR.
.Sp
A \f(CW$qtype\fR is either a numerical query type (e.g. \f(CW1\fR for A records) or
a lowercase name (you have to look at the source to see which aliases are
supported, but all types from \s-1RFC 1035, \s0\f(CW\*(C`aaaa\*(C'\fR, \f(CW\*(C`srv\*(C'\fR, \f(CW\*(C`spf\*(C'\fR and a few
more are known to this module). A \f(CW$qtype\fR of \*(L"*\*(R" is supported and means
\&\*(L"any\*(R" record type.
.Sp
The callback will be invoked with a list of matching result records or
none on any error or if the name could not be found.
.Sp
\&\s-1CNAME\s0 chains (although illegal) are followed up to a length of 10.
.Sp
The callback will be invoked with arraryefs of the form \f(CW\*(C`[$name,
$type, $class, $ttl, @data\*(C'\fR], where \f(CW$name\fR is the domain name,
\&\f(CW$type\fR a type string or number, \f(CW$class\fR a class name, \f(CW$ttl\fR is the
remaining time-to-live and \f(CW@data\fR is resource-record-dependent data, in
seconds. For \f(CW\*(C`a\*(C'\fR records, this will be the textual IPv4 addresses, for
\&\f(CW\*(C`ns\*(C'\fR or \f(CW\*(C`cname\*(C'\fR records this will be a domain name, for \f(CW\*(C`txt\*(C'\fR records
these are all the strings and so on.
.Sp
All types mentioned in \s-1RFC 1035, \s0\f(CW\*(C`aaaa\*(C'\fR, \f(CW\*(C`srv\*(C'\fR, \f(CW\*(C`naptr\*(C'\fR and \f(CW\*(C`spf\*(C'\fR are
decoded. All resource records not known to this module will have the raw
\&\f(CW\*(C`rdata\*(C'\fR field as fifth array element.
.Sp
Note that this resolver is just a stub resolver: it requires a name server
supporting recursive queries, will not do any recursive queries itself and
is not secure when used against an untrusted name server.
.Sp
The following options are supported:
.RS 4
.IP "search => [$suffix...]" 4
.IX Item "search => [$suffix...]"
Use the given search list (which might be empty), by appending each one
in turn to the \f(CW$qname\fR. If this option is missing then the configured
\&\f(CW\*(C`ndots\*(C'\fR and \f(CW\*(C`search\*(C'\fR values define its value (depending on \f(CW\*(C`ndots\*(C'\fR, the
empty suffix will be prepended or appended to that \f(CW\*(C`search\*(C'\fR value). If
the \f(CW$qname\fR ends in a dot, then the searchlist will be ignored.
.IP "accept => [$type...]" 4
.IX Item "accept => [$type...]"
Lists the acceptable result types: only result types in this set will be
accepted and returned. The default includes the \f(CW$qtype\fR and nothing
else. If this list includes \f(CW\*(C`cname\*(C'\fR, then CNAME-chains will not be
followed (because you asked for the \s-1CNAME\s0 record).
.ie n .IP "class => ""class""" 4
.el .IP "class => ``class''" 4
.IX Item "class => class"
Specify the query class (\*(L"in\*(R" for internet, \*(L"ch\*(R" for chaosnet and \*(L"hs\*(R" for
hesiod are the only ones making sense). The default is \*(L"in\*(R", of course.
.RE
.RS 4
.Sp
Examples:
.Sp
.Vb 6
\&   # full example, you can paste this into perl:
\&   use Data::Dumper;
\&   use AnyEvent::DNS;
\&   AnyEvent::DNS::resolver\->resolve (
\&      "google.com", "*", my $cv = AnyEvent\->condvar);
\&   warn Dumper [$cv\->recv];
\&
\&   # shortened result:
\&   # [
\&   #   [ \*(Aqgoogle.com\*(Aq, \*(Aqsoa\*(Aq, \*(Aqin\*(Aq, 3600, \*(Aqns1.google.com\*(Aq, \*(Aqdns\-admin.google.com\*(Aq,
\&   #     2008052701, 7200, 1800, 1209600, 300 ],
\&   #   [
\&   #     \*(Aqgoogle.com\*(Aq, \*(Aqtxt\*(Aq, \*(Aqin\*(Aq, 3600,
\&   #     \*(Aqv=spf1 include:_netblocks.google.com ~all\*(Aq
\&   #   ],
\&   #   [ \*(Aqgoogle.com\*(Aq, \*(Aqa\*(Aq, \*(Aqin\*(Aq, 3600, \*(Aq64.233.187.99\*(Aq ],
\&   #   [ \*(Aqgoogle.com\*(Aq, \*(Aqmx\*(Aq, \*(Aqin\*(Aq, 3600, 10, \*(Aqsmtp2.google.com\*(Aq ],
\&   #   [ \*(Aqgoogle.com\*(Aq, \*(Aqns\*(Aq, \*(Aqin\*(Aq, 3600, \*(Aqns2.google.com\*(Aq ],
\&   # ]
\&
\&   # resolve a records:
\&   $res\->resolve ("ruth.plan9.de", "a", sub { warn Dumper [@_] });
\&
\&   # result:
\&   # [
\&   #   [ \*(Aqruth.schmorp.de\*(Aq, \*(Aqa\*(Aq, \*(Aqin\*(Aq, 86400, \*(Aq129.13.162.95\*(Aq ]
\&   # ]
\&
\&   # resolve any records, but return only a and aaaa records:
\&   $res\->resolve ("test1.laendle", "*",
\&      accept => ["a", "aaaa"],
\&      sub {
\&         warn Dumper [@_];
\&      }
\&   );
\&
\&   # result:
\&   # [
\&   #   [ \*(Aqtest1.laendle\*(Aq, \*(Aqa\*(Aq, \*(Aqin\*(Aq, 86400, \*(Aq10.0.0.255\*(Aq ],
\&   #   [ \*(Aqtest1.laendle\*(Aq, \*(Aqaaaa\*(Aq, \*(Aqin\*(Aq, 60, \*(Aq3ffe:1900:4545:0002:0240:0000:0000:f7e1\*(Aq ]
\&   # ]
.Ve
.RE
.ie n .IP "$resolver\->wait_for_slot ($cb\->($resolver))" 4
.el .IP "\f(CW$resolver\fR\->wait_for_slot ($cb\->($resolver))" 4
.IX Item "$resolver->wait_for_slot ($cb->($resolver))"
Wait until a free request slot is available and call the callback with the
resolver object.
.Sp
A request slot is used each time a request is actually sent to the
nameservers: There are never more than \f(CW\*(C`max_outstanding\*(C'\fR of them.
.Sp
Although you can submit more requests (they will simply be queued until
a request slot becomes available), sometimes, usually for rate-limiting
purposes, it is useful to instead wait for a slot before generating the
request (or simply to know when the request load is low enough so one can
submit requests again).
.Sp
This is what this method does: The callback will be called when submitting
a \s-1DNS\s0 request will not result in that request being queued. The callback
may or may not generate any requests in response.
.Sp
Note that the callback will only be invoked when the request queue is
empty, so this does not play well if somebody else keeps the request queue
full at all times.
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 2
\&   Marc Lehmann <schmorp@schmorp.de>
\&   http://anyevent.schmorp.de
.Ve
