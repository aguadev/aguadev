.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "AnyEvent::RabbitMQ::Channel 3"
.TH AnyEvent::RabbitMQ::Channel 3 "2013-07-01" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
AnyEvent::RabbitMQ::Channel \- Abstraction of an AMQP channel.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    my $ch = $rf\->open_channel();
\&    $ch\->declare_exchange(exchange => \*(Aqtest_exchange\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.ie n .SH "ARGUMENTS FOR ""open_channel"""
.el .SH "ARGUMENTS FOR \f(CWopen_channel\fP"
.IX Header "ARGUMENTS FOR open_channel"
.IP "on_close" 4
.IX Item "on_close"
Callback invoked when the channel closes.  Callback will be passed the
incoming message that caused the close, if any.
.IP "on_return" 4
.IX Item "on_return"
Callback invoked when a mandatory or immediate message publish fails.
Callback will be passed the incoming message, with accessors
\&\f(CW\*(C`method_frame\*(C'\fR, \f(CW\*(C`header_frame\*(C'\fR, and \f(CW\*(C`body_frame\*(C'\fR.
.SH "METHODS"
.IX Header "METHODS"
.SS "declare_exchange (%args)"
.IX Subsection "declare_exchange (%args)"
Declare an exchange (to publish messages to) on the server.
.PP
Arguments:
.IP "on_success" 4
.IX Item "on_success"
.PD 0
.IP "on_failure" 4
.IX Item "on_failure"
.IP "type" 4
.IX Item "type"
.PD
Default 'direct'
.IP "passive" 4
.IX Item "passive"
Default 0
.IP "durable" 4
.IX Item "durable"
Default 0
.IP "auto_delete" 4
.IX Item "auto_delete"
Default 0
.IP "internal" 4
.IX Item "internal"
Default 0
.IP "exchange" 4
.IX Item "exchange"
The name of the exchange
.SS "delete_exchange"
.IX Subsection "delete_exchange"
.SS "declare_queue"
.IX Subsection "declare_queue"
.SS "bind_queue"
.IX Subsection "bind_queue"
Binds a queue to an exchange, with a routing key.
.PP
Arguments:
.IP "queue" 4
.IX Item "queue"
The name of the queue to bind
.IP "exchange" 4
.IX Item "exchange"
The name of the exchange to bind
.IP "routing_key" 4
.IX Item "routing_key"
The routing key to bind with
.SS "unbind_queue"
.IX Subsection "unbind_queue"
.SS "purge_queue"
.IX Subsection "purge_queue"
Flushes the contents of a queue.
.SS "delete_queue"
.IX Subsection "delete_queue"
Deletes a queue. The queue may not have any active consumers.
.SS "publish"
.IX Subsection "publish"
Publish a message to an exchange
.PP
Arguments:
.IP "body" 4
.IX Item "body"
The text body of the message to send.
.IP "header" 4
.IX Item "header"
Customer headers for the message (if any).
.IP "exchange" 4
.IX Item "exchange"
The name of the exchange to send the message to.
.IP "routing_key" 4
.IX Item "routing_key"
The routing key with which to publish the message.
.IP "on_ack" 4
.IX Item "on_ack"
Callback (if any) for confirming acknowledgment when in confirm mode.
.SS "consume"
.IX Subsection "consume"
Subscribe to consume messages from a queue.
.PP
Arguments:
.IP "on_consume" 4
.IX Item "on_consume"
Callback called with an argument of the message which has been consumed.
.IP "on_cancel" 4
.IX Item "on_cancel"
Callback called if consumption is canceled.  This may be at client request
or as a side effect of queue deletion.  (Notification of queue deletion is a
RabbitMQ extension.)
.IP "consumer_tag" 4
.IX Item "consumer_tag"
Identifies this consumer, will be auto-generated if you do not provide it, but you must
supply a value if you want to be able to later cancel the subscription.
.IP "on_success" 4
.IX Item "on_success"
Callback called if the subscription was successful (before the first message is consumed).
.IP "on_failure" 4
.IX Item "on_failure"
Callback called if the subscription fails for any reason.
.SS "publish"
.IX Subsection "publish"
Publish a message to an exchange.
.PP
Arguments:
.IP "header" 4
.IX Item "header"
Hash of \s-1AMQP\s0 message header info, including the confusingly similar element \*(L"headers\*(R",
which may contain arbitrary string key/value pairs.
.IP "body" 4
.IX Item "body"
Message body.
.IP "mandatory" 4
.IX Item "mandatory"
Boolean; if true, then if the message doesn't land in a queue (e.g. the exchange has no
bindings), it will be \*(L"returned.\*(R"  (see \*(L"on_return\*(R")
.IP "immediate" 4
.IX Item "immediate"
Boolean; if true, then if the message cannot be delivered directly to a consumer, it
will be \*(L"returned.\*(R"  (see \*(L"on_return\*(R")
.IP "on_ack" 4
.IX Item "on_ack"
Callback called with the frame that acknowledges receipt (if channel is in confirm mode),
typically Net::AMQP::Protocol::Basic::Ack.
.IP "on_nack" 4
.IX Item "on_nack"
Callback called with the frame that declines receipt (if the channel is in confirm mode),
typically Net::AMQP::Protocol::Basic::Nack or Net::AMQP::Protocol::Channel::Close.
.IP "on_return" 4
.IX Item "on_return"
In \s-1AMQP,\s0 a \*(L"returned\*(R" message is one that cannot be delivered in compliance with the
\&\f(CW\*(C`immediate\*(C'\fR or \f(CW\*(C`mandatory\*(C'\fR flags.
.Sp
If in confirm mode, this callback will be called with the frame that reports message
return, typically Net::AMQP::Protocol::Basic::Return.  If confirm mode is off or
this callback is not provided, then the channel or connection objects' on_return
callbacks (if any), will be called instead.
.Sp
\&\s-1NOTE:\s0 If confirm mode is on, the on_ack or on_nack callback will be called whether or
not on_return is called first.
.SS "cancel"
.IX Subsection "cancel"
Cancel a queue subscription.
.PP
Note that the cancellation \fBwill not\fR take place at once, and further messages may be
consumed before the subscription is cancelled. No further messages will be
consumed after the on_success callback has been called.
.PP
Arguments:
.IP "consumer_tag" 4
.IX Item "consumer_tag"
Identifies this consumer, needs to be the value supplied when the queue is initially
consumed from.
.IP "on_success" 4
.IX Item "on_success"
Callback called if the subscription was successfully cancelled.
.IP "on_failure" 4
.IX Item "on_failure"
Callback called if the subscription could not be cancelled for any reason.
.SS "get"
.IX Subsection "get"
Try to get a single message from a queue.
.PP
Arguments:
.IP "queue" 4
.IX Item "queue"
Mandatory. Name of the queue to try to receive a message from.
.IP "on_success" 4
.IX Item "on_success"
Will be called either with either a message, or, if the queue is empty,
a notification that there was nothing to collect from the queue.
.IP "on_failure" 4
.IX Item "on_failure"
This callback will be called if an error is signalled on this channel.
.SS "ack"
.IX Subsection "ack"
.SS "qos"
.IX Subsection "qos"
.SS "confirm"
.IX Subsection "confirm"
Put channel into confirm mode.  In confirm mode, publishes are confirmed by
the server, so the on_ack callback of publish works.
.SS "recover"
.IX Subsection "recover"
.SS "select_tx"
.IX Subsection "select_tx"
.SS "commit_tx"
.IX Subsection "commit_tx"
.SS "rollback_tx"
.IX Subsection "rollback_tx"
.SH "AUTHOR, COPYRIGHT AND LICENSE"
.IX Header "AUTHOR, COPYRIGHT AND LICENSE"
See AnyEvent::RabbitMQ for author(s), copyright and license.
