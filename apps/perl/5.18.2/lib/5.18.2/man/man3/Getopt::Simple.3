.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Getopt::Simple 3"
.TH Getopt::Simple 3 "2014-04-10" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
"Getopt::Simple" \- Provide a simple wrapper around Getopt::Long.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&        use Getopt::Simple;
\&
\&        # Or ...
\&        # use Getopt::Simple qw($switch);
\&
\&        my($options) =
\&        {
\&        help =>
\&                {
\&                type    => \*(Aq\*(Aq,
\&                env     => \*(Aq\-\*(Aq,
\&                default => \*(Aq\*(Aq,
\&#               verbose => \*(Aq\*(Aq,      # Not needed on every key.
\&                order   => 1,
\&                },
\&        username =>
\&                {
\&                type    => \*(Aq=s\*(Aq,    # As per Getopt::Long.
\&                env     => \*(Aq$USER\*(Aq, # Help text.
\&                default => $ENV{\*(AqUSER\*(Aq} || \*(AqRonSavage\*(Aq, # In case $USER is undef.
\&                verbose => \*(AqSpecify the username on the remote machine\*(Aq,
\&                order   => 3,       # Help text sort order.
\&                },
\&        password =>
\&                {
\&                type    => \*(Aq=s\*(Aq,
\&                env     => \*(Aq\-\*(Aq,
\&                default => \*(Aqpassword\*(Aq,
\&                verbose => \*(AqSpecify the password on the remote machine\*(Aq,
\&                order   => 4,
\&                },
\&        };
\&
\&        my($option) = Getopt::Simple \-> new();
\&
\&        if (! $option \-> getOptions($options, "Usage: testSimple.pl [options]") )
\&        {
\&                exit(\-1);       # Failure.
\&        }
\&
\&        print "username: $$option{\*(Aqswitch\*(Aq}{\*(Aqusername\*(Aq}. \en";
\&        print "password: $$option{\*(Aqswitch\*(Aq}{\*(Aqpassword\*(Aq}. \en";
\&
\&        # Or, after \*(Aquse Getopt::Simple qw($switch);\*(Aq ...
\&        # print "username: $$switch{\*(Aqusername\*(Aq}. \en";
\&        # print "password: $$switch{\*(Aqpassword\*(Aq}. \en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Getopt::Simple\*(C'\fR is a pure Perl module.
.PP
The \f(CW\*(C`Getopt::Simple\*(C'\fR module provides a simple way of specifying:
.IP "\(bu" 4
Command line switches
.IP "\(bu" 4
Type information for switch values
.IP "\(bu" 4
Default values for the switches
.IP "\(bu" 4
Help text per switch
.SH "Distributions"
.IX Header "Distributions"
This module is available both as a Unix-style distro (*.tgz) and an
ActiveState-style distro (*.ppd). The latter is shipped in a *.zip file.
.PP
See http://savage.net.au/Perl\-modules.html for details.
.PP
See http://savage.net.au/Perl\-modules/html/installing\-a\-module.html for
help on unpacking and installing each type of distro.
.SH "Constructor and initialization"
.IX Header "Constructor and initialization"
new(...) returns a \f(CW\*(C`Getopt::Simple\*(C'\fR object.
.PP
This is the class's contructor.
.PP
Usage: Getopt::Simple \-> \fInew()\fR.
.PP
This method does not take any parameters.
.ie n .SH "The ""dumpOptions()"" function"
.el .SH "The \f(CWdumpOptions()\fP function"
.IX Header "The dumpOptions() function"
\&\f(CW\*(C`dumpOptions()\*(C'\fR prints all your option's keys and their current values.
.PP
\&\f(CW\*(C`dumpOptions()\*(C'\fR does not return anything.
.ie n .SH "The ""getOptions()"" function"
.el .SH "The \f(CWgetOptions()\fP function"
.IX Header "The getOptions() function"
The \f(CW\*(C`getOptions()\*(C'\fR function takes 4 parameters:
.IP "\(bu" 4
A hash ref defining the command line switches
.Sp
The structure of this hash ref is defined in the next section.
.Sp
This parameter is mandatory.
.IP "\(bu" 4
A string to display as a help text heading
.Sp
This parameter is mandatory.
.IP "\(bu" 4
A Boolean. 0 = (Default) Use case-sensitive switch names. 1 = Ignore case
.Sp
This parameter is optional.
.IP "\(bu" 4
A Boolean. 0 = Return after displaying help. 1 = (Default) Terminate with \fIexit\fR\|(0)
after displaying help
.Sp
This parameter is optional.
.PP
\&\f(CW\*(C`getOptions()\*(C'\fR returns 0 for failure and 1 for success.
.SH "The hash ref of command line switches"
.IX Header "The hash ref of command line switches"
.IP "\(bu" 4
Each key in the hash ref is the name of a command line switch
.IP "\(bu" 4
Each key points to a hash ref which defines the nature of that command line switch
.Sp
The keys and values of this nested hash ref are as follows.
.RS 4
.IP "\(bu" 4
default => 'Some value'
.Sp
This key, value pair is mandatory.
.Sp
This is the default value for this switch.
.Sp
Examples:
.Sp
.Vb 2
\&        default => \*(Aq/users/home/dir\*(Aq
\&        default => $ENV{\*(AqREMOTEHOST\*(Aq} || \*(Aq127.0.0.1\*(Aq
.Ve
.IP "\(bu" 4
env => '\-' || 'Some short help text'
.Sp
This key, value pair is mandatory.
.Sp
This is help test, to indicate that the calling program can use an environment
variable to set the default value of this switch.
.Sp
Use '\-' to indicate that no environment variable is used.
.Sp
Examples:
.Sp
.Vb 2
\&        env => \*(Aq\-\*(Aq
\&        env => \*(Aq$REMOTEHOST\*(Aq
.Ve
.Sp
Note the use of ' to indicate we want the $ to appear in the output.
.IP "\(bu" 4
type => 'Types as per Getopt::Long'
.Sp
This key, value pair is mandatory.
.Sp
This is the type of the command line switch, as defined by Getopt::Long.
.Sp
Examples:
.Sp
.Vb 2
\&        type => \*(Aq=s\*(Aq
\&        type => \*(Aq=s@\*(Aq,
.Ve
.IP "\(bu" 4
verbose => 'Some long help text'
.Sp
This key, value pair is optional.
.Sp
This is long, explanatory help text which is displayed below the help containing
the three columns of text: switch name, env value, default value.
.Sp
Examples:
.Sp
.Vb 2
\&        verbose => \*(AqSpecify the username on the remote machine\*(Aq,
\&        verbose => \*(AqSpecify the home directory on the remote machine\*(Aq
.Ve
.IP "\(bu" 4
order => \ed+
.Sp
This key, value pair is mandatory.
.Sp
This is the sort order used to force the help text to display the switches in
a specific order down the page.
.Sp
Examples:
.Sp
.Vb 2
\&        order => 1
\&        order => 9
.Ve
.RE
.RS 4
.RE
.ie n .SH "The ""helpOptions()"" function"
.el .SH "The \f(CWhelpOptions()\fP function"
.IX Header "The helpOptions() function"
\&\f(CW\*(C`helpOptions()\*(C'\fR prints nicely formatted help text.
.PP
\&\f(CW\*(C`helpOptions()\*(C'\fR does not return anything.
.SH "The $$classRef{'switch'} hash reference"
.IX Header "The $$classRef{'switch'} hash reference"
Command line option values are accessed in your code by dereferencing
the hash reference $$classRef{'switch'}. Two examples are given above,
under synopsis.
.PP
Alternately, you can use the hash reference \f(CW$switch\fR. See below.
.ie n .SH "The $switch hash reference"
.el .SH "The \f(CW$switch\fP hash reference"
.IX Header "The $switch hash reference"
Command line option values are accessed in your code by dereferencing
the hash reference \f(CW$switch\fR. Two examples are given above,
under synopsis.
.PP
Alternately, you can use the hash reference $$classRef{'switch'}. See above.
.SH "WARNING re Perl bug"
.IX Header "WARNING re Perl bug"
As always, be aware that these 2 lines mean the same thing, sometimes:
.IP "\(bu" 4
\&\f(CW$self\fR \-> {'thing'}
.IP "\(bu" 4
\&\f(CW$self\fR\->{'thing'}
.PP
The problem is the spaces around the \->. Inside double quotes, \*(L"...\*(R", the
first space stops the dereference taking place. Outside double quotes the
scanner correctly associates the \f(CW$self\fR token with the {'thing'} token.
.PP
I regard this as a bug.
.SH "AUTHOR"
.IX Header "AUTHOR"
\&\f(CW\*(C`Getopt::Simple\*(C'\fR was written by Ron Savage \fI<ron@savage.net.au>\fR in 1997.
.SH "LICENCE"
.IX Header "LICENCE"
Australian copyright (c) 1997\-2002 Ron Savage.
.PP
.Vb 4
\&        All Programs of mine are \*(AqOSI Certified Open Source Software\*(Aq;
\&        you can redistribute them and/or modify them under the terms of
\&        The Artistic License, a copy of which is available at:
\&        http://www.opensource.org/licenses/index.html
.Ve
