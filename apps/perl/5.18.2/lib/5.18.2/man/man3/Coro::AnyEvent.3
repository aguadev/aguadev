.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "AnyEvent 3"
.TH AnyEvent 3 "2014-03-04" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Coro::AnyEvent \- integrate threads into AnyEvent
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\& use Coro;
\& use AnyEvent;
\& # using both Coro and AnyEvent will automatically load Coro::AnyEvent
\&
\& # or load it manually for its utility functions:
\& use Coro::AnyEvent;
\&
\& Coro::AnyEvent::sleep 5;     # block current thread for 5s
\& Coro::AnyEvent::poll;        # poll for new events once
\& Coro::AnyEvent::idle;        # block until process no longer busy
\& Coro::AnyEvent::idle_upto 5; # same, but only up to 5 seconds
\&
\& Coro::AnyEvent::readable $fh, 60
\&    or die "fh didn\*(Aqt become readable within 60 seconds\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
When one naively starts to use threads in Perl, one will quickly run
into the problem that threads which block on a syscall (sleeping,
reading from a socket etc.) will block all threads.
.PP
If one then uses an event loop, the problem is that the event loop has
no knowledge of threads and will not run them before it polls for new
events, again blocking the whole process.
.PP
This module integrates threads into any event loop supported by
AnyEvent, combining event-based programming with coroutine-based
programming in a natural way.
.PP
As of Coro 5.21 and newer, this module gets loaded automatically when
AnyEvent initialises itself and Coro is used in the same process, thus
there is no need to load it manually if you just want your threads to
coexist with AnyEvent.
.PP
If you want to use any functions from this module, you of course still
need to \f(CW\*(C`use Coro::AnyEvent\*(C'\fR, just as with other perl modules.
.PP
Also, this module autodetects the event loop used (by relying on
AnyEvent) and will either automatically defer to the high-performance
Coro::EV or Coro::Event modules, or will use a generic integration
method that should work with any event loop supported by AnyEvent.
.SH "USAGE"
.IX Header "USAGE"
.SS "\s-1RUN AN EVENT LOOP \- OR NOT\s0?"
.IX Subsection "RUN AN EVENT LOOP - OR NOT?"
For performance reasons, it is recommended that the main program or
something else run the event loop of the event model you use, i.e.
.PP
.Vb 3
\&   use Gtk2; # <\- the event model
\&   use AnyEvent;
\&   use Coro:
\&
\&   # initialise stuff
\&   async { ... };
\&
\&   # now run mainloop of Gtk2
\&   main Gtk2;
.Ve
.PP
You can move the event loop into a thread as well, although this tends to
get confusing:
.PP
.Vb 3
\&   use Gtk2;
\&   use AnyEvent;
\&   use Coro:
\&
\&   async { main Gtk2 };
\&
\&   # do other things...
\&   while () {
\&      use Coro::AnyEvent;
\&      Coro::AnyEvent::sleep 1;
\&      print "ping...\en";
\&   }
.Ve
.PP
You can also do nothing, in which case Coro::AnyEvent will invoke the event
loop as needed, which is less efficient, but sometimes very convenient.
.PP
What you \fI\s-1MUST NOT EVER DO\s0\fR is to block inside an event loop
callback. The reason is that most event loops are not reentrant and
this can cause a deadlock at best and corrupt memory at worst.
.PP
Coro will try to catch you when you block in the event loop
(\*(L"\s-1FATAL:\s0 \f(CW$Coro::IDLE\fR blocked itself\*(R"), but this is just best effort and
only works when you do not run your own event loop.
.PP
To avoid this problem, start a new thread (e.g. with \f(CW\*(C`Coro::async_pool\*(C'\fR)
or use \f(CW\*(C`Coro::unblock_sub\*(C'\fR to run blocking tasks.
.SS "\s-1INVERSION OF CONTROL\s0"
.IX Subsection "INVERSION OF CONTROL"
If you need to wait for a single event, the rouse functions will come in
handy (see the Coro manpage for details):
.PP
.Vb 5
\&   # wait for single SIGINT
\&   {
\&      my $int_w = AnyEvent\->signal (signal => "INT", cb => Coro::rouse_cb);
\&      Coro::rouse_wait;
\&   }
.Ve
.SS "\s-1EVENT MODULES OTHER THAN ANYEVENT\s0"
.IX Subsection "EVENT MODULES OTHER THAN ANYEVENT"
Keep in mind that, as shipped, Coro and Coro::AnyEvent only work with
AnyEvent, and only when AnyEvent is actually used (i.e. initialised), so
this will not work:
.PP
.Vb 3
\&   # does not work: EV without AnyEvent is not recognised
\&   use EV;
\&   use Coro;
\&
\&   EV::loop;
.Ve
.PP
And neither does this, unless you actually \fIuse\fR AnyEvent for something:
.PP
.Vb 4
\&   # does not work: AnyEvent must be initialised (e.g. by creating watchers)
\&   use EV;
\&   use AnyEvent;
\&   use Coro;
\&
\&   EV::loop;
.Ve
.PP
This does work, however, because you create a watcher (condvars work,
too), thus forcing AnyEvent to initialise itself:
.PP
.Vb 4
\&   # does work: AnyEvent is actually used
\&   use EV;
\&   use AnyEvent;
\&   use Coro;
\&
\&   my $timer = AE::timer 1, 1, sub { };
\&
\&   EV::loop;
.Ve
.PP
And if you want to use AnyEvent just to bridge between Coro and your event
model of choice, you can simply force it to initialise itself, like this:
.PP
.Vb 4
\&   # does work: AnyEvent is initialised manually
\&   use POE;
\&   use AnyEvent;
\&   use Coro;
\&
\&   AnyEvent::detect; # force AnyEvent to integrate Coro into POE
\&   POE::Kernel\->run;
.Ve
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
Coro::AnyEvent also offers a few functions that might be useful.
.IP "Coro::AnyEvent::poll" 4
.IX Item "Coro::AnyEvent::poll"
This call will block the current thread until the event loop has polled
for potential new events and instructs the event loop to poll for new
events once, without blocking.
.Sp
Note that this call will not actually execute the poll, nor will it wait
until there are some events, just block until the event loop has polled
for new events, so other threads will have a chance to run.
.Sp
This is useful when you have a thread that does some computations, but you
still want to poll for new events from time to time. Simply call \f(CW\*(C`poll\*(C'\fR
from time to time:
.Sp
.Vb 6
\&   my $long_calc = async {
\&      for (1..10000) {
\&         Coro::AnyEvent::poll;
\&         # do some stuff, make sure it takes at least 0.001s or so
\&      }
\&   }
.Ve
.Sp
Although you should also consider \f(CW\*(C`idle\*(C'\fR or \f(CW\*(C`idle_upto\*(C'\fR in such cases.
.ie n .IP "Coro::AnyEvent::sleep $seconds" 4
.el .IP "Coro::AnyEvent::sleep \f(CW$seconds\fR" 4
.IX Item "Coro::AnyEvent::sleep $seconds"
This blocks the current thread for at least the given number of seconds.
.IP "Coro::AnyEvent::idle" 4
.IX Item "Coro::AnyEvent::idle"
This call is similar to \f(CW\*(C`poll\*(C'\fR in that it will also poll for
events. Unlike \f(CW\*(C`poll\*(C'\fR, it will only resume the thread once there are no
events to handle anymore, i.e. when the process is otherwise idle.
.Sp
This is good for background threads that shouldn't use \s-1CPU\s0 time when
foreground jobs are ready to run.
.ie n .IP "Coro::AnyEvent::idle_upto $seconds" 4
.el .IP "Coro::AnyEvent::idle_upto \f(CW$seconds\fR" 4
.IX Item "Coro::AnyEvent::idle_upto $seconds"
Like \f(CW\*(C`idle\*(C'\fR, but with a maximum waiting time.
.Sp
If your process is busy handling events, calling \f(CW\*(C`idle\*(C'\fR can mean that
your thread will never be resumed. To avoid this, you can use \f(CW\*(C`idle_upto\*(C'\fR
and specify a timeout, after which your thread will be resumed even if the
process is completely busy.
.ie n .IP "Coro::AnyEvent::readable $fh_or_fileno[, $timeout]" 4
.el .IP "Coro::AnyEvent::readable \f(CW$fh_or_fileno\fR[, \f(CW$timeout\fR]" 4
.IX Item "Coro::AnyEvent::readable $fh_or_fileno[, $timeout]"
.PD 0
.ie n .IP "Coro::AnyEvent::writable $fh_or_fileno[, $timeout]" 4
.el .IP "Coro::AnyEvent::writable \f(CW$fh_or_fileno\fR[, \f(CW$timeout\fR]" 4
.IX Item "Coro::AnyEvent::writable $fh_or_fileno[, $timeout]"
.PD
Blocks the current thread until the given file handle (or file descriptor)
becomes readable (or writable), or the given timeout has elapsed,
whichever happens first. No timeout counts as infinite timeout.
.Sp
Returns true when the file handle became ready, false when a timeout
occured.
.Sp
Note that these functions are quite inefficient as compared to using a
single watcher (they recreate watchers on every invocation) or compared to
using Coro::Handle.
.Sp
Note also that they only work for sources that have reasonable
non-blocking behaviour (e.g. not files).
.Sp
Example: wait until \s-1STDIN\s0 becomes readable, then quit the program.
.Sp
.Vb 4
\&   use Coro::AnyEvent;
\&   print "press enter to quit...\en";
\&   Coro::AnyEvent::readable *STDIN;
\&   exit 0;
.Ve
.SH "IMPLEMENTATION DETAILS"
.IX Header "IMPLEMENTATION DETAILS"
Unfortunately, few event loops (basically only \s-1EV\s0 and Event)
support the kind of integration required for smooth operations well, and
consequently, AnyEvent cannot completely offer the functionality required
by this module, so we need to improvise.
.PP
Here is what this module does when it has to work with other event loops:
.IP "\(bu" 4
run ready threads before blocking the process
.Sp
Each time a thread is put into the ready queue (and there are no other
threads in the ready queue), a timer with an \f(CW\*(C`after\*(C'\fR value of \f(CW0\fR is
registered with AnyEvent.
.Sp
This creates something similar to an \fIidle\fR watcher, i.e. a watcher
that keeps the event loop from blocking but still polls for new
events. (Unfortunately, some badly designed event loops (e.g. Event::Lib)
don't support a timeout of \f(CW0\fR and will always block for a bit).
.Sp
The callback for that timer will \f(CW\*(C`cede\*(C'\fR to other threads of the same or
higher priority for as long as such threads exists. This has the effect of
running all threads that have work to do until all threads block to wait
for external events.
.Sp
If no threads of equal or higher priority are ready, it will cede to any
thread, but only once. This has the effect of running lower-priority
threads as well, but it will not keep higher priority threads from
receiving new events.
.Sp
The priority used is simply the priority of the thread that runs the event
loop, usually the main program, which usually has a priority of \f(CW0\fR. Note
that Coro::AnyEvent does \fInot\fR run an event loop for you, so unless the
main program runs one, there will simply be no event loop to \f(CW\*(C`cede\*(C'\fR to
(event handling will still work, somewhat inefficiently, but any thread
will have a higher priority than event handling in that case).
.IP "\(bu" 4
provide a suitable idle callback.
.Sp
In addition to hooking into \f(CW\*(C`ready\*(C'\fR, this module will also provide a
\&\f(CW$Coro::idle\fR handler that runs the event loop. It is best not to take
advantage of this too often, as this is rather inefficient, but it should
work perfectly fine.
.IP "\(bu" 4
provide overrides for AnyEvent's condvars
.Sp
This module installs overrides for AnyEvent's condvars. That is, when
the module is loaded it will provide its own condition variables. This
makes them coroutine-safe, i.e. you can safely block on them from within a
coroutine.
.IP "\(bu" 4
lead to data corruption or worse
.Sp
As \f(CW\*(C`unblock_sub\*(C'\fR cannot be used by this module (as it is the module
that implements it, basically), you must not call into the event
loop recursively from any coroutine. This is not usually a difficult
restriction to live with, just use condvars, \f(CW\*(C`unblock_sub\*(C'\fR or other means
of inter-coroutine-communications.
.Sp
If you use a module that supports AnyEvent (or uses the same event
loop as AnyEvent, making it implicitly compatible), and it offers
callbacks of any kind, then you must not block in them, either (or use
e.g. \f(CW\*(C`unblock_sub\*(C'\fR), see the description of \f(CW\*(C`unblock_sub\*(C'\fR in the
Coro module.
.Sp
This also means that you should load the module as early as possible,
as only condvars created after this module has been loaded will work
correctly.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
AnyEvent, to see which event loops are supported, Coro::EV and
Coro::Event for more efficient and more correct solutions (they will be
used automatically if applicable).
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 2
\& Marc Lehmann <schmorp@schmorp.de>
\& http://home.schmorp.de/
.Ve
