.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Channel 3"
.TH Channel 3 "2014-03-04" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Coro::Channel \- message queues
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Coro;
\&
\& $q1 = new Coro::Channel <maxsize>;
\&
\& $q1\->put ("xxx");
\& print $q1\->get;
\&
\& die unless $q1\->size;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A Coro::Channel is the equivalent of a unix pipe (and similar to amiga
message ports): you can put things into it on one end and read things out
of it from the other end. If the capacity of the Channel is maxed out
writers will block. Both ends of a Channel can be read/written from by as
many coroutines as you want concurrently.
.PP
You don't have to load \f(CW\*(C`Coro::Channel\*(C'\fR manually, it will be loaded
automatically when you \f(CW\*(C`use Coro\*(C'\fR and call the \f(CW\*(C`new\*(C'\fR constructor.
.ie n .IP "$q = new Coro:Channel $maxsize" 4
.el .IP "\f(CW$q\fR = new Coro:Channel \f(CW$maxsize\fR" 4
.IX Item "$q = new Coro:Channel $maxsize"
Create a new channel with the given maximum size (practically unlimited
if \f(CW\*(C`maxsize\*(C'\fR is omitted). Giving a size of one gives you a traditional
channel, i.e. a queue that can store only a single element (which means
there will be no buffering, and \f(CW\*(C`put\*(C'\fR will wait until there is a
corresponding \f(CW\*(C`get\*(C'\fR call). To buffer one element you have to specify
\&\f(CW2\fR, and so on.
.ie n .IP "$q\->put ($scalar)" 4
.el .IP "\f(CW$q\fR\->put ($scalar)" 4
.IX Item "$q->put ($scalar)"
Put the given scalar into the queue.
.ie n .IP "$q\->get" 4
.el .IP "\f(CW$q\fR\->get" 4
.IX Item "$q->get"
Return the next element from the queue, waiting if necessary.
.ie n .IP "$q\->shutdown" 4
.el .IP "\f(CW$q\fR\->shutdown" 4
.IX Item "$q->shutdown"
Shuts down the Channel by pushing a virtual end marker onto it: This
changes the behaviour of the Channel when it becomes or is empty to return
\&\f(CW\*(C`undef\*(C'\fR, almost as if infinitely many \f(CW\*(C`undef\*(C'\fR elements had been put
into the queue.
.Sp
Specifically, this function wakes up any pending \f(CW\*(C`get\*(C'\fR calls and lets
them return \f(CW\*(C`undef\*(C'\fR, the same on future \f(CW\*(C`get\*(C'\fR calls. \f(CW\*(C`size\*(C'\fR will return
the real number of stored elements, though.
.Sp
Another way to describe the behaviour is that \f(CW\*(C`get\*(C'\fR calls will not block
when the queue becomes empty but immediately return \f(CW\*(C`undef\*(C'\fR. This means
that calls to \f(CW\*(C`put\*(C'\fR will work normally and the data will be returned on
subsequent \f(CW\*(C`get\*(C'\fR calls.
.Sp
This method is useful to signal the end of data to any consumers, quite
similar to an end of stream on e.g. a tcp socket: You have one or more
producers that \f(CW\*(C`put\*(C'\fR data into the Channel and one or more consumers who
\&\f(CW\*(C`get\*(C'\fR them. When all producers have finished producing data, a call to
\&\f(CW\*(C`shutdown\*(C'\fR signals this fact to any consumers.
.Sp
A common implementation uses one or more threads that \f(CW\*(C`get\*(C'\fR from
a channel until it returns \f(CW\*(C`undef\*(C'\fR. To clean everything up, first
\&\f(CW\*(C`shutdown\*(C'\fR the channel, then \f(CW\*(C`join\*(C'\fR the threads.
.ie n .IP "$q\->size" 4
.el .IP "\f(CW$q\fR\->size" 4
.IX Item "$q->size"
Return the number of elements waiting to be consumed. Please note that:
.Sp
.Vb 4
\&  if ($q\->size) {
\&     my $data = $q\->get;
\&     ...
\&  }
.Ve
.Sp
is \fInot\fR a race condition but instead works just fine. Note that the
number of elements that wait can be larger than \f(CW$maxsize\fR, as it
includes any coroutines waiting to put data into the channel (but not any
shutdown condition).
.Sp
This means that the number returned is \fIprecisely\fR the number of calls
to \f(CW\*(C`get\*(C'\fR that will succeed instantly and return some data. Calling
\&\f(CW\*(C`shutdown\*(C'\fR has no effect on this number.
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 2
\& Marc Lehmann <schmorp@schmorp.de>
\& http://home.schmorp.de/
.Ve
