.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Class::DBI::Lite::Pager 3"
.TH Class::DBI::Lite::Pager 3 "2012-03-08" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Class::DBI::Lite::Pager \- Page through your records, easily.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.SS "Paged Navigation Through Large Datasets"
.IX Subsection "Paged Navigation Through Large Datasets"
.Vb 8
\&  # Say we\*(Aqre on page 1 of a list of all \*(AqRock\*(Aq artists:
\&  my $pager = app::artist\->pager({
\&    genre => \*(AqRock\*(Aq,
\&  }, {
\&    order_by    => \*(Aqname ASC\*(Aq,
\&    page_number => 1,
\&    page_size   => 20,
\&  });
\&
\&  # \-\-\-\-\-\-\-\- OR \-\-\-\-\-\-\-\-\-\-\-
\&  my $pager = app::artist\->sql_pager({
\&    data_sql  => "SELECT * FROM artists WHERE genre = ?",
\&    count_sql => "SELECT COUNT(*) FROM artists WHERE genre = ?",
\&    sql_args  => [ \*(AqRock\*(Aq ],
\&  }, {
\&    page_number => 1,
\&    page_size   => 20,
\&  });
\&  
\&  # Get the first page of items from the pager:
\&  my @artists = $pager\->items;
\&  
\&  # Is the a \*(Aqprevious\*(Aq page?:
\&  if( $pager\->has_prev ) {
\&    print "Prev page number is " . ( $pager\->page_number \- 1 ) . "\en";
\&  }
\&  
\&  # Say where we are in the total scheme of things:
\&  print "Page " . $pager\->page_number . " of " . $pager\->total_pages . "\en";
\&  print "Showing items " . $pager\->start_item . " through " . $pager\->stop_item . " out of " . $pager\->total_items . "\en";
\&  
\&  # Is there a \*(Aqnext\*(Aq page?:
\&  if( $pager\->has_next ) {
\&    print "Next page number is " . ( $pager\->page_number + 1 ) . "\en";
\&  }
\&  
\&  # Get the \*(Aqstart\*(Aq and \*(Aqstop\*(Aq page numbers for a navigation strip with 
\&  # up to 5 pages before and after the \*(Aqcurrent\*(Aq page:
\&  my ($start, $stop) = $pager\->navigations( 5 );
\&  for( $start..$stop ) {
\&    print "Page $_ | ";
\&  }
.Ve
.SS "Fetch Huge Datasets in Small Chunks"
.IX Subsection "Fetch Huge Datasets in Small Chunks"
.Vb 12
\&  # Fetch 300,000,000 records, 100 records at a time:
\&  my $pager = app::citizen\->pager({
\&    country => \*(AqUSA\*(Aq
\&  }, {
\&    order_by    => \*(Aqlast_name, first_name\*(Aq,
\&    page_size   => 100,
\&    page_number => 1,
\&  });
\&  while( my @people = $pager\->next_page ) {
\&    # We only got 100 people, instead of swamping the 
\&    # database by asking for 300M records all at once:
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Paging through records should be easy.  \f(CW\*(C`Class::DBI::Lite::Pager\*(C'\fR \fBmakes\fR it easy.
.SH "CAVEAT EMPTOR"
.IX Header "CAVEAT EMPTOR"
This has been tested with MySQL 5.x and SQLite.  It should work with any database
that provides some kind of \f(CW\*(C`LIMIT index, offset\*(C'\fR construct.
.PP
To discover the total number of pages and items, 2 queries must be performed:
.ie n .IP "1 First we do a ""SELECT COUNT(*) ..."" to find out how many items there are in total." 4
.el .IP "1 First we do a \f(CWSELECT COUNT(*) ...\fR to find out how many items there are in total." 4
.IX Item "1 First we do a SELECT COUNT(*) ... to find out how many items there are in total."
.PD 0
.IP "2 One or more queries to get the records you've requested." 4
.IX Item "2 One or more queries to get the records you've requested."
.PD
If running 2 queries is going to cause your database server to catch fire, please consider rolling your own pager
or finding some other method of doing this.
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.SS "new( page_number => 1, page_size => 10 )"
.IX Subsection "new( page_number => 1, page_size => 10 )"
Returns a new Pager object at the page number and page size specified.
.SH "PUBLIC PROPERTIES"
.IX Header "PUBLIC PROPERTIES"
.SS "page_number"
.IX Subsection "page_number"
Read-write.  Sets/gets the page number.
.SS "page_size"
.IX Subsection "page_size"
Read only.  Returns the page size.
.SS "total_pages"
.IX Subsection "total_pages"
Read only.  Returns the total number of pages in the Pager.
.SS "total_items"
.IX Subsection "total_items"
Read only.  Returns the total number of records in all the pages combined.
.SS "start_item"
.IX Subsection "start_item"
Read only.  Returns the index of the first item in this page's records.
.SS "stop_item"
.IX Subsection "stop_item"
Read only.  Returns the index of the last item in this page's records.
.SS "has_next"
.IX Subsection "has_next"
Read only.  Returns true or false depending on whether there are more pages \fBafter\fR the current page.
.SS "has_prev"
.IX Subsection "has_prev"
Read only.  Returns true or false depending on whether there are more pages \fBbefore\fR the current page.
.SH "PUBLIC METHODS"
.IX Header "PUBLIC METHODS"
.SS "items( )"
.IX Subsection "items( )"
Returns the next page of results.  Same as calling \f(CW\*(C`next_page()\*(C'\fR.  Purely for syntax alone.
.SS "next_page( )"
.IX Subsection "next_page( )"
Returns the next page of results.  If called in list context, returns an array.  If 
called in scalar context, returns a Class::DBI::Lite::Iterator.
.PP
If there is not a next page, returns undef.
.SS "prev_page( )"
.IX Subsection "prev_page( )"
Returns the previous page of results.  If called in list context, returns an array.  If 
called in scalar context, returns a Class::DBI::Lite::Iterator.
.PP
If there is not a previous page, returns undef.
.SS "navigations( [$padding = 5] )"
.IX Subsection "navigations( [$padding = 5] )"
\&\s-1OK \-\s0 grab a cup of coffee, then come back for the explanation.
.PP
Ready?  Good.
.PP
Say you have a \f(CW$pager\fR:
.PP
.Vb 4
\&  my $pager = app::album\->pager(undef, {
\&    page_size => 10,
\&    page_number => 1,
\&  });
.Ve
.PP
Then you want to make your paging navigation with at least 10 pages shown, and a
maximum of 5 pages to either side of the \*(L"current\*(R" page (like Google).
.PP
.Vb 1
\&  1  2  3  4  5  6  7  8  9  10 11
.Ve
.PP
On the first page you \fIcould\fR just do:
.PP
.Vb 3
\&  for( 1..10 ) {
\&    # print a link to that page.
\&  }
.Ve
.PP
\&...but...when you get toward the middle or off to the end, it gets weird.
.PP
Tah-Dah!
.PP
.Vb 1
\&  my ($start, $stop) = $pager\->navigations( 5 );
.Ve
.PP
Now you can simply do:
.PP
.Vb 3
\&  for( $start..$stop ) {
\&    # print a link to that page:
\&  }
.Ve
.PP
\&\fBIt\fR will always do the right thing \- will \fIyou\fR?
.PP
So when you're on page 7 it will look like this:
.PP
.Vb 1
\&  2  3  4  5  6  7  8  9  10  11  12
.Ve
.PP
Then, if there were 20 pages in your entire resultset, page 20 would look like this:
.PP
.Vb 1
\&  10  11  12  13  14  15  16  17  18  19  20
.Ve
.PP
Great, huh?
.SH "AUTHOR"
.IX Header "AUTHOR"
Copyright John Drago <jdrago_999@yahoo.com>.  All rights reserved.
.SH "LICENSE"
.IX Header "LICENSE"
This software is \fBFree\fR software and may be used and redistributed under the
same terms as perl itself.
