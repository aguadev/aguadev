.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Coro 3"
.TH Coro 3 "2014-03-04" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Coro \- the only real threads in perl
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Coro;
\&  
\&  async {
\&     # some asynchronous thread of execution
\&     print "2\en";
\&     cede; # yield back to main
\&     print "4\en";
\&  };
\&  print "1\en";
\&  cede; # yield to coro
\&  print "3\en";
\&  cede; # and again
\&  
\&  # use locking
\&  my $lock = new Coro::Semaphore;
\&  my $locked;
\&  
\&  $lock\->down;
\&  $locked = 1;
\&  $lock\->up;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
For a tutorial-style introduction, please read the Coro::Intro
manpage. This manpage mainly contains reference information.
.PP
This module collection manages continuations in general, most often in
the form of cooperative threads (also called coros, or simply \*(L"coro\*(R"
in the documentation). They are similar to kernel threads but don't (in
general) run in parallel at the same time even on \s-1SMP\s0 machines. The
specific flavor of thread offered by this module also guarantees you that
it will not switch between threads unless necessary, at easily-identified
points in your program, so locking and parallel access are rarely an
issue, making thread programming much safer and easier than using other
thread models.
.PP
Unlike the so-called \*(L"Perl threads\*(R" (which are not actually real threads
but only the windows process emulation (see section of same name for
more details) ported to \s-1UNIX,\s0 and as such act as processes), Coro
provides a full shared address space, which makes communication between
threads very easy. And coro threads are fast, too: disabling the Windows
process emulation code in your perl and using Coro can easily result in
a two to four times speed increase for your programs. A parallel matrix
multiplication benchmark (very communication-intensive) runs over 300
times faster on a single core than perls pseudo-threads on a quad core
using all four cores.
.PP
Coro achieves that by supporting multiple running interpreters that share
data, which is especially useful to code pseudo-parallel processes and
for event-based programming, such as multiple HTTP-GET requests running
concurrently. See Coro::AnyEvent to learn more on how to integrate Coro
into an event-based environment.
.PP
In this module, a thread is defined as "callchain + lexical variables +
some package variables + C stack), that is, a thread has its own callchain,
its own set of lexicals and its own set of perls most important global
variables (see Coro::State for more configuration and background info).
.PP
See also the \f(CW\*(C`SEE ALSO\*(C'\fR section at the end of this document \- the Coro
module family is quite large.
.SH "CORO THREAD LIFE CYCLE"
.IX Header "CORO THREAD LIFE CYCLE"
During the long and exciting (or not) life of a coro thread, it goes
through a number of states:
.IP "1. Creation" 4
.IX Item "1. Creation"
The first thing in the life of a coro thread is it's creation \-
obviously. The typical way to create a thread is to call the \f(CW\*(C`async
BLOCK\*(C'\fR function:
.Sp
.Vb 3
\&   async {
\&      # thread code goes here
\&   };
.Ve
.Sp
You can also pass arguments, which are put in \f(CW@_\fR:
.Sp
.Vb 3
\&   async {
\&      print $_[1]; # prints 2
\&   } 1, 2, 3;
.Ve
.Sp
This creates a new coro thread and puts it into the ready queue, meaning
it will run as soon as the \s-1CPU\s0 is free for it.
.Sp
\&\f(CW\*(C`async\*(C'\fR will return a Coro object \- you can store this for future
reference or ignore it \- a thread that is running, ready to run or waiting
for some event is alive on it's own.
.Sp
Another way to create a thread is to call the \f(CW\*(C`new\*(C'\fR constructor with a
code-reference:
.Sp
.Vb 3
\&   new Coro sub {
\&      # thread code goes here
\&   }, @optional_arguments;
.Ve
.Sp
This is quite similar to calling \f(CW\*(C`async\*(C'\fR, but the important difference is
that the new thread is not put into the ready queue, so the thread will
not run until somebody puts it there. \f(CW\*(C`async\*(C'\fR is, therefore, identical to
this sequence:
.Sp
.Vb 5
\&   my $coro = new Coro sub {
\&      # thread code goes here
\&   };
\&   $coro\->ready;
\&   return $coro;
.Ve
.IP "2. Startup" 4
.IX Item "2. Startup"
When a new coro thread is created, only a copy of the code reference
and the arguments are stored, no extra memory for stacks and so on is
allocated, keeping the coro thread in a low-memory state.
.Sp
Only when it actually starts executing will all the resources be finally
allocated.
.Sp
The optional arguments specified at coro creation are available in \f(CW@_\fR,
similar to function calls.
.IP "3. Running / Blocking" 4
.IX Item "3. Running / Blocking"
A lot can happen after the coro thread has started running. Quite usually,
it will not run to the end in one go (because you could use a function
instead), but it will give up the \s-1CPU\s0 regularly because it waits for
external events.
.Sp
As long as a coro thread runs, its Coro object is available in the global
variable \f(CW$Coro::current\fR.
.Sp
The low-level way to give up the \s-1CPU\s0 is to call the scheduler, which
selects a new coro thread to run:
.Sp
.Vb 1
\&   Coro::schedule;
.Ve
.Sp
Since running threads are not in the ready queue, calling the scheduler
without doing anything else will block the coro thread forever \- you need
to arrange either for the coro to put woken up (readied) by some other
event or some other thread, or you can put it into the ready queue before
scheduling:
.Sp
.Vb 3
\&   # this is exactly what Coro::cede does
\&   $Coro::current\->ready;
\&   Coro::schedule;
.Ve
.Sp
All the higher-level synchronisation methods (Coro::Semaphore,
Coro::rouse_*...) are actually implemented via \f(CW\*(C`\->ready\*(C'\fR and \f(CW\*(C`Coro::schedule\*(C'\fR.
.Sp
While the coro thread is running it also might get assigned a C\-level
thread, or the C\-level thread might be unassigned from it, as the Coro
runtime wishes. A C\-level thread needs to be assigned when your perl
thread calls into some C\-level function and that function in turn calls
perl and perl then wants to switch coroutines. This happens most often
when you run an event loop and block in the callback, or when perl
itself calls some function such as \f(CW\*(C`AUTOLOAD\*(C'\fR or methods via the \f(CW\*(C`tie\*(C'\fR
mechanism.
.IP "4. Termination" 4
.IX Item "4. Termination"
Many threads actually terminate after some time. There are a number of
ways to terminate a coro thread, the simplest is returning from the
top-level code reference:
.Sp
.Vb 3
\&   async {
\&      # after returning from here, the coro thread is terminated
\&   };
\&
\&   async {
\&      return if 0.5 <  rand; # terminate a little earlier, maybe
\&      print "got a chance to print this\en";
\&      # or here
\&   };
.Ve
.Sp
Any values returned from the coroutine can be recovered using \f(CW\*(C`\->join\*(C'\fR:
.Sp
.Vb 3
\&   my $coro = async {
\&      "hello, world\en" # return a string
\&   };
\&
\&   my $hello_world = $coro\->join;
\&
\&   print $hello_world;
.Ve
.Sp
Another way to terminate is to call \f(CW\*(C`Coro::terminate\*(C'\fR, which at any
subroutine call nesting level:
.Sp
.Vb 3
\&   async {
\&      Coro::terminate "return value 1", "return value 2";
\&   };
.Ve
.Sp
Yet another way is to \f(CW\*(C`\->cancel\*(C'\fR (or \f(CW\*(C`\->safe_cancel\*(C'\fR) the coro
thread from another thread:
.Sp
.Vb 3
\&   my $coro = async {
\&      exit 1;
\&   };
\&
\&   $coro\->cancel; # also accepts values for \->join to retrieve
.Ve
.Sp
Cancellation \fIcan\fR be dangerous \- it's a bit like calling \f(CW\*(C`exit\*(C'\fR without
actually exiting, and might leave C libraries and \s-1XS\s0 modules in a weird
state. Unlike other thread implementations, however, Coro is exceptionally
safe with regards to cancellation, as perl will always be in a consistent
state, and for those cases where you want to do truly marvellous things
with your coro while it is being cancelled \- that is, make sure all
cleanup code is executed from the thread being cancelled \- there is even a
\&\f(CW\*(C`\->safe_cancel\*(C'\fR method.
.Sp
So, cancelling a thread that runs in an \s-1XS\s0 event loop might not be the
best idea, but any other combination that deals with perl only (cancelling
when a thread is in a \f(CW\*(C`tie\*(C'\fR method or an \f(CW\*(C`AUTOLOAD\*(C'\fR for example) is
safe.
.Sp
Last not least, a coro thread object that isn't referenced is \f(CW\*(C`\->cancel\*(C'\fR'ed automatically \- just like other objects in Perl. This
is not such a common case, however \- a running thread is referencedy by
\&\f(CW$Coro::current\fR, a thread ready to run is referenced by the ready queue,
a thread waiting on a lock or semaphore is referenced by being in some
wait list and so on. But a thread that isn't in any of those queues gets
cancelled:
.Sp
.Vb 3
\&   async {
\&      schedule; # cede to other coros, don\*(Aqt go into the ready queue
\&   };
\&
\&   cede;
\&   # now the async above is destroyed, as it is not referenced by anything.
.Ve
.Sp
A slightly embellished example might make it clearer:
.Sp
.Vb 4
\&   async {
\&      my $guard = Guard::guard { print "destroyed\en" };
\&      schedule while 1;
\&   };
\&
\&   cede;
.Ve
.Sp
Superficially one might not expect any output \- since the \f(CW\*(C`async\*(C'\fR
implements an endless loop, the \f(CW$guard\fR will not be cleaned up. However,
since the thread object returned by \f(CW\*(C`async\*(C'\fR is not stored anywhere, the
thread is initially referenced because it is in the ready queue, when it
runs it is referenced by \f(CW$Coro::current\fR, but when it calls \f(CW\*(C`schedule\*(C'\fR,
it gets \f(CW\*(C`cancel\*(C'\fRed causing the guard object to be destroyed (see the next
section), and printing it's message.
.Sp
If this seems a bit drastic, remember that this only happens when nothing
references the thread anymore, which means there is no way to further
execute it, ever. The only options at this point are leaking the thread,
or cleaning it up, which brings us to...
.IP "5. Cleanup" 4
.IX Item "5. Cleanup"
Threads will allocate various resources. Most but not all will be returned
when a thread terminates, during clean-up.
.Sp
Cleanup is quite similar to throwing an uncaught exception: perl will
work it's way up through all subroutine calls and blocks. On it's way, it
will release all \f(CW\*(C`my\*(C'\fR variables, undo all \f(CW\*(C`local\*(C'\fR's and free any other
resources truly local to the thread.
.Sp
So, a common way to free resources is to keep them referenced only by my
variables:
.Sp
.Vb 3
\&   async {
\&      my $big_cache = new Cache ...;
\&   };
.Ve
.Sp
If there are no other references, then the \f(CW$big_cache\fR object will be
freed when the thread terminates, regardless of how it does so.
.Sp
What it does \f(CW\*(C`NOT\*(C'\fR do is unlock any Coro::Semaphores or similar
resources, but that's where the \f(CW\*(C`guard\*(C'\fR methods come in handy:
.Sp
.Vb 1
\&   my $sem = new Coro::Semaphore;
\&
\&   async {
\&      my $lock_guard = $sem\->guard;
\&      # if we return, or die or get cancelled, here,
\&      # then the semaphore will be "up"ed.
\&   };
.Ve
.Sp
The \f(CW\*(C`Guard::guard\*(C'\fR function comes in handy for any custom cleanup you
might want to do (but you cannot switch to other coroutines from those
code blocks):
.Sp
.Vb 6
\&   async {
\&      my $window = new Gtk2::Window "toplevel";
\&      # The window will not be cleaned up automatically, even when $window
\&      # gets freed, so use a guard to ensure it\*(Aqs destruction
\&      # in case of an error:
\&      my $window_guard = Guard::guard { $window\->destroy };
\&
\&      # we are safe here
\&   };
.Ve
.Sp
Last not least, \f(CW\*(C`local\*(C'\fR can often be handy, too, e.g. when temporarily
replacing the coro thread description:
.Sp
.Vb 2
\&   sub myfunction {
\&      local $Coro::current\->{desc} = "inside myfunction(@_)";
\&
\&      # if we return or die here, the description will be restored
\&   }
.Ve
.IP "6. Viva La Zombie Muerte" 4
.IX Item "6. Viva La Zombie Muerte"
Even after a thread has terminated and cleaned up its resources, the Coro
object still is there and stores the return values of the thread.
.Sp
When there are no other references, it will simply be cleaned up and
freed.
.Sp
If there areany references, the Coro object will stay around, and you
can call \f(CW\*(C`\->join\*(C'\fR as many times as you wish to retrieve the result
values:
.Sp
.Vb 4
\&   async {
\&      print "hi\en";
\&      1
\&   };
\&
\&   # run the async above, and free everything before returning
\&   # from Coro::cede:
\&   Coro::cede;
\&
\&   {
\&      my $coro = async {
\&         print "hi\en";
\&         1
\&      };
\&
\&      # run the async above, and clean up, but do not free the coro
\&      # object:
\&      Coro::cede;
\&
\&      # optionally retrieve the result values
\&      my @results = $coro\->join;
\&
\&      # now $coro goes out of scope, and presumably gets freed
\&   };
.Ve
.SH "GLOBAL VARIABLES"
.IX Header "GLOBAL VARIABLES"
.ie n .IP "$Coro::main" 4
.el .IP "\f(CW$Coro::main\fR" 4
.IX Item "$Coro::main"
This variable stores the Coro object that represents the main
program. While you can \f(CW\*(C`ready\*(C'\fR it and do most other things you can do to
coro, it is mainly useful to compare again \f(CW$Coro::current\fR, to see
whether you are running in the main program or not.
.ie n .IP "$Coro::current" 4
.el .IP "\f(CW$Coro::current\fR" 4
.IX Item "$Coro::current"
The Coro object representing the current coro (the last
coro that the Coro scheduler switched to). The initial value is
\&\f(CW$Coro::main\fR (of course).
.Sp
This variable is \fBstrictly\fR \fIread-only\fR. You can take copies of the
value stored in it and use it as any other Coro object, but you must
not otherwise modify the variable itself.
.ie n .IP "$Coro::idle" 4
.el .IP "\f(CW$Coro::idle\fR" 4
.IX Item "$Coro::idle"
This variable is mainly useful to integrate Coro into event loops. It is
usually better to rely on Coro::AnyEvent or Coro::EV, as this is
pretty low-level functionality.
.Sp
This variable stores a Coro object that is put into the ready queue when
there are no other ready threads (without invoking any ready hooks).
.Sp
The default implementation dies with \*(L"\s-1FATAL:\s0 deadlock detected.\*(R", followed
by a thread listing, because the program has no other way to continue.
.Sp
This hook is overwritten by modules such as \f(CW\*(C`Coro::EV\*(C'\fR and
\&\f(CW\*(C`Coro::AnyEvent\*(C'\fR to wait on an external event that hopefully wakes up a
coro so the scheduler can run it.
.Sp
See Coro::EV or Coro::AnyEvent for examples of using this technique.
.SH "SIMPLE CORO CREATION"
.IX Header "SIMPLE CORO CREATION"
.IP "async { ... } [@args...]" 4
.IX Item "async { ... } [@args...]"
Create a new coro and return its Coro object (usually
unused). The coro will be put into the ready queue, so
it will start running automatically on the next scheduler run.
.Sp
The first argument is a codeblock/closure that should be executed in the
coro. When it returns argument returns the coro is automatically
terminated.
.Sp
The remaining arguments are passed as arguments to the closure.
.Sp
See the \f(CW\*(C`Coro::State::new\*(C'\fR constructor for info about the coro
environment in which coro are executed.
.Sp
Calling \f(CW\*(C`exit\*(C'\fR in a coro will do the same as calling exit outside
the coro. Likewise, when the coro dies, the program will exit,
just as it would in the main program.
.Sp
If you do not want that, you can provide a default \f(CW\*(C`die\*(C'\fR handler, or
simply avoid dieing (by use of \f(CW\*(C`eval\*(C'\fR).
.Sp
Example: Create a new coro that just prints its arguments.
.Sp
.Vb 3
\&   async {
\&      print "@_\en";
\&   } 1,2,3,4;
.Ve
.IP "async_pool { ... } [@args...]" 4
.IX Item "async_pool { ... } [@args...]"
Similar to \f(CW\*(C`async\*(C'\fR, but uses a coro pool, so you should not call
terminate or join on it (although you are allowed to), and you get a
coro that might have executed other code already (which can be good
or bad :).
.Sp
On the plus side, this function is about twice as fast as creating (and
destroying) a completely new coro, so if you need a lot of generic
coros in quick successsion, use \f(CW\*(C`async_pool\*(C'\fR, not \f(CW\*(C`async\*(C'\fR.
.Sp
The code block is executed in an \f(CW\*(C`eval\*(C'\fR context and a warning will be
issued in case of an exception instead of terminating the program, as
\&\f(CW\*(C`async\*(C'\fR does. As the coro is being reused, stuff like \f(CW\*(C`on_destroy\*(C'\fR
will not work in the expected way, unless you call terminate or cancel,
which somehow defeats the purpose of pooling (but is fine in the
exceptional case).
.Sp
The priority will be reset to \f(CW0\fR after each run, tracing will be
disabled, the description will be reset and the default output filehandle
gets restored, so you can change all these. Otherwise the coro will
be re-used \*(L"as-is\*(R": most notably if you change other per-coro global
stuff such as \f(CW$/\fR you \fImust needs\fR revert that change, which is most
simply done by using local as in: \f(CW\*(C`local $/\*(C'\fR.
.Sp
The idle pool size is limited to \f(CW8\fR idle coros (this can be
adjusted by changing \f(CW$Coro::POOL_SIZE\fR), but there can be as many non-idle
coros as required.
.Sp
If you are concerned about pooled coros growing a lot because a
single \f(CW\*(C`async_pool\*(C'\fR used a lot of stackspace you can e.g. \f(CW\*(C`async_pool
{ terminate }\*(C'\fR once per second or so to slowly replenish the pool. In
addition to that, when the stacks used by a handler grows larger than 32kb
(adjustable via \f(CW$Coro::POOL_RSS\fR) it will also be destroyed.
.SH "STATIC METHODS"
.IX Header "STATIC METHODS"
Static methods are actually functions that implicitly operate on the
current coro.
.IP "schedule" 4
.IX Item "schedule"
Calls the scheduler. The scheduler will find the next coro that is
to be run from the ready queue and switches to it. The next coro
to be run is simply the one with the highest priority that is longest
in its ready queue. If there is no coro ready, it will call the
\&\f(CW$Coro::idle\fR hook.
.Sp
Please note that the current coro will \fInot\fR be put into the ready
queue, so calling this function usually means you will never be called
again unless something else (e.g. an event handler) calls \f(CW\*(C`\->ready\*(C'\fR,
thus waking you up.
.Sp
This makes \f(CW\*(C`schedule\*(C'\fR \fIthe\fR generic method to use to block the current
coro and wait for events: first you remember the current coro in
a variable, then arrange for some callback of yours to call \f(CW\*(C`\->ready\*(C'\fR on that once some event happens, and last you call \f(CW\*(C`schedule\*(C'\fR to put
yourself to sleep. Note that a lot of things can wake your coro up,
so you need to check whether the event indeed happened, e.g. by storing the
status in a variable.
.Sp
See \fB\s-1HOW TO WAIT FOR A CALLBACK\s0\fR, below, for some ways to wait for callbacks.
.IP "cede" 4
.IX Item "cede"
\&\*(L"Cede\*(R" to other coros. This function puts the current coro into
the ready queue and calls \f(CW\*(C`schedule\*(C'\fR, which has the effect of giving
up the current \*(L"timeslice\*(R" to other coros of the same or higher
priority. Once your coro gets its turn again it will automatically be
resumed.
.Sp
This function is often called \f(CW\*(C`yield\*(C'\fR in other languages.
.IP "Coro::cede_notself" 4
.IX Item "Coro::cede_notself"
Works like cede, but is not exported by default and will cede to \fIany\fR
coro, regardless of priority. This is useful sometimes to ensure
progress is made.
.IP "terminate [arg...]" 4
.IX Item "terminate [arg...]"
Terminates the current coro with the given status values (see
cancel). The values will not be copied, but referenced directly.
.IP "Coro::on_enter \s-1BLOCK,\s0 Coro::on_leave \s-1BLOCK\s0" 4
.IX Item "Coro::on_enter BLOCK, Coro::on_leave BLOCK"
These function install enter and leave winders in the current scope. The
enter block will be executed when on_enter is called and whenever the
current coro is re-entered by the scheduler, while the leave block is
executed whenever the current coro is blocked by the scheduler, and
also when the containing scope is exited (by whatever means, be it exit,
die, last etc.).
.Sp
\&\fINeither invoking the scheduler, nor exceptions, are allowed within those
BLOCKs\fR. That means: do not even think about calling \f(CW\*(C`die\*(C'\fR without an
eval, and do not even think of entering the scheduler in any way.
.Sp
Since both BLOCKs are tied to the current scope, they will automatically
be removed when the current scope exits.
.Sp
These functions implement the same concept as \f(CW\*(C`dynamic\-wind\*(C'\fR in scheme
does, and are useful when you want to localise some resource to a specific
coro.
.Sp
They slow down thread switching considerably for coros that use them
(about 40% for a \s-1BLOCK\s0 with a single assignment, so thread switching is
still reasonably fast if the handlers are fast).
.Sp
These functions are best understood by an example: The following function
will change the current timezone to \*(L"Antarctica/South_Pole\*(R", which
requires a call to \f(CW\*(C`tzset\*(C'\fR, but by using \f(CW\*(C`on_enter\*(C'\fR and \f(CW\*(C`on_leave\*(C'\fR,
which remember/change the current timezone and restore the previous
value, respectively, the timezone is only changed for the coro that
installed those handlers.
.Sp
.Vb 1
\&   use POSIX qw(tzset);
\&
\&   async {
\&      my $old_tz; # store outside TZ value here
\&
\&      Coro::on_enter {
\&         $old_tz = $ENV{TZ}; # remember the old value
\&
\&         $ENV{TZ} = "Antarctica/South_Pole";
\&         tzset; # enable new value
\&      };
\&
\&      Coro::on_leave {
\&         $ENV{TZ} = $old_tz;
\&         tzset; # restore old value
\&      };
\&
\&      # at this place, the timezone is Antarctica/South_Pole,
\&      # without disturbing the TZ of any other coro.
\&   };
.Ve
.Sp
This can be used to localise about any resource (locale, uid, current
working directory etc.) to a block, despite the existance of other
coros.
.Sp
Another interesting example implements time-sliced multitasking using
interval timers (this could obviously be optimised, but does the job):
.Sp
.Vb 3
\&   # "timeslice" the given block
\&   sub timeslice(&) {
\&      use Time::HiRes ();
\&
\&      Coro::on_enter {
\&         # on entering the thread, we set an VTALRM handler to cede
\&         $SIG{VTALRM} = sub { cede };
\&         # and then start the interval timer
\&         Time::HiRes::setitimer &Time::HiRes::ITIMER_VIRTUAL, 0.01, 0.01;
\&      };
\&      Coro::on_leave {
\&         # on leaving the thread, we stop the interval timer again
\&         Time::HiRes::setitimer &Time::HiRes::ITIMER_VIRTUAL, 0, 0;
\&      };
\&
\&      &{+shift};
\&   }
\&
\&   # use like this:
\&   timeslice {
\&      # The following is an endless loop that would normally
\&      # monopolise the process. Since it runs in a timesliced
\&      # environment, it will regularly cede to other threads.
\&      while () { }
\&   };
.Ve
.IP "killall" 4
.IX Item "killall"
Kills/terminates/cancels all coros except the currently running one.
.Sp
Note that while this will try to free some of the main interpreter
resources if the calling coro isn't the main coro, but one
cannot free all of them, so if a coro that is not the main coro
calls this function, there will be some one-time resource leak.
.SH "CORO OBJECT METHODS"
.IX Header "CORO OBJECT METHODS"
These are the methods you can call on coro objects (or to create
them).
.ie n .IP "new Coro \e&sub [, @args...]" 4
.el .IP "new Coro \e&sub [, \f(CW@args\fR...]" 4
.IX Item "new Coro &sub [, @args...]"
Create a new coro and return it. When the sub returns, the coro
automatically terminates as if \f(CW\*(C`terminate\*(C'\fR with the returned values were
called. To make the coro run you must first put it into the ready
queue by calling the ready method.
.Sp
See \f(CW\*(C`async\*(C'\fR and \f(CW\*(C`Coro::State::new\*(C'\fR for additional info about the
coro environment.
.ie n .IP "$success = $coro\->ready" 4
.el .IP "\f(CW$success\fR = \f(CW$coro\fR\->ready" 4
.IX Item "$success = $coro->ready"
Put the given coro into the end of its ready queue (there is one
queue for each priority) and return true. If the coro is already in
the ready queue, do nothing and return false.
.Sp
This ensures that the scheduler will resume this coro automatically
once all the coro of higher priority and all coro of the same
priority that were put into the ready queue earlier have been resumed.
.ie n .IP "$coro\->suspend" 4
.el .IP "\f(CW$coro\fR\->suspend" 4
.IX Item "$coro->suspend"
Suspends the specified coro. A suspended coro works just like any other
coro, except that the scheduler will not select a suspended coro for
execution.
.Sp
Suspending a coro can be useful when you want to keep the coro from
running, but you don't want to destroy it, or when you want to temporarily
freeze a coro (e.g. for debugging) to resume it later.
.Sp
A scenario for the former would be to suspend all (other) coros after a
fork and keep them alive, so their destructors aren't called, but new
coros can be created.
.ie n .IP "$coro\->resume" 4
.el .IP "\f(CW$coro\fR\->resume" 4
.IX Item "$coro->resume"
If the specified coro was suspended, it will be resumed. Note that when
the coro was in the ready queue when it was suspended, it might have been
unreadied by the scheduler, so an activation might have been lost.
.Sp
To avoid this, it is best to put a suspended coro into the ready queue
unconditionally, as every synchronisation mechanism must protect itself
against spurious wakeups, and the one in the Coro family certainly do
that.
.ie n .IP "$state\->is_new" 4
.el .IP "\f(CW$state\fR\->is_new" 4
.IX Item "$state->is_new"
Returns true iff this Coro object is \*(L"new\*(R", i.e. has never been run
yet. Those states basically consist of only the code reference to call and
the arguments, but consumes very little other resources. New states will
automatically get assigned a perl interpreter when they are transfered to.
.ie n .IP "$state\->is_zombie" 4
.el .IP "\f(CW$state\fR\->is_zombie" 4
.IX Item "$state->is_zombie"
Returns true iff the Coro object has been cancelled, i.e.
it's resources freed because they were \f(CW\*(C`cancel\*(C'\fR'ed, \f(CW\*(C`terminate\*(C'\fR'd,
\&\f(CW\*(C`safe_cancel\*(C'\fR'ed or simply went out of scope.
.Sp
The name \*(L"zombie\*(R" stems from \s-1UNIX\s0 culture, where a process that has
exited and only stores and exit status and no other resources is called a
\&\*(L"zombie\*(R".
.ie n .IP "$is_ready = $coro\->is_ready" 4
.el .IP "\f(CW$is_ready\fR = \f(CW$coro\fR\->is_ready" 4
.IX Item "$is_ready = $coro->is_ready"
Returns true iff the Coro object is in the ready queue. Unless the Coro
object gets destroyed, it will eventually be scheduled by the scheduler.
.ie n .IP "$is_running = $coro\->is_running" 4
.el .IP "\f(CW$is_running\fR = \f(CW$coro\fR\->is_running" 4
.IX Item "$is_running = $coro->is_running"
Returns true iff the Coro object is currently running. Only one Coro object
can ever be in the running state (but it currently is possible to have
multiple running Coro::States).
.ie n .IP "$is_suspended = $coro\->is_suspended" 4
.el .IP "\f(CW$is_suspended\fR = \f(CW$coro\fR\->is_suspended" 4
.IX Item "$is_suspended = $coro->is_suspended"
Returns true iff this Coro object has been suspended. Suspended Coros will
not ever be scheduled.
.ie n .IP "$coro\->cancel (arg...)" 4
.el .IP "\f(CW$coro\fR\->cancel (arg...)" 4
.IX Item "$coro->cancel (arg...)"
Terminates the given Coro thread and makes it return the given arguments as
status (default: an empty list). Never returns if the Coro is the
current Coro.
.Sp
This is a rather brutal way to free a coro, with some limitations \- if
the thread is inside a C callback that doesn't expect to be canceled,
bad things can happen, or if the cancelled thread insists on running
complicated cleanup handlers that rely on its thread context, things will
not work.
.Sp
Any cleanup code being run (e.g. from \f(CW\*(C`guard\*(C'\fR blocks) will be run without
a thread context, and is not allowed to switch to other threads. On the
plus side, \f(CW\*(C`\->cancel\*(C'\fR will always clean up the thread, no matter
what.  If your cleanup code is complex or you want to avoid cancelling a
C\-thread that doesn't know how to clean up itself, it can be better to \f(CW\*(C`\->throw\*(C'\fR an exception, or use \f(CW\*(C`\->safe_cancel\*(C'\fR.
.Sp
The arguments to \f(CW\*(C`\->cancel\*(C'\fR are not copied, but instead will
be referenced directly (e.g. if you pass \f(CW$var\fR and after the call
change that variable, then you might change the return values passed to
e.g. \f(CW\*(C`join\*(C'\fR, so don't do that).
.Sp
The resources of the Coro are usually freed (or destructed) before this
call returns, but this can be delayed for an indefinite amount of time, as
in some cases the manager thread has to run first to actually destruct the
Coro object.
.ie n .IP "$coro\->safe_cancel ($arg...)" 4
.el .IP "\f(CW$coro\fR\->safe_cancel ($arg...)" 4
.IX Item "$coro->safe_cancel ($arg...)"
Works mostly like \f(CW\*(C`\->cancel\*(C'\fR, but is inherently \*(L"safer\*(R", and
consequently, can fail with an exception in cases the thread is not in a
cancellable state.
.Sp
This method works a bit like throwing an exception that cannot be caught
\&\- specifically, it will clean up the thread from within itself, so
all cleanup handlers (e.g. \f(CW\*(C`guard\*(C'\fR blocks) are run with full thread
context and can block if they wish. The downside is that there is no
guarantee that the thread can be cancelled when you call this method, and
therefore, it might fail. It is also considerably slower than \f(CW\*(C`cancel\*(C'\fR or
\&\f(CW\*(C`terminate\*(C'\fR.
.Sp
A thread is in a safe-cancellable state if it either hasn't been run yet,
or it has no C context attached and is inside an \s-1SLF\s0 function.
.Sp
The latter two basically mean that the thread isn't currently inside a
perl callback called from some C function (usually via some \s-1XS\s0 modules)
and isn't currently executing inside some C function itself (via Coro's \s-1XS
API\s0).
.Sp
This call returns true when it could cancel the thread, or croaks with an
error otherwise (i.e. it either returns true or doesn't return at all).
.Sp
Why the weird interface? Well, there are two common models on how and
when to cancel things. In the first, you have the expectation that your
coro thread can be cancelled when you want to cancel it \- if the thread
isn't cancellable, this would be a bug somewhere, so \f(CW\*(C`\->safe_cancel\*(C'\fR
croaks to notify of the bug.
.Sp
In the second model you sometimes want to ask nicely to cancel a thread,
but if it's not a good time, well, then don't cancel. This can be done
relatively easy like this:
.Sp
.Vb 3
\&   if (! eval { $coro\->safe_cancel }) {
\&      warn "unable to cancel thread: $@";
\&   }
.Ve
.Sp
However, what you never should do is first try to cancel \*(L"safely\*(R" and
if that fails, cancel the \*(L"hard\*(R" way with \f(CW\*(C`\->cancel\*(C'\fR. That makes
no sense: either you rely on being able to execute cleanup code in your
thread context, or you don't. If you do, then \f(CW\*(C`\->safe_cancel\*(C'\fR is the
only way, and if you don't, then \f(CW\*(C`\->cancel\*(C'\fR is always faster and more
direct.
.ie n .IP "$coro\->schedule_to" 4
.el .IP "\f(CW$coro\fR\->schedule_to" 4
.IX Item "$coro->schedule_to"
Puts the current coro to sleep (like \f(CW\*(C`Coro::schedule\*(C'\fR), but instead
of continuing with the next coro from the ready queue, always switch to
the given coro object (regardless of priority etc.). The readyness
state of that coro isn't changed.
.Sp
This is an advanced method for special cases \- I'd love to hear about any
uses for this one.
.ie n .IP "$coro\->cede_to" 4
.el .IP "\f(CW$coro\fR\->cede_to" 4
.IX Item "$coro->cede_to"
Like \f(CW\*(C`schedule_to\*(C'\fR, but puts the current coro into the ready
queue. This has the effect of temporarily switching to the given
coro, and continuing some time later.
.Sp
This is an advanced method for special cases \- I'd love to hear about any
uses for this one.
.ie n .IP "$coro\->throw ([$scalar])" 4
.el .IP "\f(CW$coro\fR\->throw ([$scalar])" 4
.IX Item "$coro->throw ([$scalar])"
If \f(CW$throw\fR is specified and defined, it will be thrown as an exception
inside the coro at the next convenient point in time. Otherwise
clears the exception object.
.Sp
Coro will check for the exception each time a schedule-like-function
returns, i.e. after each \f(CW\*(C`schedule\*(C'\fR, \f(CW\*(C`cede\*(C'\fR, \f(CW\*(C`Coro::Semaphore\->down\*(C'\fR, \f(CW\*(C`Coro::Handle\->readable\*(C'\fR and so on. Most of those functions (all
that are part of Coro itself) detect this case and return early in case an
exception is pending.
.Sp
The exception object will be thrown \*(L"as is\*(R" with the specified scalar in
\&\f(CW$@\fR, i.e. if it is a string, no line number or newline will be appended
(unlike with \f(CW\*(C`die\*(C'\fR).
.Sp
This can be used as a softer means than either \f(CW\*(C`cancel\*(C'\fR or \f(CW\*(C`safe_cancel
\&\*(C'\fRto ask a coro to end itself, although there is no guarantee that the
exception will lead to termination, and if the exception isn't caught it
might well end the whole program.
.Sp
You might also think of \f(CW\*(C`throw\*(C'\fR as being the moral equivalent of
\&\f(CW\*(C`kill\*(C'\fRing a coro with a signal (in this case, a scalar).
.ie n .IP "$coro\->join" 4
.el .IP "\f(CW$coro\fR\->join" 4
.IX Item "$coro->join"
Wait until the coro terminates and return any values given to the
\&\f(CW\*(C`terminate\*(C'\fR or \f(CW\*(C`cancel\*(C'\fR functions. \f(CW\*(C`join\*(C'\fR can be called concurrently
from multiple threads, and all will be resumed and given the status
return once the \f(CW$coro\fR terminates.
.ie n .IP "$coro\->on_destroy (\e&cb)" 4
.el .IP "\f(CW$coro\fR\->on_destroy (\e&cb)" 4
.IX Item "$coro->on_destroy (&cb)"
Registers a callback that is called when this coro thread gets destroyed,
that is, after it's resources have been freed but before it is joined. The
callback gets passed the terminate/cancel arguments, if any, and \fImust
not\fR die, under any circumstances.
.Sp
There can be any number of \f(CW\*(C`on_destroy\*(C'\fR callbacks per coro, and there is
currently no way to remove a callback once added.
.ie n .IP "$oldprio = $coro\->prio ($newprio)" 4
.el .IP "\f(CW$oldprio\fR = \f(CW$coro\fR\->prio ($newprio)" 4
.IX Item "$oldprio = $coro->prio ($newprio)"
Sets (or gets, if the argument is missing) the priority of the
coro thread. Higher priority coro get run before lower priority
coros. Priorities are small signed integers (currently \-4 .. +3),
that you can refer to using PRIO_xxx constants (use the import tag :prio
to get then):
.Sp
.Vb 2
\&   PRIO_MAX > PRIO_HIGH > PRIO_NORMAL > PRIO_LOW > PRIO_IDLE > PRIO_MIN
\&       3    >     1     >      0      >    \-1    >    \-3     >    \-4
\&
\&   # set priority to HIGH
\&   current\->prio (PRIO_HIGH);
.Ve
.Sp
The idle coro thread ($Coro::idle) always has a lower priority than any
existing coro.
.Sp
Changing the priority of the current coro will take effect immediately,
but changing the priority of a coro in the ready queue (but not running)
will only take effect after the next schedule (of that coro). This is a
bug that will be fixed in some future version.
.ie n .IP "$newprio = $coro\->nice ($change)" 4
.el .IP "\f(CW$newprio\fR = \f(CW$coro\fR\->nice ($change)" 4
.IX Item "$newprio = $coro->nice ($change)"
Similar to \f(CW\*(C`prio\*(C'\fR, but subtract the given value from the priority (i.e.
higher values mean lower priority, just as in \s-1UNIX\s0's nice command).
.ie n .IP "$olddesc = $coro\->desc ($newdesc)" 4
.el .IP "\f(CW$olddesc\fR = \f(CW$coro\fR\->desc ($newdesc)" 4
.IX Item "$olddesc = $coro->desc ($newdesc)"
Sets (or gets in case the argument is missing) the description for this
coro thread. This is just a free-form string you can associate with a
coro.
.Sp
This method simply sets the \f(CW\*(C`$coro\->{desc}\*(C'\fR member to the given
string. You can modify this member directly if you wish, and in fact, this
is often preferred to indicate major processing states that can then be
seen for example in a Coro::Debug session:
.Sp
.Vb 8
\&   sub my_long_function {
\&      local $Coro::current\->{desc} = "now in my_long_function";
\&      ...
\&      $Coro::current\->{desc} = "my_long_function: phase 1";
\&      ...
\&      $Coro::current\->{desc} = "my_long_function: phase 2";
\&      ...
\&   }
.Ve
.SH "GLOBAL FUNCTIONS"
.IX Header "GLOBAL FUNCTIONS"
.IP "Coro::nready" 4
.IX Item "Coro::nready"
Returns the number of coro that are currently in the ready state,
i.e. that can be switched to by calling \f(CW\*(C`schedule\*(C'\fR directory or
indirectly. The value \f(CW0\fR means that the only runnable coro is the
currently running one, so \f(CW\*(C`cede\*(C'\fR would have no effect, and \f(CW\*(C`schedule\*(C'\fR
would cause a deadlock unless there is an idle handler that wakes up some
coro.
.ie n .IP "my $guard = Coro::guard { ... }" 4
.el .IP "my \f(CW$guard\fR = Coro::guard { ... }" 4
.IX Item "my $guard = Coro::guard { ... }"
This function still exists, but is deprecated. Please use the
\&\f(CW\*(C`Guard::guard\*(C'\fR function instead.
.IP "unblock_sub { ... }" 4
.IX Item "unblock_sub { ... }"
This utility function takes a \s-1BLOCK\s0 or code reference and \*(L"unblocks\*(R" it,
returning a new coderef. Unblocking means that calling the new coderef
will return immediately without blocking, returning nothing, while the
original code ref will be called (with parameters) from within another
coro.
.Sp
The reason this function exists is that many event libraries (such as
the venerable Event module) are not thread-safe (a weaker form
of reentrancy). This means you must not block within event callbacks,
otherwise you might suffer from crashes or worse. The only event library
currently known that is safe to use without \f(CW\*(C`unblock_sub\*(C'\fR is \s-1EV\s0 (but
you might still run into deadlocks if all event loops are blocked).
.Sp
Coro will try to catch you when you block in the event loop
(\*(L"FATAL:$Coro::IDLE blocked itself\*(R"), but this is just best effort and
only works when you do not run your own event loop.
.Sp
This function allows your callbacks to block by executing them in another
coro where it is safe to block. One example where blocking is handy
is when you use the Coro::AIO functions to save results to
disk, for example.
.Sp
In short: simply use \f(CW\*(C`unblock_sub { ... }\*(C'\fR instead of \f(CW\*(C`sub { ... }\*(C'\fR when
creating event callbacks that want to block.
.Sp
If your handler does not plan to block (e.g. simply sends a message to
another coro, or puts some other coro into the ready queue), there is
no reason to use \f(CW\*(C`unblock_sub\*(C'\fR.
.Sp
Note that you also need to use \f(CW\*(C`unblock_sub\*(C'\fR for any other callbacks that
are indirectly executed by any C\-based event loop. For example, when you
use a module that uses AnyEvent (and you use Coro::AnyEvent) and it
provides callbacks that are the result of some event callback, then you
must not block either, or use \f(CW\*(C`unblock_sub\*(C'\fR.
.ie n .IP "$cb = rouse_cb" 4
.el .IP "\f(CW$cb\fR = rouse_cb" 4
.IX Item "$cb = rouse_cb"
Create and return a \*(L"rouse callback\*(R". That's a code reference that,
when called, will remember a copy of its arguments and notify the owner
coro of the callback.
.Sp
See the next function.
.ie n .IP "@args = rouse_wait [$cb]" 4
.el .IP "\f(CW@args\fR = rouse_wait [$cb]" 4
.IX Item "@args = rouse_wait [$cb]"
Wait for the specified rouse callback (or the last one that was created in
this coro).
.Sp
As soon as the callback is invoked (or when the callback was invoked
before \f(CW\*(C`rouse_wait\*(C'\fR), it will return the arguments originally passed to
the rouse callback. In scalar context, that means you get the \fIlast\fR
argument, just as if \f(CW\*(C`rouse_wait\*(C'\fR had a \f(CW\*(C`return ($a1, $a2, $a3...)\*(C'\fR
statement at the end.
.Sp
See the section \fB\s-1HOW TO WAIT FOR A CALLBACK\s0\fR for an actual usage example.
.SH "HOW TO WAIT FOR A CALLBACK"
.IX Header "HOW TO WAIT FOR A CALLBACK"
It is very common for a coro to wait for some callback to be
called. This occurs naturally when you use coro in an otherwise
event-based program, or when you use event-based libraries.
.PP
These typically register a callback for some event, and call that callback
when the event occured. In a coro, however, you typically want to
just wait for the event, simplyifying things.
.PP
For example \f(CW\*(C`AnyEvent\->child\*(C'\fR registers a callback to be called when
a specific child has exited:
.PP
.Vb 1
\&   my $child_watcher = AnyEvent\->child (pid => $pid, cb => sub { ... });
.Ve
.PP
But from within a coro, you often just want to write this:
.PP
.Vb 1
\&   my $status = wait_for_child $pid;
.Ve
.PP
Coro offers two functions specifically designed to make this easy,
\&\f(CW\*(C`rouse_cb\*(C'\fR and \f(CW\*(C`rouse_wait\*(C'\fR.
.PP
The first function, \f(CW\*(C`rouse_cb\*(C'\fR, generates and returns a callback that,
when invoked, will save its arguments and notify the coro that
created the callback.
.PP
The second function, \f(CW\*(C`rouse_wait\*(C'\fR, waits for the callback to be called
(by calling \f(CW\*(C`schedule\*(C'\fR to go to sleep) and returns the arguments
originally passed to the callback.
.PP
Using these functions, it becomes easy to write the \f(CW\*(C`wait_for_child\*(C'\fR
function mentioned above:
.PP
.Vb 2
\&   sub wait_for_child($) {
\&      my ($pid) = @_;
\&
\&      my $watcher = AnyEvent\->child (pid => $pid, cb => rouse_cb);
\&
\&      my ($rpid, $rstatus) = rouse_wait;
\&      $rstatus
\&   }
.Ve
.PP
In the case where \f(CW\*(C`rouse_cb\*(C'\fR and \f(CW\*(C`rouse_wait\*(C'\fR are not flexible enough,
you can roll your own, using \f(CW\*(C`schedule\*(C'\fR and \f(CW\*(C`ready\*(C'\fR:
.PP
.Vb 2
\&   sub wait_for_child($) {
\&      my ($pid) = @_;
\&
\&      # store the current coro in $current,
\&      # and provide result variables for the closure passed to \->child
\&      my $current = $Coro::current;
\&      my ($done, $rstatus);
\&
\&      # pass a closure to \->child
\&      my $watcher = AnyEvent\->child (pid => $pid, cb => sub {
\&         $rstatus = $_[1]; # remember rstatus
\&         $done = 1;        # mark $rstatus as valid
\&         $current\->ready;  # wake up the waiting thread
\&      });
\&
\&      # wait until the closure has been called
\&      schedule while !$done;
\&
\&      $rstatus
\&   }
.Ve
.SH "BUGS/LIMITATIONS"
.IX Header "BUGS/LIMITATIONS"
.IP "fork with pthread backend" 4
.IX Item "fork with pthread backend"
When Coro is compiled using the pthread backend (which isn't recommended
but required on many BSDs as their libcs are completely broken), then
coro will not survive a fork. There is no known workaround except to
fix your libc and use a saner backend.
.ie n .IP "perl process emulation (""threads"")" 4
.el .IP "perl process emulation (``threads'')" 4
.IX Item "perl process emulation (threads)"
This module is not perl-pseudo-thread-safe. You should only ever use this
module from the first thread (this requirement might be removed in the
future to allow per-thread schedulers, but Coro::State does not yet allow
this). I recommend disabling thread support and using processes, as having
the windows process emulation enabled under unix roughly halves perl
performance, even when not used.
.Sp
Attempts to use threads created in another emulated process will crash
(\*(L"cleanly\*(R", with a null pointer exception).
.IP "coro switching is not signal safe" 4
.IX Item "coro switching is not signal safe"
You must not switch to another coro from within a signal handler (only
relevant with \f(CW%SIG\fR \- most event libraries provide safe signals), \fIunless\fR
you are sure you are not interrupting a Coro function.
.Sp
That means you \fI\s-1MUST NOT\s0\fR call any function that might \*(L"block\*(R" the
current coro \- \f(CW\*(C`cede\*(C'\fR, \f(CW\*(C`schedule\*(C'\fR \f(CW\*(C`Coro::Semaphore\->down\*(C'\fR or
anything that calls those. Everything else, including calling \f(CW\*(C`ready\*(C'\fR,
works.
.SH "WINDOWS PROCESS EMULATION"
.IX Header "WINDOWS PROCESS EMULATION"
A great many people seem to be confused about ithreads (for example, Chip
Salzenberg called me unintelligent, incapable, stupid and gullible,
while in the same mail making rather confused statements about perl
ithreads (for example, that memory or files would be shared), showing his
lack of understanding of this area \- if it is hard to understand for Chip,
it is probably not obvious to everybody).
.PP
What follows is an ultra-condensed version of my talk about threads in
scripting languages given on the perl workshop 2009:
.PP
The so-called \*(L"ithreads\*(R" were originally implemented for two reasons:
first, to (badly) emulate unix processes on native win32 perls, and
secondly, to replace the older, real thread model (\*(L"5.005\-threads\*(R").
.PP
It does that by using threads instead of \s-1OS\s0 processes. The difference
between processes and threads is that threads share memory (and other
state, such as files) between threads within a single process, while
processes do not share anything (at least not semantically). That
means that modifications done by one thread are seen by others, while
modifications by one process are not seen by other processes.
.PP
The \*(L"ithreads\*(R" work exactly like that: when creating a new ithreads
process, all state is copied (memory is copied physically, files and code
is copied logically). Afterwards, it isolates all modifications. On \s-1UNIX,\s0
the same behaviour can be achieved by using operating system processes,
except that \s-1UNIX\s0 typically uses hardware built into the system to do this
efficiently, while the windows process emulation emulates this hardware in
software (rather efficiently, but of course it is still much slower than
dedicated hardware).
.PP
As mentioned before, loading code, modifying code, modifying data
structures and so on is only visible in the ithreads process doing the
modification, not in other ithread processes within the same \s-1OS\s0 process.
.PP
This is why \*(L"ithreads\*(R" do not implement threads for perl at all, only
processes. What makes it so bad is that on non-windows platforms, you can
actually take advantage of custom hardware for this purpose (as evidenced
by the forks module, which gives you the (i\-) threads \s-1API,\s0 just much
faster).
.PP
Sharing data is in the i\-threads model is done by transfering data
structures between threads using copying semantics, which is very slow \-
shared data simply does not exist. Benchmarks using i\-threads which are
communication-intensive show extremely bad behaviour with i\-threads (in
fact, so bad that Coro, which cannot take direct advantage of multiple
CPUs, is often orders of magnitude faster because it shares data using
real threads, refer to my talk for details).
.PP
As summary, i\-threads *use* threads to implement processes, while
the compatible forks module *uses* processes to emulate, uhm,
processes. I\-threads slow down every perl program when enabled, and
outside of windows, serve no (or little) practical purpose, but
disadvantages every single-threaded Perl program.
.PP
This is the reason that I try to avoid the name \*(L"ithreads\*(R", as it is
misleading as it implies that it implements some kind of thread model for
perl, and prefer the name \*(L"windows process emulation\*(R", which describes the
actual use and behaviour of it much better.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Event-Loop integration: Coro::AnyEvent, Coro::EV, Coro::Event.
.PP
Debugging: Coro::Debug.
.PP
Support/Utility: Coro::Specific, Coro::Util.
.PP
Locking and \s-1IPC: \s0Coro::Signal, Coro::Channel, Coro::Semaphore,
Coro::SemaphoreSet, Coro::RWLock.
.PP
I/O and Timers: Coro::Timer, Coro::Handle, Coro::Socket, Coro::AIO.
.PP
Compatibility with other modules: Coro::LWP (but see also AnyEvent::HTTP for
a better-working alternative), Coro::BDB, Coro::Storable,
Coro::Select.
.PP
\&\s-1XS API: \s0Coro::MakeMaker.
.PP
Low level Configuration, Thread Environment, Continuations: Coro::State.
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 2
\& Marc Lehmann <schmorp@schmorp.de>
\& http://home.schmorp.de/
.Ve
