.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Files 3"
.TH Files 3 "2007-03-28" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test::Files \- A Test::Builder based module to ease testing with files and dirs
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&    use Test::More tests => 5;
\&    use Test::Files;
\&    use File::Spec;
\&
\&    my $some_file  = File::Spec\->catfile( qw/ path to some file / );
\&    my $other_file = File::Spec\->catfile( qw/ path to other file / );
\&    my $some_dir   = File::Spec\->catdir ( qw/ some dir / );
\&    my $other_dir  = File::Spec\->catdir ( qw/ dir with same stuff / );
\&
\&    file_ok($some_file, "contents\enof file", "some file has contents");
\&
\&    file_filter_ok(
\&        $some_file,
\&        "filtered contents\enof file",
\&        \e&filter,
\&        "some file has contents"
\&    );
\&
\&    compare_ok($some_file, $other_file, "files are the same");
\&    compare_filter_ok(
\&            $file1, $file2, \e&filter, "they\*(Aqre almost the same"
\&    );
\&
\&    dir_contains_ok(
\&            $some_dir,
\&            [qw(files some_dir must contain)],
\&            "$some_dir has all files in list"
\&    );
\&
\&    dir_only_contains_ok(
\&        $some_dir,
\&        [qw(files some_dir should contain)],
\&        "$some_dir has exactly the files in the list"
\&    );
\&
\&    compare_dirs_ok($some_dir, $other_dir);
\&    compare_dirs_filter_ok($some_dir, $other_dir, \e&filter_fcn);
.Ve
.SH "ABSTRACT"
.IX Header "ABSTRACT"
.Vb 1
\&  Test::Builder based test helper for file and directory contents.
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module is like Test::More, in fact you should use that first as shown
above.  It exports
.IP "file_ok" 4
.IX Item "file_ok"
compare the contents of a file to a string
.IP "file_filter_ok" 4
.IX Item "file_filter_ok"
compare the contents of a file to a string, but filter the file first.
(You must filter your own string if needed.)
.IP "compare_ok" 4
.IX Item "compare_ok"
compare the contents of two files
.IP "compare_filter_ok" 4
.IX Item "compare_filter_ok"
compare the contents of two files, but sends each line through a filter
so things that shouldn't count against success can be stripped
.IP "dir_contains_ok" 4
.IX Item "dir_contains_ok"
checks a directory for the presence of a list files
.IP "dir_contains_only_ok" 4
.IX Item "dir_contains_only_ok"
checks a directory to ensure that the listed files are present and
that they are the only ones present
.IP "compare_dirs_ok" 4
.IX Item "compare_dirs_ok"
compares all text files in two directories reporting any differences
.IP "compare_dirs_filter_ok" 4
.IX Item "compare_dirs_filter_ok"
works like compare_dirs_ok, but calls a filter function on each line of
input, allowing you to exclude or alter some text to avoid spurious failures
(like timestamp disagreements).
.PP
Though the \s-1SYNOPSIS\s0 examples don't all have names, you can and should provide
a name for each test.  Names are omitted above only to reduce clutter and line
widths.
.PP
You should follow the lead of the \s-1SYNOPSIS\s0 examples and use File::Spec.
This makes it much more likely that your tests will pass on a different
operating system.
.PP
All of the content comparison routines provide diff diagnostic output
when they report failure.  Currently that diff output is always in table
form and can't be changed.
.PP
Most of the functions are self explanatory.  One exception is
\&\f(CW\*(C`compare_dirs_filter_ok\*(C'\fR which compares two directory trees, like
\&\f(CW\*(C`compare_dirs_ok\*(C'\fR but with a twist.  The twist is a filter which each
line is fed through before comparison.  I wanted this because some
files are really the same, but look different textually.  In particular,
I was comparing files with machine generated dates.  Everything in them
was identical, except those dates.
.PP
The filter function receives each line of each file.  It may perform
any necessary transformations (like excising dates), then it must
return the line in (possibly) transformed state.  For example, my first
filter was
.PP
.Vb 5
\&    sub chop_dates {
\&        my $line = shift;
\&        $line =~ s/\ed{4}(.\ed\ed){5}//;
\&        return $line;
\&    }
.Ve
.PP
This removes all strings like 2003.10.14.14.17.37.  Everything else is
unchanged and my failing tests started passing when they shold.  If you want
to exclude the line from consideration, return "" (do not return undef,
that makes it harder to chain filters together and might lead to warnings).
.PP
\&\f(CW\*(C`compare_filter_ok\*(C'\fR works in a similar manner for a single file comparison,
while \f(CW\*(C`file_filter_ok\*(C'\fR filters the file before comparing it to your
unfiltered string.
.PP
The test suite has examples of the use of each function and what the
output looks like on failure, though it that doesn't necessarily make
them easy to read.
.SS "\s-1BUGS\s0"
.IX Subsection "BUGS"
\&\f(CW\*(C`compare_dirs_ok\*(C'\fR and \f(CW\*(C`compare_dirs_filter_ok\*(C'\fR do not test for
whether the first directory has all the files that are in the second.
If you care about missing files in the first direcotry, you must also
call \f(CW\*(C`dir_contains_ok\*(C'\fR or \f(CW\*(C`dir_contains_only_ok\*(C'\fR.  The \f(CW\*(C`compare_dirs_*\*(C'\fR
routines do notice when the second directory does not have a files that
the first one has.
.SS "\s-1EXPORT\s0"
.IX Subsection "EXPORT"
.Vb 8
\&    file_ok
\&    file_filter_ok
\&    compare_ok
\&    compare_filter_ok
\&    dir_contains_ok
\&    dir_only_contains_ok
\&    compare_dirs_ok
\&    compare_dirs_filter_ok
.Ve
.SH "DEPENDENCIES"
.IX Header "DEPENDENCIES"
.Vb 5
\&    Test::Builder
\&    Test::More
\&    Text::Diff
\&    Algorithm::Diff
\&    Test::Builder::Tester (used only during testing)
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Consult Test::Simple, Test::More, and Test::Builder for more testing help.
This module really just adds functions to what Test::More does.
.SH "AUTHOR"
.IX Header "AUTHOR"
Phil Crow, <philcrow2000@yahoo.com<gt>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2003\-2007 by Phil Crow
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl 5.8.1 itself.
