.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Package::Variant 3"
.TH Package::Variant 3 "2013-12-10" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Package::Variant \- Parameterizable packages
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 8
\&  # declaring a variable Moo role
\&  package My::Role::ObjectAttr;
\&  use strictures 1;
\&  use Package::Variant
\&    # what modules to \*(Aquse\*(Aq
\&    importing => [\*(AqMoo::Role\*(Aq],
\&    # proxied subroutines
\&    subs => [ qw(has around before after with) ],
\&
\&  sub make_variant {
\&    my ($class, $target_package, %arguments) = @_;
\&    # access arguments
\&    my $name = $arguments{name};
\&    # use proxied \*(Aqhas\*(Aq to add an attribute
\&    has $name => (is => \*(Aqlazy\*(Aq);
\&    # install a builder method
\&    install "_build_${name}" => sub {
\&      return $arguments{class}\->new;
\&    };
\&  }
\&
\&  # using the role
\&  package My::Class::WithObjectAttr;
\&  use strictures 1;
\&  use Moo;
\&  use My::Role::ObjectAttr;
\&
\&  with ObjectAttr(name => \*(Aqsome_obj\*(Aq, class => \*(AqSome::Class\*(Aq);
\&
\&  # using our class
\&  my $obj = My::Class::WithObjectAttr\->new;
\&  $obj\->some_obj; # returns a Some::Class instance
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module allows you to build packages that return different variations
depending on what parameters are given.
.PP
Users of your package will receive a subroutine able to take parameters
and return the name of a suitable variant package. The implementation does
not care about what kind of package it builds.
.SS "Declaring a variable package"
.IX Subsection "Declaring a variable package"
There are two important parts to creating a variable package. You first
have to give \f(CW\*(C`Package::Variant\*(C'\fR some basic information about what kind of
package you want to provide, and how. The second part is implementing a
method receiving the user's arguments and generating your variants.
.PP
\fISetting up the environment for building variations\fR
.IX Subsection "Setting up the environment for building variations"
.PP
When you \f(CW\*(C`use Package::Variant\*(C'\fR, you pass along some arguments that
describe how you intend to build your variations.
.PP
.Vb 3
\&  use Package::Variant
\&    importing => { $package => \e@import_arguments, ... },
\&    subs      => [ @proxied_subroutine_names ];
.Ve
.PP
The \*(L"importing\*(R" option needs to be a hash or array reference with
package names to be \f(CW\*(C`use\*(C'\fRd as keys, and array references containing the
import arguments as values. These packages will be imported into every new
variant, and need to set up every declarative subroutine you require to
build your variable package. The next option will allow you to use these
functions. See \*(L"importing\*(R" for more options. You can omit empty import
argument lists when passing an array reference.
.PP
The \*(L"subs\*(R" option is an array reference of subroutine names that are
exported by the packages specified with \*(L"importing\*(R". These subroutines
will be proxied from your declaration package to the variant to be
generated.
.PP
With \*(L"importing\*(R" initializing your package and \*(L"subs\*(R" declaring what
subroutines you want to use to build a variant, you can now write a
\&\*(L"make_variant\*(R" method building your variants.
.PP
\fIDeclaring a method to produce variants\fR
.IX Subsection "Declaring a method to produce variants"
.PP
Every time a user requests a new variant a method named \*(L"make_variant\*(R"
will be called with the name of the target package and the arguments from
the user.
.PP
It can then use the proxied subroutines declared with \*(L"subs\*(R" to
customize the new package. An \*(L"install\*(R" subroutine is exported as well
allowing you to dynamically install methods into the new package. If these
options aren't flexible enough, you can use the passed name of the new
package to do any other kind of customizations.
.PP
.Vb 6
\&  sub make_variant {
\&    my ($class, $target, @arguments) = @_;
\&    # ...
\&    # customization goes here
\&    # ...
\&  }
.Ve
.PP
When the method is finished, the user will receive the name of the new
package variant you just set up.
.SS "Using variable packages"
.IX Subsection "Using variable packages"
After your variable package is created
your users can get a variant generating subroutine by simply importing
your package.
.PP
.Vb 2
\&  use My::Variant;
\&  my $new_variant_package = Variant(@variant_arguments);
.Ve
.PP
The package is now fully initialized and used. You can import the
subroutine under a different name by specifying an \f(CW\*(C`as\*(C'\fR argument.
.SS "Dynamic creation of variant packages"
.IX Subsection "Dynamic creation of variant packages"
For regular uses, the normal import provides
more than enough flexibility. However, if you want to create variations of
dynamically determined packages, you can use the \*(L"build_variant_of\*(R"
method.
.PP
You can use this to create variations of other packages and pass arguments
on to them to allow more modular and extensible variations.
.SH "OPTIONS"
.IX Header "OPTIONS"
These are the options that can be passed when importing
\&\f(CW\*(C`Package::Variant\*(C'\fR. They describe the environment in which the variants
are created.
.PP
.Vb 3
\&  use Package::Variant
\&    importing => { $package => \e@import_arguments, ... },
\&    subs      => [ @proxied_subroutines ];
.Ve
.SS "importing"
.IX Subsection "importing"
This option is a hash reference mapping package names to array references
containing import arguments. The packages will be imported with the given
arguments by every variation before the \*(L"make_variant\*(R" method is asked
to create the package (this is done using Import::Into).
.PP
If import order is important to you, you can also pass the \f(CW\*(C`importing\*(C'\fR
arguments as a flat array reference:
.PP
.Vb 2
\&  use Package::Variant
\&    importing => [ \*(AqPackageA\*(Aq, \*(AqPackageB\*(Aq ];
\&
\&  # same as
\&  use Package::Variant
\&    importing => [ \*(AqPackageA\*(Aq => [], \*(AqPackageB\*(Aq => [] ];
\&
\&  # or
\&  use Package::Variant
\&    importing => { \*(AqPackageA\*(Aq => [], \*(AqPackageB\*(Aq => [] };
.Ve
.PP
The import method will be called even if the list of import arguments is
empty or not specified,
.PP
If you just want to import a single package's default exports, you can
also pass a string instead:
.PP
.Vb 1
\&  use Package::Variant importing => \*(AqPackage\*(Aq;
.Ve
.SS "subs"
.IX Subsection "subs"
An array reference of strings listing the names of subroutines that should
be proxied. These subroutines are expected to be installed into the new
variant package by the modules imported with \*(L"importing\*(R". Subroutines
with the same name will be available in your declaration package, and will
proxy through to the newly created package when used within
\&\*(L"make_variant\*(R".
.SH "VARIABLE PACKAGE METHODS"
.IX Header "VARIABLE PACKAGE METHODS"
These are methods on the variable package you declare when you import
\&\f(CW\*(C`Package::Variant\*(C'\fR.
.SS "make_variant"
.IX Subsection "make_variant"
.Vb 1
\&  Some::Variant::Package\->make_variant( $target, @arguments );
.Ve
.PP
\&\fBYou need to provide this method.\fR This method will be called for every
new variant of your package. This method should use the subroutines
declared in \*(L"subs\*(R" to customize the new variant package.
.PP
This is a class method receiving the \f(CW$target\fR package and the
\&\f(CW@arguments\fR defining the requested variant.
.SS "import"
.IX Subsection "import"
.Vb 2
\&  use Some::Variant::Package;
\&  my $variant_package = Package( @arguments );
.Ve
.PP
This method is provided for you. It will allow a user to \f(CW\*(C`use\*(C'\fR your
package and receive a subroutine taking \f(CW@arguments\fR defining the variant
and returning the name of the newly created variant package.
.PP
The following options can be specified when importing:
.IP "\(bu" 4
\&\fBas\fR
.Sp
.Vb 2
\&  use Some::Variant::Package as => \*(AqFoo\*(Aq;
\&  my $variant_package = Foo(@arguments);
.Ve
.Sp
Exports the generator subroutine under a different name than the default.
.SS "build_variant"
.IX Subsection "build_variant"
.Vb 2
\&  use Some::Variant::Package ();
\&  my $variant_package = Some::Variant::Package\->build_variant( @arguments );
.Ve
.PP
This method is provided for you.  It will generate a variant package
and return its name, just like the generator sub provided by
\&\*(L"import\*(R".  This allows you to avoid importing anything into the
consuming package.
.ie n .SH """Package::Variant"" METHODS"
.el .SH "\f(CWPackage::Variant\fP METHODS"
.IX Header "Package::Variant METHODS"
These methods are available on \f(CW\*(C`Package::Variant\*(C'\fR itself.
.SS "build_variant_of"
.IX Subsection "build_variant_of"
.Vb 2
\&  my $variant_package = Package::Variant
\&    \->build_variant_of($variable_package, @arguments);
.Ve
.PP
This is the dynamic method of creating new variants. It takes the
\&\f(CW$variable_package\fR, which is a pre-declared variable package, and a set
of \f(CW@arguments\fR passed to the package to generate a new
\&\f(CW$variant_package\fR, which will be returned.
.SS "import"
.IX Subsection "import"
.Vb 1
\&  use Package::Variant @options;
.Ve
.PP
Sets up the environment in which you declare the variants of your
packages. See \*(L"\s-1OPTIONS\*(R"\s0 for details on the available options and
\&\*(L"\s-1EXPORTS\*(R"\s0 for a list of exported subroutines.
.SH "EXPORTS"
.IX Header "EXPORTS"
Additionally to the proxies for subroutines provided in \*(L"subs\*(R", the
following exports will be available in your variable package:
.SS "install"
.IX Subsection "install"
.Vb 1
\&  install($method_name, $code_reference);
.Ve
.PP
Installs a method with the given \f(CW$method_name\fR into the newly created
variant package. The \f(CW$code_reference\fR will be used as the body for the
method, and if Sub::Name is available the coderef will be named. If you
want to name it something else, then use:
.PP
.Vb 1
\&  install($method_name, $name_to_use, $code_reference);
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
mst \- Matt S. Trout (cpan:MSTROUT) <mst@shadowcat.co.uk>
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
phaylon \- Robert Sedlacek (cpan:PHAYLON) <r.sedlacek@shadowcat.co.uk>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2010\-2012 the \f(CW\*(C`Package::Variant\*(C'\fR \*(L"\s-1AUTHOR\*(R"\s0 and
\&\*(L"\s-1CONTRIBUTORS\*(R"\s0 as listed above.
.SH "LICENSE"
.IX Header "LICENSE"
This library is free software and may be distributed under the same
terms as perl itself.
