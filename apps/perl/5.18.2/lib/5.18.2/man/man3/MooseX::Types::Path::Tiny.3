.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "MooseX::Types::Path::Tiny 3"
.TH MooseX::Types::Path::Tiny 3 "2014-02-16" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
MooseX::Types::Path::Tiny \- Path::Tiny types and coercions for Moose
.SH "VERSION"
.IX Header "VERSION"
version 0.010
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  ### specification of type constraint with coercion
\&
\&  package Foo;
\&
\&  use Moose;
\&  use MooseX::Types::Path::Tiny qw/Path AbsPath/;
\&
\&  has filename => (
\&    is => \*(Aqro\*(Aq,
\&    isa => Path,
\&    coerce => 1,
\&  );
\&
\&  has directory => (
\&    is => \*(Aqro\*(Aq,
\&    isa => AbsPath,
\&    coerce => 1,
\&  );
\&
\&  has filenames => (
\&    is => \*(Aqro\*(Aq,
\&    isa => Paths,
\&    coerce => 1,
\&  );
\&
\&  ### usage in code
\&
\&  Foo\->new( filename => \*(Aqfoo.txt\*(Aq ); # coerced to Path::Tiny
\&  Foo\->new( directory => \*(Aq.\*(Aq ); # coerced to path(\*(Aq.\*(Aq)\->absolute
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides Path::Tiny types for Moose.  It handles
two important types of coercion:
.IP "\(bu" 4
coercing objects with overloaded stringification
.IP "\(bu" 4
coercing to absolute paths
.PP
It also can check to ensure that files or directories exist.
.SH "SUBTYPES"
.IX Header "SUBTYPES"
This module uses MooseX::Types to define the following subtypes.
.SS "Path"
.IX Subsection "Path"
\&\f(CW\*(C`Path\*(C'\fR ensures an attribute is a Path::Tiny object.  Strings and
objects with overloaded stringification may be coerced.
.SS "AbsPath"
.IX Subsection "AbsPath"
\&\f(CW\*(C`AbsPath\*(C'\fR is a subtype of \f(CW\*(C`Path\*(C'\fR (above), but coerces to an absolute path.
.SS "File, AbsFile"
.IX Subsection "File, AbsFile"
These are just like \f(CW\*(C`Path\*(C'\fR and \f(CW\*(C`AbsPath\*(C'\fR, except they check \f(CW\*(C`\-f\*(C'\fR to ensure
the file actually exists on the filesystem.
.SS "Dir, AbsDir"
.IX Subsection "Dir, AbsDir"
These are just like \f(CW\*(C`Path\*(C'\fR and \f(CW\*(C`AbsPath\*(C'\fR, except they check \f(CW\*(C`\-d\*(C'\fR to ensure
the directory actually exists on the filesystem.
.SS "Paths, AbsPaths"
.IX Subsection "Paths, AbsPaths"
These are arrayrefs of \f(CW\*(C`Path\*(C'\fR and \f(CW\*(C`AbsPath\*(C'\fR, and include coercions from
arrayrefs of strings.
.SH "CAVEATS"
.IX Header "CAVEATS"
.SS "Path vs File vs Dir"
.IX Subsection "Path vs File vs Dir"
\&\f(CW\*(C`Path\*(C'\fR just ensures you have a Path::Tiny object.
.PP
\&\f(CW\*(C`File\*(C'\fR and \f(CW\*(C`Dir\*(C'\fR check the filesystem.  Don't use them unless that's really
what you want.
.SS "Usage with File::Temp"
.IX Subsection "Usage with File::Temp"
Be careful if you pass in a File::Temp object. Because the argument is
stringified during coercion into a Path::Tiny object, no reference to the
original File::Temp argument is held.  Be sure to hold an external reference to
it to avoid immediate cleanup of the temporary file or directory at the end of
the enclosing scope.
.PP
A better approach is to use Path::Tiny's own \f(CW\*(C`tempfile\*(C'\fR or \f(CW\*(C`tempdir\*(C'\fR
constructors, which hold the reference for you.
.PP
.Vb 1
\&    Foo\->new( filename => Path::Tiny\->tempfile );
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
Path::Tiny
.IP "\(bu" 4
Moose::Manual::Types
.IP "\(bu" 4
Types::Path::Tiny
.SH "AUTHOR"
.IX Header "AUTHOR"
David Golden <dagolden@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is Copyright (c) 2013 by David Golden.
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The Apache License, Version 2.0, January 2004
.Ve
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.IP "\(bu" 4
Toby Inkster <mail@tobyinkster.co.uk>
