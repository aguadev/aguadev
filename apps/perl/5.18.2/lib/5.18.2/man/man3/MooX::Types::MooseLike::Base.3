.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "MooX::Types::MooseLike::Base 3"
.TH MooX::Types::MooseLike::Base 3 "2013-07-29" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
MooX::Types::MooseLike::Base \- Moose like types for Moo
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&    package MyPackage;
\&    use Moo;
\&    use MooX::Types::MooseLike::Base qw(:all);
\&
\&    has "beers_by_day_of_week" => (
\&        isa => HashRef
\&    );
\&    has "current_BAC" => (
\&        isa => Num
\&    );
\&
\&    # Also supporting is_$type.  For example, is_Int() can be used as follows
\&    has \*(Aqlegal_age\*(Aq => (
\&        is => \*(Aqro\*(Aq,
\&        isa => sub { die "$_[0] is not of legal age"
\&                           unless (is_Int($_[0]) && $_[0] > 17) },
\&    );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Moo attributes (like Moose) have an 'isa' property.
This module provides some basic types for this property.
One can import all types with ':all' tag or import
a list of types like:
.PP
.Vb 1
\&    use MooX::Types::MooseLike::Base qw/HashRef ArrayRef/;
.Ve
.PP
so one could then declare some attributtes like:
.PP
.Vb 8
\&        has \*(Aqcontact\*(Aq => (
\&          is => \*(Aqro\*(Aq,
\&          isa => HashRef,
\&        );
\&        has \*(Aqguest_list\*(Aq => (
\&          is => \*(Aqro\*(Aq,
\&          isa => ArrayRef[HashRef],
\&        );
.Ve
.PP
These types provide a check that the \fIcontact\fR attribute is a \f(CW\*(C`hash\*(C'\fR reference,
and that the \fIguest_list\fR is an \f(CW\*(C`array of hash\*(C'\fR references.
.SH "TYPES (1st class functions \- return a coderef)"
.IX Header "TYPES (1st class functions - return a coderef)"
.SS "Any"
.IX Subsection "Any"
Any type (test is always true)
.SS "Item"
.IX Subsection "Item"
Synonymous with Any type
.SS "Undef"
.IX Subsection "Undef"
A type that is not defined
.SS "Defined"
.IX Subsection "Defined"
A type that is defined
.SS "Bool"
.IX Subsection "Bool"
A boolean 1|0 type
.SS "Value"
.IX Subsection "Value"
A non-reference type
.SS "Ref"
.IX Subsection "Ref"
A reference type
.SS "Str"
.IX Subsection "Str"
A non-reference type where a reference to it is a \s-1SCALAR\s0
.SS "Num"
.IX Subsection "Num"
A number type
.SS "Int"
.IX Subsection "Int"
An integer type
.SS "ArrayRef"
.IX Subsection "ArrayRef"
An ArrayRef (\s-1ARRAY\s0) type
.SS "HashRef"
.IX Subsection "HashRef"
A HashRef (\s-1HASH\s0) type
.SS "CodeRef"
.IX Subsection "CodeRef"
A CodeRef (\s-1CODE\s0) type
.SS "RegexpRef"
.IX Subsection "RegexpRef"
A regular expression reference type
.SS "GlobRef"
.IX Subsection "GlobRef"
A glob reference type
.SS "FileHandle"
.IX Subsection "FileHandle"
A type that is either a builtin perl filehandle or an IO::Handle object
.SS "Object"
.IX Subsection "Object"
A type that is an object (think blessed)
.SH "PARAMETERIZED TYPES"
.IX Header "PARAMETERIZED TYPES"
.SS "Parameterizing Types With a Single Type"
.IX Subsection "Parameterizing Types With a Single Type"
The following types can be parameterized with other types.
.PP
\fIArrayRef\fR
.IX Subsection "ArrayRef"
.PP
For example, ArrayRef[HashRef]
.PP
\fIHashRef\fR
.IX Subsection "HashRef"
.PP
\fIScalarRef\fR
.IX Subsection "ScalarRef"
.PP
\fIMaybe\fR
.IX Subsection "Maybe"
.PP
For example, Maybe[Int] would be an integer or undef
.SS "Parameterizing Types With Multiple Types"
.IX Subsection "Parameterizing Types With Multiple Types"
\fIAnyOf\fR
.IX Subsection "AnyOf"
.PP
Check if the attribute is any of the listed types (think union).
Takes a list of types as the argument, for example:
.PP
.Vb 1
\&  isa => AnyOf[Int, ArrayRef[Int], HashRef[Int]]
.Ve
.PP
Note: AnyOf is passed an ArrayRef[CodeRef]
.PP
\fIAllOf\fR
.IX Subsection "AllOf"
.PP
Check if the attribute is all of the listed types (think intersection)
Takes a list of types as the argument. For example:
.PP
.Vb 5
\&  isa => AllOf[
\&    InstanceOf[\*(AqHuman\*(Aq], 
\&    ConsumerOf[\*(AqAir\*(Aq], 
\&    HasMethods[\*(Aqbreath\*(Aq, \*(Aqdance\*(Aq]
\&  ],
.Ve
.SS "Parameterizing Types With (Multiple) Strings"
.IX Subsection "Parameterizing Types With (Multiple) Strings"
In addition, we have some parameterized types that take string arguments.
.PP
\fIInstanceOf\fR
.IX Subsection "InstanceOf"
.PP
Check if the attribute is an object instance of one or more classes.  
Uses \f(CW\*(C`blessed\*(C'\fR and \f(CW\*(C`isa\*(C'\fR to do so.
Takes a list of class names as the argument. For example:
.PP
.Vb 1
\&  isa => InstanceOf[\*(AqMyClass\*(Aq,\*(AqMyOtherClass\*(Aq]
.Ve
.PP
Note: InstanceOf is passed an ArrayRef[Str]
.PP
\fIConsumerOf\fR
.IX Subsection "ConsumerOf"
.PP
Check if the attribute is blessed and consumes one or more roles.
Uses \f(CW\*(C`blessed\*(C'\fR and \f(CW\*(C`does\*(C'\fR to do so.
Takes a list of role names as the arguments. For example:
.PP
.Vb 1
\&  isa => ConsumerOf[\*(AqMy::Role\*(Aq, \*(AqMy::AnotherRole\*(Aq]
.Ve
.PP
\fIHasMethods\fR
.IX Subsection "HasMethods"
.PP
Check if the attribute is blessed and has one or more methods.
Uses \f(CW\*(C`blessed\*(C'\fR and \f(CW\*(C`can\*(C'\fR to do so.
Takes a list of method names as the arguments. For example:
.PP
.Vb 1
\&  isa => HasMethods[qw/postulate contemplate liberate/]
.Ve
.PP
\fIEnum\fR
.IX Subsection "Enum"
.PP
Check if the attribute is one of the enumerated strings.
Takes a list of possible string values. For example:
.PP
.Vb 1
\&  isa => Enum[\*(Aqrock\*(Aq, \*(Aqspock\*(Aq, \*(Aqpaper\*(Aq, \*(Aqlizard\*(Aq, \*(Aqscissors\*(Aq]
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Mateu Hunter \f(CW\*(C`hunter@missoula.org\*(C'\fR
.SH "THANKS"
.IX Header "THANKS"
mst has provided critical guidance on the design
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2011\-2013 Mateu Hunter
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself.
