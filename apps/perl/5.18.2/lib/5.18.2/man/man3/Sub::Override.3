.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Sub::Override 3"
.TH Sub::Override 3 "2013-01-16" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Sub::Override \- Perl extension for easily overriding subroutines
.SH "VERSION"
.IX Header "VERSION"
0.09
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Sub::Override;
\&
\&  sub foo { \*(Aqoriginal sub\*(Aq };
\&  print foo(); # prints \*(Aqoriginal sub\*(Aq
\&
\&  my $override = Sub::Override\->new( foo => sub { \*(Aqoverridden sub\*(Aq } );
\&  print foo(); # prints \*(Aqoverridden sub\*(Aq
\&  $override\->restore;
\&  print foo(); # prints \*(Aqoriginal sub\*(Aq
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SS "The Problem"
.IX Subsection "The Problem"
Sometimes subroutines need to be overridden.  In fact, your author does this
constantly for tests.  Particularly when testing, using a Mock Object can be
overkill when all you want to do is override one tiny, little function.
.PP
Overriding a subroutine is often done with syntax similar to the following.
.PP
.Vb 5
\& {
\&   local *Some::sub = sub {\*(Aqsome behavior\*(Aq};
\&   # do something
\& }
\& # original subroutine behavior restored
.Ve
.PP
This has a few problems.
.PP
.Vb 4
\& {
\&   local *Get::some_feild = { \*(Aqsome behavior\*(Aq };
\&   # do something
\& }
.Ve
.PP
In the above example, not only have we probably misspelled the subroutine name,
but even if their had been a subroutine with that name, we haven't overridden
it.  These two bugs can be subtle to detect.
.PP
Further, if we're attempting to localize the effect by placing this code in a
block, the entire construct is cumbersome.
.PP
Hook::LexWrap also allows us to override sub behavior, but I can never remember
the exact syntax.
.SS "An easier way to replace subroutines"
.IX Subsection "An easier way to replace subroutines"
Instead, \f(CW\*(C`Sub::Override\*(C'\fR allows the programmer to simply name the sub to
replace and to supply a sub to replace it with.
.PP
.Vb 1
\&  my $override = Sub::Override\->new(\*(AqSome::sub\*(Aq, sub {\*(Aqnew data\*(Aq});
\&
\&  # which is equivalent to:
\&  my $override = Sub::Override\->new;
\&  $override\->replace(\*(AqSome::sub\*(Aq, sub { \*(Aqnew data\*(Aq });
.Ve
.PP
You can replace multiple subroutines, if needed:
.PP
.Vb 3
\&  $override\->replace(\*(AqSome::sub1\*(Aq, sub { \*(Aqnew data1\*(Aq });
\&  $override\->replace(\*(AqSome::sub2\*(Aq, sub { \*(Aqnew data2\*(Aq });
\&  $override\->replace(\*(AqSome::sub3\*(Aq, sub { \*(Aqnew data3\*(Aq });
.Ve
.PP
If replacing the subroutine succeeds, the object is returned.  This allows the
programmer to chain the calls, if this style of programming is preferred:
.PP
.Vb 3
\&  $override\->replace(\*(AqSome::sub1\*(Aq, sub { \*(Aqnew data1\*(Aq })
\&           \->replace(\*(AqSome::sub2\*(Aq, sub { \*(Aqnew data2\*(Aq })
\&           \->replace(\*(AqSome::sub3\*(Aq, sub { \*(Aqnew data3\*(Aq });
.Ve
.PP
If the subroutine has a prototype, the new subroutine should be declared with
same prototype as original one:
.PP
.Vb 1
\&  $override\->replace(\*(AqSome::sub_with_proto\*(Aq, sub ($$) { ($_[0], $_ [1]) });
.Ve
.PP
A subroutine may be replaced as many times as desired.  This is most useful
when testing how code behaves with multiple conditions.
.PP
.Vb 2
\&  $override\->replace(\*(AqSome::thing\*(Aq, sub { 0 });
\&  is($object\->foo, \*(Aqwibble\*(Aq, \*(Aqwibble is returned if Some::thing is false\*(Aq);
\&
\&  $override\->replace(\*(AqSome::thing\*(Aq, sub { 1 });
\&  is($object\->foo, \*(Aqpuppies\*(Aq, \*(Aqpuppies are returned if Some::thing is true\*(Aq);
.Ve
.SS "Restoring subroutines"
.IX Subsection "Restoring subroutines"
If the object falls out of scope, the original subs are restored.  However, if
you need to restore a subroutine early, just use the restore method:
.PP
.Vb 3
\&  my $override = Sub::Override\->new(\*(AqSome::sub\*(Aq, sub {\*(Aqnew data\*(Aq});
\&  # do stuff
\&  $override\->restore;
.Ve
.PP
Which is somewhat equivalent to:
.PP
.Vb 4
\&  {
\&    my $override = Sub::Override\->new(\*(AqSome::sub\*(Aq, sub {\*(Aqnew data\*(Aq});
\&    # do stuff
\&  }
.Ve
.PP
If you have override more than one subroutine with an override object, you
will have to explicitly name the subroutine you wish to restore:
.PP
.Vb 1
\&  $override\->restore(\*(AqThis::sub\*(Aq);
.Ve
.PP
Note \f(CW\*(C`restore()\*(C'\fR will always restore the original behavior of the subroutine
no matter how many times you have overridden it.
.SS "Which package is the subroutine in?"
.IX Subsection "Which package is the subroutine in?"
Ordinarily, you want to fully qualify the subroutine by including the package
name.  However, failure to fully qualify the subroutine name will assume the
current package.
.PP
.Vb 7
\&  package Foo;
\&  use Sub::Override;
\&  sub foo { 23 };
\&  my $override = Sub::Override\->new( foo => sub { 42 } ); # assumes Foo::foo
\&  print foo(); # prints 42
\&  $override\->restore;
\&  print foo(); # prints 23
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
.Vb 2
\&  my $sub = Sub::Override\->new;
\&  my $sub = Sub::Override\->new($sub_name, $sub_ref);
.Ve
.PP
Creates a new \f(CW\*(C`Sub::Override\*(C'\fR instance.  Optionally, you may override a 
subroutine while creating a new object.
.SS "replace"
.IX Subsection "replace"
.Vb 1
\& $sub\->replace($sub_name, $sub_body);
.Ve
.PP
Temporarily replaces a subroutine with another subroutine.  Returns the
instance, so chaining the method is allowed:
.PP
.Vb 2
\& $sub\->replace($sub_name, $sub_body)
\&     \->replace($another_sub, $another_body);
.Ve
.PP
This method will \f(CW\*(C`croak\*(C'\fR is the subroutine to be replaced does not exist.
.SS "override"
.IX Subsection "override"
.Vb 2
\& my $sub = Sub::Override\->new;
\& $sub\->override($sub_name, $sub_body);
.Ve
.PP
\&\f(CW\*(C`override\*(C'\fR is an alternate name for \f(CW\*(C`replace\*(C'\fR.  They are the same method.
.SS "restore"
.IX Subsection "restore"
.Vb 1
\& $sub\->restore($sub_name);
.Ve
.PP
Restores the previous behavior of the subroutine.  This will happen
automatically if the \f(CW\*(C`Sub::Override\*(C'\fR object falls out of scope.
.SH "EXPORT"
.IX Header "EXPORT"
None by default.
.SH "BUGS"
.IX Header "BUGS"
Probably.  Tell me about 'em.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
Hook::LexWrap \*(-- can also override subs, but with different capabilities
.IP "\(bu" 4
Test::MockObject \*(-- use this if you need to alter an entire class
.SH "AUTHOR"
.IX Header "AUTHOR"
Curtis \*(L"Ovid\*(R" Poe, \f(CW\*(C`<ovid [at] cpan [dot] org>\*(C'\fR
.PP
Reverse the name to email me.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2004\-2005 by Curtis \*(L"Ovid\*(R" Poe
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.2 or,
at your option, any later version of Perl 5 you may have available.
